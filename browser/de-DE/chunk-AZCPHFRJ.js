import { MatDivider, MatDividerModule, MatList, MatListItem, MatListItemIcon, MatListItemTitle, MatListModule, MatPseudoCheckbox, MatPseudoCheckboxModule, SelectionModel, UniqueSelectionDispatcher, _DisposeViewRepeaterStrategy } from "./chunk-BMXRH6OH.js";
import { animate, state, style, transition, trigger } from "./chunk-7Q5ROX6O.js";
import { AuthService, CdkTextareaAutosize, ErrorStateMatcher, LocalstorageService, MAT_FORM_FIELD, MatError, MatFormField, MatFormFieldControl, MatFormFieldModule, MatInput, MatLabel, MatPrefix, MatSnackBar, MatSuffix, Router, RouterLink, UsersService, _ErrorStateTracker, environment } from "./chunk-A2XSFK7T.js";
import { MAT_RIPPLE_GLOBAL_OPTIONS, MatButton, MatButtonModule, MatFabButton, MatIconButton, MatRipple, MatRippleLoader, MatRippleModule, _StructuralStylesLoader } from "./chunk-ETCGSIPQ.js";
import { MatIcon, MatIconModule, MatTooltip, MatTooltipModule } from "./chunk-NCTODK62.js";
import { BasePortalOutlet, CdkConnectedOverlay, CdkOverlayOrigin, CdkPortalOutlet, CdkScrollable, CdkScrollableModule, CheckboxRequiredValidator, ComponentPortal, ControlContainer, DataSource, DefaultValueAccessor, DomPortalOutlet, FormControl, FormControlDirective, FormControlName, FormGroupDirective, FormGroupName, FormsModule, HttpClient, MaxLengthValidator, MinValidator, NG_VALIDATORS, NG_VALUE_ACCESSOR, NgControl, NgControlStatus, NgControlStatusGroup, NgForm, NgModel, NumberValueAccessor, Overlay, OverlayConfig, OverlayContainer, OverlayModule, OverlayRef, PortalModule, ReactiveFormsModule, ScrollDispatcher, ScrollingModule, TemplatePortal, Validators, ViewportRuler, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, _ViewRepeaterOperation, isDataSource, ɵNgNoValidate } from "./chunk-LFO7H5VY.js";
import { VideoPlayerComponent } from "./chunk-6KEP5RK3.js";
import { A, A11yModule, ActiveDescendantKeyManager, AriaDescriber, BACKSPACE, BreakpointObserver, COMMA, DELETE, DOWN_ARROW, Directionality, ENTER, ESCAPE, FocusKeyManager, FocusMonitor, FocusTrapFactory, InteractivityChecker, LEFT_ARROW, LiveAnnouncer, MatCommonModule, Platform, RIGHT_ARROW, SPACE, TAB, TREE_KEY_MANAGER, UP_ARROW, _CdkPrivateStyleLoader, _IdGenerator, _VisuallyHiddenLoader, _bindEventWithOptions, _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _isNumberValue, addAriaReferencedId, coerceArray, coerceElement, coerceNumberProperty, coerceObservable, hasModifierKey, isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader, removeAriaReferencedId } from "./chunk-VZWK6WXM.js";
import { ANIMATION_MODULE_TYPE, ApplicationRef, AsyncPipe, BehaviorSubject, ChangeDetectionStrategy, ChangeDetectorRef, CommonModule, Component, ContentChild, ContentChildren, DOCUMENT, DatePipe, DestroyRef, Directive, EMPTY, ElementRef, EventEmitter, HostAttributeToken, Inject, Injectable, InjectionToken, Injector, Input, IterableDiffers, LOCALE_ID, Location, NgClass, NgIf, NgModule, NgStyle, NgTemplateOutlet, NgZone, Observable, Optional, Output, QueryList, Renderer2, RendererFactory2, ReplaySubject, RuntimeError, SkipSelf, Subject, Subscription, TemplateRef, Version, ViewChild, ViewContainerRef, ViewEncapsulation, __spreadProps, __spreadValues, afterNextRender, animationFrameScheduler, assertInInjectionContext, assertNotInReactiveContext, booleanAttribute, combineLatest, computed, concat, concatMap, debounceTime, defer, delay, distinctUntilChanged, effect, filter, forkJoin, forwardRef, inject, input, interval, isObservable, isSignal, lastValueFrom, map, merge, numberAttribute, of, output, reduce, setClassMetadata, shareReplay, signal, startWith, switchMap, take, takeUntil, tap, timer, ɵsetClassDebugInfo, ɵɵHostDirectivesFeature, ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵɵProvidersFeature, ɵɵadvance, ɵɵattribute, ɵɵclassMap, ɵɵclassMapInterpolate1, ɵɵclassProp, ɵɵconditional, ɵɵcontentQuery, ɵɵdefer, ɵɵdeferEnableTimerScheduling, ɵɵdeferOnIdle, ɵɵdefineComponent, ɵɵdefineDirective, ɵɵdefineInjectable, ɵɵdefineInjector, ɵɵdefineNgModule, ɵɵdefinePipe, ɵɵdirectiveInject, ɵɵelement, ɵɵelementContainer, ɵɵelementContainerEnd, ɵɵelementContainerStart, ɵɵelementEnd, ɵɵelementStart, ɵɵgetCurrentView, ɵɵgetInheritedFactory, ɵɵhostProperty, ɵɵi18n, ɵɵi18nApply, ɵɵi18nEnd, ɵɵi18nExp, ɵɵi18nPostprocess, ɵɵi18nStart, ɵɵlistener, ɵɵloadQuery, ɵɵnamespaceHTML, ɵɵnamespaceSVG, ɵɵnextContext, ɵɵpipe, ɵɵpipeBind1, ɵɵpipeBind2, ɵɵprojection, ɵɵprojectionDef, ɵɵproperty, ɵɵpropertyInterpolate, ɵɵpureFunction0, ɵɵpureFunction1, ɵɵpureFunction2, ɵɵqueryRefresh, ɵɵreference, ɵɵrepeater, ɵɵrepeaterCreate, ɵɵrepeaterTrackByIdentity, ɵɵresetView, ɵɵrestoreView, ɵɵsanitizeUrl, ɵɵstyleProp, ɵɵtemplate, ɵɵtemplateRefExtractor, ɵɵtext, ɵɵtextInterpolate, ɵɵtextInterpolate1, ɵɵtextInterpolate2, ɵɵtwoWayBindingSet, ɵɵtwoWayListener, ɵɵtwoWayProperty, ɵɵviewQuery } from "./chunk-TTKC63AX.js";

// node_modules/@angular/material/fesm2022/option-cb353f7a.mjs
var _c0 = ["*", [["mat-option"], ["ng-container"]]];
var _c1 = ["*", "mat-option, ng-container"];
var _c2 = ["text"];
var _c3 = [[["mat-icon"]], "*"];
var _c4 = ["mat-icon", "*"];
function MatOption_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-pseudo-checkbox", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r0.disabled)("state", ctx_r0.selected ? "checked" : "unchecked");
  }
}
function MatOption_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-pseudo-checkbox", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r0.disabled);
  }
}
function MatOption_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("(", ctx_r0.group.label, ")");
  }
}
var MAT_OPTION_PARENT_COMPONENT = new InjectionToken("MAT_OPTION_PARENT_COMPONENT");
var MAT_OPTGROUP = new InjectionToken("MatOptgroup");
var MatOptgroup = class _MatOptgroup {
  /** Label for the option group. */
  label;
  /** whether the option group is disabled. */
  disabled = false;
  /** Unique id for the underlying label. */
  _labelId = inject(_IdGenerator).getId("mat-optgroup-label-");
  /** Whether the group is in inert a11y mode. */
  _inert;
  constructor() {
    const parent2 = inject(MAT_OPTION_PARENT_COMPONENT, {
      optional: true
    });
    this._inert = parent2?.inertGroups ?? false;
  }
  static ɵfac = function MatOptgroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatOptgroup)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatOptgroup,
    selectors: [["mat-optgroup"]],
    hostAttrs: [1, "mat-mdc-optgroup"],
    hostVars: 3,
    hostBindings: function MatOptgroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx._inert ? null : "group")("aria-disabled", ctx._inert ? null : ctx.disabled.toString())("aria-labelledby", ctx._inert ? null : ctx._labelId);
      }
    },
    inputs: {
      label: "label",
      disabled: [2, "disabled", "disabled", booleanAttribute]
    },
    exportAs: ["matOptgroup"],
    features: [ɵɵProvidersFeature([{
      provide: MAT_OPTGROUP,
      useExisting: _MatOptgroup
    }])],
    ngContentSelectors: _c1,
    decls: 5,
    vars: 4,
    consts: [["role", "presentation", 1, "mat-mdc-optgroup-label", 3, "id"], [1, "mdc-list-item__primary-text"]],
    template: function MatOptgroup_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c0);
        ɵɵelementStart(0, "span", 0)(1, "span", 1);
        ɵɵtext(2);
        ɵɵprojection(3);
        ɵɵelementEnd()();
        ɵɵprojection(4, 1);
      }
      if (rf & 2) {
        ɵɵclassProp("mdc-list-item--disabled", ctx.disabled);
        ɵɵproperty("id", ctx._labelId);
        ɵɵadvance(2);
        ɵɵtextInterpolate1("", ctx.label, " ");
      }
    },
    styles: [".mat-mdc-optgroup{color:var(--mat-optgroup-label-text-color, var(--mat-sys-on-surface-variant));font-family:var(--mat-optgroup-label-text-font, var(--mat-sys-title-small-font));line-height:var(--mat-optgroup-label-text-line-height, var(--mat-sys-title-small-line-height));font-size:var(--mat-optgroup-label-text-size, var(--mat-sys-title-small-size));letter-spacing:var(--mat-optgroup-label-text-tracking, var(--mat-sys-title-small-tracking));font-weight:var(--mat-optgroup-label-text-weight, var(--mat-sys-title-small-weight))}.mat-mdc-optgroup-label{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;min-height:48px;padding:0 16px;outline:none}.mat-mdc-optgroup-label.mdc-list-item--disabled{opacity:.38}.mat-mdc-optgroup-label .mdc-list-item__primary-text{font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;white-space:normal;color:inherit}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatOptgroup, [{
    type: Component,
    args: [{
      selector: "mat-optgroup",
      exportAs: "matOptgroup",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "class": "mat-mdc-optgroup",
        "[attr.role]": '_inert ? null : "group"',
        "[attr.aria-disabled]": "_inert ? null : disabled.toString()",
        "[attr.aria-labelledby]": "_inert ? null : _labelId"
      },
      providers: [{
        provide: MAT_OPTGROUP,
        useExisting: MatOptgroup
      }],
      template: '<span\n  class="mat-mdc-optgroup-label"\n  role="presentation"\n  [class.mdc-list-item--disabled]="disabled"\n  [id]="_labelId">\n  <span class="mdc-list-item__primary-text">{{ label }} <ng-content></ng-content></span>\n</span>\n\n<ng-content select="mat-option, ng-container"></ng-content>\n',
      styles: [".mat-mdc-optgroup{color:var(--mat-optgroup-label-text-color, var(--mat-sys-on-surface-variant));font-family:var(--mat-optgroup-label-text-font, var(--mat-sys-title-small-font));line-height:var(--mat-optgroup-label-text-line-height, var(--mat-sys-title-small-line-height));font-size:var(--mat-optgroup-label-text-size, var(--mat-sys-title-small-size));letter-spacing:var(--mat-optgroup-label-text-tracking, var(--mat-sys-title-small-tracking));font-weight:var(--mat-optgroup-label-text-weight, var(--mat-sys-title-small-weight))}.mat-mdc-optgroup-label{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;min-height:48px;padding:0 16px;outline:none}.mat-mdc-optgroup-label.mdc-list-item--disabled{opacity:.38}.mat-mdc-optgroup-label .mdc-list-item__primary-text{font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;white-space:normal;color:inherit}"]
    }]
  }], () => [], {
    label: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var MatOptionSelectionChange = class {
  source;
  isUserInput;
  constructor(source, isUserInput = false) {
    this.source = source;
    this.isUserInput = isUserInput;
  }
};
var MatOption = class _MatOption {
  _element = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _parent = inject(MAT_OPTION_PARENT_COMPONENT, {
    optional: true
  });
  group = inject(MAT_OPTGROUP, {
    optional: true
  });
  _signalDisableRipple = false;
  _selected = false;
  _active = false;
  _disabled = false;
  _mostRecentViewValue = "";
  /** Whether the wrapping component is in multiple selection mode. */
  get multiple() {
    return this._parent && this._parent.multiple;
  }
  /** Whether or not the option is currently selected. */
  get selected() {
    return this._selected;
  }
  /** The form value of the option. */
  value;
  /** The unique ID of the option. */
  id = inject(_IdGenerator).getId("mat-option-");
  /** Whether the option is disabled. */
  get disabled() {
    return this.group && this.group.disabled || this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  /** Whether ripples for the option are disabled. */
  get disableRipple() {
    return this._signalDisableRipple ? this._parent.disableRipple() : !!this._parent?.disableRipple;
  }
  /** Whether to display checkmark for single-selection. */
  get hideSingleSelectionIndicator() {
    return !!(this._parent && this._parent.hideSingleSelectionIndicator);
  }
  /** Event emitted when the option is selected or deselected. */
  // tslint:disable-next-line:no-output-on-prefix
  onSelectionChange = new EventEmitter();
  /** Element containing the option's text. */
  _text;
  /** Emits when the state of the option changes and any parents have to be notified. */
  _stateChanges = new Subject();
  constructor() {
    const styleLoader = inject(_CdkPrivateStyleLoader);
    styleLoader.load(_StructuralStylesLoader);
    styleLoader.load(_VisuallyHiddenLoader);
    this._signalDisableRipple = !!this._parent && isSignal(this._parent.disableRipple);
  }
  /**
   * Whether or not the option is currently active and ready to be selected.
   * An active option displays styles as if it is focused, but the
   * focus is actually retained somewhere else. This comes in handy
   * for components like autocomplete where focus must remain on the input.
   */
  get active() {
    return this._active;
  }
  /**
   * The displayed value of the option. It is necessary to show the selected option in the
   * select's trigger.
   */
  get viewValue() {
    return (this._text?.nativeElement.textContent || "").trim();
  }
  /** Selects the option. */
  select(emitEvent = true) {
    if (!this._selected) {
      this._selected = true;
      this._changeDetectorRef.markForCheck();
      if (emitEvent) {
        this._emitSelectionChangeEvent();
      }
    }
  }
  /** Deselects the option. */
  deselect(emitEvent = true) {
    if (this._selected) {
      this._selected = false;
      this._changeDetectorRef.markForCheck();
      if (emitEvent) {
        this._emitSelectionChangeEvent();
      }
    }
  }
  /** Sets focus onto this option. */
  focus(_origin, options) {
    const element = this._getHostElement();
    if (typeof element.focus === "function") {
      element.focus(options);
    }
  }
  /**
   * This method sets display styles on the option to make it appear
   * active. This is used by the ActiveDescendantKeyManager so key
   * events will display the proper options as active on arrow key events.
   */
  setActiveStyles() {
    if (!this._active) {
      this._active = true;
      this._changeDetectorRef.markForCheck();
    }
  }
  /**
   * This method removes display styles on the option that made it appear
   * active. This is used by the ActiveDescendantKeyManager so key
   * events will display the proper options as active on arrow key events.
   */
  setInactiveStyles() {
    if (this._active) {
      this._active = false;
      this._changeDetectorRef.markForCheck();
    }
  }
  /** Gets the label to be used when determining whether the option should be focused. */
  getLabel() {
    return this.viewValue;
  }
  /** Ensures the option is selected when activated from the keyboard. */
  _handleKeydown(event) {
    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {
      this._selectViaInteraction();
      event.preventDefault();
    }
  }
  /**
   * `Selects the option while indicating the selection came from the user. Used to
   * determine if the select's view -> model callback should be invoked.`
   */
  _selectViaInteraction() {
    if (!this.disabled) {
      this._selected = this.multiple ? !this._selected : true;
      this._changeDetectorRef.markForCheck();
      this._emitSelectionChangeEvent(true);
    }
  }
  /** Returns the correct tabindex for the option depending on disabled state. */
  // This method is only used by `MatLegacyOption`. Keeping it here to avoid breaking the types.
  // That's because `MatLegacyOption` use `MatOption` type in a few places such as
  // `MatOptionSelectionChange`. It is safe to delete this when `MatLegacyOption` is deleted.
  _getTabIndex() {
    return this.disabled ? "-1" : "0";
  }
  /** Gets the host DOM element. */
  _getHostElement() {
    return this._element.nativeElement;
  }
  ngAfterViewChecked() {
    if (this._selected) {
      const viewValue = this.viewValue;
      if (viewValue !== this._mostRecentViewValue) {
        if (this._mostRecentViewValue) {
          this._stateChanges.next();
        }
        this._mostRecentViewValue = viewValue;
      }
    }
  }
  ngOnDestroy() {
    this._stateChanges.complete();
  }
  /** Emits the selection change event. */
  _emitSelectionChangeEvent(isUserInput = false) {
    this.onSelectionChange.emit(new MatOptionSelectionChange(this, isUserInput));
  }
  static ɵfac = function MatOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatOption)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatOption,
    selectors: [["mat-option"]],
    viewQuery: function MatOption_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c2, 7);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._text = _t2.first);
      }
    },
    hostAttrs: ["role", "option", 1, "mat-mdc-option", "mdc-list-item"],
    hostVars: 11,
    hostBindings: function MatOption_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function MatOption_click_HostBindingHandler() {
          return ctx._selectViaInteraction();
        })("keydown", function MatOption_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
        ɵɵattribute("aria-selected", ctx.selected)("aria-disabled", ctx.disabled.toString());
        ɵɵclassProp("mdc-list-item--selected", ctx.selected)("mat-mdc-option-multiple", ctx.multiple)("mat-mdc-option-active", ctx.active)("mdc-list-item--disabled", ctx.disabled);
      }
    },
    inputs: {
      value: "value",
      id: "id",
      disabled: [2, "disabled", "disabled", booleanAttribute]
    },
    outputs: {
      onSelectionChange: "onSelectionChange"
    },
    exportAs: ["matOption"],
    ngContentSelectors: _c4,
    decls: 8,
    vars: 5,
    consts: [["text", ""], ["aria-hidden", "true", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled", "state"], [1, "mdc-list-item__primary-text"], ["state", "checked", "aria-hidden", "true", "appearance", "minimal", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled"], [1, "cdk-visually-hidden"], ["aria-hidden", "true", "mat-ripple", "", 1, "mat-mdc-option-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled"]],
    template: function MatOption_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c3);
        ɵɵtemplate(0, MatOption_Conditional_0_Template, 1, 2, "mat-pseudo-checkbox", 1);
        ɵɵprojection(1);
        ɵɵelementStart(2, "span", 2, 0);
        ɵɵprojection(4, 1);
        ɵɵelementEnd();
        ɵɵtemplate(5, MatOption_Conditional_5_Template, 1, 1, "mat-pseudo-checkbox", 3)(6, MatOption_Conditional_6_Template, 2, 1, "span", 4);
        ɵɵelement(7, "div", 5);
      }
      if (rf & 2) {
        ɵɵconditional(ctx.multiple ? 0 : -1);
        ɵɵadvance(5);
        ɵɵconditional(!ctx.multiple && ctx.selected && !ctx.hideSingleSelectionIndicator ? 5 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.group && ctx.group._inert ? 6 : -1);
        ɵɵadvance();
        ɵɵproperty("matRippleTrigger", ctx._getHostElement())("matRippleDisabled", ctx.disabled || ctx.disableRipple);
      }
    },
    dependencies: [MatPseudoCheckbox, MatRipple],
    styles: ['.mat-mdc-option{-webkit-user-select:none;user-select:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;min-height:48px;padding:0 16px;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);color:var(--mat-option-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-option-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-option-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-option-label-text-size, var(--mat-sys-body-large-size));letter-spacing:var(--mat-option-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-option-label-text-weight, var(--mat-sys-body-large-weight))}.mat-mdc-option:hover:not(.mdc-list-item--disabled){background-color:var(--mat-option-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-option:focus.mdc-list-item,.mat-mdc-option.mat-mdc-option-active.mdc-list-item{background-color:var(--mat-option-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent));outline:0}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple){background-color:var(--mat-option-selected-state-layer-color, var(--mat-sys-secondary-container))}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple) .mdc-list-item__primary-text{color:var(--mat-option-selected-state-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-option .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-selected-checkmark-color: var(--mat-option-selected-state-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-option.mdc-list-item{align-items:center;background:rgba(0,0,0,0)}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}@media(forced-colors: active){.mat-mdc-option.mdc-list-item--selected:not(:has(.mat-mdc-option-pseudo-checkbox))::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .mat-mdc-option.mdc-list-item--selected:not(:has(.mat-mdc-option-pseudo-checkbox))::after{right:auto;left:16px}}.mat-mdc-option-multiple{--mdc-list-list-item-selected-container-color:var(--mdc-list-list-item-container-color, transparent)}.mat-mdc-option-active .mat-focus-indicator::before{content:""}'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatOption, [{
    type: Component,
    args: [{
      selector: "mat-option",
      exportAs: "matOption",
      host: {
        "role": "option",
        "[class.mdc-list-item--selected]": "selected",
        "[class.mat-mdc-option-multiple]": "multiple",
        "[class.mat-mdc-option-active]": "active",
        "[class.mdc-list-item--disabled]": "disabled",
        "[id]": "id",
        // Set aria-selected to false for non-selected items and true for selected items. Conform to
        // [WAI ARIA Listbox authoring practices guide](
        //  https://www.w3.org/WAI/ARIA/apg/patterns/listbox/), "If any options are selected, each
        // selected option has either aria-selected or aria-checked  set to true. All options that are
        // selectable but not selected have either aria-selected or aria-checked set to false." Align
        // aria-selected implementation of Chips and List components.
        //
        // Set `aria-selected="false"` on not-selected listbox options to fix VoiceOver announcing
        // every option as "selected" (#21491).
        "[attr.aria-selected]": "selected",
        "[attr.aria-disabled]": "disabled.toString()",
        "(click)": "_selectViaInteraction()",
        "(keydown)": "_handleKeydown($event)",
        "class": "mat-mdc-option mdc-list-item"
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [MatPseudoCheckbox, MatRipple],
      template: `<!-- Set aria-hidden="true" to this DOM node and other decorative nodes in this file. This might
 be contributing to issue where sometimes VoiceOver focuses on a TextNode in the a11y tree instead
 of the Option node (#23202). Most assistive technology will generally ignore non-role,
 non-text-content elements. Adding aria-hidden seems to make VoiceOver behave more consistently. -->
@if (multiple) {
    <mat-pseudo-checkbox
        class="mat-mdc-option-pseudo-checkbox"
        [disabled]="disabled"
        [state]="selected ? 'checked' : 'unchecked'"
        aria-hidden="true"></mat-pseudo-checkbox>
}

<ng-content select="mat-icon"></ng-content>

<span class="mdc-list-item__primary-text" #text><ng-content></ng-content></span>

<!-- Render checkmark at the end for single-selection. -->
@if (!multiple && selected && !hideSingleSelectionIndicator) {
    <mat-pseudo-checkbox
        class="mat-mdc-option-pseudo-checkbox"
        [disabled]="disabled"
        state="checked"
        aria-hidden="true"
        appearance="minimal"></mat-pseudo-checkbox>
}

<!-- See a11y notes inside optgroup.ts for context behind this element. -->
@if (group && group._inert) {
    <span class="cdk-visually-hidden">({{ group.label }})</span>
}

<div class="mat-mdc-option-ripple mat-focus-indicator" aria-hidden="true" mat-ripple
     [matRippleTrigger]="_getHostElement()" [matRippleDisabled]="disabled || disableRipple">
</div>
`,
      styles: ['.mat-mdc-option{-webkit-user-select:none;user-select:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;min-height:48px;padding:0 16px;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);color:var(--mat-option-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-option-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-option-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-option-label-text-size, var(--mat-sys-body-large-size));letter-spacing:var(--mat-option-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-option-label-text-weight, var(--mat-sys-body-large-weight))}.mat-mdc-option:hover:not(.mdc-list-item--disabled){background-color:var(--mat-option-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-option:focus.mdc-list-item,.mat-mdc-option.mat-mdc-option-active.mdc-list-item{background-color:var(--mat-option-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent));outline:0}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple){background-color:var(--mat-option-selected-state-layer-color, var(--mat-sys-secondary-container))}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple) .mdc-list-item__primary-text{color:var(--mat-option-selected-state-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-option .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-selected-checkmark-color: var(--mat-option-selected-state-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-option.mdc-list-item{align-items:center;background:rgba(0,0,0,0)}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}@media(forced-colors: active){.mat-mdc-option.mdc-list-item--selected:not(:has(.mat-mdc-option-pseudo-checkbox))::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .mat-mdc-option.mdc-list-item--selected:not(:has(.mat-mdc-option-pseudo-checkbox))::after{right:auto;left:16px}}.mat-mdc-option-multiple{--mdc-list-list-item-selected-container-color:var(--mdc-list-list-item-container-color, transparent)}.mat-mdc-option-active .mat-focus-indicator::before{content:""}']
    }]
  }], () => [], {
    value: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onSelectionChange: [{
      type: Output
    }],
    _text: [{
      type: ViewChild,
      args: ["text", {
        static: true
      }]
    }]
  });
})();
function _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {
  if (optionGroups.length) {
    let optionsArray = options.toArray();
    let groups = optionGroups.toArray();
    let groupCounter = 0;
    for (let i2 = 0; i2 < optionIndex + 1; i2++) {
      if (optionsArray[i2].group && optionsArray[i2].group === groups[groupCounter]) {
        groupCounter++;
      }
    }
    return groupCounter;
  }
  return 0;
}
function _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {
  if (optionOffset < currentScrollPosition) {
    return optionOffset;
  }
  if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
    return Math.max(0, optionOffset - panelHeight + optionHeight);
  }
  return currentScrollPosition;
}

// node_modules/@angular/material/fesm2022/index-2f2536d6.mjs
var MatOptionModule = class _MatOptionModule {
  static ɵfac = function MatOptionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatOptionModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatOptionModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [MatRippleModule, MatCommonModule, MatPseudoCheckboxModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatOptionModule, [{
    type: NgModule,
    args: [{
      imports: [MatRippleModule, MatCommonModule, MatPseudoCheckboxModule, MatOption, MatOptgroup],
      exports: [MatOption, MatOptgroup]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/module-b0a3e0af.mjs
var _c02 = ["trigger"];
var _c12 = ["panel"];
var _c22 = [[["mat-select-trigger"]], "*"];
var _c32 = ["mat-select-trigger", "*"];
function MatSelect_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.placeholder);
  }
}
function MatSelect_Conditional_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function MatSelect_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.triggerValue);
  }
}
function MatSelect_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtemplate(1, MatSelect_Conditional_5_Conditional_1_Template, 1, 0)(2, MatSelect_Conditional_5_Conditional_2_Template, 2, 1, "span", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r1.customTrigger ? 1 : 2);
  }
}
function MatSelect_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 12, 1);
    ɵɵlistener("keydown", function MatSelect_ng_template_10_Template_div_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._handleKeydown($event));
    });
    ɵɵprojection(2, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate1("mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ", ctx_r1._getPanelTheme(), "");
    ɵɵclassProp("mat-select-panel-animations-enabled", !ctx_r1._animationsDisabled);
    ɵɵproperty("ngClass", ctx_r1.panelClass);
    ɵɵattribute("id", ctx_r1.id + "-panel")("aria-multiselectable", ctx_r1.multiple)("aria-label", ctx_r1.ariaLabel || null)("aria-labelledby", ctx_r1._getPanelAriaLabelledby());
  }
}
function getMatSelectDynamicMultipleError() {
  return Error("Cannot change `multiple` mode of select after initialization.");
}
function getMatSelectNonArrayValueError() {
  return Error("Value must be an array in multiple-selection mode.");
}
function getMatSelectNonFunctionValueError() {
  return Error("`compareWith` must be a function.");
}
var MAT_SELECT_SCROLL_STRATEGY = new InjectionToken("mat-select-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition();
  }
});
function MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition();
}
var MAT_SELECT_CONFIG = new InjectionToken("MAT_SELECT_CONFIG");
var MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {
  provide: MAT_SELECT_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY
};
var MAT_SELECT_TRIGGER = new InjectionToken("MatSelectTrigger");
var MatSelectChange = class {
  source;
  value;
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
};
var MatSelect = class _MatSelect {
  _viewportRuler = inject(ViewportRuler);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _elementRef = inject(ElementRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _idGenerator = inject(_IdGenerator);
  _renderer = inject(Renderer2);
  _parentFormField = inject(MAT_FORM_FIELD, {
    optional: true
  });
  ngControl = inject(NgControl, {
    self: true,
    optional: true
  });
  _liveAnnouncer = inject(LiveAnnouncer);
  _defaultOptions = inject(MAT_SELECT_CONFIG, {
    optional: true
  });
  _animationsDisabled = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  }) === "NoopAnimations";
  _initialized = new Subject();
  _cleanupDetach;
  /** All of the defined select options. */
  options;
  // TODO(crisbeto): this is only necessary for the non-MDC select, but it's technically a
  // public API so we have to keep it. It should be deprecated and removed eventually.
  /** All of the defined groups of options. */
  optionGroups;
  /** User-supplied override of the trigger element. */
  customTrigger;
  /**
   * This position config ensures that the top "start" corner of the overlay
   * is aligned with with the top "start" of the origin by default (overlapping
   * the trigger completely). If the panel cannot fit below the trigger, it
   * will fall back to a position above the trigger.
   */
  _positions = [{
    originX: "start",
    originY: "bottom",
    overlayX: "start",
    overlayY: "top"
  }, {
    originX: "end",
    originY: "bottom",
    overlayX: "end",
    overlayY: "top"
  }, {
    originX: "start",
    originY: "top",
    overlayX: "start",
    overlayY: "bottom",
    panelClass: "mat-mdc-select-panel-above"
  }, {
    originX: "end",
    originY: "top",
    overlayX: "end",
    overlayY: "bottom",
    panelClass: "mat-mdc-select-panel-above"
  }];
  /** Scrolls a particular option into the view. */
  _scrollOptionIntoView(index) {
    const option = this.options.toArray()[index];
    if (option) {
      const panel = this.panel.nativeElement;
      const labelCount = _countGroupLabelsBeforeOption(index, this.options, this.optionGroups);
      const element = option._getHostElement();
      if (index === 0 && labelCount === 1) {
        panel.scrollTop = 0;
      } else {
        panel.scrollTop = _getOptionScrollPosition(element.offsetTop, element.offsetHeight, panel.scrollTop, panel.offsetHeight);
      }
    }
  }
  /** Called when the panel has been opened and the overlay has settled on its final position. */
  _positioningSettled() {
    this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);
  }
  /** Creates a change event object that should be emitted by the select. */
  _getChangeEvent(value) {
    return new MatSelectChange(this, value);
  }
  /** Factory function used to create a scroll strategy for this select. */
  _scrollStrategyFactory = inject(MAT_SELECT_SCROLL_STRATEGY);
  /** Whether or not the overlay panel is open. */
  _panelOpen = false;
  /** Comparison function to specify which option is displayed. Defaults to object equality. */
  _compareWith = (o1, o2) => o1 === o2;
  /** Unique id for this input. */
  _uid = this._idGenerator.getId("mat-select-");
  /** Current `aria-labelledby` value for the select trigger. */
  _triggerAriaLabelledBy = null;
  /**
   * Keeps track of the previous form control assigned to the select.
   * Used to detect if it has changed.
   */
  _previousControl;
  /** Emits whenever the component is destroyed. */
  _destroy = new Subject();
  /** Tracks the error state of the select. */
  _errorStateTracker;
  /**
   * Emits whenever the component state changes and should cause the parent
   * form-field to update. Implemented as part of `MatFormFieldControl`.
   * @docs-private
   */
  stateChanges = new Subject();
  /**
   * Disable the automatic labeling to avoid issues like #27241.
   * @docs-private
   */
  disableAutomaticLabeling = true;
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  userAriaDescribedBy;
  /** Deals with the selection logic. */
  _selectionModel;
  /** Manages keyboard events for options in the panel. */
  _keyManager;
  /** Ideal origin for the overlay panel. */
  _preferredOverlayOrigin;
  /** Width of the overlay panel. */
  _overlayWidth;
  /** `View -> model callback called when value changes` */
  _onChange = () => {};
  /** `View -> model callback called when select has been touched` */
  _onTouched = () => {};
  /** ID for the DOM node containing the select's value. */
  _valueId = this._idGenerator.getId("mat-select-value-");
  /** Strategy that will be used to handle scrolling while the select panel is open. */
  _scrollStrategy;
  _overlayPanelClass = this._defaultOptions?.overlayPanelClass || "";
  /** Whether the select is focused. */
  get focused() {
    return this._focused || this._panelOpen;
  }
  _focused = false;
  /** A name for this control that can be used by `mat-form-field`. */
  controlType = "mat-select";
  /** Trigger that opens the select. */
  trigger;
  /** Panel containing the select options. */
  panel;
  /** Overlay pane containing the options. */
  _overlayDir;
  /** Classes to be passed to the select panel. Supports the same syntax as `ngClass`. */
  panelClass;
  /** Whether the select is disabled. */
  disabled = false;
  /** Whether ripples in the select are disabled. */
  disableRipple = false;
  /** Tab index of the select. */
  tabIndex = 0;
  /** Whether checkmark indicator for single-selection options is hidden. */
  get hideSingleSelectionIndicator() {
    return this._hideSingleSelectionIndicator;
  }
  set hideSingleSelectionIndicator(value) {
    this._hideSingleSelectionIndicator = value;
    this._syncParentProperties();
  }
  _hideSingleSelectionIndicator = this._defaultOptions?.hideSingleSelectionIndicator ?? false;
  /** Placeholder to be shown if no value has been selected. */
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(value) {
    this._placeholder = value;
    this.stateChanges.next();
  }
  _placeholder;
  /** Whether the component is required. */
  get required() {
    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;
  }
  set required(value) {
    this._required = value;
    this.stateChanges.next();
  }
  _required;
  /** Whether the user should be allowed to select multiple options. */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    if (this._selectionModel && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatSelectDynamicMultipleError();
    }
    this._multiple = value;
  }
  _multiple = false;
  /** Whether to center the active option over the trigger. */
  disableOptionCentering = this._defaultOptions?.disableOptionCentering ?? false;
  /**
   * Function to compare the option values with the selected values. The first argument
   * is a value from an option. The second is a value from the selection. A boolean
   * should be returned.
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatSelectNonFunctionValueError();
    }
    this._compareWith = fn;
    if (this._selectionModel) {
      this._initializeSelection();
    }
  }
  /** Value of the select control. */
  get value() {
    return this._value;
  }
  set value(newValue) {
    const hasAssigned = this._assignValue(newValue);
    if (hasAssigned) {
      this._onChange(newValue);
    }
  }
  _value;
  /** Aria label of the select. */
  ariaLabel = "";
  /** Input that can be used to specify the `aria-labelledby` attribute. */
  ariaLabelledby;
  /** Object used to control when error messages are shown. */
  get errorStateMatcher() {
    return this._errorStateTracker.matcher;
  }
  set errorStateMatcher(value) {
    this._errorStateTracker.matcher = value;
  }
  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */
  typeaheadDebounceInterval;
  /**
   * Function used to sort the values in a select in multiple mode.
   * Follows the same logic as `Array.prototype.sort`.
   */
  sortComparator;
  /** Unique id of the element. */
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value || this._uid;
    this.stateChanges.next();
  }
  _id;
  /** Whether the select is in an error state. */
  get errorState() {
    return this._errorStateTracker.errorState;
  }
  set errorState(value) {
    this._errorStateTracker.errorState = value;
  }
  /**
   * Width of the panel. If set to `auto`, the panel will match the trigger width.
   * If set to null or an empty string, the panel will grow to match the longest option's text.
   */
  panelWidth = this._defaultOptions && typeof this._defaultOptions.panelWidth !== "undefined" ? this._defaultOptions.panelWidth : "auto";
  /**
   * By default selecting an option with a `null` or `undefined` value will reset the select's
   * value. Enable this option if the reset behavior doesn't match your requirements and instead
   * the nullable options should become selected. The value of this input can be controlled app-wide
   * using the `MAT_SELECT_CONFIG` injection token.
   */
  canSelectNullableOptions = this._defaultOptions?.canSelectNullableOptions ?? false;
  /** Combined stream of all of the child options' change events. */
  optionSelectionChanges = defer(() => {
    const options = this.options;
    if (options) {
      return options.changes.pipe(startWith(options), switchMap(() => merge(...options.map(option => option.onSelectionChange))));
    }
    return this._initialized.pipe(switchMap(() => this.optionSelectionChanges));
  });
  /** Event emitted when the select panel has been toggled. */
  openedChange = new EventEmitter();
  /** Event emitted when the select has been opened. */
  _openedStream = this.openedChange.pipe(filter(o2 => o2), map(() => {}));
  /** Event emitted when the select has been closed. */
  _closedStream = this.openedChange.pipe(filter(o2 => !o2), map(() => {}));
  /** Event emitted when the selected value has been changed by the user. */
  selectionChange = new EventEmitter();
  /**
   * Event that emits whenever the raw value of the select changes. This is here primarily
   * to facilitate the two-way binding for the `value` input.
   * @docs-private
   */
  valueChange = new EventEmitter();
  constructor() {
    const defaultErrorStateMatcher = inject(ErrorStateMatcher);
    const parentForm = inject(NgForm, {
      optional: true
    });
    const parentFormGroup = inject(FormGroupDirective, {
      optional: true
    });
    const tabIndex = inject(new HostAttributeToken("tabindex"), {
      optional: true
    });
    if (this.ngControl) {
      this.ngControl.valueAccessor = this;
    }
    if (this._defaultOptions?.typeaheadDebounceInterval != null) {
      this.typeaheadDebounceInterval = this._defaultOptions.typeaheadDebounceInterval;
    }
    this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, this.ngControl, parentFormGroup, parentForm, this.stateChanges);
    this._scrollStrategy = this._scrollStrategyFactory();
    this.tabIndex = tabIndex == null ? 0 : parseInt(tabIndex) || 0;
    this.id = this.id;
  }
  ngOnInit() {
    this._selectionModel = new SelectionModel(this.multiple);
    this.stateChanges.next();
    this._viewportRuler.change().pipe(takeUntil(this._destroy)).subscribe(() => {
      if (this.panelOpen) {
        this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);
        this._changeDetectorRef.detectChanges();
      }
    });
  }
  ngAfterContentInit() {
    this._initialized.next();
    this._initialized.complete();
    this._initKeyManager();
    this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe(event => {
      event.added.forEach(option => option.select());
      event.removed.forEach(option => option.deselect());
    });
    this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {
      this._resetOptions();
      this._initializeSelection();
    });
  }
  ngDoCheck() {
    const newAriaLabelledby = this._getTriggerAriaLabelledby();
    const ngControl = this.ngControl;
    if (newAriaLabelledby !== this._triggerAriaLabelledBy) {
      const element = this._elementRef.nativeElement;
      this._triggerAriaLabelledBy = newAriaLabelledby;
      if (newAriaLabelledby) {
        element.setAttribute("aria-labelledby", newAriaLabelledby);
      } else {
        element.removeAttribute("aria-labelledby");
      }
    }
    if (ngControl) {
      if (this._previousControl !== ngControl.control) {
        if (this._previousControl !== void 0 && ngControl.disabled !== null && ngControl.disabled !== this.disabled) {
          this.disabled = ngControl.disabled;
        }
        this._previousControl = ngControl.control;
      }
      this.updateErrorState();
    }
  }
  ngOnChanges(changes) {
    if (changes["disabled"] || changes["userAriaDescribedBy"]) {
      this.stateChanges.next();
    }
    if (changes["typeaheadDebounceInterval"] && this._keyManager) {
      this._keyManager.withTypeAhead(this.typeaheadDebounceInterval);
    }
  }
  ngOnDestroy() {
    this._cleanupDetach?.();
    this._keyManager?.destroy();
    this._destroy.next();
    this._destroy.complete();
    this.stateChanges.complete();
    this._clearFromModal();
  }
  /** Toggles the overlay panel open or closed. */
  toggle() {
    this.panelOpen ? this.close() : this.open();
  }
  /** Opens the overlay panel. */
  open() {
    if (!this._canOpen()) {
      return;
    }
    if (this._parentFormField) {
      this._preferredOverlayOrigin = this._parentFormField.getConnectedOverlayOrigin();
    }
    this._cleanupDetach?.();
    this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);
    this._applyModalPanelOwnership();
    this._panelOpen = true;
    this._overlayDir.positionChange.pipe(take(1)).subscribe(() => {
      this._changeDetectorRef.detectChanges();
      this._positioningSettled();
    });
    this._overlayDir.attachOverlay();
    this._keyManager.withHorizontalOrientation(null);
    this._highlightCorrectOption();
    this._changeDetectorRef.markForCheck();
    this.stateChanges.next();
    Promise.resolve().then(() => this.openedChange.emit(true));
  }
  /**
   * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is
   * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options
   * panel. Track the modal we have changed so we can undo the changes on destroy.
   */
  _trackedModal = null;
  /**
   * If the autocomplete trigger is inside of an `aria-modal` element, connect
   * that modal to the options panel with `aria-owns`.
   *
   * For some browser + screen reader combinations, when navigation is inside
   * of an `aria-modal` element, the screen reader treats everything outside
   * of that modal as hidden or invisible.
   *
   * This causes a problem when the combobox trigger is _inside_ of a modal, because the
   * options panel is rendered _outside_ of that modal, preventing screen reader navigation
   * from reaching the panel.
   *
   * We can work around this issue by applying `aria-owns` to the modal with the `id` of
   * the options panel. This effectively communicates to assistive technology that the
   * options panel is part of the same interaction as the modal.
   *
   * At time of this writing, this issue is present in VoiceOver.
   * See https://github.com/angular/components/issues/20694
   */
  _applyModalPanelOwnership() {
    const modal = this._elementRef.nativeElement.closest('body > .cdk-overlay-container [aria-modal="true"]');
    if (!modal) {
      return;
    }
    const panelId = `${this.id}-panel`;
    if (this._trackedModal) {
      removeAriaReferencedId(this._trackedModal, "aria-owns", panelId);
    }
    addAriaReferencedId(modal, "aria-owns", panelId);
    this._trackedModal = modal;
  }
  /** Clears the reference to the listbox overlay element from the modal it was added to. */
  _clearFromModal() {
    if (!this._trackedModal) {
      return;
    }
    const panelId = `${this.id}-panel`;
    removeAriaReferencedId(this._trackedModal, "aria-owns", panelId);
    this._trackedModal = null;
  }
  /** Closes the overlay panel and focuses the host element. */
  close() {
    if (this._panelOpen) {
      this._panelOpen = false;
      this._exitAndDetach();
      this._keyManager.withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr");
      this._changeDetectorRef.markForCheck();
      this._onTouched();
      this.stateChanges.next();
      Promise.resolve().then(() => this.openedChange.emit(false));
    }
  }
  /** Triggers the exit animation and detaches the overlay at the end. */
  _exitAndDetach() {
    if (this._animationsDisabled || !this.panel) {
      this._detachOverlay();
      return;
    }
    this._cleanupDetach?.();
    this._cleanupDetach = () => {
      cleanupEvent();
      clearTimeout(exitFallbackTimer);
      this._cleanupDetach = void 0;
    };
    const panel = this.panel.nativeElement;
    const cleanupEvent = this._renderer.listen(panel, "animationend", event => {
      if (event.animationName === "_mat-select-exit") {
        this._cleanupDetach?.();
        this._detachOverlay();
      }
    });
    const exitFallbackTimer = setTimeout(() => {
      this._cleanupDetach?.();
      this._detachOverlay();
    }, 200);
    panel.classList.add("mat-select-panel-exit");
  }
  /** Detaches the current overlay directive. */
  _detachOverlay() {
    this._overlayDir.detachOverlay();
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Sets the select's value. Part of the ControlValueAccessor interface
   * required to integrate with Angular's core forms API.
   *
   * @param value New value to be written to the model.
   */
  writeValue(value) {
    this._assignValue(value);
  }
  /**
   * Saves a callback function to be invoked when the select's value
   * changes from user input. Part of the ControlValueAccessor interface
   * required to integrate with Angular's core forms API.
   *
   * @param fn Callback to be triggered when the value changes.
   */
  registerOnChange(fn) {
    this._onChange = fn;
  }
  /**
   * Saves a callback function to be invoked when the select is blurred
   * by the user. Part of the ControlValueAccessor interface required
   * to integrate with Angular's core forms API.
   *
   * @param fn Callback to be triggered when the component has been touched.
   */
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  /**
   * Disables the select. Part of the ControlValueAccessor interface required
   * to integrate with Angular's core forms API.
   *
   * @param isDisabled Sets whether the component is disabled.
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this._changeDetectorRef.markForCheck();
    this.stateChanges.next();
  }
  /** Whether or not the overlay panel is open. */
  get panelOpen() {
    return this._panelOpen;
  }
  /** The currently selected option. */
  get selected() {
    return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0];
  }
  /** The value displayed in the trigger. */
  get triggerValue() {
    if (this.empty) {
      return "";
    }
    if (this._multiple) {
      const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);
      if (this._isRtl()) {
        selectedOptions.reverse();
      }
      return selectedOptions.join(", ");
    }
    return this._selectionModel.selected[0].viewValue;
  }
  /** Refreshes the error state of the select. */
  updateErrorState() {
    this._errorStateTracker.updateErrorState();
  }
  /** Whether the element is in RTL mode. */
  _isRtl() {
    return this._dir ? this._dir.value === "rtl" : false;
  }
  /** Handles all keydown events on the select. */
  _handleKeydown(event) {
    if (!this.disabled) {
      this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    }
  }
  /** Handles keyboard events while the select is closed. */
  _handleClosedKeydown(event) {
    const keyCode = event.keyCode;
    const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
    const isOpenKey = keyCode === ENTER || keyCode === SPACE;
    const manager = this._keyManager;
    if (!manager.isTyping() && isOpenKey && !hasModifierKey(event) || (this.multiple || event.altKey) && isArrowKey) {
      event.preventDefault();
      this.open();
    } else if (!this.multiple) {
      const previouslySelectedOption = this.selected;
      manager.onKeydown(event);
      const selectedOption = this.selected;
      if (selectedOption && previouslySelectedOption !== selectedOption) {
        this._liveAnnouncer.announce(selectedOption.viewValue, 1e4);
      }
    }
  }
  /** Handles keyboard events when the selected is open. */
  _handleOpenKeydown(event) {
    const manager = this._keyManager;
    const keyCode = event.keyCode;
    const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
    const isTyping = manager.isTyping();
    if (isArrowKey && event.altKey) {
      event.preventDefault();
      this.close();
    } else if (!isTyping && (keyCode === ENTER || keyCode === SPACE) && manager.activeItem && !hasModifierKey(event)) {
      event.preventDefault();
      manager.activeItem._selectViaInteraction();
    } else if (!isTyping && this._multiple && keyCode === A && event.ctrlKey) {
      event.preventDefault();
      const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);
      this.options.forEach(option => {
        if (!option.disabled) {
          hasDeselectedOptions ? option.select() : option.deselect();
        }
      });
    } else {
      const previouslyFocusedIndex = manager.activeItemIndex;
      manager.onKeydown(event);
      if (this._multiple && isArrowKey && event.shiftKey && manager.activeItem && manager.activeItemIndex !== previouslyFocusedIndex) {
        manager.activeItem._selectViaInteraction();
      }
    }
  }
  /** Handles keyboard events coming from the overlay. */
  _handleOverlayKeydown(event) {
    if (event.keyCode === ESCAPE && !hasModifierKey(event)) {
      event.preventDefault();
      this.close();
    }
  }
  _onFocus() {
    if (!this.disabled) {
      this._focused = true;
      this.stateChanges.next();
    }
  }
  /**
   * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
   * "blur" to the panel when it opens, causing a false positive.
   */
  _onBlur() {
    this._focused = false;
    this._keyManager?.cancelTypeahead();
    if (!this.disabled && !this.panelOpen) {
      this._onTouched();
      this._changeDetectorRef.markForCheck();
      this.stateChanges.next();
    }
  }
  /** Returns the theme to be used on the panel. */
  _getPanelTheme() {
    return this._parentFormField ? `mat-${this._parentFormField.color}` : "";
  }
  /** Whether the select has a value. */
  get empty() {
    return !this._selectionModel || this._selectionModel.isEmpty();
  }
  _initializeSelection() {
    Promise.resolve().then(() => {
      if (this.ngControl) {
        this._value = this.ngControl.value;
      }
      this._setSelectionByValue(this._value);
      this.stateChanges.next();
    });
  }
  /**
   * Sets the selected option based on a value. If no option can be
   * found with the designated value, the select trigger is cleared.
   */
  _setSelectionByValue(value) {
    this.options.forEach(option => option.setInactiveStyles());
    this._selectionModel.clear();
    if (this.multiple && value) {
      if (!Array.isArray(value) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getMatSelectNonArrayValueError();
      }
      value.forEach(currentValue => this._selectOptionByValue(currentValue));
      this._sortValues();
    } else {
      const correspondingOption = this._selectOptionByValue(value);
      if (correspondingOption) {
        this._keyManager.updateActiveItem(correspondingOption);
      } else if (!this.panelOpen) {
        this._keyManager.updateActiveItem(-1);
      }
    }
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Finds and selects and option based on its value.
   * @returns Option that has the corresponding value.
   */
  _selectOptionByValue(value) {
    const correspondingOption = this.options.find(option => {
      if (this._selectionModel.isSelected(option)) {
        return false;
      }
      try {
        return (option.value != null || this.canSelectNullableOptions) && this._compareWith(option.value, value);
      } catch (error) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          console.warn(error);
        }
        return false;
      }
    });
    if (correspondingOption) {
      this._selectionModel.select(correspondingOption);
    }
    return correspondingOption;
  }
  /** Assigns a specific value to the select. Returns whether the value has changed. */
  _assignValue(newValue) {
    if (newValue !== this._value || this._multiple && Array.isArray(newValue)) {
      if (this.options) {
        this._setSelectionByValue(newValue);
      }
      this._value = newValue;
      return true;
    }
    return false;
  }
  // `skipPredicate` determines if key manager should avoid putting a given option in the tab
  // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA
  // recommendation.
  //
  // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it
  // makes a few exceptions for compound widgets.
  //
  // From [Developing a Keyboard Interface](
  // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):
  //   "For the following composite widget elements, keep them focusable when disabled: Options in a
  //   Listbox..."
  //
  // The user can focus disabled options using the keyboard, but the user cannot click disabled
  // options.
  _skipPredicate = option => {
    if (this.panelOpen) {
      return false;
    }
    return option.disabled;
  };
  /** Gets how wide the overlay panel should be. */
  _getOverlayWidth(preferredOrigin) {
    if (this.panelWidth === "auto") {
      const refToMeasure = preferredOrigin instanceof CdkOverlayOrigin ? preferredOrigin.elementRef : preferredOrigin || this._elementRef;
      return refToMeasure.nativeElement.getBoundingClientRect().width;
    }
    return this.panelWidth === null ? "" : this.panelWidth;
  }
  /** Syncs the parent state with the individual options. */
  _syncParentProperties() {
    if (this.options) {
      for (const option of this.options) {
        option._changeDetectorRef.markForCheck();
      }
    }
  }
  /** Sets up a key manager to listen to keyboard events on the overlay panel. */
  _initKeyManager() {
    this._keyManager = new ActiveDescendantKeyManager(this.options).withTypeAhead(this.typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr").withHomeAndEnd().withPageUpDown().withAllowedModifierKeys(["shiftKey"]).skipPredicate(this._skipPredicate);
    this._keyManager.tabOut.subscribe(() => {
      if (this.panelOpen) {
        if (!this.multiple && this._keyManager.activeItem) {
          this._keyManager.activeItem._selectViaInteraction();
        }
        this.focus();
        this.close();
      }
    });
    this._keyManager.change.subscribe(() => {
      if (this._panelOpen && this.panel) {
        this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);
      } else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {
        this._keyManager.activeItem._selectViaInteraction();
      }
    });
  }
  /** Drops current option subscriptions and IDs and resets from scratch. */
  _resetOptions() {
    const changedOrDestroyed = merge(this.options.changes, this._destroy);
    this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe(event => {
      this._onSelect(event.source, event.isUserInput);
      if (event.isUserInput && !this.multiple && this._panelOpen) {
        this.close();
        this.focus();
      }
    });
    merge(...this.options.map(option => option._stateChanges)).pipe(takeUntil(changedOrDestroyed)).subscribe(() => {
      this._changeDetectorRef.detectChanges();
      this.stateChanges.next();
    });
  }
  /** Invoked when an option is clicked. */
  _onSelect(option, isUserInput) {
    const wasSelected = this._selectionModel.isSelected(option);
    if (!this.canSelectNullableOptions && option.value == null && !this._multiple) {
      option.deselect();
      this._selectionModel.clear();
      if (this.value != null) {
        this._propagateChanges(option.value);
      }
    } else {
      if (wasSelected !== option.selected) {
        option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
      }
      if (isUserInput) {
        this._keyManager.setActiveItem(option);
      }
      if (this.multiple) {
        this._sortValues();
        if (isUserInput) {
          this.focus();
        }
      }
    }
    if (wasSelected !== this._selectionModel.isSelected(option)) {
      this._propagateChanges();
    }
    this.stateChanges.next();
  }
  /** Sorts the selected values in the selected based on their order in the panel. */
  _sortValues() {
    if (this.multiple) {
      const options = this.options.toArray();
      this._selectionModel.sort((a2, b2) => {
        return this.sortComparator ? this.sortComparator(a2, b2, options) : options.indexOf(a2) - options.indexOf(b2);
      });
      this.stateChanges.next();
    }
  }
  /** Emits change event to set the model value. */
  _propagateChanges(fallbackValue) {
    let valueToEmit;
    if (this.multiple) {
      valueToEmit = this.selected.map(option => option.value);
    } else {
      valueToEmit = this.selected ? this.selected.value : fallbackValue;
    }
    this._value = valueToEmit;
    this.valueChange.emit(valueToEmit);
    this._onChange(valueToEmit);
    this.selectionChange.emit(this._getChangeEvent(valueToEmit));
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Highlights the selected item. If no option is selected, it will highlight
   * the first *enabled* option.
   */
  _highlightCorrectOption() {
    if (this._keyManager) {
      if (this.empty) {
        let firstEnabledOptionIndex = -1;
        for (let index = 0; index < this.options.length; index++) {
          const option = this.options.get(index);
          if (!option.disabled) {
            firstEnabledOptionIndex = index;
            break;
          }
        }
        this._keyManager.setActiveItem(firstEnabledOptionIndex);
      } else {
        this._keyManager.setActiveItem(this._selectionModel.selected[0]);
      }
    }
  }
  /** Whether the panel is allowed to open. */
  _canOpen() {
    return !this._panelOpen && !this.disabled && this.options?.length > 0 && !!this._overlayDir;
  }
  /** Focuses the select element. */
  focus(options) {
    this._elementRef.nativeElement.focus(options);
  }
  /** Gets the aria-labelledby for the select panel. */
  _getPanelAriaLabelledby() {
    if (this.ariaLabel) {
      return null;
    }
    const labelId = this._parentFormField?.getLabelId() || null;
    const labelExpression = labelId ? labelId + " " : "";
    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;
  }
  /** Determines the `aria-activedescendant` to be set on the host. */
  _getAriaActiveDescendant() {
    if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
      return this._keyManager.activeItem.id;
    }
    return null;
  }
  /** Gets the aria-labelledby of the select component trigger. */
  _getTriggerAriaLabelledby() {
    if (this.ariaLabel) {
      return null;
    }
    const labelId = this._parentFormField?.getLabelId();
    let value = (labelId ? labelId + " " : "") + this._valueId;
    if (this.ariaLabelledby) {
      value += " " + this.ariaLabelledby;
    }
    return value;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  setDescribedByIds(ids) {
    if (ids.length) {
      this._elementRef.nativeElement.setAttribute("aria-describedby", ids.join(" "));
    } else {
      this._elementRef.nativeElement.removeAttribute("aria-describedby");
    }
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  onContainerClick() {
    this.focus();
    this.open();
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get shouldLabelFloat() {
    return this.panelOpen || !this.empty || this.focused && !!this.placeholder;
  }
  static ɵfac = function MatSelect_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSelect)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatSelect,
    selectors: [["mat-select"]],
    contentQueries: function MatSelect_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MAT_SELECT_TRIGGER, 5);
        ɵɵcontentQuery(dirIndex, MatOption, 5);
        ɵɵcontentQuery(dirIndex, MAT_OPTGROUP, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.customTrigger = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.options = _t2);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.optionGroups = _t2);
      }
    },
    viewQuery: function MatSelect_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c02, 5);
        ɵɵviewQuery(_c12, 5);
        ɵɵviewQuery(CdkConnectedOverlay, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.trigger = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.panel = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._overlayDir = _t2.first);
      }
    },
    hostAttrs: ["role", "combobox", "aria-haspopup", "listbox", 1, "mat-mdc-select"],
    hostVars: 19,
    hostBindings: function MatSelect_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function MatSelect_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        })("focus", function MatSelect_focus_HostBindingHandler() {
          return ctx._onFocus();
        })("blur", function MatSelect_blur_HostBindingHandler() {
          return ctx._onBlur();
        });
      }
      if (rf & 2) {
        ɵɵattribute("id", ctx.id)("tabindex", ctx.disabled ? -1 : ctx.tabIndex)("aria-controls", ctx.panelOpen ? ctx.id + "-panel" : null)("aria-expanded", ctx.panelOpen)("aria-label", ctx.ariaLabel || null)("aria-required", ctx.required.toString())("aria-disabled", ctx.disabled.toString())("aria-invalid", ctx.errorState)("aria-activedescendant", ctx._getAriaActiveDescendant());
        ɵɵclassProp("mat-mdc-select-disabled", ctx.disabled)("mat-mdc-select-invalid", ctx.errorState)("mat-mdc-select-required", ctx.required)("mat-mdc-select-empty", ctx.empty)("mat-mdc-select-multiple", ctx.multiple);
      }
    },
    inputs: {
      userAriaDescribedBy: [0, "aria-describedby", "userAriaDescribedBy"],
      panelClass: "panelClass",
      disabled: [2, "disabled", "disabled", booleanAttribute],
      disableRipple: [2, "disableRipple", "disableRipple", booleanAttribute],
      tabIndex: [2, "tabIndex", "tabIndex", value => value == null ? 0 : numberAttribute(value)],
      hideSingleSelectionIndicator: [2, "hideSingleSelectionIndicator", "hideSingleSelectionIndicator", booleanAttribute],
      placeholder: "placeholder",
      required: [2, "required", "required", booleanAttribute],
      multiple: [2, "multiple", "multiple", booleanAttribute],
      disableOptionCentering: [2, "disableOptionCentering", "disableOptionCentering", booleanAttribute],
      compareWith: "compareWith",
      value: "value",
      ariaLabel: [0, "aria-label", "ariaLabel"],
      ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
      errorStateMatcher: "errorStateMatcher",
      typeaheadDebounceInterval: [2, "typeaheadDebounceInterval", "typeaheadDebounceInterval", numberAttribute],
      sortComparator: "sortComparator",
      id: "id",
      panelWidth: "panelWidth",
      canSelectNullableOptions: [2, "canSelectNullableOptions", "canSelectNullableOptions", booleanAttribute]
    },
    outputs: {
      openedChange: "openedChange",
      _openedStream: "opened",
      _closedStream: "closed",
      selectionChange: "selectionChange",
      valueChange: "valueChange"
    },
    exportAs: ["matSelect"],
    features: [ɵɵProvidersFeature([{
      provide: MatFormFieldControl,
      useExisting: _MatSelect
    }, {
      provide: MAT_OPTION_PARENT_COMPONENT,
      useExisting: _MatSelect
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c32,
    decls: 11,
    vars: 9,
    consts: [["fallbackOverlayOrigin", "cdkOverlayOrigin", "trigger", ""], ["panel", ""], ["cdk-overlay-origin", "", 1, "mat-mdc-select-trigger", 3, "click"], [1, "mat-mdc-select-value"], [1, "mat-mdc-select-placeholder", "mat-mdc-select-min-line"], [1, "mat-mdc-select-value-text"], [1, "mat-mdc-select-arrow-wrapper"], [1, "mat-mdc-select-arrow"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "focusable", "false", "aria-hidden", "true"], ["d", "M7 10l5 5 5-5z"], ["cdk-connected-overlay", "", "cdkConnectedOverlayLockPosition", "", "cdkConnectedOverlayHasBackdrop", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", 3, "backdropClick", "overlayKeydown", "cdkConnectedOverlayDisableClose", "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayWidth", "cdkConnectedOverlayFlexibleDimensions"], [1, "mat-mdc-select-min-line"], ["role", "listbox", "tabindex", "-1", 3, "keydown", "ngClass"]],
    template: function MatSelect_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c22);
        ɵɵelementStart(0, "div", 2, 0);
        ɵɵlistener("click", function MatSelect_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.open());
        });
        ɵɵelementStart(3, "div", 3);
        ɵɵtemplate(4, MatSelect_Conditional_4_Template, 2, 1, "span", 4)(5, MatSelect_Conditional_5_Template, 3, 1, "span", 5);
        ɵɵelementEnd();
        ɵɵelementStart(6, "div", 6)(7, "div", 7);
        ɵɵnamespaceSVG();
        ɵɵelementStart(8, "svg", 8);
        ɵɵelement(9, "path", 9);
        ɵɵelementEnd()()()();
        ɵɵtemplate(10, MatSelect_ng_template_10_Template, 3, 10, "ng-template", 10);
        ɵɵlistener("backdropClick", function MatSelect_Template_ng_template_backdropClick_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.close());
        })("overlayKeydown", function MatSelect_Template_ng_template_overlayKeydown_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._handleOverlayKeydown($event));
        });
      }
      if (rf & 2) {
        const fallbackOverlayOrigin_r4 = ɵɵreference(1);
        ɵɵadvance(3);
        ɵɵattribute("id", ctx._valueId);
        ɵɵadvance();
        ɵɵconditional(ctx.empty ? 4 : 5);
        ɵɵadvance(6);
        ɵɵproperty("cdkConnectedOverlayDisableClose", true)("cdkConnectedOverlayPanelClass", ctx._overlayPanelClass)("cdkConnectedOverlayScrollStrategy", ctx._scrollStrategy)("cdkConnectedOverlayOrigin", ctx._preferredOverlayOrigin || fallbackOverlayOrigin_r4)("cdkConnectedOverlayPositions", ctx._positions)("cdkConnectedOverlayWidth", ctx._overlayWidth)("cdkConnectedOverlayFlexibleDimensions", true);
      }
    },
    dependencies: [CdkOverlayOrigin, CdkConnectedOverlay, NgClass],
    styles: ['@keyframes _mat-select-enter{from{opacity:0;transform:scaleY(0.8)}to{opacity:1;transform:none}}@keyframes _mat-select-exit{from{opacity:1}to{opacity:0}}.mat-mdc-select{display:inline-block;width:100%;outline:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-select-enabled-trigger-text-color, var(--mat-sys-on-surface));font-family:var(--mat-select-trigger-text-font, var(--mat-sys-body-large-font));line-height:var(--mat-select-trigger-text-line-height, var(--mat-sys-body-large-line-height));font-size:var(--mat-select-trigger-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-select-trigger-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mat-select-trigger-text-tracking, var(--mat-sys-body-large-tracking))}div.mat-mdc-select-panel{box-shadow:var(--mat-select-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-select-disabled{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-disabled .mat-mdc-select-placeholder{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-invalid .mat-mdc-select-arrow,.mat-form-field-invalid:not(.mat-form-field-disabled) .mat-mdc-form-field-infix::after{color:var(--mat-select-invalid-arrow-color, var(--mat-sys-error))}.mat-mdc-select-arrow{width:10px;height:5px;position:relative;color:var(--mat-select-enabled-arrow-color, var(--mat-sys-on-surface-variant))}.mat-mdc-form-field.mat-focused .mat-mdc-select-arrow{color:var(--mat-select-focused-arrow-color, var(--mat-sys-primary))}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-disabled .mat-mdc-select-arrow{color:var(--mat-select-disabled-arrow-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}@media(forced-colors: active){.mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .mat-mdc-select-arrow svg{fill:GrayText}}div.mat-mdc-select-panel{width:100%;max-height:275px;outline:0;overflow:auto;padding:8px 0;border-radius:4px;box-sizing:border-box;position:static;background-color:var(--mat-select-panel-background-color, var(--mat-sys-surface-container))}@media(forced-colors: active){div.mat-mdc-select-panel{outline:solid 1px}}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) div.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above div.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}div.mat-mdc-select-panel .mat-mdc-option{--mdc-list-list-item-container-color: var(--mat-select-panel-background-color)}.mat-select-panel-animations-enabled{animation:_mat-select-enter 120ms cubic-bezier(0, 0, 0.2, 1)}.mat-select-panel-animations-enabled.mat-select-panel-exit{animation:_mat-select-exit 100ms linear}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1);color:var(--mat-select-placeholder-text-color, var(--mat-sys-on-surface-variant))}.mat-mdc-form-field:not(.mat-form-field-animations-enabled) .mat-mdc-select-placeholder,._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper{cursor:pointer}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100%/0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:var(--mat-select-arrow-transform, translateY(-8px))}'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSelect, [{
    type: Component,
    args: [{
      selector: "mat-select",
      exportAs: "matSelect",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "role": "combobox",
        "aria-haspopup": "listbox",
        "class": "mat-mdc-select",
        "[attr.id]": "id",
        "[attr.tabindex]": "disabled ? -1 : tabIndex",
        "[attr.aria-controls]": 'panelOpen ? id + "-panel" : null',
        "[attr.aria-expanded]": "panelOpen",
        "[attr.aria-label]": "ariaLabel || null",
        "[attr.aria-required]": "required.toString()",
        "[attr.aria-disabled]": "disabled.toString()",
        "[attr.aria-invalid]": "errorState",
        "[attr.aria-activedescendant]": "_getAriaActiveDescendant()",
        "[class.mat-mdc-select-disabled]": "disabled",
        "[class.mat-mdc-select-invalid]": "errorState",
        "[class.mat-mdc-select-required]": "required",
        "[class.mat-mdc-select-empty]": "empty",
        "[class.mat-mdc-select-multiple]": "multiple",
        "(keydown)": "_handleKeydown($event)",
        "(focus)": "_onFocus()",
        "(blur)": "_onBlur()"
      },
      providers: [{
        provide: MatFormFieldControl,
        useExisting: MatSelect
      }, {
        provide: MAT_OPTION_PARENT_COMPONENT,
        useExisting: MatSelect
      }],
      imports: [CdkOverlayOrigin, CdkConnectedOverlay, NgClass],
      template: `<div cdk-overlay-origin
     class="mat-mdc-select-trigger"
     (click)="open()"
     #fallbackOverlayOrigin="cdkOverlayOrigin"
     #trigger>

  <div class="mat-mdc-select-value" [attr.id]="_valueId">
    @if (empty) {
      <span class="mat-mdc-select-placeholder mat-mdc-select-min-line">{{placeholder}}</span>
    } @else {
      <span class="mat-mdc-select-value-text">
        @if (customTrigger) {
          <ng-content select="mat-select-trigger"></ng-content>
        } @else {
          <span class="mat-mdc-select-min-line">{{triggerValue}}</span>
        }
      </span>
    }
  </div>

  <div class="mat-mdc-select-arrow-wrapper">
    <div class="mat-mdc-select-arrow">
      <!-- Use an inline SVG, because it works better than a CSS triangle in high contrast mode. -->
      <svg viewBox="0 0 24 24" width="24px" height="24px" focusable="false" aria-hidden="true">
        <path d="M7 10l5 5 5-5z"/>
      </svg>
    </div>
  </div>
</div>

<ng-template
  cdk-connected-overlay
  cdkConnectedOverlayLockPosition
  cdkConnectedOverlayHasBackdrop
  cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
  [cdkConnectedOverlayDisableClose]="true"
  [cdkConnectedOverlayPanelClass]="_overlayPanelClass"
  [cdkConnectedOverlayScrollStrategy]="_scrollStrategy"
  [cdkConnectedOverlayOrigin]="_preferredOverlayOrigin || fallbackOverlayOrigin"
  [cdkConnectedOverlayPositions]="_positions"
  [cdkConnectedOverlayWidth]="_overlayWidth"
  [cdkConnectedOverlayFlexibleDimensions]="true"
  (backdropClick)="close()"
  (overlayKeydown)="_handleOverlayKeydown($event)">
  <div
    #panel
    role="listbox"
    tabindex="-1"
    class="mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open {{ _getPanelTheme() }}"
    [class.mat-select-panel-animations-enabled]="!_animationsDisabled"
    [attr.id]="id + '-panel'"
    [attr.aria-multiselectable]="multiple"
    [attr.aria-label]="ariaLabel || null"
    [attr.aria-labelledby]="_getPanelAriaLabelledby()"
    [ngClass]="panelClass"
    (keydown)="_handleKeydown($event)">
    <ng-content></ng-content>
  </div>
</ng-template>
`,
      styles: ['@keyframes _mat-select-enter{from{opacity:0;transform:scaleY(0.8)}to{opacity:1;transform:none}}@keyframes _mat-select-exit{from{opacity:1}to{opacity:0}}.mat-mdc-select{display:inline-block;width:100%;outline:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-select-enabled-trigger-text-color, var(--mat-sys-on-surface));font-family:var(--mat-select-trigger-text-font, var(--mat-sys-body-large-font));line-height:var(--mat-select-trigger-text-line-height, var(--mat-sys-body-large-line-height));font-size:var(--mat-select-trigger-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-select-trigger-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mat-select-trigger-text-tracking, var(--mat-sys-body-large-tracking))}div.mat-mdc-select-panel{box-shadow:var(--mat-select-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-select-disabled{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-disabled .mat-mdc-select-placeholder{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-invalid .mat-mdc-select-arrow,.mat-form-field-invalid:not(.mat-form-field-disabled) .mat-mdc-form-field-infix::after{color:var(--mat-select-invalid-arrow-color, var(--mat-sys-error))}.mat-mdc-select-arrow{width:10px;height:5px;position:relative;color:var(--mat-select-enabled-arrow-color, var(--mat-sys-on-surface-variant))}.mat-mdc-form-field.mat-focused .mat-mdc-select-arrow{color:var(--mat-select-focused-arrow-color, var(--mat-sys-primary))}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-disabled .mat-mdc-select-arrow{color:var(--mat-select-disabled-arrow-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}@media(forced-colors: active){.mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .mat-mdc-select-arrow svg{fill:GrayText}}div.mat-mdc-select-panel{width:100%;max-height:275px;outline:0;overflow:auto;padding:8px 0;border-radius:4px;box-sizing:border-box;position:static;background-color:var(--mat-select-panel-background-color, var(--mat-sys-surface-container))}@media(forced-colors: active){div.mat-mdc-select-panel{outline:solid 1px}}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) div.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above div.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}div.mat-mdc-select-panel .mat-mdc-option{--mdc-list-list-item-container-color: var(--mat-select-panel-background-color)}.mat-select-panel-animations-enabled{animation:_mat-select-enter 120ms cubic-bezier(0, 0, 0.2, 1)}.mat-select-panel-animations-enabled.mat-select-panel-exit{animation:_mat-select-exit 100ms linear}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1);color:var(--mat-select-placeholder-text-color, var(--mat-sys-on-surface-variant))}.mat-mdc-form-field:not(.mat-form-field-animations-enabled) .mat-mdc-select-placeholder,._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper{cursor:pointer}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100%/0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:var(--mat-select-arrow-transform, translateY(-8px))}']
    }]
  }], () => [], {
    options: [{
      type: ContentChildren,
      args: [MatOption, {
        descendants: true
      }]
    }],
    optionGroups: [{
      type: ContentChildren,
      args: [MAT_OPTGROUP, {
        descendants: true
      }]
    }],
    customTrigger: [{
      type: ContentChild,
      args: [MAT_SELECT_TRIGGER]
    }],
    userAriaDescribedBy: [{
      type: Input,
      args: ["aria-describedby"]
    }],
    trigger: [{
      type: ViewChild,
      args: ["trigger"]
    }],
    panel: [{
      type: ViewChild,
      args: ["panel"]
    }],
    _overlayDir: [{
      type: ViewChild,
      args: [CdkConnectedOverlay]
    }],
    panelClass: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    tabIndex: [{
      type: Input,
      args: [{
        transform: value => value == null ? 0 : numberAttribute(value)
      }]
    }],
    hideSingleSelectionIndicator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    placeholder: [{
      type: Input
    }],
    required: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    multiple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disableOptionCentering: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    compareWith: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    errorStateMatcher: [{
      type: Input
    }],
    typeaheadDebounceInterval: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    sortComparator: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    panelWidth: [{
      type: Input
    }],
    canSelectNullableOptions: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    openedChange: [{
      type: Output
    }],
    _openedStream: [{
      type: Output,
      args: ["opened"]
    }],
    _closedStream: [{
      type: Output,
      args: ["closed"]
    }],
    selectionChange: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var MatSelectTrigger = class _MatSelectTrigger {
  static ɵfac = function MatSelectTrigger_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSelectTrigger)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatSelectTrigger,
    selectors: [["mat-select-trigger"]],
    features: [ɵɵProvidersFeature([{
      provide: MAT_SELECT_TRIGGER,
      useExisting: _MatSelectTrigger
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSelectTrigger, [{
    type: Directive,
    args: [{
      selector: "mat-select-trigger",
      providers: [{
        provide: MAT_SELECT_TRIGGER,
        useExisting: MatSelectTrigger
      }]
    }]
  }], null, null);
})();
var MatSelectModule = class _MatSelectModule {
  static ɵfac = function MatSelectModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSelectModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatSelectModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER],
    imports: [OverlayModule, MatOptionModule, MatCommonModule, CdkScrollableModule, MatFormFieldModule, MatOptionModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSelectModule, [{
    type: NgModule,
    args: [{
      imports: [OverlayModule, MatOptionModule, MatCommonModule, MatSelect, MatSelectTrigger],
      exports: [CdkScrollableModule, MatFormFieldModule, MatSelect, MatSelectTrigger, MatOptionModule, MatCommonModule],
      providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/paginator.mjs
function MatPaginator_Conditional_2_Conditional_3_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-option", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const pageSizeOption_r3 = ctx.$implicit;
    ɵɵproperty("value", pageSizeOption_r3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", pageSizeOption_r3, " ");
  }
}
function MatPaginator_Conditional_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-form-field", 14)(1, "mat-select", 16, 0);
    ɵɵlistener("selectionChange", function MatPaginator_Conditional_2_Conditional_3_Template_mat_select_selectionChange_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._changePageSize($event.value));
    });
    ɵɵrepeaterCreate(3, MatPaginator_Conditional_2_Conditional_3_For_4_Template, 2, 2, "mat-option", 17, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 18);
    ɵɵlistener("click", function MatPaginator_Conditional_2_Conditional_3_Template_div_click_5_listener() {
      ɵɵrestoreView(_r1);
      const selectRef_r4 = ɵɵreference(2);
      return ɵɵresetView(selectRef_r4.open());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("appearance", ctx_r1._formFieldAppearance)("color", ctx_r1.color);
    ɵɵadvance();
    ɵɵproperty("value", ctx_r1.pageSize)("disabled", ctx_r1.disabled)("aria-labelledby", ctx_r1._pageSizeLabelId)("panelClass", ctx_r1.selectConfig.panelClass || "")("disableOptionCentering", ctx_r1.selectConfig.disableOptionCentering);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r1._displayedPageSizeOptions);
  }
}
function MatPaginator_Conditional_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.pageSize);
  }
}
function MatPaginator_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3)(1, "div", 13);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, MatPaginator_Conditional_2_Conditional_3_Template, 6, 7, "mat-form-field", 14)(4, MatPaginator_Conditional_2_Conditional_4_Template, 2, 1, "div", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("id", ctx_r1._pageSizeLabelId);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1._intl.itemsPerPageLabel, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r1._displayedPageSizeOptions.length > 1 ? 3 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r1._displayedPageSizeOptions.length <= 1 ? 4 : -1);
  }
}
function MatPaginator_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 19);
    ɵɵlistener("click", function MatPaginator_Conditional_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._buttonClicked(0, ctx_r1._previousButtonsDisabled()));
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 8);
    ɵɵelement(2, "path", 20);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("matTooltip", ctx_r1._intl.firstPageLabel)("matTooltipDisabled", ctx_r1._previousButtonsDisabled())("disabled", ctx_r1._previousButtonsDisabled())("tabindex", ctx_r1._previousButtonsDisabled() ? -1 : null);
    ɵɵattribute("aria-label", ctx_r1._intl.firstPageLabel);
  }
}
function MatPaginator_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 21);
    ɵɵlistener("click", function MatPaginator_Conditional_13_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._buttonClicked(ctx_r1.getNumberOfPages() - 1, ctx_r1._nextButtonsDisabled()));
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 8);
    ɵɵelement(2, "path", 22);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("matTooltip", ctx_r1._intl.lastPageLabel)("matTooltipDisabled", ctx_r1._nextButtonsDisabled())("disabled", ctx_r1._nextButtonsDisabled())("tabindex", ctx_r1._nextButtonsDisabled() ? -1 : null);
    ɵɵattribute("aria-label", ctx_r1._intl.lastPageLabel);
  }
}
var MatPaginatorIntl = class _MatPaginatorIntl {
  /**
   * Stream to emit from when labels are changed. Use this to notify components when the labels have
   * changed after initialization.
   */
  changes = new Subject();
  /** A label for the page size selector. */
  itemsPerPageLabel = "Items per page:";
  /** A label for the button that increments the current page. */
  nextPageLabel = "Next page";
  /** A label for the button that decrements the current page. */
  previousPageLabel = "Previous page";
  /** A label for the button that moves to the first page. */
  firstPageLabel = "First page";
  /** A label for the button that moves to the last page. */
  lastPageLabel = "Last page";
  /** A label for the range of items within the current page and the length of the whole list. */
  getRangeLabel = (page, pageSize, length) => {
    if (length == 0 || pageSize == 0) {
      return `0 of ${length}`;
    }
    length = Math.max(length, 0);
    const startIndex = page * pageSize;
    const endIndex = startIndex < length ? Math.min(startIndex + pageSize, length) : startIndex + pageSize;
    return `${startIndex + 1} \u2013 ${endIndex} of ${length}`;
  };
  static ɵfac = function MatPaginatorIntl_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatPaginatorIntl)();
  };
  static ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
    token: _MatPaginatorIntl,
    factory: _MatPaginatorIntl.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatPaginatorIntl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function MAT_PAGINATOR_INTL_PROVIDER_FACTORY(parentIntl) {
  return parentIntl || new MatPaginatorIntl();
}
var MAT_PAGINATOR_INTL_PROVIDER = {
  // If there is already an MatPaginatorIntl available, use that. Otherwise, provide a new one.
  provide: MatPaginatorIntl,
  deps: [[new Optional(), new SkipSelf(), MatPaginatorIntl]],
  useFactory: MAT_PAGINATOR_INTL_PROVIDER_FACTORY
};
var DEFAULT_PAGE_SIZE = 50;
var MAT_PAGINATOR_DEFAULT_OPTIONS = new InjectionToken("MAT_PAGINATOR_DEFAULT_OPTIONS");
var MatPaginator = class _MatPaginator {
  _intl = inject(MatPaginatorIntl);
  _changeDetectorRef = inject(ChangeDetectorRef);
  /** If set, styles the "page size" form field with the designated style. */
  _formFieldAppearance;
  /** ID for the DOM node containing the paginator's items per page label. */
  _pageSizeLabelId = inject(_IdGenerator).getId("mat-paginator-page-size-label-");
  _intlChanges;
  _isInitialized = false;
  _initializedStream = new ReplaySubject(1);
  /**
   * Theme color of the underlying form controls. This API is supported in M2
   * themes only,it has no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/paginator/styling.
   *
   * For information on applying color variants in M3, see
   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
   */
  color;
  /** The zero-based page index of the displayed list of items. Defaulted to 0. */
  get pageIndex() {
    return this._pageIndex;
  }
  set pageIndex(value) {
    this._pageIndex = Math.max(value || 0, 0);
    this._changeDetectorRef.markForCheck();
  }
  _pageIndex = 0;
  /** The length of the total number of items that are being paginated. Defaulted to 0. */
  get length() {
    return this._length;
  }
  set length(value) {
    this._length = value || 0;
    this._changeDetectorRef.markForCheck();
  }
  _length = 0;
  /** Number of items to display on a page. By default set to 50. */
  get pageSize() {
    return this._pageSize;
  }
  set pageSize(value) {
    this._pageSize = Math.max(value || 0, 0);
    this._updateDisplayedPageSizeOptions();
  }
  _pageSize;
  /** The set of provided page size options to display to the user. */
  get pageSizeOptions() {
    return this._pageSizeOptions;
  }
  set pageSizeOptions(value) {
    this._pageSizeOptions = (value || []).map(p2 => numberAttribute(p2, 0));
    this._updateDisplayedPageSizeOptions();
  }
  _pageSizeOptions = [];
  /** Whether to hide the page size selection UI from the user. */
  hidePageSize = false;
  /** Whether to show the first/last buttons UI to the user. */
  showFirstLastButtons = false;
  /** Used to configure the underlying `MatSelect` inside the paginator. */
  selectConfig = {};
  /** Whether the paginator is disabled. */
  disabled = false;
  /** Event emitted when the paginator changes the page size or page index. */
  page = new EventEmitter();
  /** Displayed set of page size options. Will be sorted and include current page size. */
  _displayedPageSizeOptions;
  /** Emits when the paginator is initialized. */
  initialized = this._initializedStream;
  constructor() {
    const _intl = this._intl;
    const defaults2 = inject(MAT_PAGINATOR_DEFAULT_OPTIONS, {
      optional: true
    });
    this._intlChanges = _intl.changes.subscribe(() => this._changeDetectorRef.markForCheck());
    if (defaults2) {
      const {
        pageSize,
        pageSizeOptions,
        hidePageSize,
        showFirstLastButtons
      } = defaults2;
      if (pageSize != null) {
        this._pageSize = pageSize;
      }
      if (pageSizeOptions != null) {
        this._pageSizeOptions = pageSizeOptions;
      }
      if (hidePageSize != null) {
        this.hidePageSize = hidePageSize;
      }
      if (showFirstLastButtons != null) {
        this.showFirstLastButtons = showFirstLastButtons;
      }
    }
    this._formFieldAppearance = defaults2?.formFieldAppearance || "outline";
  }
  ngOnInit() {
    this._isInitialized = true;
    this._updateDisplayedPageSizeOptions();
    this._initializedStream.next();
  }
  ngOnDestroy() {
    this._initializedStream.complete();
    this._intlChanges.unsubscribe();
  }
  /** Advances to the next page if it exists. */
  nextPage() {
    if (this.hasNextPage()) {
      this._navigate(this.pageIndex + 1);
    }
  }
  /** Move back to the previous page if it exists. */
  previousPage() {
    if (this.hasPreviousPage()) {
      this._navigate(this.pageIndex - 1);
    }
  }
  /** Move to the first page if not already there. */
  firstPage() {
    if (this.hasPreviousPage()) {
      this._navigate(0);
    }
  }
  /** Move to the last page if not already there. */
  lastPage() {
    if (this.hasNextPage()) {
      this._navigate(this.getNumberOfPages() - 1);
    }
  }
  /** Whether there is a previous page. */
  hasPreviousPage() {
    return this.pageIndex >= 1 && this.pageSize != 0;
  }
  /** Whether there is a next page. */
  hasNextPage() {
    const maxPageIndex = this.getNumberOfPages() - 1;
    return this.pageIndex < maxPageIndex && this.pageSize != 0;
  }
  /** Calculate the number of pages */
  getNumberOfPages() {
    if (!this.pageSize) {
      return 0;
    }
    return Math.ceil(this.length / this.pageSize);
  }
  /**
   * Changes the page size so that the first item displayed on the page will still be
   * displayed using the new page size.
   *
   * For example, if the page size is 10 and on the second page (items indexed 10-19) then
   * switching so that the page size is 5 will set the third page as the current page so
   * that the 10th item will still be displayed.
   */
  _changePageSize(pageSize) {
    const startIndex = this.pageIndex * this.pageSize;
    const previousPageIndex = this.pageIndex;
    this.pageIndex = Math.floor(startIndex / pageSize) || 0;
    this.pageSize = pageSize;
    this._emitPageEvent(previousPageIndex);
  }
  /** Checks whether the buttons for going forwards should be disabled. */
  _nextButtonsDisabled() {
    return this.disabled || !this.hasNextPage();
  }
  /** Checks whether the buttons for going backwards should be disabled. */
  _previousButtonsDisabled() {
    return this.disabled || !this.hasPreviousPage();
  }
  /**
   * Updates the list of page size options to display to the user. Includes making sure that
   * the page size is an option and that the list is sorted.
   */
  _updateDisplayedPageSizeOptions() {
    if (!this._isInitialized) {
      return;
    }
    if (!this.pageSize) {
      this._pageSize = this.pageSizeOptions.length != 0 ? this.pageSizeOptions[0] : DEFAULT_PAGE_SIZE;
    }
    this._displayedPageSizeOptions = this.pageSizeOptions.slice();
    if (this._displayedPageSizeOptions.indexOf(this.pageSize) === -1) {
      this._displayedPageSizeOptions.push(this.pageSize);
    }
    this._displayedPageSizeOptions.sort((a2, b2) => a2 - b2);
    this._changeDetectorRef.markForCheck();
  }
  /** Emits an event notifying that a change of the paginator's properties has been triggered. */
  _emitPageEvent(previousPageIndex) {
    this.page.emit({
      previousPageIndex,
      pageIndex: this.pageIndex,
      pageSize: this.pageSize,
      length: this.length
    });
  }
  /** Navigates to a specific page index. */
  _navigate(index) {
    const previousIndex = this.pageIndex;
    if (index !== previousIndex) {
      this.pageIndex = index;
      this._emitPageEvent(previousIndex);
    }
  }
  /**
   * Callback invoked when one of the navigation buttons is called.
   * @param targetIndex Index to which the paginator should navigate.
   * @param isDisabled Whether the button is disabled.
   */
  _buttonClicked(targetIndex, isDisabled) {
    if (!isDisabled) {
      this._navigate(targetIndex);
    }
  }
  static ɵfac = function MatPaginator_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatPaginator)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatPaginator,
    selectors: [["mat-paginator"]],
    hostAttrs: ["role", "group", 1, "mat-mdc-paginator"],
    inputs: {
      color: "color",
      pageIndex: [2, "pageIndex", "pageIndex", numberAttribute],
      length: [2, "length", "length", numberAttribute],
      pageSize: [2, "pageSize", "pageSize", numberAttribute],
      pageSizeOptions: "pageSizeOptions",
      hidePageSize: [2, "hidePageSize", "hidePageSize", booleanAttribute],
      showFirstLastButtons: [2, "showFirstLastButtons", "showFirstLastButtons", booleanAttribute],
      selectConfig: "selectConfig",
      disabled: [2, "disabled", "disabled", booleanAttribute]
    },
    outputs: {
      page: "page"
    },
    exportAs: ["matPaginator"],
    decls: 14,
    vars: 14,
    consts: [["selectRef", ""], [1, "mat-mdc-paginator-outer-container"], [1, "mat-mdc-paginator-container"], [1, "mat-mdc-paginator-page-size"], [1, "mat-mdc-paginator-range-actions"], ["aria-live", "polite", 1, "mat-mdc-paginator-range-label"], ["mat-icon-button", "", "type", "button", "matTooltipPosition", "above", "disabledInteractive", "", 1, "mat-mdc-paginator-navigation-first", 3, "matTooltip", "matTooltipDisabled", "disabled", "tabindex"], ["mat-icon-button", "", "type", "button", "matTooltipPosition", "above", "disabledInteractive", "", 1, "mat-mdc-paginator-navigation-previous", 3, "click", "matTooltip", "matTooltipDisabled", "disabled", "tabindex"], ["viewBox", "0 0 24 24", "focusable", "false", "aria-hidden", "true", 1, "mat-mdc-paginator-icon"], ["d", "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"], ["mat-icon-button", "", "type", "button", "matTooltipPosition", "above", "disabledInteractive", "", 1, "mat-mdc-paginator-navigation-next", 3, "click", "matTooltip", "matTooltipDisabled", "disabled", "tabindex"], ["d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"], ["mat-icon-button", "", "type", "button", "matTooltipPosition", "above", "disabledInteractive", "", 1, "mat-mdc-paginator-navigation-last", 3, "matTooltip", "matTooltipDisabled", "disabled", "tabindex"], [1, "mat-mdc-paginator-page-size-label"], [1, "mat-mdc-paginator-page-size-select", 3, "appearance", "color"], [1, "mat-mdc-paginator-page-size-value"], ["hideSingleSelectionIndicator", "", 3, "selectionChange", "value", "disabled", "aria-labelledby", "panelClass", "disableOptionCentering"], [3, "value"], [1, "mat-mdc-paginator-touch-target", 3, "click"], ["mat-icon-button", "", "type", "button", "matTooltipPosition", "above", "disabledInteractive", "", 1, "mat-mdc-paginator-navigation-first", 3, "click", "matTooltip", "matTooltipDisabled", "disabled", "tabindex"], ["d", "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"], ["mat-icon-button", "", "type", "button", "matTooltipPosition", "above", "disabledInteractive", "", 1, "mat-mdc-paginator-navigation-last", 3, "click", "matTooltip", "matTooltipDisabled", "disabled", "tabindex"], ["d", "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"]],
    template: function MatPaginator_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1)(1, "div", 2);
        ɵɵtemplate(2, MatPaginator_Conditional_2_Template, 5, 4, "div", 3);
        ɵɵelementStart(3, "div", 4)(4, "div", 5);
        ɵɵtext(5);
        ɵɵelementEnd();
        ɵɵtemplate(6, MatPaginator_Conditional_6_Template, 3, 5, "button", 6);
        ɵɵelementStart(7, "button", 7);
        ɵɵlistener("click", function MatPaginator_Template_button_click_7_listener() {
          return ctx._buttonClicked(ctx.pageIndex - 1, ctx._previousButtonsDisabled());
        });
        ɵɵnamespaceSVG();
        ɵɵelementStart(8, "svg", 8);
        ɵɵelement(9, "path", 9);
        ɵɵelementEnd()();
        ɵɵnamespaceHTML();
        ɵɵelementStart(10, "button", 10);
        ɵɵlistener("click", function MatPaginator_Template_button_click_10_listener() {
          return ctx._buttonClicked(ctx.pageIndex + 1, ctx._nextButtonsDisabled());
        });
        ɵɵnamespaceSVG();
        ɵɵelementStart(11, "svg", 8);
        ɵɵelement(12, "path", 11);
        ɵɵelementEnd()();
        ɵɵtemplate(13, MatPaginator_Conditional_13_Template, 3, 5, "button", 12);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(!ctx.hidePageSize ? 2 : -1);
        ɵɵadvance(3);
        ɵɵtextInterpolate1(" ", ctx._intl.getRangeLabel(ctx.pageIndex, ctx.pageSize, ctx.length), " ");
        ɵɵadvance();
        ɵɵconditional(ctx.showFirstLastButtons ? 6 : -1);
        ɵɵadvance();
        ɵɵproperty("matTooltip", ctx._intl.previousPageLabel)("matTooltipDisabled", ctx._previousButtonsDisabled())("disabled", ctx._previousButtonsDisabled())("tabindex", ctx._previousButtonsDisabled() ? -1 : null);
        ɵɵattribute("aria-label", ctx._intl.previousPageLabel);
        ɵɵadvance(3);
        ɵɵproperty("matTooltip", ctx._intl.nextPageLabel)("matTooltipDisabled", ctx._nextButtonsDisabled())("disabled", ctx._nextButtonsDisabled())("tabindex", ctx._nextButtonsDisabled() ? -1 : null);
        ɵɵattribute("aria-label", ctx._intl.nextPageLabel);
        ɵɵadvance(3);
        ɵɵconditional(ctx.showFirstLastButtons ? 13 : -1);
      }
    },
    dependencies: [MatFormField, MatSelect, MatOption, MatIconButton, MatTooltip],
    styles: [".mat-mdc-paginator{display:block;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-paginator-container-text-color, var(--mat-sys-on-surface));background-color:var(--mat-paginator-container-background-color, var(--mat-sys-surface));font-family:var(--mat-paginator-container-text-font, var(--mat-sys-body-small-font));line-height:var(--mat-paginator-container-text-line-height, var(--mat-sys-body-small-line-height));font-size:var(--mat-paginator-container-text-size, var(--mat-sys-body-small-size));font-weight:var(--mat-paginator-container-text-weight, var(--mat-sys-body-small-weight));letter-spacing:var(--mat-paginator-container-text-tracking, var(--mat-sys-body-small-tracking));--mat-form-field-container-height:var(--mat-paginator-form-field-container-height, 40px);--mat-form-field-container-vertical-padding:var(--mat-paginator-form-field-container-vertical-padding, 8px)}.mat-mdc-paginator .mat-mdc-select-value{font-size:var(--mat-paginator-select-trigger-text-size, var(--mat-sys-body-small-size))}.mat-mdc-paginator .mat-mdc-form-field-subscript-wrapper{display:none}.mat-mdc-paginator .mat-mdc-select{line-height:1.5}.mat-mdc-paginator-outer-container{display:flex}.mat-mdc-paginator-container{display:flex;align-items:center;justify-content:flex-end;padding:0 8px;flex-wrap:wrap;width:100%;min-height:var(--mat-paginator-container-size, 56px)}.mat-mdc-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-mdc-paginator-page-size{margin-right:0;margin-left:8px}.mat-mdc-paginator-page-size-label{margin:0 4px}.mat-mdc-paginator-page-size-select{margin:0 4px;width:84px}.mat-mdc-paginator-range-label{margin:0 32px 0 24px}.mat-mdc-paginator-range-actions{display:flex;align-items:center}.mat-mdc-paginator-icon{display:inline-block;width:28px;fill:var(--mat-paginator-enabled-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button[aria-disabled] .mat-mdc-paginator-icon{fill:var(--mat-paginator-disabled-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}[dir=rtl] .mat-mdc-paginator-icon{transform:rotate(180deg)}@media(forced-colors: active){.mat-mdc-icon-button[aria-disabled] .mat-mdc-paginator-icon,.mat-mdc-paginator-icon{fill:currentColor}.mat-mdc-paginator-range-actions .mat-mdc-icon-button{outline:solid 1px}.mat-mdc-paginator-range-actions .mat-mdc-icon-button[aria-disabled]{color:GrayText}}.mat-mdc-paginator-touch-target{display:var(--mat-paginator-touch-target-display, block);position:absolute;top:50%;left:50%;width:84px;height:48px;background-color:rgba(0,0,0,0);transform:translate(-50%, -50%);cursor:pointer}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatPaginator, [{
    type: Component,
    args: [{
      selector: "mat-paginator",
      exportAs: "matPaginator",
      host: {
        "class": "mat-mdc-paginator",
        "role": "group"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      imports: [MatFormField, MatSelect, MatOption, MatIconButton, MatTooltip],
      template: '<div class="mat-mdc-paginator-outer-container">\n  <div class="mat-mdc-paginator-container">\n    @if (!hidePageSize) {\n      <div class="mat-mdc-paginator-page-size">\n        <div class="mat-mdc-paginator-page-size-label" [attr.id]="_pageSizeLabelId">\n          {{_intl.itemsPerPageLabel}}\n        </div>\n\n        @if (_displayedPageSizeOptions.length > 1) {\n          <mat-form-field\n            [appearance]="_formFieldAppearance!"\n            [color]="color"\n            class="mat-mdc-paginator-page-size-select">\n            <mat-select\n              #selectRef\n              [value]="pageSize"\n              [disabled]="disabled"\n              [aria-labelledby]="_pageSizeLabelId"\n              [panelClass]="selectConfig.panelClass || \'\'"\n              [disableOptionCentering]="selectConfig.disableOptionCentering"\n              (selectionChange)="_changePageSize($event.value)"\n              hideSingleSelectionIndicator>\n              @for (pageSizeOption of _displayedPageSizeOptions; track pageSizeOption) {\n                <mat-option [value]="pageSizeOption">\n                  {{pageSizeOption}}\n                </mat-option>\n              }\n            </mat-select>\n          <div class="mat-mdc-paginator-touch-target" (click)="selectRef.open()"></div>\n          </mat-form-field>\n        }\n\n        @if (_displayedPageSizeOptions.length <= 1) {\n          <div class="mat-mdc-paginator-page-size-value">{{pageSize}}</div>\n        }\n      </div>\n    }\n\n    <div class="mat-mdc-paginator-range-actions">\n      <div class="mat-mdc-paginator-range-label" aria-live="polite">\n        {{_intl.getRangeLabel(pageIndex, pageSize, length)}}\n      </div>\n\n      <!--\n      The buttons use `disabledInteractive` so that they can retain focus if they become disabled,\n      otherwise focus is moved to the document body. However, users should not be able to navigate\n      into these buttons, so `tabindex` is set to -1 when disabled.\n      -->\n\n      @if (showFirstLastButtons) {\n        <button mat-icon-button type="button"\n                class="mat-mdc-paginator-navigation-first"\n                (click)="_buttonClicked(0, _previousButtonsDisabled())"\n                [attr.aria-label]="_intl.firstPageLabel"\n                [matTooltip]="_intl.firstPageLabel"\n                [matTooltipDisabled]="_previousButtonsDisabled()"\n                matTooltipPosition="above"\n                [disabled]="_previousButtonsDisabled()"\n                [tabindex]="_previousButtonsDisabled() ? -1 : null"\n                disabledInteractive>\n          <svg class="mat-mdc-paginator-icon"\n              viewBox="0 0 24 24"\n              focusable="false"\n              aria-hidden="true">\n            <path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"/>\n          </svg>\n        </button>\n      }\n      <button mat-icon-button type="button"\n              class="mat-mdc-paginator-navigation-previous"\n              (click)="_buttonClicked(pageIndex - 1, _previousButtonsDisabled())"\n              [attr.aria-label]="_intl.previousPageLabel"\n              [matTooltip]="_intl.previousPageLabel"\n              [matTooltipDisabled]="_previousButtonsDisabled()"\n              matTooltipPosition="above"\n              [disabled]="_previousButtonsDisabled()"\n              [tabindex]="_previousButtonsDisabled() ? -1 : null"\n              disabledInteractive>\n        <svg class="mat-mdc-paginator-icon"\n             viewBox="0 0 24 24"\n             focusable="false"\n             aria-hidden="true">\n          <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>\n        </svg>\n      </button>\n      <button mat-icon-button type="button"\n              class="mat-mdc-paginator-navigation-next"\n              (click)="_buttonClicked(pageIndex + 1, _nextButtonsDisabled())"\n              [attr.aria-label]="_intl.nextPageLabel"\n              [matTooltip]="_intl.nextPageLabel"\n              [matTooltipDisabled]="_nextButtonsDisabled()"\n              matTooltipPosition="above"\n              [disabled]="_nextButtonsDisabled()"\n              [tabindex]="_nextButtonsDisabled() ? -1 : null"\n              disabledInteractive>\n        <svg class="mat-mdc-paginator-icon"\n             viewBox="0 0 24 24"\n             focusable="false"\n             aria-hidden="true">\n          <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>\n        </svg>\n      </button>\n      @if (showFirstLastButtons) {\n        <button mat-icon-button type="button"\n                class="mat-mdc-paginator-navigation-last"\n                (click)="_buttonClicked(getNumberOfPages() - 1, _nextButtonsDisabled())"\n                [attr.aria-label]="_intl.lastPageLabel"\n                [matTooltip]="_intl.lastPageLabel"\n                [matTooltipDisabled]="_nextButtonsDisabled()"\n                matTooltipPosition="above"\n                [disabled]="_nextButtonsDisabled()"\n                [tabindex]="_nextButtonsDisabled() ? -1 : null"\n                disabledInteractive>\n          <svg class="mat-mdc-paginator-icon"\n              viewBox="0 0 24 24"\n              focusable="false"\n              aria-hidden="true">\n            <path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"/>\n          </svg>\n        </button>\n      }\n    </div>\n  </div>\n</div>\n',
      styles: [".mat-mdc-paginator{display:block;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-paginator-container-text-color, var(--mat-sys-on-surface));background-color:var(--mat-paginator-container-background-color, var(--mat-sys-surface));font-family:var(--mat-paginator-container-text-font, var(--mat-sys-body-small-font));line-height:var(--mat-paginator-container-text-line-height, var(--mat-sys-body-small-line-height));font-size:var(--mat-paginator-container-text-size, var(--mat-sys-body-small-size));font-weight:var(--mat-paginator-container-text-weight, var(--mat-sys-body-small-weight));letter-spacing:var(--mat-paginator-container-text-tracking, var(--mat-sys-body-small-tracking));--mat-form-field-container-height:var(--mat-paginator-form-field-container-height, 40px);--mat-form-field-container-vertical-padding:var(--mat-paginator-form-field-container-vertical-padding, 8px)}.mat-mdc-paginator .mat-mdc-select-value{font-size:var(--mat-paginator-select-trigger-text-size, var(--mat-sys-body-small-size))}.mat-mdc-paginator .mat-mdc-form-field-subscript-wrapper{display:none}.mat-mdc-paginator .mat-mdc-select{line-height:1.5}.mat-mdc-paginator-outer-container{display:flex}.mat-mdc-paginator-container{display:flex;align-items:center;justify-content:flex-end;padding:0 8px;flex-wrap:wrap;width:100%;min-height:var(--mat-paginator-container-size, 56px)}.mat-mdc-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-mdc-paginator-page-size{margin-right:0;margin-left:8px}.mat-mdc-paginator-page-size-label{margin:0 4px}.mat-mdc-paginator-page-size-select{margin:0 4px;width:84px}.mat-mdc-paginator-range-label{margin:0 32px 0 24px}.mat-mdc-paginator-range-actions{display:flex;align-items:center}.mat-mdc-paginator-icon{display:inline-block;width:28px;fill:var(--mat-paginator-enabled-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button[aria-disabled] .mat-mdc-paginator-icon{fill:var(--mat-paginator-disabled-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}[dir=rtl] .mat-mdc-paginator-icon{transform:rotate(180deg)}@media(forced-colors: active){.mat-mdc-icon-button[aria-disabled] .mat-mdc-paginator-icon,.mat-mdc-paginator-icon{fill:currentColor}.mat-mdc-paginator-range-actions .mat-mdc-icon-button{outline:solid 1px}.mat-mdc-paginator-range-actions .mat-mdc-icon-button[aria-disabled]{color:GrayText}}.mat-mdc-paginator-touch-target{display:var(--mat-paginator-touch-target-display, block);position:absolute;top:50%;left:50%;width:84px;height:48px;background-color:rgba(0,0,0,0);transform:translate(-50%, -50%);cursor:pointer}"]
    }]
  }], () => [], {
    color: [{
      type: Input
    }],
    pageIndex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    length: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    pageSize: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    pageSizeOptions: [{
      type: Input
    }],
    hidePageSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showFirstLastButtons: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    selectConfig: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    page: [{
      type: Output
    }]
  });
})();
var MatPaginatorModule = class _MatPaginatorModule {
  static ɵfac = function MatPaginatorModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatPaginatorModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatPaginatorModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [MAT_PAGINATOR_INTL_PROVIDER],
    imports: [MatButtonModule, MatSelectModule, MatTooltipModule, MatPaginator]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatPaginatorModule, [{
    type: NgModule,
    args: [{
      imports: [MatButtonModule, MatSelectModule, MatTooltipModule, MatPaginator],
      exports: [MatPaginator],
      providers: [MAT_PAGINATOR_INTL_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/sort.mjs
var _c03 = ["mat-sort-header", ""];
var _c13 = ["*"];
function MatSortHeader_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 3);
    ɵɵelement(2, "path", 4);
    ɵɵelementEnd()();
  }
}
function getSortDuplicateSortableIdError(id) {
  return Error(`Cannot have two MatSortables with the same id (${id}).`);
}
function getSortHeaderNotContainedWithinSortError() {
  return Error(`MatSortHeader must be placed within a parent element with the MatSort directive.`);
}
function getSortHeaderMissingIdError() {
  return Error(`MatSortHeader must be provided with a unique id.`);
}
function getSortInvalidDirectionError(direction) {
  return Error(`${direction} is not a valid sort direction ('asc' or 'desc').`);
}
var MAT_SORT_DEFAULT_OPTIONS = new InjectionToken("MAT_SORT_DEFAULT_OPTIONS");
var MatSort = class _MatSort {
  _defaultOptions;
  _initializedStream = new ReplaySubject(1);
  /** Collection of all registered sortables that this directive manages. */
  sortables = /* @__PURE__ */new Map();
  /** Used to notify any child components listening to state changes. */
  _stateChanges = new Subject();
  /** The id of the most recently sorted MatSortable. */
  active;
  /**
   * The direction to set when an MatSortable is initially sorted.
   * May be overridden by the MatSortable's sort start.
   */
  start = "asc";
  /** The sort direction of the currently active MatSortable. */
  get direction() {
    return this._direction;
  }
  set direction(direction) {
    if (direction && direction !== "asc" && direction !== "desc" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getSortInvalidDirectionError(direction);
    }
    this._direction = direction;
  }
  _direction = "";
  /**
   * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
   * May be overridden by the MatSortable's disable clear input.
   */
  disableClear;
  /** Whether the sortable is disabled. */
  disabled = false;
  /** Event emitted when the user changes either the active sort or sort direction. */
  sortChange = new EventEmitter();
  /** Emits when the paginator is initialized. */
  initialized = this._initializedStream;
  constructor(_defaultOptions) {
    this._defaultOptions = _defaultOptions;
  }
  /**
   * Register function to be used by the contained MatSortables. Adds the MatSortable to the
   * collection of MatSortables.
   */
  register(sortable) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!sortable.id) {
        throw getSortHeaderMissingIdError();
      }
      if (this.sortables.has(sortable.id)) {
        throw getSortDuplicateSortableIdError(sortable.id);
      }
    }
    this.sortables.set(sortable.id, sortable);
  }
  /**
   * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the
   * collection of contained MatSortables.
   */
  deregister(sortable) {
    this.sortables.delete(sortable.id);
  }
  /** Sets the active sort id and determines the new sort direction. */
  sort(sortable) {
    if (this.active != sortable.id) {
      this.active = sortable.id;
      this.direction = sortable.start ? sortable.start : this.start;
    } else {
      this.direction = this.getNextSortDirection(sortable);
    }
    this.sortChange.emit({
      active: this.active,
      direction: this.direction
    });
  }
  /** Returns the next sort direction of the active sortable, checking for potential overrides. */
  getNextSortDirection(sortable) {
    if (!sortable) {
      return "";
    }
    const disableClear = sortable?.disableClear ?? this.disableClear ?? !!this._defaultOptions?.disableClear;
    let sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
    let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
    if (nextDirectionIndex >= sortDirectionCycle.length) {
      nextDirectionIndex = 0;
    }
    return sortDirectionCycle[nextDirectionIndex];
  }
  ngOnInit() {
    this._initializedStream.next();
  }
  ngOnChanges() {
    this._stateChanges.next();
  }
  ngOnDestroy() {
    this._stateChanges.complete();
    this._initializedStream.complete();
  }
  static ɵfac = function MatSort_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSort)(ɵɵdirectiveInject(MAT_SORT_DEFAULT_OPTIONS, 8));
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatSort,
    selectors: [["", "matSort", ""]],
    hostAttrs: [1, "mat-sort"],
    inputs: {
      active: [0, "matSortActive", "active"],
      start: [0, "matSortStart", "start"],
      direction: [0, "matSortDirection", "direction"],
      disableClear: [2, "matSortDisableClear", "disableClear", booleanAttribute],
      disabled: [2, "matSortDisabled", "disabled", booleanAttribute]
    },
    outputs: {
      sortChange: "matSortChange"
    },
    exportAs: ["matSort"],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSort, [{
    type: Directive,
    args: [{
      selector: "[matSort]",
      exportAs: "matSort",
      host: {
        "class": "mat-sort"
      }
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MAT_SORT_DEFAULT_OPTIONS]
    }]
  }], {
    active: [{
      type: Input,
      args: ["matSortActive"]
    }],
    start: [{
      type: Input,
      args: ["matSortStart"]
    }],
    direction: [{
      type: Input,
      args: ["matSortDirection"]
    }],
    disableClear: [{
      type: Input,
      args: [{
        alias: "matSortDisableClear",
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "matSortDisabled",
        transform: booleanAttribute
      }]
    }],
    sortChange: [{
      type: Output,
      args: ["matSortChange"]
    }]
  });
})();
function getSortDirectionCycle(start, disableClear) {
  let sortOrder = ["asc", "desc"];
  if (start == "desc") {
    sortOrder.reverse();
  }
  if (!disableClear) {
    sortOrder.push("");
  }
  return sortOrder;
}
var MatSortHeaderIntl = class _MatSortHeaderIntl {
  /**
   * Stream that emits whenever the labels here are changed. Use this to notify
   * components if the labels have changed after initialization.
   */
  changes = new Subject();
  static ɵfac = function MatSortHeaderIntl_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSortHeaderIntl)();
  };
  static ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
    token: _MatSortHeaderIntl,
    factory: _MatSortHeaderIntl.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSortHeaderIntl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function MAT_SORT_HEADER_INTL_PROVIDER_FACTORY(parentIntl) {
  return parentIntl || new MatSortHeaderIntl();
}
var MAT_SORT_HEADER_INTL_PROVIDER = {
  // If there is already an MatSortHeaderIntl available, use that. Otherwise, provide a new one.
  provide: MatSortHeaderIntl,
  deps: [[new Optional(), new SkipSelf(), MatSortHeaderIntl]],
  useFactory: MAT_SORT_HEADER_INTL_PROVIDER_FACTORY
};
var MatSortHeader = class _MatSortHeader {
  _intl = inject(MatSortHeaderIntl);
  _sort = inject(MatSort, {
    optional: true
  });
  _columnDef = inject("MAT_SORT_HEADER_COLUMN_DEF", {
    optional: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  _focusMonitor = inject(FocusMonitor);
  _elementRef = inject(ElementRef);
  _ariaDescriber = inject(AriaDescriber, {
    optional: true
  });
  _renderChanges;
  _animationModule = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  /**
   * Indicates which state was just cleared from the sort header.
   * Will be reset on the next interaction. Used for coordinating animations.
   */
  _recentlyCleared = signal(null);
  /**
   * The element with role="button" inside this component's view. We need this
   * in order to apply a description with AriaDescriber.
   */
  _sortButton;
  /**
   * ID of this sort header. If used within the context of a CdkColumnDef, this will default to
   * the column's name.
   */
  id;
  /** Sets the position of the arrow that displays when sorted. */
  arrowPosition = "after";
  /** Overrides the sort start value of the containing MatSort for this MatSortable. */
  start;
  /** whether the sort header is disabled. */
  disabled = false;
  /**
   * Description applied to MatSortHeader's button element with aria-describedby. This text should
   * describe the action that will occur when the user clicks the sort header.
   */
  get sortActionDescription() {
    return this._sortActionDescription;
  }
  set sortActionDescription(value) {
    this._updateSortActionDescription(value);
  }
  // Default the action description to "Sort" because it's better than nothing.
  // Without a description, the button's label comes from the sort header text content,
  // which doesn't give any indication that it performs a sorting operation.
  _sortActionDescription = "Sort";
  /** Overrides the disable clear value of the containing MatSort for this MatSortable. */
  disableClear;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
    const defaultOptions = inject(MAT_SORT_DEFAULT_OPTIONS, {
      optional: true
    });
    if (!this._sort && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getSortHeaderNotContainedWithinSortError();
    }
    if (defaultOptions?.arrowPosition) {
      this.arrowPosition = defaultOptions?.arrowPosition;
    }
  }
  ngOnInit() {
    if (!this.id && this._columnDef) {
      this.id = this._columnDef.name;
    }
    this._sort.register(this);
    this._renderChanges = merge(this._sort._stateChanges, this._sort.sortChange).subscribe(() => this._changeDetectorRef.markForCheck());
    this._sortButton = this._elementRef.nativeElement.querySelector(".mat-sort-header-container");
    this._updateSortActionDescription(this._sortActionDescription);
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this._elementRef, true).subscribe(() => this._recentlyCleared.set(null));
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    this._sort.deregister(this);
    this._renderChanges?.unsubscribe();
    if (this._sortButton) {
      this._ariaDescriber?.removeDescription(this._sortButton, this._sortActionDescription);
    }
  }
  /** Triggers the sort on this sort header and removes the indicator hint. */
  _toggleOnInteraction() {
    if (!this._isDisabled()) {
      const wasSorted = this._isSorted();
      const prevDirection = this._sort.direction;
      this._sort.sort(this);
      this._recentlyCleared.set(wasSorted && !this._isSorted() ? prevDirection : null);
    }
  }
  _handleKeydown(event) {
    if (event.keyCode === SPACE || event.keyCode === ENTER) {
      event.preventDefault();
      this._toggleOnInteraction();
    }
  }
  /** Whether this MatSortHeader is currently sorted in either ascending or descending order. */
  _isSorted() {
    return this._sort.active == this.id && (this._sort.direction === "asc" || this._sort.direction === "desc");
  }
  _isDisabled() {
    return this._sort.disabled || this.disabled;
  }
  /**
   * Gets the aria-sort attribute that should be applied to this sort header. If this header
   * is not sorted, returns null so that the attribute is removed from the host element. Aria spec
   * says that the aria-sort property should only be present on one header at a time, so removing
   * ensures this is true.
   */
  _getAriaSortAttribute() {
    if (!this._isSorted()) {
      return "none";
    }
    return this._sort.direction == "asc" ? "ascending" : "descending";
  }
  /** Whether the arrow inside the sort header should be rendered. */
  _renderArrow() {
    return !this._isDisabled() || this._isSorted();
  }
  _updateSortActionDescription(newDescription) {
    if (this._sortButton) {
      this._ariaDescriber?.removeDescription(this._sortButton, this._sortActionDescription);
      this._ariaDescriber?.describe(this._sortButton, newDescription);
    }
    this._sortActionDescription = newDescription;
  }
  static ɵfac = function MatSortHeader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSortHeader)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatSortHeader,
    selectors: [["", "mat-sort-header", ""]],
    hostAttrs: [1, "mat-sort-header"],
    hostVars: 3,
    hostBindings: function MatSortHeader_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function MatSortHeader_click_HostBindingHandler() {
          return ctx._toggleOnInteraction();
        })("keydown", function MatSortHeader_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        })("mouseleave", function MatSortHeader_mouseleave_HostBindingHandler() {
          return ctx._recentlyCleared.set(null);
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-sort", ctx._getAriaSortAttribute());
        ɵɵclassProp("mat-sort-header-disabled", ctx._isDisabled());
      }
    },
    inputs: {
      id: [0, "mat-sort-header", "id"],
      arrowPosition: "arrowPosition",
      start: "start",
      disabled: [2, "disabled", "disabled", booleanAttribute],
      sortActionDescription: "sortActionDescription",
      disableClear: [2, "disableClear", "disableClear", booleanAttribute]
    },
    exportAs: ["matSortHeader"],
    attrs: _c03,
    ngContentSelectors: _c13,
    decls: 4,
    vars: 17,
    consts: [[1, "mat-sort-header-container", "mat-focus-indicator"], [1, "mat-sort-header-content"], [1, "mat-sort-header-arrow"], ["viewBox", "0 -960 960 960", "focusable", "false", "aria-hidden", "true"], ["d", "M440-240v-368L296-464l-56-56 240-240 240 240-56 56-144-144v368h-80Z"]],
    template: function MatSortHeader_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵɵprojection(2);
        ɵɵelementEnd();
        ɵɵtemplate(3, MatSortHeader_Conditional_3_Template, 3, 0, "div", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("mat-sort-header-sorted", ctx._isSorted())("mat-sort-header-position-before", ctx.arrowPosition === "before")("mat-sort-header-descending", ctx._sort.direction === "desc")("mat-sort-header-ascending", ctx._sort.direction === "asc")("mat-sort-header-recently-cleared-ascending", ctx._recentlyCleared() === "asc")("mat-sort-header-recently-cleared-descending", ctx._recentlyCleared() === "desc")("mat-sort-header-animations-disabled", ctx._animationModule === "NoopAnimations");
        ɵɵattribute("tabindex", ctx._isDisabled() ? null : 0)("role", ctx._isDisabled() ? null : "button");
        ɵɵadvance(3);
        ɵɵconditional(ctx._renderArrow() ? 3 : -1);
      }
    },
    styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center;letter-spacing:normal;outline:0}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-container,[mat-sort-header].cdk-program-focused .mat-sort-header-container{border-bottom:solid 1px currentColor}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-container::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-sort-header-content{display:flex;align-items:center}.mat-sort-header-position-before{flex-direction:row-reverse}@keyframes _mat-sort-header-recently-cleared-ascending{from{transform:translateY(0);opacity:1}to{transform:translateY(-25%);opacity:0}}@keyframes _mat-sort-header-recently-cleared-descending{from{transform:translateY(0) rotate(180deg);opacity:1}to{transform:translateY(25%) rotate(180deg);opacity:0}}.mat-sort-header-arrow{height:12px;width:12px;position:relative;transition:transform 225ms cubic-bezier(0.4, 0, 0.2, 1),opacity 225ms cubic-bezier(0.4, 0, 0.2, 1);opacity:0;overflow:visible;color:var(--mat-sort-arrow-color, var(--mat-sys-on-surface))}.mat-sort-header.cdk-keyboard-focused .mat-sort-header-arrow,.mat-sort-header.cdk-program-focused .mat-sort-header-arrow,.mat-sort-header:hover .mat-sort-header-arrow{opacity:.54}.mat-sort-header .mat-sort-header-sorted .mat-sort-header-arrow{opacity:1}.mat-sort-header-descending .mat-sort-header-arrow{transform:rotate(180deg)}.mat-sort-header-recently-cleared-ascending .mat-sort-header-arrow{transform:translateY(-25%)}.mat-sort-header-recently-cleared-ascending .mat-sort-header-arrow{transition:none;animation:_mat-sort-header-recently-cleared-ascending 225ms cubic-bezier(0.4, 0, 0.2, 1) forwards}.mat-sort-header-recently-cleared-descending .mat-sort-header-arrow{transition:none;animation:_mat-sort-header-recently-cleared-descending 225ms cubic-bezier(0.4, 0, 0.2, 1) forwards}.mat-sort-header-animations-disabled .mat-sort-header-arrow{transition-duration:0ms;animation-duration:0ms}.mat-sort-header-arrow svg{width:24px;height:24px;fill:currentColor;position:absolute;top:50%;left:50%;margin:-12px 0 0 -12px;transform:translateZ(0)}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSortHeader, [{
    type: Component,
    args: [{
      selector: "[mat-sort-header]",
      exportAs: "matSortHeader",
      host: {
        "class": "mat-sort-header",
        "(click)": "_toggleOnInteraction()",
        "(keydown)": "_handleKeydown($event)",
        "(mouseleave)": "_recentlyCleared.set(null)",
        "[attr.aria-sort]": "_getAriaSortAttribute()",
        "[class.mat-sort-header-disabled]": "_isDisabled()"
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<!--
  We set the \`tabindex\` on an element inside the table header, rather than the header itself,
  because of a bug in NVDA where having a \`tabindex\` on a \`th\` breaks keyboard navigation in the
  table (see https://github.com/nvaccess/nvda/issues/7718). This allows for the header to both
  be focusable, and have screen readers read out its \`aria-sort\` state. We prefer this approach
  over having a button with an \`aria-label\` inside the header, because the button's \`aria-label\`
  will be read out as the user is navigating the table's cell (see #13012).

  The approach is based off of: https://dequeuniversity.com/library/aria/tables/sf-sortable-grid
-->
<div class="mat-sort-header-container mat-focus-indicator"
     [class.mat-sort-header-sorted]="_isSorted()"
     [class.mat-sort-header-position-before]="arrowPosition === 'before'"
     [class.mat-sort-header-descending]="this._sort.direction === 'desc'"
     [class.mat-sort-header-ascending]="this._sort.direction === 'asc'"
     [class.mat-sort-header-recently-cleared-ascending]="_recentlyCleared() === 'asc'"
     [class.mat-sort-header-recently-cleared-descending]="_recentlyCleared() === 'desc'"
     [class.mat-sort-header-animations-disabled]="_animationModule === 'NoopAnimations'"
     [attr.tabindex]="_isDisabled() ? null : 0"
     [attr.role]="_isDisabled() ? null : 'button'">

  <!--
    TODO(crisbeto): this div isn't strictly necessary, but we have to keep it due to a large
    number of screenshot diff failures. It should be removed eventually. Note that the difference
    isn't visible with a shorter header, but once it breaks up into multiple lines, this element
    causes it to be center-aligned, whereas removing it will keep the text to the left.
  -->
  <div class="mat-sort-header-content">
    <ng-content></ng-content>
  </div>

  <!-- Disable animations while a current animation is running -->
  @if (_renderArrow()) {
    <div class="mat-sort-header-arrow">
      <svg viewBox="0 -960 960 960" focusable="false" aria-hidden="true">
        <path d="M440-240v-368L296-464l-56-56 240-240 240 240-56 56-144-144v368h-80Z"/>
      </svg>
    </div>
  }
</div>
`,
      styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center;letter-spacing:normal;outline:0}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-container,[mat-sort-header].cdk-program-focused .mat-sort-header-container{border-bottom:solid 1px currentColor}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-container::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-sort-header-content{display:flex;align-items:center}.mat-sort-header-position-before{flex-direction:row-reverse}@keyframes _mat-sort-header-recently-cleared-ascending{from{transform:translateY(0);opacity:1}to{transform:translateY(-25%);opacity:0}}@keyframes _mat-sort-header-recently-cleared-descending{from{transform:translateY(0) rotate(180deg);opacity:1}to{transform:translateY(25%) rotate(180deg);opacity:0}}.mat-sort-header-arrow{height:12px;width:12px;position:relative;transition:transform 225ms cubic-bezier(0.4, 0, 0.2, 1),opacity 225ms cubic-bezier(0.4, 0, 0.2, 1);opacity:0;overflow:visible;color:var(--mat-sort-arrow-color, var(--mat-sys-on-surface))}.mat-sort-header.cdk-keyboard-focused .mat-sort-header-arrow,.mat-sort-header.cdk-program-focused .mat-sort-header-arrow,.mat-sort-header:hover .mat-sort-header-arrow{opacity:.54}.mat-sort-header .mat-sort-header-sorted .mat-sort-header-arrow{opacity:1}.mat-sort-header-descending .mat-sort-header-arrow{transform:rotate(180deg)}.mat-sort-header-recently-cleared-ascending .mat-sort-header-arrow{transform:translateY(-25%)}.mat-sort-header-recently-cleared-ascending .mat-sort-header-arrow{transition:none;animation:_mat-sort-header-recently-cleared-ascending 225ms cubic-bezier(0.4, 0, 0.2, 1) forwards}.mat-sort-header-recently-cleared-descending .mat-sort-header-arrow{transition:none;animation:_mat-sort-header-recently-cleared-descending 225ms cubic-bezier(0.4, 0, 0.2, 1) forwards}.mat-sort-header-animations-disabled .mat-sort-header-arrow{transition-duration:0ms;animation-duration:0ms}.mat-sort-header-arrow svg{width:24px;height:24px;fill:currentColor;position:absolute;top:50%;left:50%;margin:-12px 0 0 -12px;transform:translateZ(0)}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}"]
    }]
  }], () => [], {
    id: [{
      type: Input,
      args: ["mat-sort-header"]
    }],
    arrowPosition: [{
      type: Input
    }],
    start: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    sortActionDescription: [{
      type: Input
    }],
    disableClear: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var MatSortModule = class _MatSortModule {
  static ɵfac = function MatSortModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSortModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatSortModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [MAT_SORT_HEADER_INTL_PROVIDER],
    imports: [MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSortModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, MatSort, MatSortHeader],
      exports: [MatSort, MatSortHeader],
      providers: [MAT_SORT_HEADER_INTL_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/table.mjs
var _c04 = [[["caption"]], [["colgroup"], ["col"]], "*"];
var _c14 = ["caption", "colgroup, col", "*"];
function CdkTable_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
  }
}
function CdkTable_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead", 0);
    ɵɵelementContainer(1, 1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "tbody", 0);
    ɵɵelementContainer(3, 2)(4, 3);
    ɵɵelementEnd();
    ɵɵelementStart(5, "tfoot", 0);
    ɵɵelementContainer(6, 4);
    ɵɵelementEnd();
  }
}
function CdkTable_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 1)(1, 2)(2, 3)(3, 4);
  }
}
function CdkTextColumn_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.headerText, " ");
  }
}
function CdkTextColumn_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.dataAccessor(data_r2, ctx_r0.name), " ");
  }
}
var CDK_TABLE = new InjectionToken("CDK_TABLE");
var TEXT_COLUMN_OPTIONS = new InjectionToken("text-column-options");
var CdkCellDef = class _CdkCellDef {
  /** @docs-private */
  template = inject(TemplateRef);
  constructor() {}
  static ɵfac = function CdkCellDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkCellDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkCellDef,
    selectors: [["", "cdkCellDef", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkCellDef]"
    }]
  }], () => [], null);
})();
var CdkHeaderCellDef = class _CdkHeaderCellDef {
  /** @docs-private */
  template = inject(TemplateRef);
  constructor() {}
  static ɵfac = function CdkHeaderCellDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkHeaderCellDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkHeaderCellDef,
    selectors: [["", "cdkHeaderCellDef", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkHeaderCellDef]"
    }]
  }], () => [], null);
})();
var CdkFooterCellDef = class _CdkFooterCellDef {
  /** @docs-private */
  template = inject(TemplateRef);
  constructor() {}
  static ɵfac = function CdkFooterCellDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFooterCellDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkFooterCellDef,
    selectors: [["", "cdkFooterCellDef", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkFooterCellDef]"
    }]
  }], () => [], null);
})();
var CdkColumnDef = class _CdkColumnDef {
  _table = inject(CDK_TABLE, {
    optional: true
  });
  _hasStickyChanged = false;
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._setNameInput(name);
  }
  _name;
  /** Whether the cell is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  _sticky = false;
  /**
   * Whether this column should be sticky positioned on the end of the row. Should make sure
   * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
   * has been changed.
   */
  get stickyEnd() {
    return this._stickyEnd;
  }
  set stickyEnd(value) {
    if (value !== this._stickyEnd) {
      this._stickyEnd = value;
      this._hasStickyChanged = true;
    }
  }
  _stickyEnd = false;
  /** @docs-private */
  cell;
  /** @docs-private */
  headerCell;
  /** @docs-private */
  footerCell;
  /**
   * Transformed version of the column name that can be used as part of a CSS classname. Excludes
   * all non-alphanumeric characters and the special characters '-' and '_'. Any characters that
   * do not match are replaced by the '-' character.
   */
  cssClassFriendlyName;
  /**
   * Class name for cells in this column.
   * @docs-private
   */
  _columnCssClassName;
  constructor() {}
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
  /**
   * Overridable method that sets the css classes that will be added to every cell in this
   * column.
   * In the future, columnCssClassName will change from type string[] to string and this
   * will set a single string value.
   * @docs-private
   */
  _updateColumnCssClassName() {
    this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setNameInput(value) {
    if (value) {
      this._name = value;
      this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/gi, "-");
      this._updateColumnCssClassName();
    }
  }
  static ɵfac = function CdkColumnDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkColumnDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkColumnDef,
    selectors: [["", "cdkColumnDef", ""]],
    contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CdkCellDef, 5);
        ɵɵcontentQuery(dirIndex, CdkHeaderCellDef, 5);
        ɵɵcontentQuery(dirIndex, CdkFooterCellDef, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.cell = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.headerCell = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.footerCell = _t2.first);
      }
    },
    inputs: {
      name: [0, "cdkColumnDef", "name"],
      sticky: [2, "sticky", "sticky", booleanAttribute],
      stickyEnd: [2, "stickyEnd", "stickyEnd", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: "MAT_SORT_HEADER_COLUMN_DEF",
      useExisting: _CdkColumnDef
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnDef, [{
    type: Directive,
    args: [{
      selector: "[cdkColumnDef]",
      providers: [{
        provide: "MAT_SORT_HEADER_COLUMN_DEF",
        useExisting: CdkColumnDef
      }]
    }]
  }], () => [], {
    name: [{
      type: Input,
      args: ["cdkColumnDef"]
    }],
    sticky: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    stickyEnd: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    cell: [{
      type: ContentChild,
      args: [CdkCellDef]
    }],
    headerCell: [{
      type: ContentChild,
      args: [CdkHeaderCellDef]
    }],
    footerCell: [{
      type: ContentChild,
      args: [CdkFooterCellDef]
    }]
  });
})();
var BaseCdkCell = class {
  constructor(columnDef, elementRef) {
    elementRef.nativeElement.classList.add(...columnDef._columnCssClassName);
  }
};
var CdkHeaderCell = class _CdkHeaderCell extends BaseCdkCell {
  constructor() {
    super(inject(CdkColumnDef), inject(ElementRef));
  }
  static ɵfac = function CdkHeaderCell_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkHeaderCell)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkHeaderCell,
    selectors: [["cdk-header-cell"], ["th", "cdk-header-cell", ""]],
    hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderCell, [{
    type: Directive,
    args: [{
      selector: "cdk-header-cell, th[cdk-header-cell]",
      host: {
        "class": "cdk-header-cell",
        "role": "columnheader"
      }
    }]
  }], () => [], null);
})();
var CdkFooterCell = class _CdkFooterCell extends BaseCdkCell {
  constructor() {
    const columnDef = inject(CdkColumnDef);
    const elementRef = inject(ElementRef);
    super(columnDef, elementRef);
    const role = columnDef._table?._getCellRole();
    if (role) {
      elementRef.nativeElement.setAttribute("role", role);
    }
  }
  static ɵfac = function CdkFooterCell_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFooterCell)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkFooterCell,
    selectors: [["cdk-footer-cell"], ["td", "cdk-footer-cell", ""]],
    hostAttrs: [1, "cdk-footer-cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterCell, [{
    type: Directive,
    args: [{
      selector: "cdk-footer-cell, td[cdk-footer-cell]",
      host: {
        "class": "cdk-footer-cell"
      }
    }]
  }], () => [], null);
})();
var CdkCell = class _CdkCell extends BaseCdkCell {
  constructor() {
    const columnDef = inject(CdkColumnDef);
    const elementRef = inject(ElementRef);
    super(columnDef, elementRef);
    const role = columnDef._table?._getCellRole();
    if (role) {
      elementRef.nativeElement.setAttribute("role", role);
    }
  }
  static ɵfac = function CdkCell_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkCell)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkCell,
    selectors: [["cdk-cell"], ["td", "cdk-cell", ""]],
    hostAttrs: [1, "cdk-cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCell, [{
    type: Directive,
    args: [{
      selector: "cdk-cell, td[cdk-cell]",
      host: {
        "class": "cdk-cell"
      }
    }]
  }], () => [], null);
})();
var _Schedule = class {
  tasks = [];
  endTasks = [];
};
var _COALESCED_STYLE_SCHEDULER = new InjectionToken("_COALESCED_STYLE_SCHEDULER");
var _CoalescedStyleScheduler = class __CoalescedStyleScheduler {
  _currentSchedule = null;
  _ngZone = inject(NgZone);
  constructor() {}
  /**
   * Schedules the specified task to run at the end of the current VM turn.
   */
  schedule(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.tasks.push(task);
  }
  /**
   * Schedules the specified task to run after other scheduled tasks at the end of the current
   * VM turn.
   */
  scheduleEnd(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.endTasks.push(task);
  }
  _createScheduleIfNeeded() {
    if (this._currentSchedule) {
      return;
    }
    this._currentSchedule = new _Schedule();
    this._ngZone.runOutsideAngular(() =>
    // TODO(mmalerba): Scheduling this using something that runs less frequently
    //  (e.g. requestAnimationFrame, setTimeout, etc.) causes noticeable jank with the column
    //  resizer. We should audit the usages of schedule / scheduleEnd in that component and see
    //  if we can refactor it so that we don't need to flush the tasks quite so frequently.
    queueMicrotask(() => {
      while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {
        const schedule = this._currentSchedule;
        this._currentSchedule = new _Schedule();
        for (const task of schedule.tasks) {
          task();
        }
        for (const task of schedule.endTasks) {
          task();
        }
      }
      this._currentSchedule = null;
    }));
  }
  static ɵfac = function _CoalescedStyleScheduler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CoalescedStyleScheduler)();
  };
  static ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
    token: __CoalescedStyleScheduler,
    factory: __CoalescedStyleScheduler.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CoalescedStyleScheduler, [{
    type: Injectable
  }], () => [], null);
})();
var CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;
var BaseRowDef = class _BaseRowDef {
  template = inject(TemplateRef);
  _differs = inject(IterableDiffers);
  /** The columns to be displayed on this row. */
  columns;
  /** Differ used to check if any changes were made to the columns. */
  _columnsDiffer;
  constructor() {}
  ngOnChanges(changes) {
    if (!this._columnsDiffer) {
      const columns = changes["columns"] && changes["columns"].currentValue || [];
      this._columnsDiffer = this._differs.find(columns).create();
      this._columnsDiffer.diff(columns);
    }
  }
  /**
   * Returns the difference between the current columns and the columns from the last diff, or null
   * if there is no difference.
   */
  getColumnsDiff() {
    return this._columnsDiffer.diff(this.columns);
  }
  /** Gets this row def's relevant cell template from the provided column def. */
  extractCellTemplate(column) {
    if (this instanceof CdkHeaderRowDef) {
      return column.headerCell.template;
    }
    if (this instanceof CdkFooterRowDef) {
      return column.footerCell.template;
    } else {
      return column.cell.template;
    }
  }
  static ɵfac = function BaseRowDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseRowDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _BaseRowDef,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseRowDef, [{
    type: Directive
  }], () => [], null);
})();
var CdkHeaderRowDef = class _CdkHeaderRowDef extends BaseRowDef {
  _table = inject(CDK_TABLE, {
    optional: true
  });
  _hasStickyChanged = false;
  /** Whether the row is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  _sticky = false;
  constructor() {
    super(inject(TemplateRef), inject(IterableDiffers));
  }
  // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
  // Explicitly define it so that the method is called as part of the Angular lifecycle.
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
  static ɵfac = function CdkHeaderRowDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkHeaderRowDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkHeaderRowDef,
    selectors: [["", "cdkHeaderRowDef", ""]],
    inputs: {
      columns: [0, "cdkHeaderRowDef", "columns"],
      sticky: [2, "cdkHeaderRowDefSticky", "sticky", booleanAttribute]
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkHeaderRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkHeaderRowDef"
      }]
    }]
  }], () => [], {
    sticky: [{
      type: Input,
      args: [{
        alias: "cdkHeaderRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkFooterRowDef = class _CdkFooterRowDef extends BaseRowDef {
  _table = inject(CDK_TABLE, {
    optional: true
  });
  _hasStickyChanged = false;
  /** Whether the row is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  _sticky = false;
  constructor() {
    super(inject(TemplateRef), inject(IterableDiffers));
  }
  // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
  // Explicitly define it so that the method is called as part of the Angular lifecycle.
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
  static ɵfac = function CdkFooterRowDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFooterRowDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkFooterRowDef,
    selectors: [["", "cdkFooterRowDef", ""]],
    inputs: {
      columns: [0, "cdkFooterRowDef", "columns"],
      sticky: [2, "cdkFooterRowDefSticky", "sticky", booleanAttribute]
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkFooterRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkFooterRowDef"
      }]
    }]
  }], () => [], {
    sticky: [{
      type: Input,
      args: [{
        alias: "cdkFooterRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkRowDef = class _CdkRowDef extends BaseRowDef {
  _table = inject(CDK_TABLE, {
    optional: true
  });
  /**
   * Function that should return true if this row template should be used for the provided index
   * and row data. If left undefined, this row will be considered the default row template to use
   * when no other when functions return true for the data.
   * For every row, there must be at least one when function that passes or an undefined to default.
   */
  when;
  constructor() {
    super(inject(TemplateRef), inject(IterableDiffers));
  }
  static ɵfac = function CdkRowDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkRowDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkRowDef,
    selectors: [["", "cdkRowDef", ""]],
    inputs: {
      columns: [0, "cdkRowDefColumns", "columns"],
      when: [0, "cdkRowDefWhen", "when"]
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkRowDefColumns"
      }, {
        name: "when",
        alias: "cdkRowDefWhen"
      }]
    }]
  }], () => [], null);
})();
var CdkCellOutlet = class _CdkCellOutlet {
  _viewContainer = inject(ViewContainerRef);
  /** The ordered list of cells to render within this outlet's view container */
  cells;
  /** The data context to be provided to each cell */
  context;
  /**
   * Static property containing the latest constructed instance of this class.
   * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using
   * createEmbeddedView. After one of these components are created, this property will provide
   * a handle to provide that component's cells and context. After init, the CdkCellOutlet will
   * construct the cells with the provided context.
   */
  static mostRecentCellOutlet = null;
  constructor() {
    _CdkCellOutlet.mostRecentCellOutlet = this;
  }
  ngOnDestroy() {
    if (_CdkCellOutlet.mostRecentCellOutlet === this) {
      _CdkCellOutlet.mostRecentCellOutlet = null;
    }
  }
  static ɵfac = function CdkCellOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkCellOutlet)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkCellOutlet,
    selectors: [["", "cdkCellOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCellOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkCellOutlet]"
    }]
  }], () => [], null);
})();
var CdkHeaderRow = class _CdkHeaderRow {
  static ɵfac = function CdkHeaderRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkHeaderRow)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _CdkHeaderRow,
    selectors: [["cdk-header-row"], ["tr", "cdk-header-row", ""]],
    hostAttrs: ["role", "row", 1, "cdk-header-row"],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function CdkHeaderRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderRow, [{
    type: Component,
    args: [{
      selector: "cdk-header-row, tr[cdk-header-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-header-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var CdkFooterRow = class _CdkFooterRow {
  static ɵfac = function CdkFooterRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFooterRow)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _CdkFooterRow,
    selectors: [["cdk-footer-row"], ["tr", "cdk-footer-row", ""]],
    hostAttrs: ["role", "row", 1, "cdk-footer-row"],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function CdkFooterRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterRow, [{
    type: Component,
    args: [{
      selector: "cdk-footer-row, tr[cdk-footer-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-footer-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var CdkRow = class _CdkRow {
  static ɵfac = function CdkRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkRow)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _CdkRow,
    selectors: [["cdk-row"], ["tr", "cdk-row", ""]],
    hostAttrs: ["role", "row", 1, "cdk-row"],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function CdkRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRow, [{
    type: Component,
    args: [{
      selector: "cdk-row, tr[cdk-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var CdkNoDataRow = class _CdkNoDataRow {
  templateRef = inject(TemplateRef);
  _contentClassName = "cdk-no-data-row";
  constructor() {}
  static ɵfac = function CdkNoDataRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkNoDataRow)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkNoDataRow,
    selectors: [["ng-template", "cdkNoDataRow", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkNoDataRow, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkNoDataRow]"
    }]
  }], () => [], null);
})();
var STICKY_DIRECTIONS = ["top", "bottom", "left", "right"];
var StickyStyler = class {
  _isNativeHtmlTable;
  _stickCellCss;
  direction;
  _coalescedStyleScheduler;
  _isBrowser;
  _needsPositionStickyOnElement;
  _positionListener;
  _tableInjector;
  _elemSizeCache = /* @__PURE__ */new WeakMap();
  _resizeObserver = globalThis?.ResizeObserver ? new globalThis.ResizeObserver(entries => this._updateCachedSizes(entries)) : null;
  _updatedStickyColumnsParamsToReplay = [];
  _stickyColumnsReplayTimeout = null;
  _cachedCellWidths = [];
  _borderCellCss;
  _destroyed = false;
  /**
   * @param _isNativeHtmlTable Whether the sticky logic should be based on a table
   *     that uses the native `<table>` element.
   * @param _stickCellCss The CSS class that will be applied to every row/cell that has
   *     sticky positioning applied.
   * @param direction The directionality context of the table (ltr/rtl); affects column positioning
   *     by reversing left/right positions.
   * @param _isBrowser Whether the table is currently being rendered on the server or the client.
   * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells
   *     using inline styles. If false, it is assumed that position: sticky is included in
   *     the component stylesheet for _stickCellCss.
   * @param _positionListener A listener that is notified of changes to sticky rows/columns
   *     and their dimensions.
   * @param _tableInjector The table's Injector.
   */
  constructor(_isNativeHtmlTable, _stickCellCss, direction, _coalescedStyleScheduler, _isBrowser = true, _needsPositionStickyOnElement = true, _positionListener, _tableInjector) {
    this._isNativeHtmlTable = _isNativeHtmlTable;
    this._stickCellCss = _stickCellCss;
    this.direction = direction;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._isBrowser = _isBrowser;
    this._needsPositionStickyOnElement = _needsPositionStickyOnElement;
    this._positionListener = _positionListener;
    this._tableInjector = _tableInjector;
    this._borderCellCss = {
      "top": `${_stickCellCss}-border-elem-top`,
      "bottom": `${_stickCellCss}-border-elem-bottom`,
      "left": `${_stickCellCss}-border-elem-left`,
      "right": `${_stickCellCss}-border-elem-right`
    };
  }
  /**
   * Clears the sticky positioning styles from the row and its cells by resetting the `position`
   * style, setting the zIndex to 0, and unsetting each provided sticky direction.
   * @param rows The list of rows that should be cleared from sticking in the provided directions
   * @param stickyDirections The directions that should no longer be set as sticky on the rows.
   */
  clearStickyPositioning(rows, stickyDirections) {
    if (stickyDirections.includes("left") || stickyDirections.includes("right")) {
      this._removeFromStickyColumnReplayQueue(rows);
    }
    const elementsToClear = [];
    for (const row of rows) {
      if (row.nodeType !== row.ELEMENT_NODE) {
        continue;
      }
      elementsToClear.push(row, ...Array.from(row.children));
    }
    this._afterNextRender({
      write: () => {
        for (const element of elementsToClear) {
          this._removeStickyStyle(element, stickyDirections);
        }
      }
    });
  }
  /**
   * Applies sticky left and right positions to the cells of each row according to the sticky
   * states of the rendered column definitions.
   * @param rows The rows that should have its set of cells stuck according to the sticky states.
   * @param stickyStartStates A list of boolean states where each state represents whether the cell
   *     in this index position should be stuck to the start of the row.
   * @param stickyEndStates A list of boolean states where each state represents whether the cell
   *     in this index position should be stuck to the end of the row.
   * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each
   *     column cell. If `false` cached widths will be used instead.
   * @param replay Whether to enqueue this call for replay after a ResizeObserver update.
   */
  updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true, replay = true) {
    if (!rows.length || !this._isBrowser || !(stickyStartStates.some(state2 => state2) || stickyEndStates.some(state2 => state2))) {
      this._positionListener?.stickyColumnsUpdated({
        sizes: []
      });
      this._positionListener?.stickyEndColumnsUpdated({
        sizes: []
      });
      return;
    }
    const firstRow = rows[0];
    const numCells = firstRow.children.length;
    const isRtl = this.direction === "rtl";
    const start = isRtl ? "right" : "left";
    const end = isRtl ? "left" : "right";
    const lastStickyStart = stickyStartStates.lastIndexOf(true);
    const firstStickyEnd = stickyEndStates.indexOf(true);
    let cellWidths;
    let startPositions;
    let endPositions;
    if (replay) {
      this._updateStickyColumnReplayQueue({
        rows: [...rows],
        stickyStartStates: [...stickyStartStates],
        stickyEndStates: [...stickyEndStates]
      });
    }
    this._afterNextRender({
      earlyRead: () => {
        cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);
        startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
        endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
      },
      write: () => {
        for (const row of rows) {
          for (let i2 = 0; i2 < numCells; i2++) {
            const cell = row.children[i2];
            if (stickyStartStates[i2]) {
              this._addStickyStyle(cell, start, startPositions[i2], i2 === lastStickyStart);
            }
            if (stickyEndStates[i2]) {
              this._addStickyStyle(cell, end, endPositions[i2], i2 === firstStickyEnd);
            }
          }
        }
        if (this._positionListener && cellWidths.some(w2 => !!w2)) {
          this._positionListener.stickyColumnsUpdated({
            sizes: lastStickyStart === -1 ? [] : cellWidths.slice(0, lastStickyStart + 1).map((width, index) => stickyStartStates[index] ? width : null)
          });
          this._positionListener.stickyEndColumnsUpdated({
            sizes: firstStickyEnd === -1 ? [] : cellWidths.slice(firstStickyEnd).map((width, index) => stickyEndStates[index + firstStickyEnd] ? width : null).reverse()
          });
        }
      }
    });
  }
  /**
   * Applies sticky positioning to the row's cells if using the native table layout, and to the
   * row itself otherwise.
   * @param rowsToStick The list of rows that should be stuck according to their corresponding
   *     sticky state and to the provided top or bottom position.
   * @param stickyStates A list of boolean states where each state represents whether the row
   *     should be stuck in the particular top or bottom position.
   * @param position The position direction in which the row should be stuck if that row should be
   *     sticky.
   *
   */
  stickRows(rowsToStick, stickyStates, position) {
    if (!this._isBrowser) {
      return;
    }
    const rows = position === "bottom" ? rowsToStick.slice().reverse() : rowsToStick;
    const states = position === "bottom" ? stickyStates.slice().reverse() : stickyStates;
    const stickyOffsets = [];
    const stickyCellHeights = [];
    const elementsToStick = [];
    this._afterNextRender({
      earlyRead: () => {
        for (let rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {
          if (!states[rowIndex]) {
            continue;
          }
          stickyOffsets[rowIndex] = stickyOffset;
          const row = rows[rowIndex];
          elementsToStick[rowIndex] = this._isNativeHtmlTable ? Array.from(row.children) : [row];
          const height = this._retrieveElementSize(row).height;
          stickyOffset += height;
          stickyCellHeights[rowIndex] = height;
        }
      },
      write: () => {
        const borderedRowIndex = states.lastIndexOf(true);
        for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
          if (!states[rowIndex]) {
            continue;
          }
          const offset = stickyOffsets[rowIndex];
          const isBorderedRowIndex = rowIndex === borderedRowIndex;
          for (const element of elementsToStick[rowIndex]) {
            this._addStickyStyle(element, position, offset, isBorderedRowIndex);
          }
        }
        if (position === "top") {
          this._positionListener?.stickyHeaderRowsUpdated({
            sizes: stickyCellHeights,
            offsets: stickyOffsets,
            elements: elementsToStick
          });
        } else {
          this._positionListener?.stickyFooterRowsUpdated({
            sizes: stickyCellHeights,
            offsets: stickyOffsets,
            elements: elementsToStick
          });
        }
      }
    });
  }
  /**
   * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
   * footer rows is to apply sticky styling to the tfoot container. This should only be done if
   * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
   * the tfoot element.
   */
  updateStickyFooterContainer(tableElement, stickyStates) {
    if (!this._isNativeHtmlTable) {
      return;
    }
    this._afterNextRender({
      write: () => {
        const tfoot = tableElement.querySelector("tfoot");
        if (tfoot) {
          if (stickyStates.some(state2 => !state2)) {
            this._removeStickyStyle(tfoot, ["bottom"]);
          } else {
            this._addStickyStyle(tfoot, "bottom", 0, false);
          }
        }
      }
    });
  }
  /** Triggered by the table's OnDestroy hook. */
  destroy() {
    if (this._stickyColumnsReplayTimeout) {
      clearTimeout(this._stickyColumnsReplayTimeout);
    }
    this._resizeObserver?.disconnect();
    this._destroyed = true;
  }
  /**
   * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
   * the zIndex, removing each of the provided sticky directions, and removing the
   * sticky position if there are no more directions.
   */
  _removeStickyStyle(element, stickyDirections) {
    if (!element.classList.contains(this._stickCellCss)) {
      return;
    }
    for (const dir of stickyDirections) {
      element.style[dir] = "";
      element.classList.remove(this._borderCellCss[dir]);
    }
    const hasDirection = STICKY_DIRECTIONS.some(dir => stickyDirections.indexOf(dir) === -1 && element.style[dir]);
    if (hasDirection) {
      element.style.zIndex = this._getCalculatedZIndex(element);
    } else {
      element.style.zIndex = "";
      if (this._needsPositionStickyOnElement) {
        element.style.position = "";
      }
      element.classList.remove(this._stickCellCss);
    }
  }
  /**
   * Adds the sticky styling to the element by adding the sticky style class, changing position
   * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
   * direction and value.
   */
  _addStickyStyle(element, dir, dirValue, isBorderElement) {
    element.classList.add(this._stickCellCss);
    if (isBorderElement) {
      element.classList.add(this._borderCellCss[dir]);
    }
    element.style[dir] = `${dirValue}px`;
    element.style.zIndex = this._getCalculatedZIndex(element);
    if (this._needsPositionStickyOnElement) {
      element.style.cssText += "position: -webkit-sticky; position: sticky; ";
    }
  }
  /**
   * Calculate what the z-index should be for the element, depending on what directions (top,
   * bottom, left, right) have been set. It should be true that elements with a top direction
   * should have the highest index since these are elements like a table header. If any of those
   * elements are also sticky in another direction, then they should appear above other elements
   * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
   * (e.g. footer rows) should then be next in the ordering such that they are below the header
   * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
   * should minimally increment so that they are above non-sticky elements but below top and bottom
   * elements.
   */
  _getCalculatedZIndex(element) {
    const zIndexIncrements = {
      top: 100,
      bottom: 10,
      left: 1,
      right: 1
    };
    let zIndex = 0;
    for (const dir of STICKY_DIRECTIONS) {
      if (element.style[dir]) {
        zIndex += zIndexIncrements[dir];
      }
    }
    return zIndex ? `${zIndex}` : "";
  }
  /** Gets the widths for each cell in the provided row. */
  _getCellWidths(row, recalculateCellWidths = true) {
    if (!recalculateCellWidths && this._cachedCellWidths.length) {
      return this._cachedCellWidths;
    }
    const cellWidths = [];
    const firstRowCells = row.children;
    for (let i2 = 0; i2 < firstRowCells.length; i2++) {
      const cell = firstRowCells[i2];
      cellWidths.push(this._retrieveElementSize(cell).width);
    }
    this._cachedCellWidths = cellWidths;
    return cellWidths;
  }
  /**
   * Determines the left and right positions of each sticky column cell, which will be the
   * accumulation of all sticky column cell widths to the left and right, respectively.
   * Non-sticky cells do not need to have a value set since their positions will not be applied.
   */
  _getStickyStartColumnPositions(widths, stickyStates) {
    const positions = [];
    let nextPosition = 0;
    for (let i2 = 0; i2 < widths.length; i2++) {
      if (stickyStates[i2]) {
        positions[i2] = nextPosition;
        nextPosition += widths[i2];
      }
    }
    return positions;
  }
  /**
   * Determines the left and right positions of each sticky column cell, which will be the
   * accumulation of all sticky column cell widths to the left and right, respectively.
   * Non-sticky cells do not need to have a value set since their positions will not be applied.
   */
  _getStickyEndColumnPositions(widths, stickyStates) {
    const positions = [];
    let nextPosition = 0;
    for (let i2 = widths.length; i2 > 0; i2--) {
      if (stickyStates[i2]) {
        positions[i2] = nextPosition;
        nextPosition += widths[i2];
      }
    }
    return positions;
  }
  /**
   * Retreives the most recently observed size of the specified element from the cache, or
   * meaures it directly if not yet cached.
   */
  _retrieveElementSize(element) {
    const cachedSize = this._elemSizeCache.get(element);
    if (cachedSize) {
      return cachedSize;
    }
    const clientRect = element.getBoundingClientRect();
    const size = {
      width: clientRect.width,
      height: clientRect.height
    };
    if (!this._resizeObserver) {
      return size;
    }
    this._elemSizeCache.set(element, size);
    this._resizeObserver.observe(element, {
      box: "border-box"
    });
    return size;
  }
  /**
   * Conditionally enqueue the requested sticky update and clear previously queued updates
   * for the same rows.
   */
  _updateStickyColumnReplayQueue(params) {
    this._removeFromStickyColumnReplayQueue(params.rows);
    if (!this._stickyColumnsReplayTimeout) {
      this._updatedStickyColumnsParamsToReplay.push(params);
    }
  }
  /** Remove updates for the specified rows from the queue. */
  _removeFromStickyColumnReplayQueue(rows) {
    const rowsSet = new Set(rows);
    for (const update of this._updatedStickyColumnsParamsToReplay) {
      update.rows = update.rows.filter(row => !rowsSet.has(row));
    }
    this._updatedStickyColumnsParamsToReplay = this._updatedStickyColumnsParamsToReplay.filter(update => !!update.rows.length);
  }
  /** Update _elemSizeCache with the observed sizes. */
  _updateCachedSizes(entries) {
    let needsColumnUpdate = false;
    for (const entry of entries) {
      const newEntry = entry.borderBoxSize?.length ? {
        width: entry.borderBoxSize[0].inlineSize,
        height: entry.borderBoxSize[0].blockSize
      } : {
        width: entry.contentRect.width,
        height: entry.contentRect.height
      };
      if (newEntry.width !== this._elemSizeCache.get(entry.target)?.width && isCell(entry.target)) {
        needsColumnUpdate = true;
      }
      this._elemSizeCache.set(entry.target, newEntry);
    }
    if (needsColumnUpdate && this._updatedStickyColumnsParamsToReplay.length) {
      if (this._stickyColumnsReplayTimeout) {
        clearTimeout(this._stickyColumnsReplayTimeout);
      }
      this._stickyColumnsReplayTimeout = setTimeout(() => {
        if (this._destroyed) {
          return;
        }
        for (const update of this._updatedStickyColumnsParamsToReplay) {
          this.updateStickyColumns(update.rows, update.stickyStartStates, update.stickyEndStates, true, false);
        }
        this._updatedStickyColumnsParamsToReplay = [];
        this._stickyColumnsReplayTimeout = null;
      }, 0);
    }
  }
  /**
   * Invoke afterNextRender with the table's injector, falling back to CoalescedStyleScheduler
   * if the injector was not provided.
   */
  _afterNextRender(spec) {
    if (this._tableInjector) {
      afterNextRender(spec, {
        injector: this._tableInjector
      });
    } else {
      this._coalescedStyleScheduler.schedule(() => {
        spec.earlyRead?.();
        spec.write();
      });
    }
  }
};
function isCell(element) {
  return ["cdk-cell", "cdk-header-cell", "cdk-footer-cell"].some(klass => element.classList.contains(klass));
}
function getTableUnknownColumnError(id) {
  return Error(`Could not find column with id "${id}".`);
}
function getTableDuplicateColumnNameError(name) {
  return Error(`Duplicate column definition name provided: "${name}".`);
}
function getTableMultipleDefaultRowDefsError() {
  return Error(`There can only be one default row without a when predicate function.`);
}
function getTableMissingMatchingRowDefError(data) {
  return Error(`Could not find a matching row definition for theprovided row data: ${JSON.stringify(data)}`);
}
function getTableMissingRowDefsError() {
  return Error("Missing definitions for header, footer, and row; cannot determine which columns should be rendered.");
}
function getTableUnknownDataSourceError() {
  return Error(`Provided data source did not match an array, Observable, or DataSource`);
}
function getTableTextColumnMissingParentTableError() {
  return Error(`Text column could not find a parent table for registration.`);
}
function getTableTextColumnMissingNameError() {
  return Error(`Table text column must have a name.`);
}
var STICKY_POSITIONING_LISTENER = new InjectionToken("CDK_SPL");
var CdkRecycleRows = class _CdkRecycleRows {
  static ɵfac = function CdkRecycleRows_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkRecycleRows)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkRecycleRows,
    selectors: [["cdk-table", "recycleRows", ""], ["table", "cdk-table", "", "recycleRows", ""]],
    features: [ɵɵProvidersFeature([{
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _RecycleViewRepeaterStrategy
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRecycleRows, [{
    type: Directive,
    args: [{
      selector: "cdk-table[recycleRows], table[cdk-table][recycleRows]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }]
    }]
  }], null, null);
})();
var DataRowOutlet = class _DataRowOutlet {
  viewContainer = inject(ViewContainerRef);
  elementRef = inject(ElementRef);
  constructor() {
    const table = inject(CDK_TABLE);
    table._rowOutlet = this;
    table._outletAssigned();
  }
  static ɵfac = function DataRowOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataRowOutlet)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _DataRowOutlet,
    selectors: [["", "rowOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[rowOutlet]"
    }]
  }], () => [], null);
})();
var HeaderRowOutlet = class _HeaderRowOutlet {
  viewContainer = inject(ViewContainerRef);
  elementRef = inject(ElementRef);
  constructor() {
    const table = inject(CDK_TABLE);
    table._headerRowOutlet = this;
    table._outletAssigned();
  }
  static ɵfac = function HeaderRowOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderRowOutlet)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _HeaderRowOutlet,
    selectors: [["", "headerRowOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[headerRowOutlet]"
    }]
  }], () => [], null);
})();
var FooterRowOutlet = class _FooterRowOutlet {
  viewContainer = inject(ViewContainerRef);
  elementRef = inject(ElementRef);
  constructor() {
    const table = inject(CDK_TABLE);
    table._footerRowOutlet = this;
    table._outletAssigned();
  }
  static ɵfac = function FooterRowOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterRowOutlet)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _FooterRowOutlet,
    selectors: [["", "footerRowOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[footerRowOutlet]"
    }]
  }], () => [], null);
})();
var NoDataRowOutlet = class _NoDataRowOutlet {
  viewContainer = inject(ViewContainerRef);
  elementRef = inject(ElementRef);
  constructor() {
    const table = inject(CDK_TABLE);
    table._noDataRowOutlet = this;
    table._outletAssigned();
  }
  static ɵfac = function NoDataRowOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoDataRowOutlet)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _NoDataRowOutlet,
    selectors: [["", "noDataRowOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoDataRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[noDataRowOutlet]"
    }]
  }], () => [], null);
})();
var CDK_TABLE_TEMPLATE =
// Note that according to MDN, the `caption` element has to be projected as the **first**
// element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
`
  <ng-content select="caption"/>
  <ng-content select="colgroup, col"/>

  <!--
    Unprojected content throws a hydration error so we need this to capture it.
    It gets removed on the client so it doesn't affect the layout.
  -->
  @if (_isServer) {
    <ng-content/>
  }

  @if (_isNativeHtmlTable) {
    <thead role="rowgroup">
      <ng-container headerRowOutlet/>
    </thead>
    <tbody role="rowgroup">
      <ng-container rowOutlet/>
      <ng-container noDataRowOutlet/>
    </tbody>
    <tfoot role="rowgroup">
      <ng-container footerRowOutlet/>
    </tfoot>
  } @else {
    <ng-container headerRowOutlet/>
    <ng-container rowOutlet/>
    <ng-container noDataRowOutlet/>
    <ng-container footerRowOutlet/>
  }
`;
var CdkTable = class _CdkTable {
  _differs = inject(IterableDiffers);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _elementRef = inject(ElementRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _platform = inject(Platform);
  _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);
  _coalescedStyleScheduler = inject(_COALESCED_STYLE_SCHEDULER);
  _viewportRuler = inject(ViewportRuler);
  _stickyPositioningListener = inject(STICKY_POSITIONING_LISTENER, {
    optional: true,
    skipSelf: true
  });
  _document = inject(DOCUMENT);
  /** Latest data provided by the data source. */
  _data;
  /** Subject that emits when the component has been destroyed. */
  _onDestroy = new Subject();
  /** List of the rendered rows as identified by their `RenderRow` object. */
  _renderRows;
  /** Subscription that listens for the data provided by the data source. */
  _renderChangeSubscription;
  /**
   * Map of all the user's defined columns (header, data, and footer cell template) identified by
   * name. Collection populated by the column definitions gathered by `ContentChildren` as well as
   * any custom column definitions added to `_customColumnDefs`.
   */
  _columnDefsByName = /* @__PURE__ */new Map();
  /**
   * Set of all row definitions that can be used by this table. Populated by the rows gathered by
   * using `ContentChildren` as well as any custom row definitions added to `_customRowDefs`.
   */
  _rowDefs;
  /**
   * Set of all header row definitions that can be used by this table. Populated by the rows
   * gathered by using `ContentChildren` as well as any custom row definitions added to
   * `_customHeaderRowDefs`.
   */
  _headerRowDefs;
  /**
   * Set of all row definitions that can be used by this table. Populated by the rows gathered by
   * using `ContentChildren` as well as any custom row definitions added to
   * `_customFooterRowDefs`.
   */
  _footerRowDefs;
  /** Differ used to find the changes in the data provided by the data source. */
  _dataDiffer;
  /** Stores the row definition that does not have a when predicate. */
  _defaultRowDef;
  /**
   * Column definitions that were defined outside of the direct content children of the table.
   * These will be defined when, e.g., creating a wrapper around the cdkTable that has
   * column definitions as *its* content child.
   */
  _customColumnDefs = /* @__PURE__ */new Set();
  /**
   * Data row definitions that were defined outside of the direct content children of the table.
   * These will be defined when, e.g., creating a wrapper around the cdkTable that has
   * built-in data rows as *its* content child.
   */
  _customRowDefs = /* @__PURE__ */new Set();
  /**
   * Header row definitions that were defined outside of the direct content children of the table.
   * These will be defined when, e.g., creating a wrapper around the cdkTable that has
   * built-in header rows as *its* content child.
   */
  _customHeaderRowDefs = /* @__PURE__ */new Set();
  /**
   * Footer row definitions that were defined outside of the direct content children of the table.
   * These will be defined when, e.g., creating a wrapper around the cdkTable that has a
   * built-in footer row as *its* content child.
   */
  _customFooterRowDefs = /* @__PURE__ */new Set();
  /** No data row that was defined outside of the direct content children of the table. */
  _customNoDataRow;
  /**
   * Whether the header row definition has been changed. Triggers an update to the header row after
   * content is checked. Initialized as true so that the table renders the initial set of rows.
   */
  _headerRowDefChanged = true;
  /**
   * Whether the footer row definition has been changed. Triggers an update to the footer row after
   * content is checked. Initialized as true so that the table renders the initial set of rows.
   */
  _footerRowDefChanged = true;
  /**
   * Whether the sticky column styles need to be updated. Set to `true` when the visible columns
   * change.
   */
  _stickyColumnStylesNeedReset = true;
  /**
   * Whether the sticky styler should recalculate cell widths when applying sticky styles. If
   * `false`, cached values will be used instead. This is only applicable to tables with
   * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.
   */
  _forceRecalculateCellWidths = true;
  /**
   * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing
   * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with
   * the cached `RenderRow` objects when possible, the row identity is preserved when the data
   * and row template matches, which allows the `IterableDiffer` to check rows by reference
   * and understand which rows are added/moved/removed.
   *
   * Implemented as a map of maps where the first key is the `data: T` object and the second is the
   * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that
   * contains an array of created pairs. The array is necessary to handle cases where the data
   * array contains multiple duplicate data objects and each instantiated `RenderRow` must be
   * stored.
   */
  _cachedRenderRowsMap = /* @__PURE__ */new Map();
  /** Whether the table is applied to a native `<table>`. */
  _isNativeHtmlTable;
  /**
   * Utility class that is responsible for applying the appropriate sticky positioning styles to
   * the table's rows and cells.
   */
  _stickyStyler;
  /**
   * CSS class added to any row or cell that has sticky positioning applied. May be overridden by
   * table subclasses.
   */
  stickyCssClass = "cdk-table-sticky";
  /**
   * Whether to manually add position: sticky to all sticky cell elements. Not needed if
   * the position is set in a selector associated with the value of stickyCssClass. May be
   * overridden by table subclasses
   */
  needsPositionStickyOnElement = true;
  /** Whether the component is being rendered on the server. */
  _isServer;
  /** Whether the no data row is currently showing anything. */
  _isShowingNoDataRow = false;
  /** Whether the table has rendered out all the outlets for the first time. */
  _hasAllOutlets = false;
  /** Whether the table is done initializing. */
  _hasInitialized = false;
  /** Aria role to apply to the table's cells based on the table's own role. */
  _getCellRole() {
    if (this._cellRoleInternal === void 0) {
      const tableRole = this._elementRef.nativeElement.getAttribute("role");
      return tableRole === "grid" || tableRole === "treegrid" ? "gridcell" : "cell";
    }
    return this._cellRoleInternal;
  }
  _cellRoleInternal = void 0;
  /**
   * Tracking function that will be used to check the differences in data changes. Used similarly
   * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
   * relative to the function to know if a row should be added/removed/moved.
   * Accepts a function that takes two parameters, `index` and `item`.
   */
  get trackBy() {
    return this._trackByFn;
  }
  set trackBy(fn) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._trackByFn = fn;
  }
  _trackByFn;
  /**
   * The table's source of data, which can be provided in three ways (in order of complexity):
   *   - Simple data array (each object represents one table row)
   *   - Stream that emits a data array each time the array changes
   *   - `DataSource` object that implements the connect/disconnect interface.
   *
   * If a data array is provided, the table must be notified when the array's objects are
   * added, removed, or moved. This can be done by calling the `renderRows()` function which will
   * render the diff since the last table render. If the data array reference is changed, the table
   * will automatically trigger an update to the rows.
   *
   * When providing an Observable stream, the table will trigger an update automatically when the
   * stream emits a new array of data.
   *
   * Finally, when providing a `DataSource` object, the table will use the Observable stream
   * provided by the connect function and trigger updates when that stream emits new data array
   * values. During the table's ngOnDestroy or when the data source is removed from the table, the
   * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
   * subscriptions registered during the connect process).
   */
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(dataSource) {
    if (this._dataSource !== dataSource) {
      this._switchDataSource(dataSource);
    }
  }
  _dataSource;
  /**
   * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
   * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
   * dataobject will render the first row that evaluates its when predicate to true, in the order
   * defined in the table, or otherwise the default row which does not have a when predicate.
   */
  get multiTemplateDataRows() {
    return this._multiTemplateDataRows;
  }
  set multiTemplateDataRows(value) {
    this._multiTemplateDataRows = value;
    if (this._rowOutlet && this._rowOutlet.viewContainer.length) {
      this._forceRenderDataRows();
      this.updateStickyColumnStyles();
    }
  }
  _multiTemplateDataRows = false;
  /**
   * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths
   * and optimize rendering sticky styles for native tables. No-op for flex tables.
   */
  get fixedLayout() {
    return this._fixedLayout;
  }
  set fixedLayout(value) {
    this._fixedLayout = value;
    this._forceRecalculateCellWidths = true;
    this._stickyColumnStylesNeedReset = true;
  }
  _fixedLayout = false;
  /**
   * Emits when the table completes rendering a set of data rows based on the latest data from the
   * data source, even if the set of rows is empty.
   */
  contentChanged = new EventEmitter();
  // TODO(andrewseguin): Remove max value as the end index
  //   and instead calculate the view on init and scroll.
  /**
   * Stream containing the latest information on what rows are being displayed on screen.
   * Can be used by the data source to as a heuristic of what data should be provided.
   *
   * @docs-private
   */
  viewChange = new BehaviorSubject({
    start: 0,
    end: Number.MAX_VALUE
  });
  // Outlets in the table's template where the header, data rows, and footer will be inserted.
  _rowOutlet;
  _headerRowOutlet;
  _footerRowOutlet;
  _noDataRowOutlet;
  /**
   * The column definitions provided by the user that contain what the header, data, and footer
   * cells should render for each column.
   */
  _contentColumnDefs;
  /** Set of data row definitions that were provided to the table as content children. */
  _contentRowDefs;
  /** Set of header row definitions that were provided to the table as content children. */
  _contentHeaderRowDefs;
  /** Set of footer row definitions that were provided to the table as content children. */
  _contentFooterRowDefs;
  /** Row definition that will only be rendered if there's no data in the table. */
  _noDataRow;
  _injector = inject(Injector);
  constructor() {
    const role = inject(new HostAttributeToken("role"), {
      optional: true
    });
    if (!role) {
      this._elementRef.nativeElement.setAttribute("role", "table");
    }
    this._isServer = !this._platform.isBrowser;
    this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === "TABLE";
  }
  ngOnInit() {
    this._setupStickyStyler();
    this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {
      return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
    });
    this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {
      this._forceRecalculateCellWidths = true;
    });
  }
  ngAfterContentInit() {
    this._hasInitialized = true;
  }
  ngAfterContentChecked() {
    if (this._canRender()) {
      this._render();
    }
  }
  ngOnDestroy() {
    this._stickyStyler?.destroy();
    [this._rowOutlet?.viewContainer, this._headerRowOutlet?.viewContainer, this._footerRowOutlet?.viewContainer, this._cachedRenderRowsMap, this._customColumnDefs, this._customRowDefs, this._customHeaderRowDefs, this._customFooterRowDefs, this._columnDefsByName].forEach(def => {
      def?.clear();
    });
    this._headerRowDefs = [];
    this._footerRowDefs = [];
    this._defaultRowDef = null;
    this._onDestroy.next();
    this._onDestroy.complete();
    if (isDataSource(this.dataSource)) {
      this.dataSource.disconnect(this);
    }
  }
  /**
   * Renders rows based on the table's latest set of data, which was either provided directly as an
   * input or retrieved through an Observable stream (directly or from a DataSource).
   * Checks for differences in the data since the last diff to perform only the necessary
   * changes (add/remove/move rows).
   *
   * If the table's data source is a DataSource or Observable, this will be invoked automatically
   * each time the provided Observable stream emits a new data array. Otherwise if your data is
   * an array, this function will need to be called to render any changes.
   */
  renderRows() {
    this._renderRows = this._getAllRenderRows();
    const changes = this._dataDiffer.diff(this._renderRows);
    if (!changes) {
      this._updateNoDataRow();
      this.contentChanged.next();
      return;
    }
    const viewContainer = this._rowOutlet.viewContainer;
    this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), record => record.item.data, change => {
      if (change.operation === _ViewRepeaterOperation.INSERTED && change.context) {
        this._renderCellTemplateForItem(change.record.item.rowDef, change.context);
      }
    });
    this._updateRowIndexContext();
    changes.forEachIdentityChange(record => {
      const rowView = viewContainer.get(record.currentIndex);
      rowView.context.$implicit = record.item.data;
    });
    this._updateNoDataRow();
    this.contentChanged.next();
    this.updateStickyColumnStyles();
  }
  /** Adds a column definition that was not included as part of the content children. */
  addColumnDef(columnDef) {
    this._customColumnDefs.add(columnDef);
  }
  /** Removes a column definition that was not included as part of the content children. */
  removeColumnDef(columnDef) {
    this._customColumnDefs.delete(columnDef);
  }
  /** Adds a row definition that was not included as part of the content children. */
  addRowDef(rowDef) {
    this._customRowDefs.add(rowDef);
  }
  /** Removes a row definition that was not included as part of the content children. */
  removeRowDef(rowDef) {
    this._customRowDefs.delete(rowDef);
  }
  /** Adds a header row definition that was not included as part of the content children. */
  addHeaderRowDef(headerRowDef) {
    this._customHeaderRowDefs.add(headerRowDef);
    this._headerRowDefChanged = true;
  }
  /** Removes a header row definition that was not included as part of the content children. */
  removeHeaderRowDef(headerRowDef) {
    this._customHeaderRowDefs.delete(headerRowDef);
    this._headerRowDefChanged = true;
  }
  /** Adds a footer row definition that was not included as part of the content children. */
  addFooterRowDef(footerRowDef) {
    this._customFooterRowDefs.add(footerRowDef);
    this._footerRowDefChanged = true;
  }
  /** Removes a footer row definition that was not included as part of the content children. */
  removeFooterRowDef(footerRowDef) {
    this._customFooterRowDefs.delete(footerRowDef);
    this._footerRowDefChanged = true;
  }
  /** Sets a no data row definition that was not included as a part of the content children. */
  setNoDataRow(noDataRow) {
    this._customNoDataRow = noDataRow;
  }
  /**
   * Updates the header sticky styles. First resets all applied styles with respect to the cells
   * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
   * automatically called when the header row changes its displayed set of columns, or if its
   * sticky input changes. May be called manually for cases where the cell content changes outside
   * of these events.
   */
  updateStickyHeaderRowStyles() {
    const headerRows = this._getRenderedRows(this._headerRowOutlet);
    if (this._isNativeHtmlTable) {
      const thead = closestTableSection(this._headerRowOutlet, "thead");
      if (thead) {
        thead.style.display = headerRows.length ? "" : "none";
      }
    }
    const stickyStates = this._headerRowDefs.map(def => def.sticky);
    this._stickyStyler.clearStickyPositioning(headerRows, ["top"]);
    this._stickyStyler.stickRows(headerRows, stickyStates, "top");
    this._headerRowDefs.forEach(def => def.resetStickyChanged());
  }
  /**
   * Updates the footer sticky styles. First resets all applied styles with respect to the cells
   * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
   * automatically called when the footer row changes its displayed set of columns, or if its
   * sticky input changes. May be called manually for cases where the cell content changes outside
   * of these events.
   */
  updateStickyFooterRowStyles() {
    const footerRows = this._getRenderedRows(this._footerRowOutlet);
    if (this._isNativeHtmlTable) {
      const tfoot = closestTableSection(this._footerRowOutlet, "tfoot");
      if (tfoot) {
        tfoot.style.display = footerRows.length ? "" : "none";
      }
    }
    const stickyStates = this._footerRowDefs.map(def => def.sticky);
    this._stickyStyler.clearStickyPositioning(footerRows, ["bottom"]);
    this._stickyStyler.stickRows(footerRows, stickyStates, "bottom");
    this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);
    this._footerRowDefs.forEach(def => def.resetStickyChanged());
  }
  /**
   * Updates the column sticky styles. First resets all applied styles with respect to the cells
   * sticking to the left and right. Then sticky styles are added for the left and right according
   * to the column definitions for each cell in each row. This is automatically called when
   * the data source provides a new set of data or when a column definition changes its sticky
   * input. May be called manually for cases where the cell content changes outside of these events.
   */
  updateStickyColumnStyles() {
    const headerRows = this._getRenderedRows(this._headerRowOutlet);
    const dataRows = this._getRenderedRows(this._rowOutlet);
    const footerRows = this._getRenderedRows(this._footerRowOutlet);
    if (this._isNativeHtmlTable && !this._fixedLayout || this._stickyColumnStylesNeedReset) {
      this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ["left", "right"]);
      this._stickyColumnStylesNeedReset = false;
    }
    headerRows.forEach((headerRow, i2) => {
      this._addStickyColumnStyles([headerRow], this._headerRowDefs[i2]);
    });
    this._rowDefs.forEach(rowDef => {
      const rows = [];
      for (let i2 = 0; i2 < dataRows.length; i2++) {
        if (this._renderRows[i2].rowDef === rowDef) {
          rows.push(dataRows[i2]);
        }
      }
      this._addStickyColumnStyles(rows, rowDef);
    });
    footerRows.forEach((footerRow, i2) => {
      this._addStickyColumnStyles([footerRow], this._footerRowDefs[i2]);
    });
    Array.from(this._columnDefsByName.values()).forEach(def => def.resetStickyChanged());
  }
  /** Invoked whenever an outlet is created and has been assigned to the table. */
  _outletAssigned() {
    if (!this._hasAllOutlets && this._rowOutlet && this._headerRowOutlet && this._footerRowOutlet && this._noDataRowOutlet) {
      this._hasAllOutlets = true;
      if (this._canRender()) {
        this._render();
      }
    }
  }
  /** Whether the table has all the information to start rendering. */
  _canRender() {
    return this._hasAllOutlets && this._hasInitialized;
  }
  /** Renders the table if its state has changed. */
  _render() {
    this._cacheRowDefs();
    this._cacheColumnDefs();
    if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMissingRowDefsError();
    }
    const columnsChanged = this._renderUpdatedColumns();
    const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;
    this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;
    this._forceRecalculateCellWidths = rowDefsChanged;
    if (this._headerRowDefChanged) {
      this._forceRenderHeaderRows();
      this._headerRowDefChanged = false;
    }
    if (this._footerRowDefChanged) {
      this._forceRenderFooterRows();
      this._footerRowDefChanged = false;
    }
    if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
      this._observeRenderChanges();
    } else if (this._stickyColumnStylesNeedReset) {
      this.updateStickyColumnStyles();
    }
    this._checkStickyStates();
  }
  /**
   * Get the list of RenderRow objects to render according to the current list of data and defined
   * row definitions. If the previous list already contained a particular pair, it should be reused
   * so that the differ equates their references.
   */
  _getAllRenderRows() {
    const renderRows = [];
    const prevCachedRenderRows = this._cachedRenderRowsMap;
    this._cachedRenderRowsMap = /* @__PURE__ */new Map();
    for (let i2 = 0; i2 < this._data.length; i2++) {
      let data = this._data[i2];
      const renderRowsForData = this._getRenderRowsForData(data, i2, prevCachedRenderRows.get(data));
      if (!this._cachedRenderRowsMap.has(data)) {
        this._cachedRenderRowsMap.set(data, /* @__PURE__ */new WeakMap());
      }
      for (let j2 = 0; j2 < renderRowsForData.length; j2++) {
        let renderRow = renderRowsForData[j2];
        const cache = this._cachedRenderRowsMap.get(renderRow.data);
        if (cache.has(renderRow.rowDef)) {
          cache.get(renderRow.rowDef).push(renderRow);
        } else {
          cache.set(renderRow.rowDef, [renderRow]);
        }
        renderRows.push(renderRow);
      }
    }
    return renderRows;
  }
  /**
   * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
   * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
   * `(T, CdkRowDef)` pair.
   */
  _getRenderRowsForData(data, dataIndex, cache) {
    const rowDefs = this._getRowDefs(data, dataIndex);
    return rowDefs.map(rowDef => {
      const cachedRenderRows = cache && cache.has(rowDef) ? cache.get(rowDef) : [];
      if (cachedRenderRows.length) {
        const dataRow = cachedRenderRows.shift();
        dataRow.dataIndex = dataIndex;
        return dataRow;
      } else {
        return {
          data,
          rowDef,
          dataIndex
        };
      }
    });
  }
  /** Update the map containing the content's column definitions. */
  _cacheColumnDefs() {
    this._columnDefsByName.clear();
    const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);
    columnDefs.forEach(columnDef => {
      if (this._columnDefsByName.has(columnDef.name) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableDuplicateColumnNameError(columnDef.name);
      }
      this._columnDefsByName.set(columnDef.name, columnDef);
    });
  }
  /** Update the list of all available row definitions that can be used. */
  _cacheRowDefs() {
    this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);
    this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);
    this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);
    const defaultRowDefs = this._rowDefs.filter(def => !def.when);
    if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMultipleDefaultRowDefsError();
    }
    this._defaultRowDef = defaultRowDefs[0];
  }
  /**
   * Check if the header, data, or footer rows have changed what columns they want to display or
   * whether the sticky states have changed for the header or footer. If there is a diff, then
   * re-render that section.
   */
  _renderUpdatedColumns() {
    const columnsDiffReducer = (acc, def) => {
      const diff = !!def.getColumnsDiff();
      return acc || diff;
    };
    const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);
    if (dataColumnsChanged) {
      this._forceRenderDataRows();
    }
    const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);
    if (headerColumnsChanged) {
      this._forceRenderHeaderRows();
    }
    const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);
    if (footerColumnsChanged) {
      this._forceRenderFooterRows();
    }
    return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;
  }
  /**
   * Switch to the provided data source by resetting the data and unsubscribing from the current
   * render change subscription if one exists. If the data source is null, interpret this by
   * clearing the row outlet. Otherwise start listening for new data.
   */
  _switchDataSource(dataSource) {
    this._data = [];
    if (isDataSource(this.dataSource)) {
      this.dataSource.disconnect(this);
    }
    if (this._renderChangeSubscription) {
      this._renderChangeSubscription.unsubscribe();
      this._renderChangeSubscription = null;
    }
    if (!dataSource) {
      if (this._dataDiffer) {
        this._dataDiffer.diff([]);
      }
      if (this._rowOutlet) {
        this._rowOutlet.viewContainer.clear();
      }
    }
    this._dataSource = dataSource;
  }
  /** Set up a subscription for the data provided by the data source. */
  _observeRenderChanges() {
    if (!this.dataSource) {
      return;
    }
    let dataStream;
    if (isDataSource(this.dataSource)) {
      dataStream = this.dataSource.connect(this);
    } else if (isObservable(this.dataSource)) {
      dataStream = this.dataSource;
    } else if (Array.isArray(this.dataSource)) {
      dataStream = of(this.dataSource);
    }
    if (dataStream === void 0 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableUnknownDataSourceError();
    }
    this._renderChangeSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe(data => {
      this._data = data || [];
      this.renderRows();
    });
  }
  /**
   * Clears any existing content in the header row outlet and creates a new embedded view
   * in the outlet using the header row definition.
   */
  _forceRenderHeaderRows() {
    if (this._headerRowOutlet.viewContainer.length > 0) {
      this._headerRowOutlet.viewContainer.clear();
    }
    this._headerRowDefs.forEach((def, i2) => this._renderRow(this._headerRowOutlet, def, i2));
    this.updateStickyHeaderRowStyles();
  }
  /**
   * Clears any existing content in the footer row outlet and creates a new embedded view
   * in the outlet using the footer row definition.
   */
  _forceRenderFooterRows() {
    if (this._footerRowOutlet.viewContainer.length > 0) {
      this._footerRowOutlet.viewContainer.clear();
    }
    this._footerRowDefs.forEach((def, i2) => this._renderRow(this._footerRowOutlet, def, i2));
    this.updateStickyFooterRowStyles();
  }
  /** Adds the sticky column styles for the rows according to the columns' stick states. */
  _addStickyColumnStyles(rows, rowDef) {
    const columnDefs = Array.from(rowDef?.columns || []).map(columnName => {
      const columnDef = this._columnDefsByName.get(columnName);
      if (!columnDef && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableUnknownColumnError(columnName);
      }
      return columnDef;
    });
    const stickyStartStates = columnDefs.map(columnDef => columnDef.sticky);
    const stickyEndStates = columnDefs.map(columnDef => columnDef.stickyEnd);
    this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);
  }
  /** Gets the list of rows that have been rendered in the row outlet. */
  _getRenderedRows(rowOutlet) {
    const renderedRows = [];
    for (let i2 = 0; i2 < rowOutlet.viewContainer.length; i2++) {
      const viewRef = rowOutlet.viewContainer.get(i2);
      renderedRows.push(viewRef.rootNodes[0]);
    }
    return renderedRows;
  }
  /**
   * Get the matching row definitions that should be used for this row data. If there is only
   * one row definition, it is returned. Otherwise, find the row definitions that has a when
   * predicate that returns true with the data. If none return true, return the default row
   * definition.
   */
  _getRowDefs(data, dataIndex) {
    if (this._rowDefs.length == 1) {
      return [this._rowDefs[0]];
    }
    let rowDefs = [];
    if (this.multiTemplateDataRows) {
      rowDefs = this._rowDefs.filter(def => !def.when || def.when(dataIndex, data));
    } else {
      let rowDef = this._rowDefs.find(def => def.when && def.when(dataIndex, data)) || this._defaultRowDef;
      if (rowDef) {
        rowDefs.push(rowDef);
      }
    }
    if (!rowDefs.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMissingMatchingRowDefError(data);
    }
    return rowDefs;
  }
  _getEmbeddedViewArgs(renderRow, index) {
    const rowDef = renderRow.rowDef;
    const context = {
      $implicit: renderRow.data
    };
    return {
      templateRef: rowDef.template,
      context,
      index
    };
  }
  /**
   * Creates a new row template in the outlet and fills it with the set of cell templates.
   * Optionally takes a context to provide to the row and cells, as well as an optional index
   * of where to place the new row template in the outlet.
   */
  _renderRow(outlet, rowDef, index, context = {}) {
    const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
    this._renderCellTemplateForItem(rowDef, context);
    return view;
  }
  _renderCellTemplateForItem(rowDef, context) {
    for (let cellTemplate of this._getCellTemplates(rowDef)) {
      if (CdkCellOutlet.mostRecentCellOutlet) {
        CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
      }
    }
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Updates the index-related context for each row to reflect any changes in the index of the rows,
   * e.g. first/last/even/odd.
   */
  _updateRowIndexContext() {
    const viewContainer = this._rowOutlet.viewContainer;
    for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
      const viewRef = viewContainer.get(renderIndex);
      const context = viewRef.context;
      context.count = count;
      context.first = renderIndex === 0;
      context.last = renderIndex === count - 1;
      context.even = renderIndex % 2 === 0;
      context.odd = !context.even;
      if (this.multiTemplateDataRows) {
        context.dataIndex = this._renderRows[renderIndex].dataIndex;
        context.renderIndex = renderIndex;
      } else {
        context.index = this._renderRows[renderIndex].dataIndex;
      }
    }
  }
  /** Gets the column definitions for the provided row def. */
  _getCellTemplates(rowDef) {
    if (!rowDef || !rowDef.columns) {
      return [];
    }
    return Array.from(rowDef.columns, columnId => {
      const column = this._columnDefsByName.get(columnId);
      if (!column && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableUnknownColumnError(columnId);
      }
      return rowDef.extractCellTemplate(column);
    });
  }
  /**
   * Forces a re-render of the data rows. Should be called in cases where there has been an input
   * change that affects the evaluation of which rows should be rendered, e.g. toggling
   * `multiTemplateDataRows` or adding/removing row definitions.
   */
  _forceRenderDataRows() {
    this._dataDiffer.diff([]);
    this._rowOutlet.viewContainer.clear();
    this.renderRows();
  }
  /**
   * Checks if there has been a change in sticky states since last check and applies the correct
   * sticky styles. Since checking resets the "dirty" state, this should only be performed once
   * during a change detection and after the inputs are settled (after content check).
   */
  _checkStickyStates() {
    const stickyCheckReducer = (acc, d2) => {
      return acc || d2.hasStickyChanged();
    };
    if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
      this.updateStickyHeaderRowStyles();
    }
    if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
      this.updateStickyFooterRowStyles();
    }
    if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
      this._stickyColumnStylesNeedReset = true;
      this.updateStickyColumnStyles();
    }
  }
  /**
   * Creates the sticky styler that will be used for sticky rows and columns. Listens
   * for directionality changes and provides the latest direction to the styler. Re-applies column
   * stickiness when directionality changes.
   */
  _setupStickyStyler() {
    const direction = this._dir ? this._dir.value : "ltr";
    this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener, this._injector);
    (this._dir ? this._dir.change : of()).pipe(takeUntil(this._onDestroy)).subscribe(value => {
      this._stickyStyler.direction = value;
      this.updateStickyColumnStyles();
    });
  }
  /** Filters definitions that belong to this table from a QueryList. */
  _getOwnDefs(items) {
    return items.filter(item => !item._table || item._table === this);
  }
  /** Creates or removes the no data row, depending on whether any data is being shown. */
  _updateNoDataRow() {
    const noDataRow = this._customNoDataRow || this._noDataRow;
    if (!noDataRow) {
      return;
    }
    const shouldShow = this._rowOutlet.viewContainer.length === 0;
    if (shouldShow === this._isShowingNoDataRow) {
      return;
    }
    const container = this._noDataRowOutlet.viewContainer;
    if (shouldShow) {
      const view = container.createEmbeddedView(noDataRow.templateRef);
      const rootNode = view.rootNodes[0];
      if (view.rootNodes.length === 1 && rootNode?.nodeType === this._document.ELEMENT_NODE) {
        rootNode.setAttribute("role", "row");
        rootNode.classList.add(noDataRow._contentClassName);
      }
    } else {
      container.clear();
    }
    this._isShowingNoDataRow = shouldShow;
    this._changeDetectorRef.markForCheck();
  }
  static ɵfac = function CdkTable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTable)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _CdkTable,
    selectors: [["cdk-table"], ["table", "cdk-table", ""]],
    contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CdkNoDataRow, 5);
        ɵɵcontentQuery(dirIndex, CdkColumnDef, 5);
        ɵɵcontentQuery(dirIndex, CdkRowDef, 5);
        ɵɵcontentQuery(dirIndex, CdkHeaderRowDef, 5);
        ɵɵcontentQuery(dirIndex, CdkFooterRowDef, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._noDataRow = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._contentColumnDefs = _t2);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._contentRowDefs = _t2);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._contentHeaderRowDefs = _t2);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._contentFooterRowDefs = _t2);
      }
    },
    hostAttrs: [1, "cdk-table"],
    hostVars: 2,
    hostBindings: function CdkTable_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("cdk-table-fixed-layout", ctx.fixedLayout);
      }
    },
    inputs: {
      trackBy: "trackBy",
      dataSource: "dataSource",
      multiTemplateDataRows: [2, "multiTemplateDataRows", "multiTemplateDataRows", booleanAttribute],
      fixedLayout: [2, "fixedLayout", "fixedLayout", booleanAttribute]
    },
    outputs: {
      contentChanged: "contentChanged"
    },
    exportAs: ["cdkTable"],
    features: [ɵɵProvidersFeature([{
      provide: CDK_TABLE,
      useExisting: _CdkTable
    }, {
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _DisposeViewRepeaterStrategy
    }, {
      provide: _COALESCED_STYLE_SCHEDULER,
      useClass: _CoalescedStyleScheduler
    },
    // Prevent nested tables from seeing this table's StickyPositioningListener.
    {
      provide: STICKY_POSITIONING_LISTENER,
      useValue: null
    }])],
    ngContentSelectors: _c14,
    decls: 5,
    vars: 2,
    consts: [["role", "rowgroup"], ["headerRowOutlet", ""], ["rowOutlet", ""], ["noDataRowOutlet", ""], ["footerRowOutlet", ""]],
    template: function CdkTable_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c04);
        ɵɵprojection(0);
        ɵɵprojection(1, 1);
        ɵɵtemplate(2, CdkTable_Conditional_2_Template, 1, 0)(3, CdkTable_Conditional_3_Template, 7, 0)(4, CdkTable_Conditional_4_Template, 4, 0);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(ctx._isServer ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx._isNativeHtmlTable ? 3 : 4);
      }
    },
    dependencies: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
    styles: [".cdk-table-fixed-layout{table-layout:fixed}"],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTable, [{
    type: Component,
    args: [{
      selector: "cdk-table, table[cdk-table]",
      exportAs: "cdkTable",
      template: CDK_TABLE_TEMPLATE,
      host: {
        "class": "cdk-table",
        "[class.cdk-table-fixed-layout]": "fixedLayout"
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.Default,
      providers: [{
        provide: CDK_TABLE,
        useExisting: CdkTable
      }, {
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _DisposeViewRepeaterStrategy
      }, {
        provide: _COALESCED_STYLE_SCHEDULER,
        useClass: _CoalescedStyleScheduler
      },
      // Prevent nested tables from seeing this table's StickyPositioningListener.
      {
        provide: STICKY_POSITIONING_LISTENER,
        useValue: null
      }],
      imports: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
      styles: [".cdk-table-fixed-layout{table-layout:fixed}"]
    }]
  }], () => [], {
    trackBy: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    multiTemplateDataRows: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fixedLayout: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    contentChanged: [{
      type: Output
    }],
    _contentColumnDefs: [{
      type: ContentChildren,
      args: [CdkColumnDef, {
        descendants: true
      }]
    }],
    _contentRowDefs: [{
      type: ContentChildren,
      args: [CdkRowDef, {
        descendants: true
      }]
    }],
    _contentHeaderRowDefs: [{
      type: ContentChildren,
      args: [CdkHeaderRowDef, {
        descendants: true
      }]
    }],
    _contentFooterRowDefs: [{
      type: ContentChildren,
      args: [CdkFooterRowDef, {
        descendants: true
      }]
    }],
    _noDataRow: [{
      type: ContentChild,
      args: [CdkNoDataRow]
    }]
  });
})();
function mergeArrayAndSet(array, set) {
  return array.concat(Array.from(set));
}
function closestTableSection(outlet, section) {
  const uppercaseSection = section.toUpperCase();
  let current = outlet.viewContainer.element.nativeElement;
  while (current) {
    const nodeName = current.nodeType === 1 ? current.nodeName : null;
    if (nodeName === uppercaseSection) {
      return current;
    } else if (nodeName === "TABLE") {
      break;
    }
    current = current.parentNode;
  }
  return null;
}
var CdkTextColumn = class _CdkTextColumn {
  _table = inject(CdkTable, {
    optional: true
  });
  _options = inject(TEXT_COLUMN_OPTIONS, {
    optional: true
  });
  /** Column name that should be used to reference this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this._syncColumnDefName();
  }
  _name;
  /**
   * Text label that should be used for the column header. If this property is not
   * set, the header text will default to the column name with its first letter capitalized.
   */
  headerText;
  /**
   * Accessor function to retrieve the data rendered for each cell. If this
   * property is not set, the data cells will render the value found in the data's property matching
   * the column's name. For example, if the column is named `id`, then the rendered value will be
   * value defined by the data's `id` property.
   */
  dataAccessor;
  /** Alignment of the cell values. */
  justify = "start";
  /** @docs-private */
  columnDef;
  /**
   * The column cell is provided to the column during `ngOnInit` with a static query.
   * Normally, this will be retrieved by the column using `ContentChild`, but that assumes the
   * column definition was provided in the same view as the table, which is not the case with this
   * component.
   * @docs-private
   */
  cell;
  /**
   * The column headerCell is provided to the column during `ngOnInit` with a static query.
   * Normally, this will be retrieved by the column using `ContentChild`, but that assumes the
   * column definition was provided in the same view as the table, which is not the case with this
   * component.
   * @docs-private
   */
  headerCell;
  constructor() {
    this._options = this._options || {};
  }
  ngOnInit() {
    this._syncColumnDefName();
    if (this.headerText === void 0) {
      this.headerText = this._createDefaultHeaderText();
    }
    if (!this.dataAccessor) {
      this.dataAccessor = this._options.defaultDataAccessor || ((data, name) => data[name]);
    }
    if (this._table) {
      this.columnDef.cell = this.cell;
      this.columnDef.headerCell = this.headerCell;
      this._table.addColumnDef(this.columnDef);
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getTableTextColumnMissingParentTableError();
    }
  }
  ngOnDestroy() {
    if (this._table) {
      this._table.removeColumnDef(this.columnDef);
    }
  }
  /**
   * Creates a default header text. Use the options' header text transformation function if one
   * has been provided. Otherwise simply capitalize the column name.
   */
  _createDefaultHeaderText() {
    const name = this.name;
    if (!name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableTextColumnMissingNameError();
    }
    if (this._options && this._options.defaultHeaderTextTransform) {
      return this._options.defaultHeaderTextTransform(name);
    }
    return name[0].toUpperCase() + name.slice(1);
  }
  /** Synchronizes the column definition name with the text column name. */
  _syncColumnDefName() {
    if (this.columnDef) {
      this.columnDef.name = this.name;
    }
  }
  static ɵfac = function CdkTextColumn_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTextColumn)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _CdkTextColumn,
    selectors: [["cdk-text-column"]],
    viewQuery: function CdkTextColumn_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(CdkColumnDef, 7);
        ɵɵviewQuery(CdkCellDef, 7);
        ɵɵviewQuery(CdkHeaderCellDef, 7);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.columnDef = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.cell = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.headerCell = _t2.first);
      }
    },
    inputs: {
      name: "name",
      headerText: "headerText",
      dataAccessor: "dataAccessor",
      justify: "justify"
    },
    decls: 3,
    vars: 0,
    consts: [["cdkColumnDef", ""], ["cdk-header-cell", "", 3, "text-align", 4, "cdkHeaderCellDef"], ["cdk-cell", "", 3, "text-align", 4, "cdkCellDef"], ["cdk-header-cell", ""], ["cdk-cell", ""]],
    template: function CdkTextColumn_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 0);
        ɵɵtemplate(1, CdkTextColumn_th_1_Template, 2, 3, "th", 1)(2, CdkTextColumn_td_2_Template, 2, 3, "td", 2);
        ɵɵelementContainerEnd();
      }
    },
    dependencies: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTextColumn, [{
    type: Component,
    args: [{
      selector: "cdk-text-column",
      template: `
    <ng-container cdkColumnDef>
      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]="justify">
        {{headerText}}
      </th>
      <td cdk-cell *cdkCellDef="let data" [style.text-align]="justify">
        {{dataAccessor(data, name)}}
      </td>
    </ng-container>
  `,
      encapsulation: ViewEncapsulation.None,
      // Change detection is intentionally not set to OnPush. This component's template will be provided
      // to the table to be inserted into its view. This is problematic when change detection runs since
      // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
      // mean's the template in the table's view will not have the updated value (and in fact will cause
      // an ExpressionChangedAfterItHasBeenCheckedError).
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      imports: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell]
    }]
  }], () => [], {
    name: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    dataAccessor: [{
      type: Input
    }],
    justify: [{
      type: Input
    }],
    columnDef: [{
      type: ViewChild,
      args: [CdkColumnDef, {
        static: true
      }]
    }],
    cell: [{
      type: ViewChild,
      args: [CdkCellDef, {
        static: true
      }]
    }],
    headerCell: [{
      type: ViewChild,
      args: [CdkHeaderCellDef, {
        static: true
      }]
    }]
  });
})();
var EXPORTED_DECLARATIONS = [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet];
var CdkTableModule = class _CdkTableModule {
  static ɵfac = function CdkTableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTableModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _CdkTableModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [ScrollingModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTableModule, [{
    type: NgModule,
    args: [{
      exports: EXPORTED_DECLARATIONS,
      imports: [ScrollingModule, ...EXPORTED_DECLARATIONS]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/table.mjs
var _c05 = [[["caption"]], [["colgroup"], ["col"]], "*"];
var _c15 = ["caption", "colgroup, col", "*"];
function MatTable_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
  }
}
function MatTable_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead", 0);
    ɵɵelementContainer(1, 1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "tbody", 2);
    ɵɵelementContainer(3, 3)(4, 4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "tfoot", 0);
    ɵɵelementContainer(6, 5);
    ɵɵelementEnd();
  }
}
function MatTable_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 1)(1, 3)(2, 4)(3, 5);
  }
}
function MatTextColumn_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.headerText, " ");
  }
}
function MatTextColumn_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.dataAccessor(data_r2, ctx_r0.name), " ");
  }
}
var MatRecycleRows = class _MatRecycleRows {
  static ɵfac = function MatRecycleRows_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatRecycleRows)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatRecycleRows,
    selectors: [["mat-table", "recycleRows", ""], ["table", "mat-table", "", "recycleRows", ""]],
    features: [ɵɵProvidersFeature([{
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _RecycleViewRepeaterStrategy
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatRecycleRows, [{
    type: Directive,
    args: [{
      selector: "mat-table[recycleRows], table[mat-table][recycleRows]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }]
    }]
  }], null, null);
})();
var MatTable = class _MatTable extends CdkTable {
  /** Overrides the sticky CSS class set by the `CdkTable`. */
  stickyCssClass = "mat-mdc-table-sticky";
  /** Overrides the need to add position: sticky on every sticky cell element in `CdkTable`. */
  needsPositionStickyOnElement = false;
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatTable_BaseFactory;
    return function MatTable_Factory(__ngFactoryType__) {
      return (ɵMatTable_BaseFactory || (ɵMatTable_BaseFactory = ɵɵgetInheritedFactory(_MatTable)))(__ngFactoryType__ || _MatTable);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatTable,
    selectors: [["mat-table"], ["table", "mat-table", ""]],
    hostAttrs: [1, "mat-mdc-table", "mdc-data-table__table"],
    hostVars: 2,
    hostBindings: function MatTable_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("mdc-table-fixed-layout", ctx.fixedLayout);
      }
    },
    exportAs: ["matTable"],
    features: [ɵɵProvidersFeature([{
      provide: CdkTable,
      useExisting: _MatTable
    }, {
      provide: CDK_TABLE,
      useExisting: _MatTable
    }, {
      provide: _COALESCED_STYLE_SCHEDULER,
      useClass: _CoalescedStyleScheduler
    },
    // TODO(michaeljamesparsons) Abstract the view repeater strategy to a directive API so this code
    //  is only included in the build if used.
    {
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _DisposeViewRepeaterStrategy
    },
    // Prevent nested tables from seeing this table's StickyPositioningListener.
    {
      provide: STICKY_POSITIONING_LISTENER,
      useValue: null
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c15,
    decls: 5,
    vars: 2,
    consts: [["role", "rowgroup"], ["headerRowOutlet", ""], ["role", "rowgroup", 1, "mdc-data-table__content"], ["rowOutlet", ""], ["noDataRowOutlet", ""], ["footerRowOutlet", ""]],
    template: function MatTable_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c05);
        ɵɵprojection(0);
        ɵɵprojection(1, 1);
        ɵɵtemplate(2, MatTable_Conditional_2_Template, 1, 0)(3, MatTable_Conditional_3_Template, 7, 0)(4, MatTable_Conditional_4_Template, 4, 0);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(ctx._isServer ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx._isNativeHtmlTable ? 3 : 4);
      }
    },
    dependencies: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
    styles: [".mat-mdc-table-sticky{position:sticky !important}mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}.mat-mdc-table{min-width:100%;border:0;border-spacing:0;table-layout:auto;white-space:normal;background-color:var(--mat-table-background-color, var(--mat-sys-surface))}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell{text-align:right}.mdc-data-table__cell,.mdc-data-table__header-cell{padding:0 16px}.mat-mdc-header-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-header-container-height, 56px);color:var(--mat-table-header-headline-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-header-headline-font, var(--mat-sys-title-small-font, Roboto, sans-serif));line-height:var(--mat-table-header-headline-line-height, var(--mat-sys-title-small-line-height));font-size:var(--mat-table-header-headline-size, var(--mat-sys-title-small-size, 14px));font-weight:var(--mat-table-header-headline-weight, var(--mat-sys-title-small-weight, 500))}.mat-mdc-row{height:var(--mat-table-row-item-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)))}.mat-mdc-row,.mdc-data-table__content{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-table-row-item-label-text-font, var(--mat-sys-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-row-item-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-table-row-item-label-text-size, var(--mat-sys-body-medium-size, 14px));font-weight:var(--mat-table-row-item-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-footer-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-footer-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-footer-supporting-text-font, var(--mat-sys-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-footer-supporting-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-table-footer-supporting-text-size, var(--mat-sys-body-medium-size, 14px));font-weight:var(--mat-table-footer-supporting-text-weight, var(--mat-sys-body-medium-weight));letter-spacing:var(--mat-table-footer-supporting-text-tracking, var(--mat-sys-body-medium-tracking))}.mat-mdc-header-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-sys-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-header-headline-tracking, var(--mat-sys-title-small-tracking));font-weight:inherit;line-height:inherit;box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mat-mdc-header-cell{text-align:right}.mdc-data-table__row:last-child>.mat-mdc-header-cell{border-bottom:none}.mat-mdc-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-sys-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-sys-body-medium-tracking));line-height:inherit}.mdc-data-table__row:last-child>.mat-mdc-cell{border-bottom:none}.mat-mdc-footer-cell{letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-sys-body-medium-tracking))}mat-row.mat-mdc-row,mat-header-row.mat-mdc-header-row,mat-footer-row.mat-mdc-footer-row{border-bottom:none}.mat-mdc-table tbody,.mat-mdc-table tfoot,.mat-mdc-table thead,.mat-mdc-cell,.mat-mdc-footer-cell,.mat-mdc-header-row,.mat-mdc-row,.mat-mdc-footer-row,.mat-mdc-table .mat-mdc-header-cell{background:inherit}.mat-mdc-table mat-header-row.mat-mdc-header-row,.mat-mdc-table mat-row.mat-mdc-row,.mat-mdc-table mat-footer-row.mat-mdc-footer-cell{height:unset}mat-header-cell.mat-mdc-header-cell,mat-cell.mat-mdc-cell,mat-footer-cell.mat-mdc-footer-cell{align-self:stretch}"],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTable, [{
    type: Component,
    args: [{
      selector: "mat-table, table[mat-table]",
      exportAs: "matTable",
      template: `
    <ng-content select="caption"/>
    <ng-content select="colgroup, col"/>

    <!--
      Unprojected content throws a hydration error so we need this to capture it.
      It gets removed on the client so it doesn't affect the layout.
    -->
    @if (_isServer) {
      <ng-content/>
    }

    @if (_isNativeHtmlTable) {
      <thead role="rowgroup">
        <ng-container headerRowOutlet/>
      </thead>
      <tbody class="mdc-data-table__content" role="rowgroup">
        <ng-container rowOutlet/>
        <ng-container noDataRowOutlet/>
      </tbody>
      <tfoot role="rowgroup">
        <ng-container footerRowOutlet/>
      </tfoot>
    } @else {
      <ng-container headerRowOutlet/>
      <ng-container rowOutlet/>
      <ng-container noDataRowOutlet/>
      <ng-container footerRowOutlet/>
    }
  `,
      host: {
        "class": "mat-mdc-table mdc-data-table__table",
        "[class.mdc-table-fixed-layout]": "fixedLayout"
      },
      providers: [{
        provide: CdkTable,
        useExisting: MatTable
      }, {
        provide: CDK_TABLE,
        useExisting: MatTable
      }, {
        provide: _COALESCED_STYLE_SCHEDULER,
        useClass: _CoalescedStyleScheduler
      },
      // TODO(michaeljamesparsons) Abstract the view repeater strategy to a directive API so this code
      //  is only included in the build if used.
      {
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _DisposeViewRepeaterStrategy
      },
      // Prevent nested tables from seeing this table's StickyPositioningListener.
      {
        provide: STICKY_POSITIONING_LISTENER,
        useValue: null
      }],
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.Default,
      imports: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
      styles: [".mat-mdc-table-sticky{position:sticky !important}mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}.mat-mdc-table{min-width:100%;border:0;border-spacing:0;table-layout:auto;white-space:normal;background-color:var(--mat-table-background-color, var(--mat-sys-surface))}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell{text-align:right}.mdc-data-table__cell,.mdc-data-table__header-cell{padding:0 16px}.mat-mdc-header-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-header-container-height, 56px);color:var(--mat-table-header-headline-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-header-headline-font, var(--mat-sys-title-small-font, Roboto, sans-serif));line-height:var(--mat-table-header-headline-line-height, var(--mat-sys-title-small-line-height));font-size:var(--mat-table-header-headline-size, var(--mat-sys-title-small-size, 14px));font-weight:var(--mat-table-header-headline-weight, var(--mat-sys-title-small-weight, 500))}.mat-mdc-row{height:var(--mat-table-row-item-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)))}.mat-mdc-row,.mdc-data-table__content{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-table-row-item-label-text-font, var(--mat-sys-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-row-item-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-table-row-item-label-text-size, var(--mat-sys-body-medium-size, 14px));font-weight:var(--mat-table-row-item-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-footer-row{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;height:var(--mat-table-footer-container-height, 52px);color:var(--mat-table-row-item-label-text-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mat-table-footer-supporting-text-font, var(--mat-sys-body-medium-font, Roboto, sans-serif));line-height:var(--mat-table-footer-supporting-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-table-footer-supporting-text-size, var(--mat-sys-body-medium-size, 14px));font-weight:var(--mat-table-footer-supporting-text-weight, var(--mat-sys-body-medium-weight));letter-spacing:var(--mat-table-footer-supporting-text-tracking, var(--mat-sys-body-medium-tracking))}.mat-mdc-header-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-sys-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-header-headline-tracking, var(--mat-sys-title-small-tracking));font-weight:inherit;line-height:inherit;box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mat-mdc-header-cell{text-align:right}.mdc-data-table__row:last-child>.mat-mdc-header-cell{border-bottom:none}.mat-mdc-cell{border-bottom-color:var(--mat-table-row-item-outline-color, var(--mat-sys-outline, rgba(0, 0, 0, 0.12)));border-bottom-width:var(--mat-table-row-item-outline-width, 1px);border-bottom-style:solid;letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-sys-body-medium-tracking));line-height:inherit}.mdc-data-table__row:last-child>.mat-mdc-cell{border-bottom:none}.mat-mdc-footer-cell{letter-spacing:var(--mat-table-row-item-label-text-tracking, var(--mat-sys-body-medium-tracking))}mat-row.mat-mdc-row,mat-header-row.mat-mdc-header-row,mat-footer-row.mat-mdc-footer-row{border-bottom:none}.mat-mdc-table tbody,.mat-mdc-table tfoot,.mat-mdc-table thead,.mat-mdc-cell,.mat-mdc-footer-cell,.mat-mdc-header-row,.mat-mdc-row,.mat-mdc-footer-row,.mat-mdc-table .mat-mdc-header-cell{background:inherit}.mat-mdc-table mat-header-row.mat-mdc-header-row,.mat-mdc-table mat-row.mat-mdc-row,.mat-mdc-table mat-footer-row.mat-mdc-footer-cell{height:unset}mat-header-cell.mat-mdc-header-cell,mat-cell.mat-mdc-cell,mat-footer-cell.mat-mdc-footer-cell{align-self:stretch}"]
    }]
  }], null, null);
})();
var MatCellDef = class _MatCellDef extends CdkCellDef {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatCellDef_BaseFactory;
    return function MatCellDef_Factory(__ngFactoryType__) {
      return (ɵMatCellDef_BaseFactory || (ɵMatCellDef_BaseFactory = ɵɵgetInheritedFactory(_MatCellDef)))(__ngFactoryType__ || _MatCellDef);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatCellDef,
    selectors: [["", "matCellDef", ""]],
    features: [ɵɵProvidersFeature([{
      provide: CdkCellDef,
      useExisting: _MatCellDef
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatCellDef, [{
    type: Directive,
    args: [{
      selector: "[matCellDef]",
      providers: [{
        provide: CdkCellDef,
        useExisting: MatCellDef
      }]
    }]
  }], null, null);
})();
var MatHeaderCellDef = class _MatHeaderCellDef extends CdkHeaderCellDef {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatHeaderCellDef_BaseFactory;
    return function MatHeaderCellDef_Factory(__ngFactoryType__) {
      return (ɵMatHeaderCellDef_BaseFactory || (ɵMatHeaderCellDef_BaseFactory = ɵɵgetInheritedFactory(_MatHeaderCellDef)))(__ngFactoryType__ || _MatHeaderCellDef);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatHeaderCellDef,
    selectors: [["", "matHeaderCellDef", ""]],
    features: [ɵɵProvidersFeature([{
      provide: CdkHeaderCellDef,
      useExisting: _MatHeaderCellDef
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatHeaderCellDef, [{
    type: Directive,
    args: [{
      selector: "[matHeaderCellDef]",
      providers: [{
        provide: CdkHeaderCellDef,
        useExisting: MatHeaderCellDef
      }]
    }]
  }], null, null);
})();
var MatFooterCellDef = class _MatFooterCellDef extends CdkFooterCellDef {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatFooterCellDef_BaseFactory;
    return function MatFooterCellDef_Factory(__ngFactoryType__) {
      return (ɵMatFooterCellDef_BaseFactory || (ɵMatFooterCellDef_BaseFactory = ɵɵgetInheritedFactory(_MatFooterCellDef)))(__ngFactoryType__ || _MatFooterCellDef);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatFooterCellDef,
    selectors: [["", "matFooterCellDef", ""]],
    features: [ɵɵProvidersFeature([{
      provide: CdkFooterCellDef,
      useExisting: _MatFooterCellDef
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatFooterCellDef, [{
    type: Directive,
    args: [{
      selector: "[matFooterCellDef]",
      providers: [{
        provide: CdkFooterCellDef,
        useExisting: MatFooterCellDef
      }]
    }]
  }], null, null);
})();
var MatColumnDef = class _MatColumnDef extends CdkColumnDef {
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._setNameInput(name);
  }
  /**
   * Add "mat-column-" prefix in addition to "cdk-column-" prefix.
   * In the future, this will only add "mat-column-" and columnCssClassName
   * will change from type string[] to string.
   * @docs-private
   */
  _updateColumnCssClassName() {
    super._updateColumnCssClassName();
    this._columnCssClassName.push(`mat-column-${this.cssClassFriendlyName}`);
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatColumnDef_BaseFactory;
    return function MatColumnDef_Factory(__ngFactoryType__) {
      return (ɵMatColumnDef_BaseFactory || (ɵMatColumnDef_BaseFactory = ɵɵgetInheritedFactory(_MatColumnDef)))(__ngFactoryType__ || _MatColumnDef);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatColumnDef,
    selectors: [["", "matColumnDef", ""]],
    inputs: {
      name: [0, "matColumnDef", "name"]
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkColumnDef,
      useExisting: _MatColumnDef
    }, {
      provide: "MAT_SORT_HEADER_COLUMN_DEF",
      useExisting: _MatColumnDef
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatColumnDef, [{
    type: Directive,
    args: [{
      selector: "[matColumnDef]",
      providers: [{
        provide: CdkColumnDef,
        useExisting: MatColumnDef
      }, {
        provide: "MAT_SORT_HEADER_COLUMN_DEF",
        useExisting: MatColumnDef
      }]
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["matColumnDef"]
    }]
  });
})();
var MatHeaderCell = class _MatHeaderCell extends CdkHeaderCell {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatHeaderCell_BaseFactory;
    return function MatHeaderCell_Factory(__ngFactoryType__) {
      return (ɵMatHeaderCell_BaseFactory || (ɵMatHeaderCell_BaseFactory = ɵɵgetInheritedFactory(_MatHeaderCell)))(__ngFactoryType__ || _MatHeaderCell);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatHeaderCell,
    selectors: [["mat-header-cell"], ["th", "mat-header-cell", ""]],
    hostAttrs: ["role", "columnheader", 1, "mat-mdc-header-cell", "mdc-data-table__header-cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatHeaderCell, [{
    type: Directive,
    args: [{
      selector: "mat-header-cell, th[mat-header-cell]",
      host: {
        "class": "mat-mdc-header-cell mdc-data-table__header-cell",
        "role": "columnheader"
      }
    }]
  }], null, null);
})();
var MatFooterCell = class _MatFooterCell extends CdkFooterCell {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatFooterCell_BaseFactory;
    return function MatFooterCell_Factory(__ngFactoryType__) {
      return (ɵMatFooterCell_BaseFactory || (ɵMatFooterCell_BaseFactory = ɵɵgetInheritedFactory(_MatFooterCell)))(__ngFactoryType__ || _MatFooterCell);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatFooterCell,
    selectors: [["mat-footer-cell"], ["td", "mat-footer-cell", ""]],
    hostAttrs: [1, "mat-mdc-footer-cell", "mdc-data-table__cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatFooterCell, [{
    type: Directive,
    args: [{
      selector: "mat-footer-cell, td[mat-footer-cell]",
      host: {
        "class": "mat-mdc-footer-cell mdc-data-table__cell"
      }
    }]
  }], null, null);
})();
var MatCell = class _MatCell extends CdkCell {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatCell_BaseFactory;
    return function MatCell_Factory(__ngFactoryType__) {
      return (ɵMatCell_BaseFactory || (ɵMatCell_BaseFactory = ɵɵgetInheritedFactory(_MatCell)))(__ngFactoryType__ || _MatCell);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatCell,
    selectors: [["mat-cell"], ["td", "mat-cell", ""]],
    hostAttrs: [1, "mat-mdc-cell", "mdc-data-table__cell"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatCell, [{
    type: Directive,
    args: [{
      selector: "mat-cell, td[mat-cell]",
      host: {
        "class": "mat-mdc-cell mdc-data-table__cell"
      }
    }]
  }], null, null);
})();
var ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;
var MatHeaderRowDef = class _MatHeaderRowDef extends CdkHeaderRowDef {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatHeaderRowDef_BaseFactory;
    return function MatHeaderRowDef_Factory(__ngFactoryType__) {
      return (ɵMatHeaderRowDef_BaseFactory || (ɵMatHeaderRowDef_BaseFactory = ɵɵgetInheritedFactory(_MatHeaderRowDef)))(__ngFactoryType__ || _MatHeaderRowDef);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatHeaderRowDef,
    selectors: [["", "matHeaderRowDef", ""]],
    inputs: {
      columns: [0, "matHeaderRowDef", "columns"],
      sticky: [2, "matHeaderRowDefSticky", "sticky", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkHeaderRowDef,
      useExisting: _MatHeaderRowDef
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatHeaderRowDef, [{
    type: Directive,
    args: [{
      selector: "[matHeaderRowDef]",
      providers: [{
        provide: CdkHeaderRowDef,
        useExisting: MatHeaderRowDef
      }],
      inputs: [{
        name: "columns",
        alias: "matHeaderRowDef"
      }, {
        name: "sticky",
        alias: "matHeaderRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  }], null, null);
})();
var MatFooterRowDef = class _MatFooterRowDef extends CdkFooterRowDef {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatFooterRowDef_BaseFactory;
    return function MatFooterRowDef_Factory(__ngFactoryType__) {
      return (ɵMatFooterRowDef_BaseFactory || (ɵMatFooterRowDef_BaseFactory = ɵɵgetInheritedFactory(_MatFooterRowDef)))(__ngFactoryType__ || _MatFooterRowDef);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatFooterRowDef,
    selectors: [["", "matFooterRowDef", ""]],
    inputs: {
      columns: [0, "matFooterRowDef", "columns"],
      sticky: [2, "matFooterRowDefSticky", "sticky", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkFooterRowDef,
      useExisting: _MatFooterRowDef
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatFooterRowDef, [{
    type: Directive,
    args: [{
      selector: "[matFooterRowDef]",
      providers: [{
        provide: CdkFooterRowDef,
        useExisting: MatFooterRowDef
      }],
      inputs: [{
        name: "columns",
        alias: "matFooterRowDef"
      }, {
        name: "sticky",
        alias: "matFooterRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  }], null, null);
})();
var MatRowDef = class _MatRowDef extends CdkRowDef {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatRowDef_BaseFactory;
    return function MatRowDef_Factory(__ngFactoryType__) {
      return (ɵMatRowDef_BaseFactory || (ɵMatRowDef_BaseFactory = ɵɵgetInheritedFactory(_MatRowDef)))(__ngFactoryType__ || _MatRowDef);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatRowDef,
    selectors: [["", "matRowDef", ""]],
    inputs: {
      columns: [0, "matRowDefColumns", "columns"],
      when: [0, "matRowDefWhen", "when"]
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkRowDef,
      useExisting: _MatRowDef
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatRowDef, [{
    type: Directive,
    args: [{
      selector: "[matRowDef]",
      providers: [{
        provide: CdkRowDef,
        useExisting: MatRowDef
      }],
      inputs: [{
        name: "columns",
        alias: "matRowDefColumns"
      }, {
        name: "when",
        alias: "matRowDefWhen"
      }]
    }]
  }], null, null);
})();
var MatHeaderRow = class _MatHeaderRow extends CdkHeaderRow {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatHeaderRow_BaseFactory;
    return function MatHeaderRow_Factory(__ngFactoryType__) {
      return (ɵMatHeaderRow_BaseFactory || (ɵMatHeaderRow_BaseFactory = ɵɵgetInheritedFactory(_MatHeaderRow)))(__ngFactoryType__ || _MatHeaderRow);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatHeaderRow,
    selectors: [["mat-header-row"], ["tr", "mat-header-row", ""]],
    hostAttrs: ["role", "row", 1, "mat-mdc-header-row", "mdc-data-table__header-row"],
    exportAs: ["matHeaderRow"],
    features: [ɵɵProvidersFeature([{
      provide: CdkHeaderRow,
      useExisting: _MatHeaderRow
    }]), ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function MatHeaderRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatHeaderRow, [{
    type: Component,
    args: [{
      selector: "mat-header-row, tr[mat-header-row]",
      template: ROW_TEMPLATE,
      host: {
        "class": "mat-mdc-header-row mdc-data-table__header-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      exportAs: "matHeaderRow",
      providers: [{
        provide: CdkHeaderRow,
        useExisting: MatHeaderRow
      }],
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var MatFooterRow = class _MatFooterRow extends CdkFooterRow {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatFooterRow_BaseFactory;
    return function MatFooterRow_Factory(__ngFactoryType__) {
      return (ɵMatFooterRow_BaseFactory || (ɵMatFooterRow_BaseFactory = ɵɵgetInheritedFactory(_MatFooterRow)))(__ngFactoryType__ || _MatFooterRow);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatFooterRow,
    selectors: [["mat-footer-row"], ["tr", "mat-footer-row", ""]],
    hostAttrs: ["role", "row", 1, "mat-mdc-footer-row", "mdc-data-table__row"],
    exportAs: ["matFooterRow"],
    features: [ɵɵProvidersFeature([{
      provide: CdkFooterRow,
      useExisting: _MatFooterRow
    }]), ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function MatFooterRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatFooterRow, [{
    type: Component,
    args: [{
      selector: "mat-footer-row, tr[mat-footer-row]",
      template: ROW_TEMPLATE,
      host: {
        "class": "mat-mdc-footer-row mdc-data-table__row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      exportAs: "matFooterRow",
      providers: [{
        provide: CdkFooterRow,
        useExisting: MatFooterRow
      }],
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var MatRow = class _MatRow extends CdkRow {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatRow_BaseFactory;
    return function MatRow_Factory(__ngFactoryType__) {
      return (ɵMatRow_BaseFactory || (ɵMatRow_BaseFactory = ɵɵgetInheritedFactory(_MatRow)))(__ngFactoryType__ || _MatRow);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatRow,
    selectors: [["mat-row"], ["tr", "mat-row", ""]],
    hostAttrs: ["role", "row", 1, "mat-mdc-row", "mdc-data-table__row"],
    exportAs: ["matRow"],
    features: [ɵɵProvidersFeature([{
      provide: CdkRow,
      useExisting: _MatRow
    }]), ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 0,
    consts: [["cdkCellOutlet", ""]],
    template: function MatRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkCellOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatRow, [{
    type: Component,
    args: [{
      selector: "mat-row, tr[mat-row]",
      template: ROW_TEMPLATE,
      host: {
        "class": "mat-mdc-row mdc-data-table__row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      exportAs: "matRow",
      providers: [{
        provide: CdkRow,
        useExisting: MatRow
      }],
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var MatNoDataRow = class _MatNoDataRow extends CdkNoDataRow {
  _contentClassName = "mat-mdc-no-data-row";
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatNoDataRow_BaseFactory;
    return function MatNoDataRow_Factory(__ngFactoryType__) {
      return (ɵMatNoDataRow_BaseFactory || (ɵMatNoDataRow_BaseFactory = ɵɵgetInheritedFactory(_MatNoDataRow)))(__ngFactoryType__ || _MatNoDataRow);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatNoDataRow,
    selectors: [["ng-template", "matNoDataRow", ""]],
    features: [ɵɵProvidersFeature([{
      provide: CdkNoDataRow,
      useExisting: _MatNoDataRow
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatNoDataRow, [{
    type: Directive,
    args: [{
      selector: "ng-template[matNoDataRow]",
      providers: [{
        provide: CdkNoDataRow,
        useExisting: MatNoDataRow
      }]
    }]
  }], null, null);
})();
var MatTextColumn = class _MatTextColumn extends CdkTextColumn {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatTextColumn_BaseFactory;
    return function MatTextColumn_Factory(__ngFactoryType__) {
      return (ɵMatTextColumn_BaseFactory || (ɵMatTextColumn_BaseFactory = ɵɵgetInheritedFactory(_MatTextColumn)))(__ngFactoryType__ || _MatTextColumn);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatTextColumn,
    selectors: [["mat-text-column"]],
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 0,
    consts: [["matColumnDef", ""], ["mat-header-cell", "", 3, "text-align", 4, "matHeaderCellDef"], ["mat-cell", "", 3, "text-align", 4, "matCellDef"], ["mat-header-cell", ""], ["mat-cell", ""]],
    template: function MatTextColumn_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 0);
        ɵɵtemplate(1, MatTextColumn_th_1_Template, 2, 3, "th", 1)(2, MatTextColumn_td_2_Template, 2, 3, "td", 2);
        ɵɵelementContainerEnd();
      }
    },
    dependencies: [MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTextColumn, [{
    type: Component,
    args: [{
      selector: "mat-text-column",
      template: `
    <ng-container matColumnDef>
      <th mat-header-cell *matHeaderCellDef [style.text-align]="justify">
        {{headerText}}
      </th>
      <td mat-cell *matCellDef="let data" [style.text-align]="justify">
        {{dataAccessor(data, name)}}
      </td>
    </ng-container>
  `,
      encapsulation: ViewEncapsulation.None,
      // Change detection is intentionally not set to OnPush. This component's template will be provided
      // to the table to be inserted into its view. This is problematic when change detection runs since
      // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
      // mean's the template in the table's view will not have the updated value (and in fact will cause
      // an ExpressionChangedAfterItHasBeenCheckedError).
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      imports: [MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell]
    }]
  }], null, null);
})();
var EXPORTED_DECLARATIONS2 = [
// Table
MatTable, MatRecycleRows,
// Template defs
MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatFooterCellDef, MatFooterRowDef,
// Cell directives
MatHeaderCell, MatCell, MatFooterCell,
// Row directives
MatHeaderRow, MatRow, MatFooterRow, MatNoDataRow, MatTextColumn];
var MatTableModule = class _MatTableModule {
  static ɵfac = function MatTableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatTableModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatTableModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [MatCommonModule, CdkTableModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTableModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, CdkTableModule, ...EXPORTED_DECLARATIONS2],
      exports: [MatCommonModule, EXPORTED_DECLARATIONS2]
    }]
  }], null, null);
})();
var MAX_SAFE_INTEGER = 9007199254740991;
var MatTableDataSource = class extends DataSource {
  /** Stream that emits when a new data array is set on the data source. */
  _data;
  /** Stream emitting render data to the table (depends on ordered data changes). */
  _renderData = new BehaviorSubject([]);
  /** Stream that emits when a new filter string is set on the data source. */
  _filter = new BehaviorSubject("");
  /** Used to react to internal changes of the paginator that are made by the data source itself. */
  _internalPageChanges = new Subject();
  /**
   * Subscription to the changes that should trigger an update to the table's rendered rows, such
   * as filtering, sorting, pagination, or base data changes.
   */
  _renderChangesSubscription = null;
  /**
   * The filtered set of data that has been matched by the filter string, or all the data if there
   * is no filter. Useful for knowing the set of data the table represents.
   * For example, a 'selectAll()' function would likely want to select the set of filtered data
   * shown to the user rather than all the data.
   */
  filteredData;
  /** Array of data that should be rendered by the table, where each object represents one row. */
  get data() {
    return this._data.value;
  }
  set data(data) {
    data = Array.isArray(data) ? data : [];
    this._data.next(data);
    if (!this._renderChangesSubscription) {
      this._filterData(data);
    }
  }
  /**
   * Filter term that should be used to filter out objects from the data array. To override how
   * data objects match to this filter string, provide a custom function for filterPredicate.
   */
  get filter() {
    return this._filter.value;
  }
  set filter(filter2) {
    this._filter.next(filter2);
    if (!this._renderChangesSubscription) {
      this._filterData(this.data);
    }
  }
  /**
   * Instance of the MatSort directive used by the table to control its sorting. Sort changes
   * emitted by the MatSort will trigger an update to the table's rendered data.
   */
  get sort() {
    return this._sort;
  }
  set sort(sort) {
    this._sort = sort;
    this._updateChangeSubscription();
  }
  _sort;
  /**
   * Instance of the paginator component used by the table to control what page of the data is
   * displayed. Page changes emitted by the paginator will trigger an update to the
   * table's rendered data.
   *
   * Note that the data source uses the paginator's properties to calculate which page of data
   * should be displayed. If the paginator receives its properties as template inputs,
   * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
   * initialized before assigning it to this data source.
   */
  get paginator() {
    return this._paginator;
  }
  set paginator(paginator) {
    this._paginator = paginator;
    this._updateChangeSubscription();
  }
  _paginator;
  /**
   * Data accessor function that is used for accessing data properties for sorting through
   * the default sortData function.
   * This default function assumes that the sort header IDs (which defaults to the column name)
   * matches the data's properties (e.g. column Xyz represents data['Xyz']).
   * May be set to a custom function for different behavior.
   * @param data Data object that is being accessed.
   * @param sortHeaderId The name of the column that represents the data.
   */
  sortingDataAccessor = (data, sortHeaderId) => {
    const value = data[sortHeaderId];
    if (_isNumberValue(value)) {
      const numberValue = Number(value);
      return numberValue < MAX_SAFE_INTEGER ? numberValue : value;
    }
    return value;
  };
  /**
   * Gets a sorted copy of the data array based on the state of the MatSort. Called
   * after changes are made to the filtered data or when sort changes are emitted from MatSort.
   * By default, the function retrieves the active sort and its direction and compares data
   * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation
   * of data ordering.
   * @param data The array of data that should be sorted.
   * @param sort The connected MatSort that holds the current sort state.
   */
  sortData = (data, sort) => {
    const active = sort.active;
    const direction = sort.direction;
    if (!active || direction == "") {
      return data;
    }
    return data.sort((a2, b2) => {
      let valueA = this.sortingDataAccessor(a2, active);
      let valueB = this.sortingDataAccessor(b2, active);
      const valueAType = typeof valueA;
      const valueBType = typeof valueB;
      if (valueAType !== valueBType) {
        if (valueAType === "number") {
          valueA += "";
        }
        if (valueBType === "number") {
          valueB += "";
        }
      }
      let comparatorResult = 0;
      if (valueA != null && valueB != null) {
        if (valueA > valueB) {
          comparatorResult = 1;
        } else if (valueA < valueB) {
          comparatorResult = -1;
        }
      } else if (valueA != null) {
        comparatorResult = 1;
      } else if (valueB != null) {
        comparatorResult = -1;
      }
      return comparatorResult * (direction == "asc" ? 1 : -1);
    });
  };
  /**
   * Checks if a data object matches the data source's filter string. By default, each data object
   * is converted to a string of its properties and returns true if the filter has
   * at least one occurrence in that string. By default, the filter string has its whitespace
   * trimmed and the match is case-insensitive. May be overridden for a custom implementation of
   * filter matching.
   * @param data Data object used to check against the filter.
   * @param filter Filter string that has been set on the data source.
   * @returns Whether the filter matches against the data
   */
  filterPredicate = (data, filter2) => {
    const transformedFilter = filter2.trim().toLowerCase();
    return Object.values(data).some(value => `${value}`.toLowerCase().includes(transformedFilter));
  };
  constructor(initialData = []) {
    super();
    this._data = new BehaviorSubject(initialData);
    this._updateChangeSubscription();
  }
  /**
   * Subscribe to changes that should trigger an update to the table's rendered rows. When the
   * changes occur, process the current state of the filter, sort, and pagination along with
   * the provided base data and send it to the table for rendering.
   */
  _updateChangeSubscription() {
    const sortChange = this._sort ? merge(this._sort.sortChange, this._sort.initialized) : of(null);
    const pageChange = this._paginator ? merge(this._paginator.page, this._internalPageChanges, this._paginator.initialized) : of(null);
    const dataStream = this._data;
    const filteredData = combineLatest([dataStream, this._filter]).pipe(map(([data]) => this._filterData(data)));
    const orderedData = combineLatest([filteredData, sortChange]).pipe(map(([data]) => this._orderData(data)));
    const paginatedData = combineLatest([orderedData, pageChange]).pipe(map(([data]) => this._pageData(data)));
    this._renderChangesSubscription?.unsubscribe();
    this._renderChangesSubscription = paginatedData.subscribe(data => this._renderData.next(data));
  }
  /**
   * Returns a filtered data array where each filter object contains the filter string within
   * the result of the filterPredicate function. If no filter is set, returns the data array
   * as provided.
   */
  _filterData(data) {
    this.filteredData = this.filter == null || this.filter === "" ? data : data.filter(obj => this.filterPredicate(obj, this.filter));
    if (this.paginator) {
      this._updatePaginator(this.filteredData.length);
    }
    return this.filteredData;
  }
  /**
   * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the
   * data array as provided. Uses the default data accessor for data lookup, unless a
   * sortDataAccessor function is defined.
   */
  _orderData(data) {
    if (!this.sort) {
      return data;
    }
    return this.sortData(data.slice(), this.sort);
  }
  /**
   * Returns a paged slice of the provided data array according to the provided paginator's page
   * index and length. If there is no paginator provided, returns the data array as provided.
   */
  _pageData(data) {
    if (!this.paginator) {
      return data;
    }
    const startIndex = this.paginator.pageIndex * this.paginator.pageSize;
    return data.slice(startIndex, startIndex + this.paginator.pageSize);
  }
  /**
   * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
   * index does not exceed the paginator's last page. Values are changed in a resolved promise to
   * guard against making property changes within a round of change detection.
   */
  _updatePaginator(filteredDataLength) {
    Promise.resolve().then(() => {
      const paginator = this.paginator;
      if (!paginator) {
        return;
      }
      paginator.length = filteredDataLength;
      if (paginator.pageIndex > 0) {
        const lastPageIndex = Math.ceil(paginator.length / paginator.pageSize) - 1 || 0;
        const newPageIndex = Math.min(paginator.pageIndex, lastPageIndex);
        if (newPageIndex !== paginator.pageIndex) {
          paginator.pageIndex = newPageIndex;
          this._internalPageChanges.next();
        }
      }
    });
  }
  /**
   * Used by the MatTable. Called when it connects to the data source.
   * @docs-private
   */
  connect() {
    if (!this._renderChangesSubscription) {
      this._updateChangeSubscription();
    }
    return this._renderData;
  }
  /**
   * Used by the MatTable. Called when it disconnects from the data source.
   * @docs-private
   */
  disconnect() {
    this._renderChangesSubscription?.unsubscribe();
    this._renderChangesSubscription = null;
  }
};

// libs/exercises/src/lib/services/exercises.service.ts
var ExercisesService = class _ExercisesService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLExercises = environment.apiURL + "exercises";
    this.apiURLMuscles = environment.apiURL + "muscles";
    this.apiURLBodyAreas = environment.apiURL + "bodyareas";
    this.apiURLMovements = environment.apiURL + "movements";
    this.apiURLStartingPositions = environment.apiURL + "startingpositions";
    this.apiURLEquipments = environment.apiURL + "equipments";
  }
  getExercises() {
    return this.http.get(this.apiURLExercises);
  }
  getExercise(exerciseId) {
    return this.http.get(`${this.apiURLExercises}/${exerciseId}`);
  }
  createExercise(exerciseData) {
    return this.http.post(this.apiURLExercises, exerciseData);
  }
  updateExercise(exerciseData, exerciseId) {
    return this.http.put(`${this.apiURLExercises}/${exerciseId}`, exerciseData);
  }
  deleteExercise(exerciseId) {
    return this.http.delete(`${this.apiURLExercises}/${exerciseId}`);
  }
  getMuscles() {
    return this.http.get(this.apiURLMuscles);
  }
  createMuscle(muscle) {
    return this.http.post(this.apiURLMuscles, muscle);
  }
  getBodyAreas() {
    return this.http.get(this.apiURLBodyAreas);
  }
  createBodyArea(bodyArea) {
    return this.http.post(this.apiURLBodyAreas, bodyArea);
  }
  getMovements() {
    return this.http.get(this.apiURLMovements);
  }
  createMovement(movement) {
    return this.http.post(this.apiURLMovements, movement);
  }
  getStartingPositions() {
    return this.http.get(this.apiURLStartingPositions);
  }
  createStartingPosition(startingPosition) {
    return this.http.post(this.apiURLStartingPositions, startingPosition);
  }
  getEquipments() {
    return this.http.get(this.apiURLEquipments);
  }
  createEquipment(equipment) {
    return this.http.post(this.apiURLEquipments, equipment);
  }
  static {
    this.ɵfac = function ExercisesService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ExercisesService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ExercisesService,
      factory: _ExercisesService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/categories/muscles.service.ts
var MusclesService = class _MusclesService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLMuscles = environment.apiURL + "muscles";
  }
  getMuscles() {
    return this.http.get(this.apiURLMuscles);
  }
  getMuscle(muscleId) {
    return this.http.get(`${this.apiURLMuscles}/${muscleId}`);
  }
  createMuscle(muscle) {
    return this.http.post(this.apiURLMuscles, muscle);
  }
  updateMuscle(muscle) {
    return this.http.put(`${this.apiURLMuscles}/${muscle.id}`, muscle);
  }
  deleteMuscle(muscleId) {
    return this.http.delete(`${this.apiURLMuscles}/${muscleId}`);
  }
  static {
    this.ɵfac = function MusclesService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MusclesService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _MusclesService,
      factory: _MusclesService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/categories/bodyareas.service.ts
var BodyAreasService = class _BodyAreasService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLBodyAreas = environment.apiURL + "bodyareas";
  }
  getBodyAreas() {
    return this.http.get(this.apiURLBodyAreas);
  }
  getBodyArea(bodyAreaId) {
    return this.http.get(`${this.apiURLBodyAreas}/${bodyAreaId}`);
  }
  createBodyArea(bodyArea) {
    return this.http.post(this.apiURLBodyAreas, bodyArea);
  }
  updateBodyArea(bodyArea) {
    return this.http.put(`${this.apiURLBodyAreas}/${bodyArea.id}`, bodyArea);
  }
  deleteBodyArea(bodyAreaId) {
    return this.http.delete(`${this.apiURLBodyAreas}/${bodyAreaId}`);
  }
  static {
    this.ɵfac = function BodyAreasService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BodyAreasService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _BodyAreasService,
      factory: _BodyAreasService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/categories/movements.service.ts
var MovementsService = class _MovementsService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLMovements = environment.apiURL + "movements";
  }
  getMovements() {
    return this.http.get(this.apiURLMovements);
  }
  getMovement(movementId) {
    return this.http.get(`${this.apiURLMovements}/${movementId}`);
  }
  createMovement(movement) {
    return this.http.post(this.apiURLMovements, movement);
  }
  updateMovement(movement) {
    return this.http.put(`${this.apiURLMovements}/${movement.id}`, movement);
  }
  deleteMovement(movementId) {
    return this.http.delete(`${this.apiURLMovements}/${movementId}`);
  }
  static {
    this.ɵfac = function MovementsService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MovementsService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _MovementsService,
      factory: _MovementsService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/categories/starting-positions.service.ts
var StartingPositionsService = class _StartingPositionsService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLStartingPositions = environment.apiURL + "startingpositions";
  }
  getStartingPositions() {
    return this.http.get(this.apiURLStartingPositions);
  }
  getStartingPosition(startingPositionId) {
    return this.http.get(`${this.apiURLStartingPositions}/${startingPositionId}`);
  }
  createStartingPosition(startingPosition) {
    return this.http.post(this.apiURLStartingPositions, startingPosition);
  }
  updateStartingPosition(startingPosition) {
    return this.http.put(`${this.apiURLStartingPositions}/${startingPosition.id}`, startingPosition);
  }
  deleteStartingPosition(startingPositionId) {
    return this.http.delete(`${this.apiURLStartingPositions}/${startingPositionId}`);
  }
  static {
    this.ɵfac = function StartingPositionsService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _StartingPositionsService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _StartingPositionsService,
      factory: _StartingPositionsService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/categories/equipment.service.ts
var EquipmentService = class _EquipmentService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLEquipments = environment.apiURL + "equipments";
  }
  getEquipments() {
    return this.http.get(this.apiURLEquipments);
  }
  getEquipment(equipmentId) {
    return this.http.get(`${this.apiURLEquipments}/${equipmentId}`);
  }
  createEquipment(equipment) {
    return this.http.post(this.apiURLEquipments, equipment);
  }
  updateEquipment(equipment) {
    return this.http.put(`${this.apiURLEquipments}/${equipment.id}`, equipment);
  }
  deleteEquipment(equipmentId) {
    return this.http.delete(`${this.apiURLEquipments}/${equipmentId}`);
  }
  static {
    this.ɵfac = function EquipmentService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _EquipmentService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _EquipmentService,
      factory: _EquipmentService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/pipes/language-name.pipe.ts
var LanguageNamePipe = class _LanguageNamePipe {
  transform(languageCode) {
    const languageMap = {
      en: "English",
      de: "Deutsch",
      sr: "Srpski"
    };
    return languageMap[languageCode] || languageCode;
  }
  static {
    this.ɵfac = function LanguageNamePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LanguageNamePipe)();
    };
  }
  static {
    this.ɵpipe = /* @__PURE__ */ɵɵdefinePipe({
      name: "languageName",
      type: _LanguageNamePipe,
      pure: true
    });
  }
};

// libs/exercises/src/lib/services/search.service.ts
var SearchService = class _SearchService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLSearch = environment.apiURL + "search";
  }
  searchExercises(searchTerm, filters, langCode) {
    const requstBody = {
      searchTerm,
      filters
    };
    const params = {
      langCode
    };
    return this.http.post(this.apiURLSearch, requstBody, {
      params
    });
  }
  static {
    this.ɵfac = function SearchService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SearchService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _SearchService,
      factory: _SearchService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/share-data.service.ts
var ShareDataService = class _ShareDataService {
  // private data3$ = new BehaviorSubject<boolean>(false);
  // toggleDrawerSignal$: Observable<boolean> = this.data3$.asObservable();
  constructor() {
    this.data$ = new BehaviorSubject([]);
    this.searchedData$ = this.data$.asObservable();
    this.data2$ = new BehaviorSubject([]);
    this.filterData$ = this.data2$.asObservable();
  }
  updateSearchResults(data) {
    this.data$.next(data);
  }
  updateFilterResults(data2) {
    this.data2$.next(data2);
  }
  static {
    this.ɵfac = function ShareDataService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ShareDataService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ShareDataService,
      factory: _ShareDataService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/add-remove-data.service.ts
var AddRemoveDataService = class _AddRemoveDataService {
  constructor() {
    this.sharedDataService = inject(ShareDataService);
    this.dataSignal = signal([]);
  }
  addDataItem(name, value, localeName) {
    const itemIndex = this.dataSignal().findIndex(item => item.name === name);
    console.log(name, value);
    if (itemIndex !== -1) {
      this.dataSignal.update(data => {
        const updatedData = [...data];
        updatedData[itemIndex].values.push(value);
        updatedData[itemIndex].localeNames.push(localeName);
        console.log("when updateng: ", data === updatedData);
        return updatedData;
      });
      console.log(this.dataSignal());
    } else {
      this.dataSignal.update(data => {
        const updatedData = [...data];
        console.log("when adding new: ", data === updatedData);
        updatedData.push({
          name,
          values: [value],
          localeNames: [localeName]
        });
        return updatedData;
      });
      console.log(this.dataSignal());
    }
    this.sharedDataService.updateFilterResults(this.dataSignal());
  }
  removeDataItem(name, value, localeName) {
    const itemIndex = this.dataSignal().findIndex(item => item.name === name);
    if (itemIndex !== -1) {
      this.dataSignal.update(data => {
        const updatedData = [...data];
        console.log("this is updated before removal: ", updatedData);
        updatedData[itemIndex].values = updatedData[itemIndex].values.filter(v2 => v2 !== value);
        console.log("this is updated after removal: ", updatedData);
        updatedData[itemIndex].localeNames = updatedData[itemIndex].localeNames.filter(v2 => v2 !== localeName);
        return updatedData;
      });
      if (this.dataSignal()[itemIndex].values.length === 0) {
        this.dataSignal.update(data => {
          const updatedData = [...data];
          updatedData.splice(itemIndex, 1);
          return updatedData;
        });
      }
    }
    this.sharedDataService.updateFilterResults(this.dataSignal());
  }
  // getData(): DataItem[] {
  //   return this.data;
  // }
  resetAll() {
    this.dataSignal.set([]);
    this.sharedDataService.updateFilterResults(this.dataSignal());
  }
  static {
    this.ɵfac = function AddRemoveDataService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AddRemoveDataService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _AddRemoveDataService,
      factory: _AddRemoveDataService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/share-state.service.ts
var ShareStateService = class _ShareStateService {
  constructor() {
    this.drawerSignal = signal(false);
    this.listOption = signal("all");
    this.isFetchingData = signal(false);
    this.isLoading = signal(false);
  }
  static {
    this.ɵfac = function ShareStateService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ShareStateService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ShareStateService,
      factory: _ShareStateService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/selected-exercises.service.ts
var SelectedExercisesService = class _SelectedExercisesService {
  constructor() {
    this.selectedExercises = signal([]);
  }
  // Add exercise to selected list
  addToSelected(exercise) {
    console.log(exercise);
    const index = this.selectedExercises().findIndex(selectedExercise => selectedExercise.id === exercise.id);
    if (index === -1) {
      exercise.isSelected = true;
      exercise.reps = 10;
      exercise.sets = 3;
      exercise.pause = "1min";
      exercise.weight = "";
      this.selectedExercises.update(selectedExercises => [...selectedExercises, exercise]);
    }
  }
  removeFromSelected(exercise) {
    exercise.isSelected = false;
    this.selectedExercises.update(selectedExercises => selectedExercises.filter(selectedExercise => selectedExercise.id !== exercise.id));
  }
  static {
    this.ɵfac = function SelectedExercisesService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SelectedExercisesService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _SelectedExercisesService,
      factory: _SelectedExercisesService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/programs/program-data.service.ts
var ProgramDataService = class _ProgramDataService {
  constructor() {
    this.programData = signal({
      name: "",
      notes: ""
    });
    this.programId = signal("");
    this.programName = signal("");
  }
  static {
    this.ɵfac = function ProgramDataService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ProgramDataService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ProgramDataService,
      factory: _ProgramDataService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/programs/program-clients-data.service.ts
var ProgramClientsDataService = class _ProgramClientsDataService {
  constructor() {
    this.programClientsData = signal({
      selectedClients: [],
      dateRange: ""
    });
  }
  static {
    this.ɵfac = function ProgramClientsDataService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ProgramClientsDataService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ProgramClientsDataService,
      factory: _ProgramClientsDataService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/programs/programs.service.ts
var ProgramsService = class _ProgramsService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLPrograms = environment.apiURL + "programs";
    this.isAdminProgram = signal(false);
  }
  getPrograms() {
    return this.http.get(this.apiURLPrograms);
  }
  getProgram(programId) {
    return this.http.get(`${this.apiURLPrograms}/${programId}`);
  }
  createProgram(programData) {
    return this.http.post(this.apiURLPrograms, programData);
  }
  updateProgram(programData, programId) {
    return this.http.put(`${this.apiURLPrograms}/${programId}`, programData);
  }
  deleteProgram(programId) {
    return this.http.delete(`${this.apiURLPrograms}/${programId}`);
  }
  static {
    this.ɵfac = function ProgramsService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ProgramsService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ProgramsService,
      factory: _ProgramsService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/programs/isClientValid.service.ts
var IsClientValidService = class _IsClientValidService {
  constructor() {
    this.isClientValid = signal(false);
  }
  static {
    this.ɵfac = function IsClientValidService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsClientValidService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _IsClientValidService,
      factory: _IsClientValidService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/clients/clients.service.ts
var ClientsService = class _ClientsService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLClients = environment.apiURL + "clients";
  }
  getClients() {
    return this.http.get(this.apiURLClients);
  }
  getClientsBasic() {
    return this.http.get(`${this.apiURLClients}/basic`);
  }
  getClient(clientId) {
    return this.http.get(`${this.apiURLClients}/${clientId}`);
  }
  createClient(clientData) {
    return this.http.post(this.apiURLClients, clientData);
  }
  updateClient(clientData, clientId) {
    return this.http.put(`${this.apiURLClients}/${clientId}`, clientData);
  }
  deleteClient(clientId) {
    return this.http.delete(`${this.apiURLClients}/${clientId}`);
  }
  getClientProgram(programId) {
    return this.http.get(`${this.apiURLClients}/program/${programId}`);
  }
  getAllClientsPrograms() {
    return this.http.get(`${this.apiURLClients}/programs/all`);
  }
  getAllClientsProgramsBasic() {
    return this.http.get(`${this.apiURLClients}/programs/all/basic`);
  }
  updateClientProgram(clientId, updatedProgram, programPosition) {
    const positionParam = programPosition;
    return this.http.put(`${this.apiURLClients}/program/${clientId}?pos=${positionParam}`, updatedProgram);
  }
  deleteClientProgram(clientId, programPosition) {
    const positionParam = programPosition;
    return this.http.delete(`${this.apiURLClients}/program/${clientId}?pos=${positionParam}`);
  }
  static {
    this.ɵfac = function ClientsService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ClientsService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ClientsService,
      factory: _ClientsService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/clients/share-clients-data.service.ts
var ShareClientsDataService = class _ShareClientsDataService {
  constructor() {
    this.clients = signal([]);
    this.isClientProgram = signal(false);
    this.clientInfo = signal({
      clientId: "",
      clientName: "",
      programPosition: 0,
      programId: "",
      programName: "",
      dateRange: {
        start: "",
        end: ""
      }
    });
    this.reuseProgram = signal(false);
    this.isBrandNewClientsProgram = signal(false);
  }
  static {
    this.ɵfac = function ShareClientsDataService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ShareClientsDataService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ShareClientsDataService,
      factory: _ShareClientsDataService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/exercises/src/lib/services/drop-list-transfer-item.service.ts
var DropListTransferItemService = class _DropListTransferItemService {
  constructor() {
    this.transferringItem = signal(void 0);
  }
  static {
    this.ɵfac = function DropListTransferItemService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DropListTransferItemService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _DropListTransferItemService,
      factory: _DropListTransferItemService.ɵfac,
      providedIn: "root"
    });
  }
};

// node_modules/@angular/cdk/fesm2022/dialog.mjs
function CdkDialogContainer_ng_template_0_Template(rf, ctx) {}
var DialogConfig = class {
  /**
   * Where the attached component should live in Angular's *logical* component tree.
   * This affects what is available for injection and the change detection order for the
   * component instantiated inside of the dialog. This does not affect where the dialog
   * content will be rendered.
   */
  viewContainerRef;
  /**
   * Injector used for the instantiation of the component to be attached. If provided,
   * takes precedence over the injector indirectly provided by `ViewContainerRef`.
   */
  injector;
  /** ID for the dialog. If omitted, a unique one will be generated. */
  id;
  /** The ARIA role of the dialog element. */
  role = "dialog";
  /** Optional CSS class or classes applied to the overlay panel. */
  panelClass = "";
  /** Whether the dialog has a backdrop. */
  hasBackdrop = true;
  /** Optional CSS class or classes applied to the overlay backdrop. */
  backdropClass = "";
  /** Whether the dialog closes with the escape key or pointer events outside the panel element. */
  disableClose = false;
  /** Width of the dialog. */
  width = "";
  /** Height of the dialog. */
  height = "";
  /** Min-width of the dialog. If a number is provided, assumes pixel units. */
  minWidth;
  /** Min-height of the dialog. If a number is provided, assumes pixel units. */
  minHeight;
  /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */
  maxWidth;
  /** Max-height of the dialog. If a number is provided, assumes pixel units. */
  maxHeight;
  /** Strategy to use when positioning the dialog. Defaults to centering it on the page. */
  positionStrategy;
  /** Data being injected into the child component. */
  data = null;
  /** Layout direction for the dialog's content. */
  direction;
  /** ID of the element that describes the dialog. */
  ariaDescribedBy = null;
  /** ID of the element that labels the dialog. */
  ariaLabelledBy = null;
  /** Dialog label applied via `aria-label` */
  ariaLabel = null;
  /**
   * Whether this is a modal dialog. Used to set the `aria-modal` attribute. Off by default,
   * because it can interfere with other overlay-based components (e.g. `mat-select`) and because
   * it is redundant since the dialog marks all outside content as `aria-hidden` anyway.
   */
  ariaModal = false;
  /**
   * Where the dialog should focus on open.
   * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or
   * AutoFocusTarget instead.
   */
  autoFocus = "first-tabbable";
  /**
   * Whether the dialog should restore focus to the previously-focused element upon closing.
   * Has the following behavior based on the type that is passed in:
   * - `boolean` - when true, will return focus to the element that was focused before the dialog
   *    was opened, otherwise won't restore focus at all.
   * - `string` - focus will be restored to the first element that matches the CSS selector.
   * - `HTMLElement` - focus will be restored to the specific element.
   */
  restoreFocus = true;
  /**
   * Scroll strategy to be used for the dialog. This determines how
   * the dialog responds to scrolling underneath the panel element.
   */
  scrollStrategy;
  /**
   * Whether the dialog should close when the user navigates backwards or forwards through browser
   * history. This does not apply to navigation via anchor element unless using URL-hash based
   * routing (`HashLocationStrategy` in the Angular router).
   */
  closeOnNavigation = true;
  /**
   * Whether the dialog should close when the dialog service is destroyed. This is useful if
   * another service is wrapping the dialog and is managing the destruction instead.
   */
  closeOnDestroy = true;
  /**
   * Whether the dialog should close when the underlying overlay is detached. This is useful if
   * another service is wrapping the dialog and is managing the destruction instead. E.g. an
   * external detachment can happen as a result of a scroll strategy triggering it or when the
   * browser location changes.
   */
  closeOnOverlayDetachments = true;
  /**
   * Alternate `ComponentFactoryResolver` to use when resolving the associated component.
   * @deprecated No longer used. Will be removed.
   * @breaking-change 20.0.0
   */
  componentFactoryResolver;
  /**
   * Providers that will be exposed to the contents of the dialog. Can also
   * be provided as a function in order to generate the providers lazily.
   */
  providers;
  /**
   * Component into which the dialog content will be rendered. Defaults to `CdkDialogContainer`.
   * A configuration object can be passed in to customize the providers that will be exposed
   * to the dialog container.
   */
  container;
  /**
   * Context that will be passed to template-based dialogs.
   * A function can be passed in to resolve the context lazily.
   */
  templateContext;
};
function throwDialogContentAlreadyAttachedError() {
  throw Error("Attempting to attach dialog content after content is already attached");
}
var CdkDialogContainer = class _CdkDialogContainer extends BasePortalOutlet {
  _elementRef = inject(ElementRef);
  _focusTrapFactory = inject(FocusTrapFactory);
  _config;
  _interactivityChecker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _overlayRef = inject(OverlayRef);
  _focusMonitor = inject(FocusMonitor);
  _renderer = inject(Renderer2);
  _platform = inject(Platform);
  _document = inject(DOCUMENT, {
    optional: true
  });
  /** The portal outlet inside of this container into which the dialog content will be loaded. */
  _portalOutlet;
  /** The class that traps and manages focus within the dialog. */
  _focusTrap = null;
  /** Element that was focused before the dialog was opened. Save this to restore upon close. */
  _elementFocusedBeforeDialogWasOpened = null;
  /**
   * Type of interaction that led to the dialog being closed. This is used to determine
   * whether the focus style will be applied when returning focus to its original location
   * after the dialog is closed.
   */
  _closeInteractionType = null;
  /**
   * Queue of the IDs of the dialog's label element, based on their definition order. The first
   * ID will be used as the `aria-labelledby` value. We use a queue here to handle the case
   * where there are two or more titles in the DOM at a time and the first one is destroyed while
   * the rest are present.
   */
  _ariaLabelledByQueue = [];
  _changeDetectorRef = inject(ChangeDetectorRef);
  _injector = inject(Injector);
  _isDestroyed = false;
  constructor() {
    super();
    this._config = inject(DialogConfig, {
      optional: true
    }) || new DialogConfig();
    if (this._config.ariaLabelledBy) {
      this._ariaLabelledByQueue.push(this._config.ariaLabelledBy);
    }
  }
  _addAriaLabelledBy(id) {
    this._ariaLabelledByQueue.push(id);
    this._changeDetectorRef.markForCheck();
  }
  _removeAriaLabelledBy(id) {
    const index = this._ariaLabelledByQueue.indexOf(id);
    if (index > -1) {
      this._ariaLabelledByQueue.splice(index, 1);
      this._changeDetectorRef.markForCheck();
    }
  }
  _contentAttached() {
    this._initializeFocusTrap();
    this._handleBackdropClicks();
    this._captureInitialFocus();
  }
  /**
   * Can be used by child classes to customize the initial focus
   * capturing behavior (e.g. if it's tied to an animation).
   */
  _captureInitialFocus() {
    this._trapFocus();
  }
  ngOnDestroy() {
    this._isDestroyed = true;
    this._restoreFocus();
  }
  /**
   * Attach a ComponentPortal as content to this dialog container.
   * @param portal Portal to be attached as the dialog content.
   */
  attachComponentPortal(portal) {
    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwDialogContentAlreadyAttachedError();
    }
    const result = this._portalOutlet.attachComponentPortal(portal);
    this._contentAttached();
    return result;
  }
  /**
   * Attach a TemplatePortal as content to this dialog container.
   * @param portal Portal to be attached as the dialog content.
   */
  attachTemplatePortal(portal) {
    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwDialogContentAlreadyAttachedError();
    }
    const result = this._portalOutlet.attachTemplatePortal(portal);
    this._contentAttached();
    return result;
  }
  /**
   * Attaches a DOM portal to the dialog container.
   * @param portal Portal to be attached.
   * @deprecated To be turned into a method.
   * @breaking-change 10.0.0
   */
  attachDomPortal = portal => {
    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwDialogContentAlreadyAttachedError();
    }
    const result = this._portalOutlet.attachDomPortal(portal);
    this._contentAttached();
    return result;
  };
  // TODO(crisbeto): this shouldn't be exposed, but there are internal references to it.
  /** Captures focus if it isn't already inside the dialog. */
  _recaptureFocus() {
    if (!this._containsFocus()) {
      this._trapFocus();
    }
  }
  /**
   * Focuses the provided element. If the element is not focusable, it will add a tabIndex
   * attribute to forcefully focus it. The attribute is removed after focus is moved.
   * @param element The element to focus.
   */
  _forceFocus(element, options) {
    if (!this._interactivityChecker.isFocusable(element)) {
      element.tabIndex = -1;
      this._ngZone.runOutsideAngular(() => {
        const callback = () => {
          deregisterBlur();
          deregisterMousedown();
          element.removeAttribute("tabindex");
        };
        const deregisterBlur = this._renderer.listen(element, "blur", callback);
        const deregisterMousedown = this._renderer.listen(element, "mousedown", callback);
      });
    }
    element.focus(options);
  }
  /**
   * Focuses the first element that matches the given selector within the focus trap.
   * @param selector The CSS selector for the element to set focus to.
   */
  _focusByCssSelector(selector, options) {
    let elementToFocus = this._elementRef.nativeElement.querySelector(selector);
    if (elementToFocus) {
      this._forceFocus(elementToFocus, options);
    }
  }
  /**
   * Moves the focus inside the focus trap. When autoFocus is not set to 'dialog', if focus
   * cannot be moved then focus will go to the dialog container.
   */
  _trapFocus() {
    if (this._isDestroyed) {
      return;
    }
    afterNextRender(() => {
      const element = this._elementRef.nativeElement;
      switch (this._config.autoFocus) {
        case false:
        case "dialog":
          if (!this._containsFocus()) {
            element.focus();
          }
          break;
        case true:
        case "first-tabbable":
          const focusedSuccessfully = this._focusTrap?.focusInitialElement();
          if (!focusedSuccessfully) {
            this._focusDialogContainer();
          }
          break;
        case "first-heading":
          this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');
          break;
        default:
          this._focusByCssSelector(this._config.autoFocus);
          break;
      }
    }, {
      injector: this._injector
    });
  }
  /** Restores focus to the element that was focused before the dialog opened. */
  _restoreFocus() {
    const focusConfig = this._config.restoreFocus;
    let focusTargetElement = null;
    if (typeof focusConfig === "string") {
      focusTargetElement = this._document.querySelector(focusConfig);
    } else if (typeof focusConfig === "boolean") {
      focusTargetElement = focusConfig ? this._elementFocusedBeforeDialogWasOpened : null;
    } else if (focusConfig) {
      focusTargetElement = focusConfig;
    }
    if (this._config.restoreFocus && focusTargetElement && typeof focusTargetElement.focus === "function") {
      const activeElement = _getFocusedElementPierceShadowDom();
      const element = this._elementRef.nativeElement;
      if (!activeElement || activeElement === this._document.body || activeElement === element || element.contains(activeElement)) {
        if (this._focusMonitor) {
          this._focusMonitor.focusVia(focusTargetElement, this._closeInteractionType);
          this._closeInteractionType = null;
        } else {
          focusTargetElement.focus();
        }
      }
    }
    if (this._focusTrap) {
      this._focusTrap.destroy();
    }
  }
  /** Focuses the dialog container. */
  _focusDialogContainer() {
    if (this._elementRef.nativeElement.focus) {
      this._elementRef.nativeElement.focus();
    }
  }
  /** Returns whether focus is inside the dialog. */
  _containsFocus() {
    const element = this._elementRef.nativeElement;
    const activeElement = _getFocusedElementPierceShadowDom();
    return element === activeElement || element.contains(activeElement);
  }
  /** Sets up the focus trap. */
  _initializeFocusTrap() {
    if (this._platform.isBrowser) {
      this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
      if (this._document) {
        this._elementFocusedBeforeDialogWasOpened = _getFocusedElementPierceShadowDom();
      }
    }
  }
  /** Sets up the listener that handles clicks on the dialog backdrop. */
  _handleBackdropClicks() {
    this._overlayRef.backdropClick().subscribe(() => {
      if (this._config.disableClose) {
        this._recaptureFocus();
      }
    });
  }
  static ɵfac = function CdkDialogContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDialogContainer)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _CdkDialogContainer,
    selectors: [["cdk-dialog-container"]],
    viewQuery: function CdkDialogContainer_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(CdkPortalOutlet, 7);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._portalOutlet = _t2.first);
      }
    },
    hostAttrs: ["tabindex", "-1", 1, "cdk-dialog-container"],
    hostVars: 6,
    hostBindings: function CdkDialogContainer_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx._config.id || null)("role", ctx._config.role)("aria-modal", ctx._config.ariaModal)("aria-labelledby", ctx._config.ariaLabel ? null : ctx._ariaLabelledByQueue[0])("aria-label", ctx._config.ariaLabel)("aria-describedby", ctx._config.ariaDescribedBy || null);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 0,
    consts: [["cdkPortalOutlet", ""]],
    template: function CdkDialogContainer_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, CdkDialogContainer_ng_template_0_Template, 0, 0, "ng-template", 0);
      }
    },
    dependencies: [CdkPortalOutlet],
    styles: [".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDialogContainer, [{
    type: Component,
    args: [{
      selector: "cdk-dialog-container",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.Default,
      imports: [CdkPortalOutlet],
      host: {
        "class": "cdk-dialog-container",
        "tabindex": "-1",
        "[attr.id]": "_config.id || null",
        "[attr.role]": "_config.role",
        "[attr.aria-modal]": "_config.ariaModal",
        "[attr.aria-labelledby]": "_config.ariaLabel ? null : _ariaLabelledByQueue[0]",
        "[attr.aria-label]": "_config.ariaLabel",
        "[attr.aria-describedby]": "_config.ariaDescribedBy || null"
      },
      template: "<ng-template cdkPortalOutlet />\n",
      styles: [".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"]
    }]
  }], () => [], {
    _portalOutlet: [{
      type: ViewChild,
      args: [CdkPortalOutlet, {
        static: true
      }]
    }]
  });
})();
var DialogRef = class {
  overlayRef;
  config;
  /**
   * Instance of component opened into the dialog. Will be
   * null when the dialog is opened using a `TemplateRef`.
   */
  componentInstance;
  /**
   * `ComponentRef` of the component opened into the dialog. Will be
   * null when the dialog is opened using a `TemplateRef`.
   */
  componentRef;
  /** Instance of the container that is rendering out the dialog content. */
  containerInstance;
  /** Whether the user is allowed to close the dialog. */
  disableClose;
  /** Emits when the dialog has been closed. */
  closed = new Subject();
  /** Emits when the backdrop of the dialog is clicked. */
  backdropClick;
  /** Emits when on keyboard events within the dialog. */
  keydownEvents;
  /** Emits on pointer events that happen outside of the dialog. */
  outsidePointerEvents;
  /** Unique ID for the dialog. */
  id;
  /** Subscription to external detachments of the dialog. */
  _detachSubscription;
  constructor(overlayRef, config) {
    this.overlayRef = overlayRef;
    this.config = config;
    this.disableClose = config.disableClose;
    this.backdropClick = overlayRef.backdropClick();
    this.keydownEvents = overlayRef.keydownEvents();
    this.outsidePointerEvents = overlayRef.outsidePointerEvents();
    this.id = config.id;
    this.keydownEvents.subscribe(event => {
      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {
        event.preventDefault();
        this.close(void 0, {
          focusOrigin: "keyboard"
        });
      }
    });
    this.backdropClick.subscribe(() => {
      if (!this.disableClose) {
        this.close(void 0, {
          focusOrigin: "mouse"
        });
      }
    });
    this._detachSubscription = overlayRef.detachments().subscribe(() => {
      if (config.closeOnOverlayDetachments !== false) {
        this.close();
      }
    });
  }
  /**
   * Close the dialog.
   * @param result Optional result to return to the dialog opener.
   * @param options Additional options to customize the closing behavior.
   */
  close(result, options) {
    if (this.containerInstance) {
      const closedSubject = this.closed;
      this.containerInstance._closeInteractionType = options?.focusOrigin || "program";
      this._detachSubscription.unsubscribe();
      this.overlayRef.dispose();
      closedSubject.next(result);
      closedSubject.complete();
      this.componentInstance = this.containerInstance = null;
    }
  }
  /** Updates the position of the dialog based on the current position strategy. */
  updatePosition() {
    this.overlayRef.updatePosition();
    return this;
  }
  /**
   * Updates the dialog's width and height.
   * @param width New width of the dialog.
   * @param height New height of the dialog.
   */
  updateSize(width = "", height = "") {
    this.overlayRef.updateSize({
      width,
      height
    });
    return this;
  }
  /** Add a CSS class or an array of classes to the overlay pane. */
  addPanelClass(classes) {
    this.overlayRef.addPanelClass(classes);
    return this;
  }
  /** Remove a CSS class or an array of classes from the overlay pane. */
  removePanelClass(classes) {
    this.overlayRef.removePanelClass(classes);
    return this;
  }
};
var DIALOG_SCROLL_STRATEGY = new InjectionToken("DialogScrollStrategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.block();
  }
});
var DIALOG_DATA = new InjectionToken("DialogData");
var DEFAULT_DIALOG_CONFIG = new InjectionToken("DefaultDialogConfig");
var Dialog = class _Dialog {
  _overlay = inject(Overlay);
  _injector = inject(Injector);
  _defaultOptions = inject(DEFAULT_DIALOG_CONFIG, {
    optional: true
  });
  _parentDialog = inject(_Dialog, {
    optional: true,
    skipSelf: true
  });
  _overlayContainer = inject(OverlayContainer);
  _idGenerator = inject(_IdGenerator);
  _openDialogsAtThisLevel = [];
  _afterAllClosedAtThisLevel = new Subject();
  _afterOpenedAtThisLevel = new Subject();
  _ariaHiddenElements = /* @__PURE__ */new Map();
  _scrollStrategy = inject(DIALOG_SCROLL_STRATEGY);
  /** Keeps track of the currently-open dialogs. */
  get openDialogs() {
    return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
  }
  /** Stream that emits when a dialog has been opened. */
  get afterOpened() {
    return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
  }
  /**
   * Stream that emits when all open dialog have finished closing.
   * Will emit on subscribe if there are no open dialogs to begin with.
   */
  afterAllClosed = defer(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(startWith(void 0)));
  constructor() {}
  open(componentOrTemplateRef, config) {
    const defaults2 = this._defaultOptions || new DialogConfig();
    config = __spreadValues(__spreadValues({}, defaults2), config);
    config.id = config.id || this._idGenerator.getId("cdk-dialog-");
    if (config.id && this.getDialogById(config.id) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Dialog with id "${config.id}" exists already. The dialog id must be unique.`);
    }
    const overlayConfig = this._getOverlayConfig(config);
    const overlayRef = this._overlay.create(overlayConfig);
    const dialogRef = new DialogRef(overlayRef, config);
    const dialogContainer = this._attachContainer(overlayRef, dialogRef, config);
    dialogRef.containerInstance = dialogContainer;
    this._attachDialogContent(componentOrTemplateRef, dialogRef, dialogContainer, config);
    if (!this.openDialogs.length) {
      this._hideNonDialogContentFromAssistiveTechnology();
    }
    this.openDialogs.push(dialogRef);
    dialogRef.closed.subscribe(() => this._removeOpenDialog(dialogRef, true));
    this.afterOpened.next(dialogRef);
    return dialogRef;
  }
  /**
   * Closes all of the currently-open dialogs.
   */
  closeAll() {
    reverseForEach(this.openDialogs, dialog => dialog.close());
  }
  /**
   * Finds an open dialog by its id.
   * @param id ID to use when looking up the dialog.
   */
  getDialogById(id) {
    return this.openDialogs.find(dialog => dialog.id === id);
  }
  ngOnDestroy() {
    reverseForEach(this._openDialogsAtThisLevel, dialog => {
      if (dialog.config.closeOnDestroy === false) {
        this._removeOpenDialog(dialog, false);
      }
    });
    reverseForEach(this._openDialogsAtThisLevel, dialog => dialog.close());
    this._afterAllClosedAtThisLevel.complete();
    this._afterOpenedAtThisLevel.complete();
    this._openDialogsAtThisLevel = [];
  }
  /**
   * Creates an overlay config from a dialog config.
   * @param config The dialog configuration.
   * @returns The overlay configuration.
   */
  _getOverlayConfig(config) {
    const state2 = new OverlayConfig({
      positionStrategy: config.positionStrategy || this._overlay.position().global().centerHorizontally().centerVertically(),
      scrollStrategy: config.scrollStrategy || this._scrollStrategy(),
      panelClass: config.panelClass,
      hasBackdrop: config.hasBackdrop,
      direction: config.direction,
      minWidth: config.minWidth,
      minHeight: config.minHeight,
      maxWidth: config.maxWidth,
      maxHeight: config.maxHeight,
      width: config.width,
      height: config.height,
      disposeOnNavigation: config.closeOnNavigation
    });
    if (config.backdropClass) {
      state2.backdropClass = config.backdropClass;
    }
    return state2;
  }
  /**
   * Attaches a dialog container to a dialog's already-created overlay.
   * @param overlay Reference to the dialog's underlying overlay.
   * @param config The dialog configuration.
   * @returns A promise resolving to a ComponentRef for the attached container.
   */
  _attachContainer(overlay, dialogRef, config) {
    const userInjector = config.injector || config.viewContainerRef?.injector;
    const providers = [{
      provide: DialogConfig,
      useValue: config
    }, {
      provide: DialogRef,
      useValue: dialogRef
    }, {
      provide: OverlayRef,
      useValue: overlay
    }];
    let containerType;
    if (config.container) {
      if (typeof config.container === "function") {
        containerType = config.container;
      } else {
        containerType = config.container.type;
        providers.push(...config.container.providers(config));
      }
    } else {
      containerType = CdkDialogContainer;
    }
    const containerPortal = new ComponentPortal(containerType, config.viewContainerRef, Injector.create({
      parent: userInjector || this._injector,
      providers
    }));
    const containerRef = overlay.attach(containerPortal);
    return containerRef.instance;
  }
  /**
   * Attaches the user-provided component to the already-created dialog container.
   * @param componentOrTemplateRef The type of component being loaded into the dialog,
   *     or a TemplateRef to instantiate as the content.
   * @param dialogRef Reference to the dialog being opened.
   * @param dialogContainer Component that is going to wrap the dialog content.
   * @param config Configuration used to open the dialog.
   */
  _attachDialogContent(componentOrTemplateRef, dialogRef, dialogContainer, config) {
    if (componentOrTemplateRef instanceof TemplateRef) {
      const injector = this._createInjector(config, dialogRef, dialogContainer, void 0);
      let context = {
        $implicit: config.data,
        dialogRef
      };
      if (config.templateContext) {
        context = __spreadValues(__spreadValues({}, context), typeof config.templateContext === "function" ? config.templateContext() : config.templateContext);
      }
      dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, context, injector));
    } else {
      const injector = this._createInjector(config, dialogRef, dialogContainer, this._injector);
      const contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));
      dialogRef.componentRef = contentRef;
      dialogRef.componentInstance = contentRef.instance;
    }
  }
  /**
   * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
   * of a dialog to close itself and, optionally, to return a value.
   * @param config Config object that is used to construct the dialog.
   * @param dialogRef Reference to the dialog being opened.
   * @param dialogContainer Component that is going to wrap the dialog content.
   * @param fallbackInjector Injector to use as a fallback when a lookup fails in the custom
   * dialog injector, if the user didn't provide a custom one.
   * @returns The custom injector that can be used inside the dialog.
   */
  _createInjector(config, dialogRef, dialogContainer, fallbackInjector) {
    const userInjector = config.injector || config.viewContainerRef?.injector;
    const providers = [{
      provide: DIALOG_DATA,
      useValue: config.data
    }, {
      provide: DialogRef,
      useValue: dialogRef
    }];
    if (config.providers) {
      if (typeof config.providers === "function") {
        providers.push(...config.providers(dialogRef, config, dialogContainer));
      } else {
        providers.push(...config.providers);
      }
    }
    if (config.direction && (!userInjector || !userInjector.get(Directionality, null, {
      optional: true
    }))) {
      providers.push({
        provide: Directionality,
        useValue: {
          value: config.direction,
          change: of()
        }
      });
    }
    return Injector.create({
      parent: userInjector || fallbackInjector,
      providers
    });
  }
  /**
   * Removes a dialog from the array of open dialogs.
   * @param dialogRef Dialog to be removed.
   * @param emitEvent Whether to emit an event if this is the last dialog.
   */
  _removeOpenDialog(dialogRef, emitEvent) {
    const index = this.openDialogs.indexOf(dialogRef);
    if (index > -1) {
      this.openDialogs.splice(index, 1);
      if (!this.openDialogs.length) {
        this._ariaHiddenElements.forEach((previousValue, element) => {
          if (previousValue) {
            element.setAttribute("aria-hidden", previousValue);
          } else {
            element.removeAttribute("aria-hidden");
          }
        });
        this._ariaHiddenElements.clear();
        if (emitEvent) {
          this._getAfterAllClosed().next();
        }
      }
    }
  }
  /** Hides all of the content that isn't an overlay from assistive technology. */
  _hideNonDialogContentFromAssistiveTechnology() {
    const overlayContainer = this._overlayContainer.getContainerElement();
    if (overlayContainer.parentElement) {
      const siblings = overlayContainer.parentElement.children;
      for (let i2 = siblings.length - 1; i2 > -1; i2--) {
        const sibling = siblings[i2];
        if (sibling !== overlayContainer && sibling.nodeName !== "SCRIPT" && sibling.nodeName !== "STYLE" && !sibling.hasAttribute("aria-live")) {
          this._ariaHiddenElements.set(sibling, sibling.getAttribute("aria-hidden"));
          sibling.setAttribute("aria-hidden", "true");
        }
      }
    }
  }
  _getAfterAllClosed() {
    const parent2 = this._parentDialog;
    return parent2 ? parent2._getAfterAllClosed() : this._afterAllClosedAtThisLevel;
  }
  static ɵfac = function Dialog_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Dialog)();
  };
  static ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
    token: _Dialog,
    factory: _Dialog.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dialog, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function reverseForEach(items, callback) {
  let i2 = items.length;
  while (i2--) {
    callback(items[i2]);
  }
}
var DialogModule = class _DialogModule {
  static ɵfac = function DialogModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _DialogModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [Dialog],
    imports: [OverlayModule, PortalModule, A11yModule,
    // Re-export the PortalModule so that people extending the `CdkDialogContainer`
    // don't have to remember to import it or be faced with an unhelpful error.
    PortalModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogModule, [{
    type: NgModule,
    args: [{
      imports: [OverlayModule, PortalModule, A11yModule, CdkDialogContainer],
      exports: [
      // Re-export the PortalModule so that people extending the `CdkDialogContainer`
      // don't have to remember to import it or be faced with an unhelpful error.
      PortalModule, CdkDialogContainer],
      providers: [Dialog]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/module-b3de5709.mjs
function MatDialogContainer_ng_template_2_Template(rf, ctx) {}
var MatDialogConfig = class {
  /**
   * Where the attached component should live in Angular's *logical* component tree.
   * This affects what is available for injection and the change detection order for the
   * component instantiated inside of the dialog. This does not affect where the dialog
   * content will be rendered.
   */
  viewContainerRef;
  /**
   * Injector used for the instantiation of the component to be attached. If provided,
   * takes precedence over the injector indirectly provided by `ViewContainerRef`.
   */
  injector;
  /** ID for the dialog. If omitted, a unique one will be generated. */
  id;
  /** The ARIA role of the dialog element. */
  role = "dialog";
  /** Custom class for the overlay pane. */
  panelClass = "";
  /** Whether the dialog has a backdrop. */
  hasBackdrop = true;
  /** Custom class for the backdrop. */
  backdropClass = "";
  /** Whether the user can use escape or clicking on the backdrop to close the modal. */
  disableClose = false;
  /** Width of the dialog. */
  width = "";
  /** Height of the dialog. */
  height = "";
  /** Min-width of the dialog. If a number is provided, assumes pixel units. */
  minWidth;
  /** Min-height of the dialog. If a number is provided, assumes pixel units. */
  minHeight;
  /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */
  maxWidth;
  /** Max-height of the dialog. If a number is provided, assumes pixel units. */
  maxHeight;
  /** Position overrides. */
  position;
  /** Data being injected into the child component. */
  data = null;
  /** Layout direction for the dialog's content. */
  direction;
  /** ID of the element that describes the dialog. */
  ariaDescribedBy = null;
  /** ID of the element that labels the dialog. */
  ariaLabelledBy = null;
  /** Aria label to assign to the dialog element. */
  ariaLabel = null;
  /**
   * Whether this is a modal dialog. Used to set the `aria-modal` attribute. Off by default,
   * because it can interfere with other overlay-based components (e.g. `mat-select`) and because
   * it is redundant since the dialog marks all outside content as `aria-hidden` anyway.
   */
  ariaModal = false;
  /**
   * Where the dialog should focus on open.
   * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or
   * AutoFocusTarget instead.
   */
  autoFocus = "first-tabbable";
  /**
   * Whether the dialog should restore focus to the
   * previously-focused element, after it's closed.
   */
  restoreFocus = true;
  /** Whether to wait for the opening animation to finish before trapping focus. */
  delayFocusTrap = true;
  /** Scroll strategy to be used for the dialog. */
  scrollStrategy;
  /**
   * Whether the dialog should close when the user goes backwards/forwards in history.
   * Note that this usually doesn't include clicking on links (unless the user is using
   * the `HashLocationStrategy`).
   */
  closeOnNavigation = true;
  /**
   * Alternate `ComponentFactoryResolver` to use when resolving the associated component.
   * @deprecated No longer used. Will be removed.
   * @breaking-change 20.0.0
   */
  componentFactoryResolver;
  /**
   * Duration of the enter animation in ms.
   * Should be a number, string type is deprecated.
   * @breaking-change 17.0.0 Remove string signature.
   */
  enterAnimationDuration;
  /**
   * Duration of the exit animation in ms.
   * Should be a number, string type is deprecated.
   * @breaking-change 17.0.0 Remove string signature.
   */
  exitAnimationDuration;
};
var OPEN_CLASS = "mdc-dialog--open";
var OPENING_CLASS = "mdc-dialog--opening";
var CLOSING_CLASS = "mdc-dialog--closing";
var OPEN_ANIMATION_DURATION = 150;
var CLOSE_ANIMATION_DURATION = 75;
var MatDialogContainer = class _MatDialogContainer extends CdkDialogContainer {
  _animationMode = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  /** Emits when an animation state changes. */
  _animationStateChanged = new EventEmitter();
  /** Whether animations are enabled. */
  _animationsEnabled = this._animationMode !== "NoopAnimations";
  /** Number of actions projected in the dialog. */
  _actionSectionCount = 0;
  /** Host element of the dialog container component. */
  _hostElement = this._elementRef.nativeElement;
  /** Duration of the dialog open animation. */
  _enterAnimationDuration = this._animationsEnabled ? parseCssTime(this._config.enterAnimationDuration) ?? OPEN_ANIMATION_DURATION : 0;
  /** Duration of the dialog close animation. */
  _exitAnimationDuration = this._animationsEnabled ? parseCssTime(this._config.exitAnimationDuration) ?? CLOSE_ANIMATION_DURATION : 0;
  /** Current timer for dialog animations. */
  _animationTimer = null;
  _contentAttached() {
    super._contentAttached();
    this._startOpenAnimation();
  }
  /** Starts the dialog open animation if enabled. */
  _startOpenAnimation() {
    this._animationStateChanged.emit({
      state: "opening",
      totalTime: this._enterAnimationDuration
    });
    if (this._animationsEnabled) {
      this._hostElement.style.setProperty(TRANSITION_DURATION_PROPERTY, `${this._enterAnimationDuration}ms`);
      this._requestAnimationFrame(() => this._hostElement.classList.add(OPENING_CLASS, OPEN_CLASS));
      this._waitForAnimationToComplete(this._enterAnimationDuration, this._finishDialogOpen);
    } else {
      this._hostElement.classList.add(OPEN_CLASS);
      Promise.resolve().then(() => this._finishDialogOpen());
    }
  }
  /**
   * Starts the exit animation of the dialog if enabled. This method is
   * called by the dialog ref.
   */
  _startExitAnimation() {
    this._animationStateChanged.emit({
      state: "closing",
      totalTime: this._exitAnimationDuration
    });
    this._hostElement.classList.remove(OPEN_CLASS);
    if (this._animationsEnabled) {
      this._hostElement.style.setProperty(TRANSITION_DURATION_PROPERTY, `${this._exitAnimationDuration}ms`);
      this._requestAnimationFrame(() => this._hostElement.classList.add(CLOSING_CLASS));
      this._waitForAnimationToComplete(this._exitAnimationDuration, this._finishDialogClose);
    } else {
      Promise.resolve().then(() => this._finishDialogClose());
    }
  }
  /**
   * Updates the number action sections.
   * @param delta Increase/decrease in the number of sections.
   */
  _updateActionSectionCount(delta) {
    this._actionSectionCount += delta;
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Completes the dialog open by clearing potential animation classes, trapping
   * focus and emitting an opened event.
   */
  _finishDialogOpen = () => {
    this._clearAnimationClasses();
    this._openAnimationDone(this._enterAnimationDuration);
  };
  /**
   * Completes the dialog close by clearing potential animation classes, restoring
   * focus and emitting a closed event.
   */
  _finishDialogClose = () => {
    this._clearAnimationClasses();
    this._animationStateChanged.emit({
      state: "closed",
      totalTime: this._exitAnimationDuration
    });
  };
  /** Clears all dialog animation classes. */
  _clearAnimationClasses() {
    this._hostElement.classList.remove(OPENING_CLASS, CLOSING_CLASS);
  }
  _waitForAnimationToComplete(duration, callback) {
    if (this._animationTimer !== null) {
      clearTimeout(this._animationTimer);
    }
    this._animationTimer = setTimeout(callback, duration);
  }
  /** Runs a callback in `requestAnimationFrame`, if available. */
  _requestAnimationFrame(callback) {
    this._ngZone.runOutsideAngular(() => {
      if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(callback);
      } else {
        callback();
      }
    });
  }
  _captureInitialFocus() {
    if (!this._config.delayFocusTrap) {
      this._trapFocus();
    }
  }
  /**
   * Callback for when the open dialog animation has finished. Intended to
   * be called by sub-classes that use different animation implementations.
   */
  _openAnimationDone(totalTime) {
    if (this._config.delayFocusTrap) {
      this._trapFocus();
    }
    this._animationStateChanged.next({
      state: "opened",
      totalTime
    });
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this._animationTimer !== null) {
      clearTimeout(this._animationTimer);
    }
  }
  attachComponentPortal(portal) {
    const ref = super.attachComponentPortal(portal);
    ref.location.nativeElement.classList.add("mat-mdc-dialog-component-host");
    return ref;
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatDialogContainer_BaseFactory;
    return function MatDialogContainer_Factory(__ngFactoryType__) {
      return (ɵMatDialogContainer_BaseFactory || (ɵMatDialogContainer_BaseFactory = ɵɵgetInheritedFactory(_MatDialogContainer)))(__ngFactoryType__ || _MatDialogContainer);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatDialogContainer,
    selectors: [["mat-dialog-container"]],
    hostAttrs: ["tabindex", "-1", 1, "mat-mdc-dialog-container", "mdc-dialog"],
    hostVars: 10,
    hostBindings: function MatDialogContainer_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵhostProperty("id", ctx._config.id);
        ɵɵattribute("aria-modal", ctx._config.ariaModal)("role", ctx._config.role)("aria-labelledby", ctx._config.ariaLabel ? null : ctx._ariaLabelledByQueue[0])("aria-label", ctx._config.ariaLabel)("aria-describedby", ctx._config.ariaDescribedBy || null);
        ɵɵclassProp("_mat-animation-noopable", !ctx._animationsEnabled)("mat-mdc-dialog-container-with-actions", ctx._actionSectionCount > 0);
      }
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 0,
    consts: [[1, "mat-mdc-dialog-inner-container", "mdc-dialog__container"], [1, "mat-mdc-dialog-surface", "mdc-dialog__surface"], ["cdkPortalOutlet", ""]],
    template: function MatDialogContainer_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵɵtemplate(2, MatDialogContainer_ng_template_2_Template, 0, 0, "ng-template", 2);
        ɵɵelementEnd()();
      }
    },
    dependencies: [CdkPortalOutlet],
    styles: ['.mat-mdc-dialog-container{width:100%;height:100%;display:block;box-sizing:border-box;max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit;outline:0}.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-max-width, 560px);min-width:var(--mat-dialog-container-min-width, 280px)}@media(max-width: 599px){.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-small-max-width, calc(100vw - 32px))}}.mat-mdc-dialog-inner-container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;opacity:0;transition:opacity linear var(--mat-dialog-transition-duration, 0ms);max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mdc-dialog--closing .mat-mdc-dialog-inner-container{transition:opacity 75ms linear;transform:none}.mdc-dialog--open .mat-mdc-dialog-inner-container{opacity:1}._mat-animation-noopable .mat-mdc-dialog-inner-container{transition:none}.mat-mdc-dialog-surface{display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;width:100%;height:100%;position:relative;overflow-y:auto;outline:0;transform:scale(0.8);transition:transform var(--mat-dialog-transition-duration, 0ms) cubic-bezier(0, 0, 0.2, 1);max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit;box-shadow:var(--mat-dialog-container-elevation-shadow, none);border-radius:var(--mdc-dialog-container-shape, var(--mat-sys-corner-extra-large, 4px));background-color:var(--mdc-dialog-container-color, var(--mat-sys-surface, white))}[dir=rtl] .mat-mdc-dialog-surface{text-align:right}.mdc-dialog--open .mat-mdc-dialog-surface,.mdc-dialog--closing .mat-mdc-dialog-surface{transform:none}._mat-animation-noopable .mat-mdc-dialog-surface{transition:none}.mat-mdc-dialog-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-dialog-title{display:block;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:var(--mat-dialog-headline-padding, 6px 24px 13px)}.mat-mdc-dialog-title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mat-mdc-dialog-title{text-align:right}.mat-mdc-dialog-container .mat-mdc-dialog-title{color:var(--mdc-dialog-subhead-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mdc-dialog-subhead-font, var(--mat-sys-headline-small-font, inherit));line-height:var(--mdc-dialog-subhead-line-height, var(--mat-sys-headline-small-line-height, 1.5rem));font-size:var(--mdc-dialog-subhead-size, var(--mat-sys-headline-small-size, 1rem));font-weight:var(--mdc-dialog-subhead-weight, var(--mat-sys-headline-small-weight, 400));letter-spacing:var(--mdc-dialog-subhead-tracking, var(--mat-sys-headline-small-tracking, 0.03125em))}.mat-mdc-dialog-content{display:block;flex-grow:1;box-sizing:border-box;margin:0;overflow:auto;max-height:65vh}.mat-mdc-dialog-content>:first-child{margin-top:0}.mat-mdc-dialog-content>:last-child{margin-bottom:0}.mat-mdc-dialog-container .mat-mdc-dialog-content{color:var(--mdc-dialog-supporting-text-color, var(--mat-sys-on-surface-variant, rgba(0, 0, 0, 0.6)));font-family:var(--mdc-dialog-supporting-text-font, var(--mat-sys-body-medium-font, inherit));line-height:var(--mdc-dialog-supporting-text-line-height, var(--mat-sys-body-medium-line-height, 1.5rem));font-size:var(--mdc-dialog-supporting-text-size, var(--mat-sys-body-medium-size, 1rem));font-weight:var(--mdc-dialog-supporting-text-weight, var(--mat-sys-body-medium-weight, 400));letter-spacing:var(--mdc-dialog-supporting-text-tracking, var(--mat-sys-body-medium-tracking, 0.03125em))}.mat-mdc-dialog-container .mat-mdc-dialog-content{padding:var(--mat-dialog-content-padding, 20px 24px)}.mat-mdc-dialog-container-with-actions .mat-mdc-dialog-content{padding:var(--mat-dialog-with-actions-content-padding, 20px 24px 0)}.mat-mdc-dialog-container .mat-mdc-dialog-title+.mat-mdc-dialog-content{padding-top:0}.mat-mdc-dialog-actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0);padding:var(--mat-dialog-actions-padding, 16px 24px);justify-content:var(--mat-dialog-actions-alignment, flex-end)}@media(forced-colors: active){.mat-mdc-dialog-actions{border-top-color:CanvasText}}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-start,.mat-mdc-dialog-actions[align=start]{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}.mat-mdc-dialog-component-host{display:contents}'],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDialogContainer, [{
    type: Component,
    args: [{
      selector: "mat-dialog-container",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.Default,
      imports: [CdkPortalOutlet],
      host: {
        "class": "mat-mdc-dialog-container mdc-dialog",
        "tabindex": "-1",
        "[attr.aria-modal]": "_config.ariaModal",
        "[id]": "_config.id",
        "[attr.role]": "_config.role",
        "[attr.aria-labelledby]": "_config.ariaLabel ? null : _ariaLabelledByQueue[0]",
        "[attr.aria-label]": "_config.ariaLabel",
        "[attr.aria-describedby]": "_config.ariaDescribedBy || null",
        "[class._mat-animation-noopable]": "!_animationsEnabled",
        "[class.mat-mdc-dialog-container-with-actions]": "_actionSectionCount > 0"
      },
      template: '<div class="mat-mdc-dialog-inner-container mdc-dialog__container">\n  <div class="mat-mdc-dialog-surface mdc-dialog__surface">\n    <ng-template cdkPortalOutlet />\n  </div>\n</div>\n',
      styles: ['.mat-mdc-dialog-container{width:100%;height:100%;display:block;box-sizing:border-box;max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit;outline:0}.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-max-width, 560px);min-width:var(--mat-dialog-container-min-width, 280px)}@media(max-width: 599px){.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-small-max-width, calc(100vw - 32px))}}.mat-mdc-dialog-inner-container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;opacity:0;transition:opacity linear var(--mat-dialog-transition-duration, 0ms);max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mdc-dialog--closing .mat-mdc-dialog-inner-container{transition:opacity 75ms linear;transform:none}.mdc-dialog--open .mat-mdc-dialog-inner-container{opacity:1}._mat-animation-noopable .mat-mdc-dialog-inner-container{transition:none}.mat-mdc-dialog-surface{display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;width:100%;height:100%;position:relative;overflow-y:auto;outline:0;transform:scale(0.8);transition:transform var(--mat-dialog-transition-duration, 0ms) cubic-bezier(0, 0, 0.2, 1);max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit;box-shadow:var(--mat-dialog-container-elevation-shadow, none);border-radius:var(--mdc-dialog-container-shape, var(--mat-sys-corner-extra-large, 4px));background-color:var(--mdc-dialog-container-color, var(--mat-sys-surface, white))}[dir=rtl] .mat-mdc-dialog-surface{text-align:right}.mdc-dialog--open .mat-mdc-dialog-surface,.mdc-dialog--closing .mat-mdc-dialog-surface{transform:none}._mat-animation-noopable .mat-mdc-dialog-surface{transition:none}.mat-mdc-dialog-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-dialog-title{display:block;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:var(--mat-dialog-headline-padding, 6px 24px 13px)}.mat-mdc-dialog-title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mat-mdc-dialog-title{text-align:right}.mat-mdc-dialog-container .mat-mdc-dialog-title{color:var(--mdc-dialog-subhead-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mdc-dialog-subhead-font, var(--mat-sys-headline-small-font, inherit));line-height:var(--mdc-dialog-subhead-line-height, var(--mat-sys-headline-small-line-height, 1.5rem));font-size:var(--mdc-dialog-subhead-size, var(--mat-sys-headline-small-size, 1rem));font-weight:var(--mdc-dialog-subhead-weight, var(--mat-sys-headline-small-weight, 400));letter-spacing:var(--mdc-dialog-subhead-tracking, var(--mat-sys-headline-small-tracking, 0.03125em))}.mat-mdc-dialog-content{display:block;flex-grow:1;box-sizing:border-box;margin:0;overflow:auto;max-height:65vh}.mat-mdc-dialog-content>:first-child{margin-top:0}.mat-mdc-dialog-content>:last-child{margin-bottom:0}.mat-mdc-dialog-container .mat-mdc-dialog-content{color:var(--mdc-dialog-supporting-text-color, var(--mat-sys-on-surface-variant, rgba(0, 0, 0, 0.6)));font-family:var(--mdc-dialog-supporting-text-font, var(--mat-sys-body-medium-font, inherit));line-height:var(--mdc-dialog-supporting-text-line-height, var(--mat-sys-body-medium-line-height, 1.5rem));font-size:var(--mdc-dialog-supporting-text-size, var(--mat-sys-body-medium-size, 1rem));font-weight:var(--mdc-dialog-supporting-text-weight, var(--mat-sys-body-medium-weight, 400));letter-spacing:var(--mdc-dialog-supporting-text-tracking, var(--mat-sys-body-medium-tracking, 0.03125em))}.mat-mdc-dialog-container .mat-mdc-dialog-content{padding:var(--mat-dialog-content-padding, 20px 24px)}.mat-mdc-dialog-container-with-actions .mat-mdc-dialog-content{padding:var(--mat-dialog-with-actions-content-padding, 20px 24px 0)}.mat-mdc-dialog-container .mat-mdc-dialog-title+.mat-mdc-dialog-content{padding-top:0}.mat-mdc-dialog-actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0);padding:var(--mat-dialog-actions-padding, 16px 24px);justify-content:var(--mat-dialog-actions-alignment, flex-end)}@media(forced-colors: active){.mat-mdc-dialog-actions{border-top-color:CanvasText}}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-start,.mat-mdc-dialog-actions[align=start]{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}.mat-mdc-dialog-component-host{display:contents}']
    }]
  }], null, null);
})();
var TRANSITION_DURATION_PROPERTY = "--mat-dialog-transition-duration";
function parseCssTime(time) {
  if (time == null) {
    return null;
  }
  if (typeof time === "number") {
    return time;
  }
  if (time.endsWith("ms")) {
    return coerceNumberProperty(time.substring(0, time.length - 2));
  }
  if (time.endsWith("s")) {
    return coerceNumberProperty(time.substring(0, time.length - 1)) * 1e3;
  }
  if (time === "0") {
    return 0;
  }
  return null;
}
var MatDialogState;
(function (MatDialogState2) {
  MatDialogState2[MatDialogState2["OPEN"] = 0] = "OPEN";
  MatDialogState2[MatDialogState2["CLOSING"] = 1] = "CLOSING";
  MatDialogState2[MatDialogState2["CLOSED"] = 2] = "CLOSED";
})(MatDialogState || (MatDialogState = {}));
var MatDialogRef = class {
  _ref;
  _containerInstance;
  /** The instance of component opened into the dialog. */
  componentInstance;
  /**
   * `ComponentRef` of the component opened into the dialog. Will be
   * null when the dialog is opened using a `TemplateRef`.
   */
  componentRef;
  /** Whether the user is allowed to close the dialog. */
  disableClose;
  /** Unique ID for the dialog. */
  id;
  /** Subject for notifying the user that the dialog has finished opening. */
  _afterOpened = new Subject();
  /** Subject for notifying the user that the dialog has started closing. */
  _beforeClosed = new Subject();
  /** Result to be passed to afterClosed. */
  _result;
  /** Handle to the timeout that's running as a fallback in case the exit animation doesn't fire. */
  _closeFallbackTimeout;
  /** Current state of the dialog. */
  _state = MatDialogState.OPEN;
  // TODO(crisbeto): we shouldn't have to declare this property, because `DialogRef.close`
  // already has a second `options` parameter that we can use. The problem is that internal tests
  // have assertions like `expect(MatDialogRef.close).toHaveBeenCalledWith(foo)` which will break,
  // because it'll be called with two arguments by things like `MatDialogClose`.
  /** Interaction that caused the dialog to close. */
  _closeInteractionType;
  constructor(_ref, config, _containerInstance) {
    this._ref = _ref;
    this._containerInstance = _containerInstance;
    this.disableClose = config.disableClose;
    this.id = _ref.id;
    _ref.addPanelClass("mat-mdc-dialog-panel");
    _containerInstance._animationStateChanged.pipe(filter(event => event.state === "opened"), take(1)).subscribe(() => {
      this._afterOpened.next();
      this._afterOpened.complete();
    });
    _containerInstance._animationStateChanged.pipe(filter(event => event.state === "closed"), take(1)).subscribe(() => {
      clearTimeout(this._closeFallbackTimeout);
      this._finishDialogClose();
    });
    _ref.overlayRef.detachments().subscribe(() => {
      this._beforeClosed.next(this._result);
      this._beforeClosed.complete();
      this._finishDialogClose();
    });
    merge(this.backdropClick(), this.keydownEvents().pipe(filter(event => event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)))).subscribe(event => {
      if (!this.disableClose) {
        event.preventDefault();
        _closeDialogVia(this, event.type === "keydown" ? "keyboard" : "mouse");
      }
    });
  }
  /**
   * Close the dialog.
   * @param dialogResult Optional result to return to the dialog opener.
   */
  close(dialogResult) {
    this._result = dialogResult;
    this._containerInstance._animationStateChanged.pipe(filter(event => event.state === "closing"), take(1)).subscribe(event => {
      this._beforeClosed.next(dialogResult);
      this._beforeClosed.complete();
      this._ref.overlayRef.detachBackdrop();
      this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), event.totalTime + 100);
    });
    this._state = MatDialogState.CLOSING;
    this._containerInstance._startExitAnimation();
  }
  /**
   * Gets an observable that is notified when the dialog is finished opening.
   */
  afterOpened() {
    return this._afterOpened;
  }
  /**
   * Gets an observable that is notified when the dialog is finished closing.
   */
  afterClosed() {
    return this._ref.closed;
  }
  /**
   * Gets an observable that is notified when the dialog has started closing.
   */
  beforeClosed() {
    return this._beforeClosed;
  }
  /**
   * Gets an observable that emits when the overlay's backdrop has been clicked.
   */
  backdropClick() {
    return this._ref.backdropClick;
  }
  /**
   * Gets an observable that emits when keydown events are targeted on the overlay.
   */
  keydownEvents() {
    return this._ref.keydownEvents;
  }
  /**
   * Updates the dialog's position.
   * @param position New dialog position.
   */
  updatePosition(position) {
    let strategy = this._ref.config.positionStrategy;
    if (position && (position.left || position.right)) {
      position.left ? strategy.left(position.left) : strategy.right(position.right);
    } else {
      strategy.centerHorizontally();
    }
    if (position && (position.top || position.bottom)) {
      position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
    } else {
      strategy.centerVertically();
    }
    this._ref.updatePosition();
    return this;
  }
  /**
   * Updates the dialog's width and height.
   * @param width New width of the dialog.
   * @param height New height of the dialog.
   */
  updateSize(width = "", height = "") {
    this._ref.updateSize(width, height);
    return this;
  }
  /** Add a CSS class or an array of classes to the overlay pane. */
  addPanelClass(classes) {
    this._ref.addPanelClass(classes);
    return this;
  }
  /** Remove a CSS class or an array of classes from the overlay pane. */
  removePanelClass(classes) {
    this._ref.removePanelClass(classes);
    return this;
  }
  /** Gets the current state of the dialog's lifecycle. */
  getState() {
    return this._state;
  }
  /**
   * Finishes the dialog close by updating the state of the dialog
   * and disposing the overlay.
   */
  _finishDialogClose() {
    this._state = MatDialogState.CLOSED;
    this._ref.close(this._result, {
      focusOrigin: this._closeInteractionType
    });
    this.componentInstance = null;
  }
};
function _closeDialogVia(ref, interactionType, result) {
  ref._closeInteractionType = interactionType;
  return ref.close(result);
}
var MAT_DIALOG_DATA = new InjectionToken("MatMdcDialogData");
var MAT_DIALOG_DEFAULT_OPTIONS = new InjectionToken("mat-mdc-dialog-default-options");
var MAT_DIALOG_SCROLL_STRATEGY = new InjectionToken("mat-mdc-dialog-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.block();
  }
});
var MatDialog = class _MatDialog {
  _overlay = inject(Overlay);
  _defaultOptions = inject(MAT_DIALOG_DEFAULT_OPTIONS, {
    optional: true
  });
  _scrollStrategy = inject(MAT_DIALOG_SCROLL_STRATEGY);
  _parentDialog = inject(_MatDialog, {
    optional: true,
    skipSelf: true
  });
  _idGenerator = inject(_IdGenerator);
  _dialog = inject(Dialog);
  _openDialogsAtThisLevel = [];
  _afterAllClosedAtThisLevel = new Subject();
  _afterOpenedAtThisLevel = new Subject();
  dialogConfigClass = MatDialogConfig;
  _dialogRefConstructor;
  _dialogContainerType;
  _dialogDataToken;
  /** Keeps track of the currently-open dialogs. */
  get openDialogs() {
    return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
  }
  /** Stream that emits when a dialog has been opened. */
  get afterOpened() {
    return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
  }
  _getAfterAllClosed() {
    const parent2 = this._parentDialog;
    return parent2 ? parent2._getAfterAllClosed() : this._afterAllClosedAtThisLevel;
  }
  /**
   * Stream that emits when all open dialog have finished closing.
   * Will emit on subscribe if there are no open dialogs to begin with.
   */
  afterAllClosed = defer(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(startWith(void 0)));
  constructor() {
    this._dialogRefConstructor = MatDialogRef;
    this._dialogContainerType = MatDialogContainer;
    this._dialogDataToken = MAT_DIALOG_DATA;
  }
  open(componentOrTemplateRef, config) {
    let dialogRef;
    config = __spreadValues(__spreadValues({}, this._defaultOptions || new MatDialogConfig()), config);
    config.id = config.id || this._idGenerator.getId("mat-mdc-dialog-");
    config.scrollStrategy = config.scrollStrategy || this._scrollStrategy();
    const cdkRef = this._dialog.open(componentOrTemplateRef, __spreadProps(__spreadValues({}, config), {
      positionStrategy: this._overlay.position().global().centerHorizontally().centerVertically(),
      // Disable closing since we need to sync it up to the animation ourselves.
      disableClose: true,
      // Disable closing on destroy, because this service cleans up its open dialogs as well.
      // We want to do the cleanup here, rather than the CDK service, because the CDK destroys
      // the dialogs immediately whereas we want it to wait for the animations to finish.
      closeOnDestroy: false,
      // Disable closing on detachments so that we can sync up the animation.
      // The Material dialog ref handles this manually.
      closeOnOverlayDetachments: false,
      container: {
        type: this._dialogContainerType,
        providers: () => [
        // Provide our config as the CDK config as well since it has the same interface as the
        // CDK one, but it contains the actual values passed in by the user for things like
        // `disableClose` which we disable for the CDK dialog since we handle it ourselves.
        {
          provide: this.dialogConfigClass,
          useValue: config
        }, {
          provide: DialogConfig,
          useValue: config
        }]
      },
      templateContext: () => ({
        dialogRef
      }),
      providers: (ref, cdkConfig, dialogContainer) => {
        dialogRef = new this._dialogRefConstructor(ref, config, dialogContainer);
        dialogRef.updatePosition(config?.position);
        return [{
          provide: this._dialogContainerType,
          useValue: dialogContainer
        }, {
          provide: this._dialogDataToken,
          useValue: cdkConfig.data
        }, {
          provide: this._dialogRefConstructor,
          useValue: dialogRef
        }];
      }
    }));
    dialogRef.componentRef = cdkRef.componentRef;
    dialogRef.componentInstance = cdkRef.componentInstance;
    this.openDialogs.push(dialogRef);
    this.afterOpened.next(dialogRef);
    dialogRef.afterClosed().subscribe(() => {
      const index = this.openDialogs.indexOf(dialogRef);
      if (index > -1) {
        this.openDialogs.splice(index, 1);
        if (!this.openDialogs.length) {
          this._getAfterAllClosed().next();
        }
      }
    });
    return dialogRef;
  }
  /**
   * Closes all of the currently-open dialogs.
   */
  closeAll() {
    this._closeDialogs(this.openDialogs);
  }
  /**
   * Finds an open dialog by its id.
   * @param id ID to use when looking up the dialog.
   */
  getDialogById(id) {
    return this.openDialogs.find(dialog => dialog.id === id);
  }
  ngOnDestroy() {
    this._closeDialogs(this._openDialogsAtThisLevel);
    this._afterAllClosedAtThisLevel.complete();
    this._afterOpenedAtThisLevel.complete();
  }
  _closeDialogs(dialogs) {
    let i2 = dialogs.length;
    while (i2--) {
      dialogs[i2].close();
    }
  }
  static ɵfac = function MatDialog_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatDialog)();
  };
  static ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
    token: _MatDialog,
    factory: _MatDialog.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDialog, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var MatDialogClose = class _MatDialogClose {
  dialogRef = inject(MatDialogRef, {
    optional: true
  });
  _elementRef = inject(ElementRef);
  _dialog = inject(MatDialog);
  /** Screen-reader label for the button. */
  ariaLabel;
  /** Default to "button" to prevents accidental form submits. */
  type = "button";
  /** Dialog close input. */
  dialogResult;
  _matDialogClose;
  constructor() {}
  ngOnInit() {
    if (!this.dialogRef) {
      this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);
    }
  }
  ngOnChanges(changes) {
    const proxiedChange = changes["_matDialogClose"] || changes["_matDialogCloseResult"];
    if (proxiedChange) {
      this.dialogResult = proxiedChange.currentValue;
    }
  }
  _onButtonClick(event) {
    _closeDialogVia(this.dialogRef, event.screenX === 0 && event.screenY === 0 ? "keyboard" : "mouse", this.dialogResult);
  }
  static ɵfac = function MatDialogClose_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatDialogClose)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatDialogClose,
    selectors: [["", "mat-dialog-close", ""], ["", "matDialogClose", ""]],
    hostVars: 2,
    hostBindings: function MatDialogClose_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function MatDialogClose_click_HostBindingHandler($event) {
          return ctx._onButtonClick($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-label", ctx.ariaLabel || null)("type", ctx.type);
      }
    },
    inputs: {
      ariaLabel: [0, "aria-label", "ariaLabel"],
      type: "type",
      dialogResult: [0, "mat-dialog-close", "dialogResult"],
      _matDialogClose: [0, "matDialogClose", "_matDialogClose"]
    },
    exportAs: ["matDialogClose"],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDialogClose, [{
    type: Directive,
    args: [{
      selector: "[mat-dialog-close], [matDialogClose]",
      exportAs: "matDialogClose",
      host: {
        "(click)": "_onButtonClick($event)",
        "[attr.aria-label]": "ariaLabel || null",
        "[attr.type]": "type"
      }
    }]
  }], () => [], {
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    type: [{
      type: Input
    }],
    dialogResult: [{
      type: Input,
      args: ["mat-dialog-close"]
    }],
    _matDialogClose: [{
      type: Input,
      args: ["matDialogClose"]
    }]
  });
})();
var MatDialogLayoutSection = class _MatDialogLayoutSection {
  _dialogRef = inject(MatDialogRef, {
    optional: true
  });
  _elementRef = inject(ElementRef);
  _dialog = inject(MatDialog);
  constructor() {}
  ngOnInit() {
    if (!this._dialogRef) {
      this._dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);
    }
    if (this._dialogRef) {
      Promise.resolve().then(() => {
        this._onAdd();
      });
    }
  }
  ngOnDestroy() {
    const instance = this._dialogRef?._containerInstance;
    if (instance) {
      Promise.resolve().then(() => {
        this._onRemove();
      });
    }
  }
  static ɵfac = function MatDialogLayoutSection_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatDialogLayoutSection)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatDialogLayoutSection
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDialogLayoutSection, [{
    type: Directive
  }], () => [], null);
})();
var MatDialogTitle = class _MatDialogTitle extends MatDialogLayoutSection {
  id = inject(_IdGenerator).getId("mat-mdc-dialog-title-");
  _onAdd() {
    this._dialogRef._containerInstance?._addAriaLabelledBy?.(this.id);
  }
  _onRemove() {
    this._dialogRef?._containerInstance?._removeAriaLabelledBy?.(this.id);
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatDialogTitle_BaseFactory;
    return function MatDialogTitle_Factory(__ngFactoryType__) {
      return (ɵMatDialogTitle_BaseFactory || (ɵMatDialogTitle_BaseFactory = ɵɵgetInheritedFactory(_MatDialogTitle)))(__ngFactoryType__ || _MatDialogTitle);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatDialogTitle,
    selectors: [["", "mat-dialog-title", ""], ["", "matDialogTitle", ""]],
    hostAttrs: [1, "mat-mdc-dialog-title", "mdc-dialog__title"],
    hostVars: 1,
    hostBindings: function MatDialogTitle_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
      }
    },
    inputs: {
      id: "id"
    },
    exportAs: ["matDialogTitle"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDialogTitle, [{
    type: Directive,
    args: [{
      selector: "[mat-dialog-title], [matDialogTitle]",
      exportAs: "matDialogTitle",
      host: {
        "class": "mat-mdc-dialog-title mdc-dialog__title",
        "[id]": "id"
      }
    }]
  }], null, {
    id: [{
      type: Input
    }]
  });
})();
var MatDialogContent = class _MatDialogContent {
  static ɵfac = function MatDialogContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatDialogContent)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatDialogContent,
    selectors: [["", "mat-dialog-content", ""], ["mat-dialog-content"], ["", "matDialogContent", ""]],
    hostAttrs: [1, "mat-mdc-dialog-content", "mdc-dialog__content"],
    features: [ɵɵHostDirectivesFeature([CdkScrollable])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDialogContent, [{
    type: Directive,
    args: [{
      selector: `[mat-dialog-content], mat-dialog-content, [matDialogContent]`,
      host: {
        "class": "mat-mdc-dialog-content mdc-dialog__content"
      },
      hostDirectives: [CdkScrollable]
    }]
  }], null, null);
})();
var MatDialogActions = class _MatDialogActions extends MatDialogLayoutSection {
  /**
   * Horizontal alignment of action buttons.
   */
  align;
  _onAdd() {
    this._dialogRef._containerInstance?._updateActionSectionCount?.(1);
  }
  _onRemove() {
    this._dialogRef._containerInstance?._updateActionSectionCount?.(-1);
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatDialogActions_BaseFactory;
    return function MatDialogActions_Factory(__ngFactoryType__) {
      return (ɵMatDialogActions_BaseFactory || (ɵMatDialogActions_BaseFactory = ɵɵgetInheritedFactory(_MatDialogActions)))(__ngFactoryType__ || _MatDialogActions);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatDialogActions,
    selectors: [["", "mat-dialog-actions", ""], ["mat-dialog-actions"], ["", "matDialogActions", ""]],
    hostAttrs: [1, "mat-mdc-dialog-actions", "mdc-dialog__actions"],
    hostVars: 6,
    hostBindings: function MatDialogActions_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("mat-mdc-dialog-actions-align-start", ctx.align === "start")("mat-mdc-dialog-actions-align-center", ctx.align === "center")("mat-mdc-dialog-actions-align-end", ctx.align === "end");
      }
    },
    inputs: {
      align: "align"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDialogActions, [{
    type: Directive,
    args: [{
      selector: `[mat-dialog-actions], mat-dialog-actions, [matDialogActions]`,
      host: {
        "class": "mat-mdc-dialog-actions mdc-dialog__actions",
        "[class.mat-mdc-dialog-actions-align-start]": 'align === "start"',
        "[class.mat-mdc-dialog-actions-align-center]": 'align === "center"',
        "[class.mat-mdc-dialog-actions-align-end]": 'align === "end"'
      }
    }]
  }], null, {
    align: [{
      type: Input
    }]
  });
})();
function getClosestDialog(element, openDialogs) {
  let parent2 = element.nativeElement.parentElement;
  while (parent2 && !parent2.classList.contains("mat-mdc-dialog-container")) {
    parent2 = parent2.parentElement;
  }
  return parent2 ? openDialogs.find(dialog => dialog.id === parent2.id) : null;
}
var DIRECTIVES = [MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogActions, MatDialogContent];
var MatDialogModule = class _MatDialogModule {
  static ɵfac = function MatDialogModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatDialogModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatDialogModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [MatDialog],
    imports: [DialogModule, OverlayModule, PortalModule, MatCommonModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDialogModule, [{
    type: NgModule,
    args: [{
      imports: [DialogModule, OverlayModule, PortalModule, MatCommonModule, ...DIRECTIVES],
      exports: [MatCommonModule, ...DIRECTIVES],
      providers: [MatDialog]
    }]
  }], null, null);
})();

// libs/ui/src/lib/services/browser-storage.service.ts
var BROWSER_STORAGE = new InjectionToken("Browser Storage", {
  providedIn: "root",
  factory: () => localStorage
});
var BrowserStorageService = class _BrowserStorageService {
  constructor() {
    this.storage = inject(BROWSER_STORAGE);
  }
  get(key) {
    return this.storage.getItem(key);
  }
  set(key, value) {
    this.storage.setItem(key, value);
  }
  remove(key) {
    this.storage.removeItem(key);
  }
  clear() {
    this.storage.clear();
  }
  static {
    this.ɵfac = function BrowserStorageService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BrowserStorageService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _BrowserStorageService,
      factory: _BrowserStorageService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/ui/src/lib/services/theme-manager.service.ts
var LOCAL_STORAGE_KEY = "themeMode";
var ThemeManagerService = class _ThemeManagerService {
  constructor() {
    this.document = inject(DOCUMENT);
    this.browserStorage = inject(BrowserStorageService);
    this.isDark = signal(false);
    this._window = this.document.defaultView;
    this.themeSignal = signal({
      // paddingAbsolute: false,
      // showNativeOverlaidScrollbars: false,
      // update: {
      //   elementEvents: [['img', 'load']],
      //   debounce: [0, 33],
      //   attributes: null,
      //   ignoreMutation: null
      // },
      overflow: {
        x: "hidden",
        y: "scroll"
      },
      scrollbars: {
        theme: "os-theme-light",
        // visibility: 'auto',
        autoHide: "leave",
        autoHideDelay: 100
        // autoHideSuspend: false,
        // dragScroll: true,
        // clickScroll: true,
        // pointers: ['mouse', 'touch', 'pen']
      }
    });
    this.customScrollbarOptions = signal({
      overflow: {
        x: "hidden",
        y: "hidden"
      },
      scrollbars: {
        theme: "os-theme-light",
        autoHide: "leave",
        autoHideDelay: 100,
        visibility: "hidden"
      }
    });
    this.getStoredTheme = () => JSON.parse(this.browserStorage.get(LOCAL_STORAGE_KEY) ?? "{}").theme;
    this.setStoredTheme = theme => {
      const meta = JSON.parse(this.browserStorage.get(LOCAL_STORAGE_KEY) ?? "{}");
      meta.theme = theme;
      this.browserStorage.set(LOCAL_STORAGE_KEY, JSON.stringify(meta));
    };
    this.getPreferredTheme = () => {
      const storedTheme = this.getStoredTheme();
      console.log(storedTheme);
      if (storedTheme) {
        return storedTheme;
      }
      if (this._window !== null && this._window.matchMedia) {
        console.log(this._window.matchMedia("(prefers-color-scheme: dark)").matches);
        return this._window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      }
      return "light";
    };
    this.setTheme = theme => {
      if (this._window !== null && this._window.matchMedia) {
        if (theme === "auto" && this._window.matchMedia("(prefers-color-scheme: dark)").matches) {
          this.document.documentElement.setAttribute("data-bs-theme", "dark");
          this.isDark.set(true);
        } else {
          this.document.documentElement.setAttribute("data-bs-theme", theme);
          this.isDark.set(theme === "dark");
        }
        this.setMaterialTheme();
      }
    };
    this.setTheme(this.getPreferredTheme());
    if (this._window !== null && this._window.matchMedia) {
      this._window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
        const storedTheme = this.getStoredTheme();
        if (storedTheme !== "light" && storedTheme !== "dark") {
          this.setTheme(this.getPreferredTheme());
        }
      });
    }
  }
  setMaterialTheme() {
    if (this.isDark()) {
      const href = "dark-theme.css";
      getLinkElementForKey("dark-theme").setAttribute("href", href);
      this.document.documentElement.classList.add("dark-theme");
    } else {
      this.removeStyle("dark-theme");
      this.document.documentElement.classList.remove("dark-theme");
    }
  }
  removeStyle(key) {
    const existingLinkElement = getExistingLinkElementByKey(key);
    if (existingLinkElement) {
      this.document.head.removeChild(existingLinkElement);
    }
  }
  changeTheme(theme) {
    this.setStoredTheme(theme);
    this.setTheme(theme);
    this.themeSignal.update(options => {
      let scrollbarTheme = "";
      if (theme === "auto") scrollbarTheme = "light";
      if (theme === "dark") scrollbarTheme = "light";
      if (theme === "light") scrollbarTheme = "dark";
      return __spreadProps(__spreadValues({}, options), {
        scrollbars: __spreadProps(__spreadValues({}, options.scrollbars), {
          theme: `os-theme-${scrollbarTheme}`
        })
      });
    });
  }
  static {
    this.ɵfac = function ThemeManagerService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThemeManagerService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ThemeManagerService,
      factory: _ThemeManagerService.ɵfac,
      providedIn: "root"
    });
  }
};
function getLinkElementForKey(key) {
  return getExistingLinkElementByKey(key) || createLinkElementWithKey(key);
}
function getExistingLinkElementByKey(key) {
  return document.head.querySelector(`link[rel="stylesheet"].${getClassNameForKey(key)}`);
}
function createLinkElementWithKey(key) {
  const linkEl = document.createElement("link");
  linkEl.setAttribute("rel", "stylesheet");
  linkEl.classList.add(getClassNameForKey(key));
  document.head.appendChild(linkEl);
  return linkEl;
}
function getClassNameForKey(key) {
  return `style-manager-${key}`;
}

// libs/ui/src/lib/services/paginator-i18n.service.ts
var PaginatorI18nService = class _PaginatorI18nService {
  constructor() {
    this.changes = new Subject();
    this.firstPageLabel = "Erste Seite";
    this.itemsPerPageLabel = "Elemente pro Seite:";
    this.lastPageLabel = "Letzte Seite";
    this.nextPageLabel = "Next page";
    this.previousPageLabel = "Previous page";
  }
  getRangeLabel(page, pageSize, length) {
    if (length === 0) {
      return "Seite 1 von 1";
    }
    const amountPages = Math.ceil(length / pageSize);
    return "Seite " + (page + 1) + " von " + amountPages + "";
  }
  static {
    this.ɵfac = function PaginatorI18nService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PaginatorI18nService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _PaginatorI18nService,
      factory: _PaginatorI18nService.ɵfac
    });
  }
};

// libs/ui/src/lib/services/active-page.service.ts
var ActivePageService = class _ActivePageService {
  constructor() {
    this.pageTitle = signal("Dashboard");
    this.backNavigation = signal(false);
  }
  static {
    this.ɵfac = function ActivePageService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ActivePageService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ActivePageService,
      factory: _ActivePageService.ɵfac,
      providedIn: "root"
    });
  }
};

// node_modules/@angular/core/fesm2022/rxjs-interop.mjs
function toSignal(source, options) {
  ngDevMode && assertNotInReactiveContext(toSignal, "Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.");
  const requiresCleanup = !options?.manualCleanup;
  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);
  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;
  const equal2 = makeToSignalEqual(options?.equal);
  let state2;
  if (options?.requireSync) {
    state2 = signal({
      kind: 0
      /* StateKind.NoValue */
    }, {
      equal: equal2
    });
  } else {
    state2 = signal({
      kind: 1,
      value: options?.initialValue
    }, {
      equal: equal2
    });
  }
  const sub = source.subscribe({
    next: value => state2.set({
      kind: 1,
      value
    }),
    error: error => {
      if (options?.rejectErrors) {
        throw error;
      }
      state2.set({
        kind: 2,
        error
      });
    }
    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of
    // "complete".
  });
  if (options?.requireSync && state2().kind === 0) {
    throw new RuntimeError(601, (typeof ngDevMode === "undefined" || ngDevMode) && "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");
  }
  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));
  return computed(() => {
    const current = state2();
    switch (current.kind) {
      case 1:
        return current.value;
      case 2:
        throw current.error;
      case 0:
        throw new RuntimeError(601, (typeof ngDevMode === "undefined" || ngDevMode) && "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");
    }
  }, {
    equal: options?.equal
  });
}
function makeToSignalEqual(userEquality = Object.is) {
  return (a2, b2) => a2.kind === 1 && b2.kind === 1 && userEquality(a2.value, b2.value);
}

// libs/ui/src/lib/services/screen-size.service.ts
var ScreenSizeService = class _ScreenSizeService {
  constructor() {
    this.breakpointObserver = inject(BreakpointObserver);
    this.compactBP = "(max-width: 599px)";
    this.mediumBP = "(min-width: 600px) and (max-width: 839px)";
    this.expandedBP = "(min-width: 840px) and (max-width: 1199px)";
    this.screenSize = toSignal(this.breakpointObserver.observe([this.compactBP, this.mediumBP, this.expandedBP]).pipe(map(result => ({
      isCompact: result.breakpoints[this.compactBP],
      isMedium: result.breakpoints[this.mediumBP],
      isExpanded: result.breakpoints[this.expandedBP]
    })), shareReplay({
      bufferSize: 1,
      refCount: true
    }), tap(result => console.log(result))));
  }
  static {
    this.ɵfac = function ScreenSizeService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ScreenSizeService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _ScreenSizeService,
      factory: _ScreenSizeService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/ui/src/lib/services/countries-lib.service.ts
var CountriesLibService = class _CountriesLibService {
  constructor() {
    this.http = inject(HttpClient);
    this.apiURLCountriesLib = environment.apiURL + "countriesLib";
  }
  getCountriesLib(lang) {
    return this.http.get(`${this.apiURLCountriesLib}/${lang}`);
  }
  static {
    this.ɵfac = function CountriesLibService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CountriesLibService)();
    };
  }
  static {
    this.ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
      token: _CountriesLibService,
      factory: _CountriesLibService.ɵfac,
      providedIn: "root"
    });
  }
};

// libs/ui/src/lib/components/dynamic-fab-button/dynamic-fab-button.component.ts
var DynamicFabButtonComponent = class _DynamicFabButtonComponent {
  constructor() {
    this.isScrolling = input.required();
    this.matTooltip = input("");
    this.newButtonString = input("");
    this.newFabEvent = output();
  }
  static {
    this.ɵfac = function DynamicFabButtonComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DynamicFabButtonComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _DynamicFabButtonComponent,
      selectors: [["ui-dynamic-fab-button"]],
      inputs: {
        isScrolling: [1, "isScrolling"],
        matTooltip: [1, "matTooltip"],
        newButtonString: [1, "newButtonString"]
      },
      outputs: {
        newFabEvent: "newFabEvent"
      },
      decls: 4,
      vars: 3,
      consts: [["mat-fab", "", 1, "floating-fab-button", 3, "click", "extended", "matTooltip"]],
      template: function DynamicFabButtonComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "button", 0);
          ɵɵlistener("click", function DynamicFabButtonComponent_Template_button_click_0_listener() {
            return ctx.newFabEvent.emit();
          });
          ɵɵelementStart(1, "mat-icon");
          ɵɵtext(2, "add");
          ɵɵelementEnd();
          ɵɵtext(3);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵproperty("extended", !ctx.isScrolling())("matTooltip", ctx.matTooltip());
          ɵɵadvance(3);
          ɵɵtextInterpolate1(" ", ctx.isScrolling() ? "" : ctx.newButtonString(), "\n");
        }
      },
      dependencies: [CommonModule, MatButtonModule, MatFabButton, MatIconModule, MatIcon, MatTooltipModule, MatTooltip],
      styles: ["[_nghost-%COMP%]{position:absolute;bottom:20px;right:24px;z-index:9999}.floating-fab-button[_ngcontent-%COMP%]{color:var(--mat-sys-on-tertiary)}.floating-fab-button[_ngcontent-%COMP%]{--mdc-fab-container-color: var(--mat-sys-tertiary)}\n/*# sourceMappingURL=dynamic-fab-button.component-ARS2QCSP.css.map */"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(DynamicFabButtonComponent, {
    className: "DynamicFabButtonComponent",
    filePath: "libs/ui/src/lib/components/dynamic-fab-button/dynamic-fab-button.component.ts",
    lineNumber: 13
  });
})();

// libs/ui/src/lib/components/page-toolbar/page-toolbar.component.ts
var _c06 = ["*"];
var _c16 = a0 => ({
  "flex-grow": a0
});
function PageToolbarComponent_Conditional_2_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.clientName, " / ");
  }
}
function PageToolbarComponent_Conditional_2_Conditional_4_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 16);
    ɵɵlistener("click", function PageToolbarComponent_Conditional_2_Conditional_4_Conditional_7_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.printEvent.emit());
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "print_outline");
    ɵɵelementEnd()();
  }
}
function PageToolbarComponent_Conditional_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵtemplate(2, PageToolbarComponent_Conditional_2_Conditional_4_Conditional_2_Template, 2, 1, "span", 10);
    ɵɵelementStart(3, "span", 11);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 12);
    ɵɵelement(6, "mat-divider", 13);
    ɵɵtemplate(7, PageToolbarComponent_Conditional_2_Conditional_4_Conditional_7_Template, 3, 0, "button", 14);
    ɵɵelementStart(8, "button", 15);
    ɵɵlistener("click", function PageToolbarComponent_Conditional_2_Conditional_4_Template_button_click_8_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.deleteEvent.emit());
    });
    ɵɵelementStart(9, "mat-icon");
    ɵɵtext(10, "delete_outline");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getDynamicPageTypeString("edit"));
    ɵɵadvance();
    ɵɵconditional(ctx_r1.clientName ? 2 : -1);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(7, _c16, ctx_r1.editMode ? "0" : "1"));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.itemName);
    ɵɵadvance(3);
    ɵɵconditional(ctx_r1.pageType !== "client" ? 7 : -1);
    ɵɵadvance();
    ɵɵproperty("matTooltip", ctx_r1.getDynamicPageTypeString("delete"))("disabled", ctx_r1.reuseProgram);
  }
}
function PageToolbarComponent_Conditional_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.pageType === "exercise" ? ctx_r1.getDynamicPageTypeString("exercise") : ctx_r1.getDynamicPageTypeString("new"));
  }
}
function PageToolbarComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "button", 8);
    ɵɵlistener("click", function PageToolbarComponent_Conditional_2_Template_button_click_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cancelEvent.emit());
    });
    ɵɵelementStart(2, "mat-icon");
    ɵɵtext(3, "arrow_back");
    ɵɵelementEnd()();
    ɵɵtemplate(4, PageToolbarComponent_Conditional_2_Conditional_4_Template, 11, 9)(5, PageToolbarComponent_Conditional_2_Conditional_5_Template, 2, 1, "span", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵconditional(ctx_r1.itemName ? 4 : 5);
  }
}
function PageToolbarComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h2", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.pageTitle);
  }
}
function PageToolbarComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 17);
    ɵɵlistener("click", function PageToolbarComponent_Conditional_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cancelEvent.emit());
    });
    ɵɵi18n(1, 0);
    ɵɵelementEnd();
  }
}
function PageToolbarComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 18);
    ɵɵlistener("click", function PageToolbarComponent_Conditional_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSubmit());
    });
    ɵɵi18n(1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("spinner", ctx_r1.isLoading());
    ɵɵproperty("disabled", ctx_r1.isLoading());
  }
}
function PageToolbarComponent_Conditional_7_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "ui-dynamic-fab-button", 21);
    ɵɵlistener("newFabEvent", function PageToolbarComponent_Conditional_7_Conditional_0_Template_ui_dynamic_fab_button_newFabEvent_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.newFabEvent());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("isScrolling", ctx_r1.isScrolling())("matTooltip", ctx_r1.getDynamicPageTypeString("new"))("newButtonString", ctx_r1.newButtonString);
  }
}
function PageToolbarComponent_Conditional_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 22);
    ɵɵlistener("click", function PageToolbarComponent_Conditional_7_Conditional_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.newEvent.emit());
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "add");
    ɵɵelementEnd();
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("matTooltip", ctx_r1.getDynamicPageTypeString("new"));
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r1.newButtonString, " ");
  }
}
function PageToolbarComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PageToolbarComponent_Conditional_7_Conditional_0_Template, 1, 3, "ui-dynamic-fab-button", 19)(1, PageToolbarComponent_Conditional_7_Conditional_1_Template, 4, 2, "button", 20);
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(((tmp_1_0 = ctx_r1.screenSize()) == null ? null : tmp_1_0.isCompact) ? 0 : 1);
  }
}
var PageToolbarComponent = class _PageToolbarComponent {
  constructor() {
    this.router = inject(Router);
    this.shareStateService = inject(ShareStateService);
    this.screenSizeService = inject(ScreenSizeService);
    this.screenSize = this.screenSizeService.screenSize;
    this.newButtonString = "Neu";
    this.isLoading = this.shareStateService.isLoading;
    this.isScrolling = signal(false);
    this.cancelButton = false;
    this.submitButton = false;
    this.newButton = false;
    this.editMode = false;
    this.itemName = "";
    this.clientName = "";
    this.isClientProgram = false;
    this.reuseProgram = false;
    this.submitEvent = output();
    this.newEvent = output();
    this.cancelEvent = output();
    this.deleteEvent = output();
    this.printEvent = output();
  }
  onSubmit() {
    this.submitEvent.emit();
  }
  getDynamicPageTypeString(action) {
    if (this.pageType === "client") {
      switch (action) {
        case "new":
          return "Neuer Patient";
        case "edit":
          return "Patient bearbeiten / ";
        case "delete":
          return "Patient l\xF6schen";
        default:
          return "";
      }
    } else {
      switch (action) {
        case "new":
          return "Neues Programm";
        case "edit":
          return "Programm bearbeiten /";
        case "delete":
          return "Programm l\xF6schen";
        case "exercise":
          return "\xDCbungsdetails";
        default:
          return "";
      }
    }
  }
  newFabEvent() {
    this.newEvent.emit();
  }
  static {
    this.ɵfac = function PageToolbarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PageToolbarComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _PageToolbarComponent,
      selectors: [["ui-page-toolbar"]],
      inputs: {
        pageTitle: "pageTitle",
        pageType: "pageType",
        cancelButton: "cancelButton",
        submitButton: "submitButton",
        newButton: "newButton",
        editMode: "editMode",
        itemName: "itemName",
        clientName: "clientName",
        isClientProgram: "isClientProgram",
        reuseProgram: "reuseProgram"
      },
      outputs: {
        submitEvent: "submitEvent",
        newEvent: "newEvent",
        cancelEvent: "cancelEvent",
        deleteEvent: "deleteEvent",
        printEvent: "printEvent"
      },
      ngContentSelectors: _c06,
      decls: 9,
      vars: 4,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_backBtnTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_0 = goog.getMsg("Back");
          i18n_0 = MSG_EXTERNAL_PageToolbar_backBtnTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_0;
        } else {
          i18n_0 = "Zur\xFCck";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_backButtonAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_1 = goog.getMsg("Arrow back icon button");
          i18n_1 = MSG_EXTERNAL_PageToolbar_backButtonAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_1;
        } else {
          i18n_1 = "Pfeil-Zur\xFCck-Symbolschaltfl\xE4che";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_printBtnTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_2 = goog.getMsg("Print");
          i18n_2 = MSG_EXTERNAL_PageToolbar_printBtnTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_2;
        } else {
          i18n_2 = "Drucken";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_printBtnAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_3 = goog.getMsg("Print icon button");
          i18n_3 = MSG_EXTERNAL_PageToolbar_printBtnAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_3;
        } else {
          i18n_3 = "Schaltfl\xE4che \u201ESymbol \u201EDrucken\u201C\u201C";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_deleteBtnAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_4 = goog.getMsg("Delete icon button");
          i18n_4 = MSG_EXTERNAL_PageToolbar_deleteBtnAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_4;
        } else {
          i18n_4 = "Symbolschaltfl\xE4che \u201EL\xF6schen\u201C";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_cancelBtn$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_5 = goog.getMsg(" Cancel ");
          i18n_5 = MSG_EXTERNAL_PageToolbar_cancelBtn$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_5;
        } else {
          i18n_5 = " Stornieren ";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_saveBtn$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_6 = goog.getMsg(" Save ");
          i18n_6 = MSG_EXTERNAL_PageToolbar_saveBtn$$LIBS_UI_SRC_LIB_COMPONENTS_PAGE_TOOLBAR_PAGE_TOOLBAR_COMPONENT_TS_6;
        } else {
          i18n_6 = " Speichern ";
        }
        return [i18n_5, i18n_6, [1, "page-toolbar-container"], [1, "title-edit-mode"], [1, "hide-page-title"], [1, "toolbar-btns"], ["mat-stroked-button", "", "color", "primary", 1, "custom-btn"], ["mat-flat-button", "", "color", "primary", 1, "custom-btn", 3, "spinner", "disabled"], ["mat-icon-button", "", "matTooltip", i18n_0, "aria-label", i18n_1, 3, "click"], [1, "mat-title-large"], [1, "edit-client-name", "mat-title-large"], [1, "edit-program-name", "mat-title-large", 3, "ngStyle"], [1, "program-options-wrapper"], ["vertical", "", 2, "display", "inline-block", "height", "24px"], ["mat-icon-button", "", "matTooltip", i18n_2, "aria-label", i18n_3], ["mat-icon-button", "", "aria-label", i18n_4, 3, "click", "matTooltip", "disabled"], ["mat-icon-button", "", "matTooltip", i18n_2, "aria-label", i18n_3, 3, "click"], ["mat-stroked-button", "", "color", "primary", 1, "custom-btn", 3, "click"], ["mat-flat-button", "", "color", "primary", 1, "custom-btn", 3, "click", "disabled"], [3, "isScrolling", "matTooltip", "newButtonString"], ["mat-flat-button", "", "color", "primary", 1, "custom-btn", 3, "matTooltip"], [3, "newFabEvent", "isScrolling", "matTooltip", "newButtonString"], ["mat-flat-button", "", "color", "primary", 1, "custom-btn", 3, "click", "matTooltip"]];
      },
      template: function PageToolbarComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵprojectionDef();
          ɵɵelementStart(0, "div", 2)(1, "div");
          ɵɵtemplate(2, PageToolbarComponent_Conditional_2_Template, 6, 1, "div", 3)(3, PageToolbarComponent_Conditional_3_Template, 2, 1, "h2", 4);
          ɵɵelementEnd();
          ɵɵelementStart(4, "div", 5);
          ɵɵtemplate(5, PageToolbarComponent_Conditional_5_Template, 2, 0, "button", 6)(6, PageToolbarComponent_Conditional_6_Template, 2, 3, "button", 7)(7, PageToolbarComponent_Conditional_7_Template, 2, 1);
          ɵɵprojection(8);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance(2);
          ɵɵconditional(ctx.editMode ? 2 : 3);
          ɵɵadvance(3);
          ɵɵconditional(ctx.cancelButton ? 5 : -1);
          ɵɵadvance();
          ɵɵconditional(ctx.submitButton ? 6 : -1);
          ɵɵadvance();
          ɵɵconditional(ctx.newButton ? 7 : -1);
        }
      },
      dependencies: [CommonModule, NgStyle, MatButtonModule, MatButton, MatIconButton, MatTooltipModule, MatTooltip, MatDividerModule, MatDivider, MatIconModule, MatIcon, DynamicFabButtonComponent],
      styles: [".page-toolbar-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:space-between;padding-bottom:16px}.page-toolbar-container[_ngcontent-%COMP%]   .title-edit-mode[_ngcontent-%COMP%]{display:flex;align-items:center}.page-toolbar-container[_ngcontent-%COMP%]   .title-edit-mode[_ngcontent-%COMP%]   .edit-program-name[_ngcontent-%COMP%]{margin-left:8px}.page-toolbar-container[_ngcontent-%COMP%]   .toolbar-btns[_ngcontent-%COMP%]{display:flex;flex-direction:row;gap:8px}.page-toolbar-container[_ngcontent-%COMP%]   .toolbar-btns[_ngcontent-%COMP%]   .custom-btn[_ngcontent-%COMP%]{width:100px}@media (max-width: 599px){.page-toolbar-container[_ngcontent-%COMP%]{padding-bottom:0}.page-toolbar-container[_ngcontent-%COMP%]   .hide-page-title[_ngcontent-%COMP%]{display:none}}\n/*# sourceMappingURL=page-toolbar.component-TWKVXFKQ.css.map */"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PageToolbarComponent, {
    className: "PageToolbarComponent",
    filePath: "libs/ui/src/lib/components/page-toolbar/page-toolbar.component.ts",
    lineNumber: 29
  });
})();

// node_modules/@angular/material/fesm2022/chips.mjs
var _c07 = ["*", [["mat-chip-avatar"], ["", "matChipAvatar", ""]], [["mat-chip-trailing-icon"], ["", "matChipRemove", ""], ["", "matChipTrailingIcon", ""]]];
var _c17 = ["*", "mat-chip-avatar, [matChipAvatar]", "mat-chip-trailing-icon,[matChipRemove],[matChipTrailingIcon]"];
function MatChip_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
}
function MatChip_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
}
function MatChipOption_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵprojection(1, 1);
    ɵɵelementStart(2, "span", 8);
    ɵɵnamespaceSVG();
    ɵɵelementStart(3, "svg", 9);
    ɵɵelement(4, "path", 10);
    ɵɵelementEnd()()();
  }
}
function MatChipOption_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
}
var _c23 = '.mdc-evolution-chip,.mdc-evolution-chip__cell,.mdc-evolution-chip__action{display:inline-flex;align-items:center}.mdc-evolution-chip{position:relative;max-width:100%}.mdc-evolution-chip__cell,.mdc-evolution-chip__action{height:100%}.mdc-evolution-chip__cell--primary{flex-basis:100%;overflow-x:hidden}.mdc-evolution-chip__cell--trailing{flex:1 0 auto}.mdc-evolution-chip__action{align-items:center;background:none;border:none;box-sizing:content-box;cursor:pointer;display:inline-flex;justify-content:center;outline:none;padding:0;text-decoration:none;color:inherit}.mdc-evolution-chip__action--presentational{cursor:auto}.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{pointer-events:none}@media(forced-colors: active){.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{forced-color-adjust:none}}.mdc-evolution-chip__action--primary{font:inherit;letter-spacing:inherit;white-space:inherit;overflow-x:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-outline-width, 1px);border-radius:var(--mdc-chip-container-shape-radius, 8px);box-sizing:border-box;content:"";height:100%;left:0;position:absolute;pointer-events:none;top:0;width:100%;z-index:1;border-style:solid}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-outline-color, var(--mat-sys-outline))}.mdc-evolution-chip__action--primary:not(.mdc-evolution-chip__action--presentational):not(.mdc-ripple-upgraded):focus::before{border-color:var(--mdc-chip-focus-outline-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-basic-chip .mdc-evolution-chip__action--primary{font:inherit}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip__action--trailing{position:relative;overflow:visible}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-trailing-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip__text-label{-webkit-user-select:none;user-select:none;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__text-label{font-family:var(--mdc-chip-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mdc-chip-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mdc-chip-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mdc-chip-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mdc-chip-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-label-text-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label,.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-evolution-chip__graphic{align-items:center;display:inline-flex;justify-content:center;overflow:hidden;pointer-events:none;position:relative;flex:1 0 auto}.mat-mdc-standard-chip .mdc-evolution-chip__graphic{width:var(--mdc-chip-with-avatar-avatar-size, 24px);height:var(--mdc-chip-with-avatar-avatar-size, 24px);font-size:var(--mdc-chip-with-avatar-avatar-size, 24px)}.mdc-evolution-chip--selecting .mdc-evolution-chip__graphic{transition:width 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--selected):not(.mdc-evolution-chip--with-primary-icon) .mdc-evolution-chip__graphic{width:0}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mdc-evolution-chip__checkmark{position:absolute;opacity:0;top:50%;left:50%;height:20px;width:20px}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark{transition:transform 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{transform:translate(-50%, -50%);opacity:1}.mdc-evolution-chip__checkmark-svg{display:block}.mdc-evolution-chip__checkmark-path{stroke-width:2px;stroke-dasharray:29.7833385;stroke-dashoffset:29.7833385;stroke:currentColor}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}@media(forced-colors: active){.mdc-evolution-chip__checkmark-path{stroke:CanvasText !important}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--trailing{height:18px;width:18px;font-size:18px}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove{opacity:calc(var(--mat-chip-trailing-action-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove:focus{opacity:calc(var(--mat-chip-trailing-action-focus-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mat-mdc-standard-chip{border-radius:var(--mdc-chip-container-shape-radius, 8px);height:var(--mdc-chip-container-height, 32px)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-container-color, transparent)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-flat-disabled-selected-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}@media(forced-colors: active){.mat-mdc-standard-chip{outline:solid 1px}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{border-radius:var(--mdc-chip-with-avatar-avatar-shape-radius, 24px);width:var(--mdc-chip-with-icon-icon-size, 18px);height:var(--mdc-chip-with-icon-icon-size, 18px);font-size:var(--mdc-chip-with-icon-icon-size, 18px)}.mdc-evolution-chip--selected .mdc-evolution-chip__icon--primary{opacity:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-highlighted{--mdc-chip-with-icon-icon-color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container));--mdc-chip-elevated-container-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container));--mdc-chip-label-text-color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container));--mdc-chip-outline-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-selected .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-chip:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-hover-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-focus-overlay .mat-mdc-chip-selected:hover,.mat-mdc-chip-highlighted:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-hover-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected.cdk-focused .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-evolution-chip--disabled:not(.mdc-evolution-chip--selected) .mat-mdc-chip-avatar{opacity:var(--mdc-chip-with-avatar-disabled-avatar-opacity, 0.38)}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{opacity:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38)}.mdc-evolution-chip--disabled.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{opacity:var(--mdc-chip-with-icon-disabled-icon-opacity, 0.38)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{opacity:var(--mat-chip-disabled-container-opacity, 1)}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-trailing-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-remove{opacity:var(--mat-chip-trailing-action-opacity, 1)}.mat-mdc-chip-remove:focus{opacity:var(--mat-chip-trailing-action-focus-opacity, 1)}.mat-mdc-chip-remove::after{background-color:var(--mat-chip-trailing-action-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-remove:hover::after{opacity:var(--mat-chip-trailing-action-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-remove:focus::after{opacity:var(--mat-chip-trailing-action-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected .mat-mdc-chip-remove::after,.mat-mdc-chip-highlighted .mat-mdc-chip-remove::after{background-color:var(--mat-chip-selected-trailing-action-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mat-mdc-chip-action-label{overflow:visible}.mat-mdc-standard-chip .mat-mdc-chip-graphic,.mat-mdc-standard-chip .mat-mdc-chip-trailing-icon{box-sizing:content-box}.mat-mdc-standard-chip._mat-animation-noopable,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__graphic,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark-path{transition-duration:1ms;animation-duration:1ms}.mat-mdc-chip-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;opacity:0;border-radius:inherit;transition:opacity 150ms linear}._mat-animation-noopable .mat-mdc-chip-focus-overlay{transition:none}.mat-mdc-basic-chip .mat-mdc-chip-focus-overlay{display:none}.mat-mdc-chip .mat-ripple.mat-mdc-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-chip-avatar{text-align:center;line-height:1;color:var(--mdc-chip-with-icon-icon-color, currentColor)}.mat-mdc-chip{position:relative;z-index:0}.mat-mdc-chip-action-label{text-align:left;z-index:1}[dir=rtl] .mat-mdc-chip-action-label{text-align:right}.mat-mdc-chip.mdc-evolution-chip--with-trailing-action .mat-mdc-chip-action-label{position:relative}.mat-mdc-chip-action-label .mat-mdc-chip-primary-focus-indicator{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.mat-mdc-chip-action-label .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-chip-remove::before{margin:calc(var(--mat-focus-indicator-border-width, 3px)*-1);left:8px;right:8px}.mat-mdc-chip-remove::after{content:"";display:block;opacity:0;position:absolute;top:-3px;bottom:-3px;left:5px;right:5px;border-radius:50%;box-sizing:border-box;padding:12px;margin:-12px;background-clip:content-box}.mat-mdc-chip-remove .mat-icon{width:18px;height:18px;font-size:18px;box-sizing:content-box}.mat-chip-edit-input{cursor:text;display:inline-block;color:inherit;outline:0}@media(forced-colors: active){.mat-mdc-chip-selected:not(.mat-mdc-chip-multiple){outline-width:3px}}.mat-mdc-chip-action:focus .mat-focus-indicator::before{content:""}';
var _c33 = [[["mat-chip-avatar"], ["", "matChipAvatar", ""]], [["", "matChipEditInput", ""]], "*", [["mat-chip-trailing-icon"], ["", "matChipRemove", ""], ["", "matChipTrailingIcon", ""]]];
var _c42 = ["mat-chip-avatar, [matChipAvatar]", "[matChipEditInput]", "*", "mat-chip-trailing-icon,[matChipRemove],[matChipTrailingIcon]"];
function MatChipRow_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 0);
  }
}
function MatChipRow_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
}
function MatChipRow_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1);
  }
}
function MatChipRow_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
}
function MatChipRow_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MatChipRow_Conditional_4_Conditional_0_Template, 1, 0)(1, MatChipRow_Conditional_4_Conditional_1_Template, 1, 0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(ctx_r0.contentEditInput ? 0 : 1);
  }
}
function MatChipRow_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
  }
}
function MatChipRow_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵprojection(1, 3);
    ɵɵelementEnd();
  }
}
var _c5 = ["*"];
var _c6 = ".mat-mdc-chip-set{display:flex}.mat-mdc-chip-set:focus{outline:none}.mat-mdc-chip-set .mdc-evolution-chip-set__chips{min-width:100%;margin-left:-8px;margin-right:0}.mat-mdc-chip-set .mdc-evolution-chip{margin:4px 0 4px 8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip-set__chips{margin-left:0;margin-right:-8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip{margin-left:0;margin-right:8px}.mdc-evolution-chip-set__chips{display:flex;flex-flow:wrap;min-width:0}.mat-mdc-chip-set-stacked{flex-direction:column;align-items:flex-start}.mat-mdc-chip-set-stacked .mat-mdc-chip{width:100%}.mat-mdc-chip-set-stacked .mdc-evolution-chip__graphic{flex-grow:0}.mat-mdc-chip-set-stacked .mdc-evolution-chip__action--primary{flex-basis:100%;justify-content:start}input.mat-mdc-chip-input{flex:1 0 150px;margin-left:8px}[dir=rtl] input.mat-mdc-chip-input{margin-left:0;margin-right:8px}";
var MAT_CHIPS_DEFAULT_OPTIONS = new InjectionToken("mat-chips-default-options", {
  providedIn: "root",
  factory: () => ({
    separatorKeyCodes: [ENTER]
  })
});
var MAT_CHIP_AVATAR = new InjectionToken("MatChipAvatar");
var MAT_CHIP_TRAILING_ICON = new InjectionToken("MatChipTrailingIcon");
var MAT_CHIP_REMOVE = new InjectionToken("MatChipRemove");
var MAT_CHIP = new InjectionToken("MatChip");
var MatChipAction = class _MatChipAction {
  _elementRef = inject(ElementRef);
  _parentChip = inject(MAT_CHIP);
  /** Whether the action is interactive. */
  isInteractive = true;
  /** Whether this is the primary action in the chip. */
  _isPrimary = true;
  /** Whether the action is disabled. */
  get disabled() {
    return this._disabled || this._parentChip?.disabled || false;
  }
  set disabled(value) {
    this._disabled = value;
  }
  _disabled = false;
  /** Tab index of the action. */
  tabIndex = -1;
  /**
   * Private API to allow focusing this chip when it is disabled.
   */
  _allowFocusWhenDisabled = false;
  /**
   * Determine the value of the disabled attribute for this chip action.
   */
  _getDisabledAttribute() {
    return this.disabled && !this._allowFocusWhenDisabled ? "" : null;
  }
  /**
   * Determine the value of the tabindex attribute for this chip action.
   */
  _getTabindex() {
    return this.disabled && !this._allowFocusWhenDisabled || !this.isInteractive ? null : this.tabIndex.toString();
  }
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
    if (this._elementRef.nativeElement.nodeName === "BUTTON") {
      this._elementRef.nativeElement.setAttribute("type", "button");
    }
  }
  focus() {
    this._elementRef.nativeElement.focus();
  }
  _handleClick(event) {
    if (!this.disabled && this.isInteractive && this._isPrimary) {
      event.preventDefault();
      this._parentChip._handlePrimaryActionInteraction();
    }
  }
  _handleKeydown(event) {
    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !this.disabled && this.isInteractive && this._isPrimary && !this._parentChip._isEditing) {
      event.preventDefault();
      this._parentChip._handlePrimaryActionInteraction();
    }
  }
  static ɵfac = function MatChipAction_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChipAction)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatChipAction,
    selectors: [["", "matChipAction", ""]],
    hostAttrs: [1, "mdc-evolution-chip__action", "mat-mdc-chip-action"],
    hostVars: 9,
    hostBindings: function MatChipAction_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function MatChipAction_click_HostBindingHandler($event) {
          return ctx._handleClick($event);
        })("keydown", function MatChipAction_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("tabindex", ctx._getTabindex())("disabled", ctx._getDisabledAttribute())("aria-disabled", ctx.disabled);
        ɵɵclassProp("mdc-evolution-chip__action--primary", ctx._isPrimary)("mdc-evolution-chip__action--presentational", !ctx.isInteractive)("mdc-evolution-chip__action--trailing", !ctx._isPrimary);
      }
    },
    inputs: {
      isInteractive: "isInteractive",
      disabled: [2, "disabled", "disabled", booleanAttribute],
      tabIndex: [2, "tabIndex", "tabIndex", value => value == null ? -1 : numberAttribute(value)],
      _allowFocusWhenDisabled: "_allowFocusWhenDisabled"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipAction, [{
    type: Directive,
    args: [{
      selector: "[matChipAction]",
      host: {
        "class": "mdc-evolution-chip__action mat-mdc-chip-action",
        "[class.mdc-evolution-chip__action--primary]": "_isPrimary",
        "[class.mdc-evolution-chip__action--presentational]": "!isInteractive",
        "[class.mdc-evolution-chip__action--trailing]": "!_isPrimary",
        "[attr.tabindex]": "_getTabindex()",
        "[attr.disabled]": "_getDisabledAttribute()",
        "[attr.aria-disabled]": "disabled",
        "(click)": "_handleClick($event)",
        "(keydown)": "_handleKeydown($event)"
      }
    }]
  }], () => [], {
    isInteractive: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    tabIndex: [{
      type: Input,
      args: [{
        transform: value => value == null ? -1 : numberAttribute(value)
      }]
    }],
    _allowFocusWhenDisabled: [{
      type: Input
    }]
  });
})();
var MatChipAvatar = class _MatChipAvatar {
  static ɵfac = function MatChipAvatar_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChipAvatar)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatChipAvatar,
    selectors: [["mat-chip-avatar"], ["", "matChipAvatar", ""]],
    hostAttrs: ["role", "img", 1, "mat-mdc-chip-avatar", "mdc-evolution-chip__icon", "mdc-evolution-chip__icon--primary"],
    features: [ɵɵProvidersFeature([{
      provide: MAT_CHIP_AVATAR,
      useExisting: _MatChipAvatar
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipAvatar, [{
    type: Directive,
    args: [{
      selector: "mat-chip-avatar, [matChipAvatar]",
      host: {
        "class": "mat-mdc-chip-avatar mdc-evolution-chip__icon mdc-evolution-chip__icon--primary",
        "role": "img"
      },
      providers: [{
        provide: MAT_CHIP_AVATAR,
        useExisting: MatChipAvatar
      }]
    }]
  }], null, null);
})();
var MatChipTrailingIcon = class _MatChipTrailingIcon extends MatChipAction {
  /**
   * MDC considers all trailing actions as a remove icon,
   * but we support non-interactive trailing icons.
   */
  isInteractive = false;
  _isPrimary = false;
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatChipTrailingIcon_BaseFactory;
    return function MatChipTrailingIcon_Factory(__ngFactoryType__) {
      return (ɵMatChipTrailingIcon_BaseFactory || (ɵMatChipTrailingIcon_BaseFactory = ɵɵgetInheritedFactory(_MatChipTrailingIcon)))(__ngFactoryType__ || _MatChipTrailingIcon);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatChipTrailingIcon,
    selectors: [["mat-chip-trailing-icon"], ["", "matChipTrailingIcon", ""]],
    hostAttrs: ["aria-hidden", "true", 1, "mat-mdc-chip-trailing-icon", "mdc-evolution-chip__icon", "mdc-evolution-chip__icon--trailing"],
    features: [ɵɵProvidersFeature([{
      provide: MAT_CHIP_TRAILING_ICON,
      useExisting: _MatChipTrailingIcon
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipTrailingIcon, [{
    type: Directive,
    args: [{
      selector: "mat-chip-trailing-icon, [matChipTrailingIcon]",
      host: {
        "class": "mat-mdc-chip-trailing-icon mdc-evolution-chip__icon mdc-evolution-chip__icon--trailing",
        "aria-hidden": "true"
      },
      providers: [{
        provide: MAT_CHIP_TRAILING_ICON,
        useExisting: MatChipTrailingIcon
      }]
    }]
  }], null, null);
})();
var MatChipRemove = class _MatChipRemove extends MatChipAction {
  _isPrimary = false;
  _handleClick(event) {
    if (!this.disabled) {
      event.stopPropagation();
      event.preventDefault();
      this._parentChip.remove();
    }
  }
  _handleKeydown(event) {
    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !this.disabled) {
      event.stopPropagation();
      event.preventDefault();
      this._parentChip.remove();
    }
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatChipRemove_BaseFactory;
    return function MatChipRemove_Factory(__ngFactoryType__) {
      return (ɵMatChipRemove_BaseFactory || (ɵMatChipRemove_BaseFactory = ɵɵgetInheritedFactory(_MatChipRemove)))(__ngFactoryType__ || _MatChipRemove);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatChipRemove,
    selectors: [["", "matChipRemove", ""]],
    hostAttrs: ["role", "button", 1, "mat-mdc-chip-remove", "mat-mdc-chip-trailing-icon", "mat-focus-indicator", "mdc-evolution-chip__icon", "mdc-evolution-chip__icon--trailing"],
    hostVars: 1,
    hostBindings: function MatChipRemove_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-hidden", null);
      }
    },
    features: [ɵɵProvidersFeature([{
      provide: MAT_CHIP_REMOVE,
      useExisting: _MatChipRemove
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipRemove, [{
    type: Directive,
    args: [{
      selector: "[matChipRemove]",
      host: {
        "class": "mat-mdc-chip-remove mat-mdc-chip-trailing-icon mat-focus-indicator mdc-evolution-chip__icon mdc-evolution-chip__icon--trailing",
        "role": "button",
        "[attr.aria-hidden]": "null"
      },
      providers: [{
        provide: MAT_CHIP_REMOVE,
        useExisting: MatChipRemove
      }]
    }]
  }], null, null);
})();
var MatChip = class _MatChip {
  _changeDetectorRef = inject(ChangeDetectorRef);
  _elementRef = inject(ElementRef);
  _ngZone = inject(NgZone);
  _focusMonitor = inject(FocusMonitor);
  _globalRippleOptions = inject(MAT_RIPPLE_GLOBAL_OPTIONS, {
    optional: true
  });
  _document = inject(DOCUMENT);
  /** Emits when the chip is focused. */
  _onFocus = new Subject();
  /** Emits when the chip is blurred. */
  _onBlur = new Subject();
  /** Whether this chip is a basic (unstyled) chip. */
  _isBasicChip;
  /** Role for the root of the chip. */
  role = null;
  /** Whether the chip has focus. */
  _hasFocusInternal = false;
  /** Whether moving focus into the chip is pending. */
  _pendingFocus;
  /** Subscription to changes in the chip's actions. */
  _actionChanges;
  /** Whether animations for the chip are enabled. */
  _animationsDisabled;
  /** All avatars present in the chip. */
  _allLeadingIcons;
  /** All trailing icons present in the chip. */
  _allTrailingIcons;
  /** All remove icons present in the chip. */
  _allRemoveIcons;
  _hasFocus() {
    return this._hasFocusInternal;
  }
  /** A unique id for the chip. If none is supplied, it will be auto-generated. */
  id = inject(_IdGenerator).getId("mat-mdc-chip-");
  // TODO(#26104): Consider deprecating and using `_computeAriaAccessibleName` instead.
  // `ariaLabel` may be unnecessary, and `_computeAriaAccessibleName` only supports
  // datepicker's use case.
  /** ARIA label for the content of the chip. */
  ariaLabel = null;
  // TODO(#26104): Consider deprecating and using `_computeAriaAccessibleName` instead.
  // `ariaDescription` may be unnecessary, and `_computeAriaAccessibleName` only supports
  // datepicker's use case.
  /** ARIA description for the content of the chip. */
  ariaDescription = null;
  /** Id of a span that contains this chip's aria description. */
  _ariaDescriptionId = `${this.id}-aria-description`;
  /** Whether the chip list is disabled. */
  _chipListDisabled = false;
  _textElement;
  /**
   * The value of the chip. Defaults to the content inside
   * the `mat-mdc-chip-action-label` element.
   */
  get value() {
    return this._value !== void 0 ? this._value : this._textElement.textContent.trim();
  }
  set value(value) {
    this._value = value;
  }
  _value;
  // TODO: should be typed as `ThemePalette` but internal apps pass in arbitrary strings.
  /**
   * Theme color of the chip. This API is supported in M2 themes only, it has no
   * effect in M3 themes. For color customization in M3, see https://material.angular.io/components/chips/styling.
   *
   * For information on applying color variants in M3, see
   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
   */
  color;
  /**
   * Determines whether or not the chip displays the remove styling and emits (removed) events.
   */
  removable = true;
  /**
   * Colors the chip for emphasis as if it were selected.
   */
  highlighted = false;
  /** Whether the ripple effect is disabled or not. */
  disableRipple = false;
  /** Whether the chip is disabled. */
  get disabled() {
    return this._disabled || this._chipListDisabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  _disabled = false;
  /** Emitted when a chip is to be removed. */
  removed = new EventEmitter();
  /** Emitted when the chip is destroyed. */
  destroyed = new EventEmitter();
  /** The unstyled chip selector for this component. */
  basicChipAttrName = "mat-basic-chip";
  /** The chip's leading icon. */
  leadingIcon;
  /** The chip's trailing icon. */
  trailingIcon;
  /** The chip's trailing remove icon. */
  removeIcon;
  /** Action receiving the primary set of user interactions. */
  primaryAction;
  /**
   * Handles the lazy creation of the MatChip ripple.
   * Used to improve initial load time of large applications.
   */
  _rippleLoader = inject(MatRippleLoader);
  _injector = inject(Injector);
  constructor() {
    const styleLoader = inject(_CdkPrivateStyleLoader);
    styleLoader.load(_StructuralStylesLoader);
    styleLoader.load(_VisuallyHiddenLoader);
    const animationMode = inject(ANIMATION_MODULE_TYPE, {
      optional: true
    });
    this._animationsDisabled = animationMode === "NoopAnimations";
    this._monitorFocus();
    this._rippleLoader?.configureRipple(this._elementRef.nativeElement, {
      className: "mat-mdc-chip-ripple",
      disabled: this._isRippleDisabled()
    });
  }
  ngOnInit() {
    const element = this._elementRef.nativeElement;
    this._isBasicChip = element.hasAttribute(this.basicChipAttrName) || element.tagName.toLowerCase() === this.basicChipAttrName;
  }
  ngAfterViewInit() {
    this._textElement = this._elementRef.nativeElement.querySelector(".mat-mdc-chip-action-label");
    if (this._pendingFocus) {
      this._pendingFocus = false;
      this.focus();
    }
  }
  ngAfterContentInit() {
    this._actionChanges = merge(this._allLeadingIcons.changes, this._allTrailingIcons.changes, this._allRemoveIcons.changes).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  ngDoCheck() {
    this._rippleLoader.setDisabled(this._elementRef.nativeElement, this._isRippleDisabled());
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    this._rippleLoader?.destroyRipple(this._elementRef.nativeElement);
    this._actionChanges?.unsubscribe();
    this.destroyed.emit({
      chip: this
    });
    this.destroyed.complete();
  }
  /**
   * Allows for programmatic removal of the chip.
   *
   * Informs any listeners of the removal request. Does not remove the chip from the DOM.
   */
  remove() {
    if (this.removable) {
      this.removed.emit({
        chip: this
      });
    }
  }
  /** Whether or not the ripple should be disabled. */
  _isRippleDisabled() {
    return this.disabled || this.disableRipple || this._animationsDisabled || this._isBasicChip || !!this._globalRippleOptions?.disabled;
  }
  /** Returns whether the chip has a trailing icon. */
  _hasTrailingIcon() {
    return !!(this.trailingIcon || this.removeIcon);
  }
  /** Handles keyboard events on the chip. */
  _handleKeydown(event) {
    if (event.keyCode === BACKSPACE && !event.repeat || event.keyCode === DELETE) {
      event.preventDefault();
      this.remove();
    }
  }
  /** Allows for programmatic focusing of the chip. */
  focus() {
    if (!this.disabled) {
      if (this.primaryAction) {
        this.primaryAction.focus();
      } else {
        this._pendingFocus = true;
      }
    }
  }
  /** Gets the action that contains a specific target node. */
  _getSourceAction(target) {
    return this._getActions().find(action => {
      const element = action._elementRef.nativeElement;
      return element === target || element.contains(target);
    });
  }
  /** Gets all of the actions within the chip. */
  _getActions() {
    const result = [];
    if (this.primaryAction) {
      result.push(this.primaryAction);
    }
    if (this.removeIcon) {
      result.push(this.removeIcon);
    }
    if (this.trailingIcon) {
      result.push(this.trailingIcon);
    }
    return result;
  }
  /** Handles interactions with the primary action of the chip. */
  _handlePrimaryActionInteraction() {}
  /** Starts the focus monitoring process on the chip. */
  _monitorFocus() {
    this._focusMonitor.monitor(this._elementRef, true).subscribe(origin => {
      const hasFocus = origin !== null;
      if (hasFocus !== this._hasFocusInternal) {
        this._hasFocusInternal = hasFocus;
        if (hasFocus) {
          this._onFocus.next({
            chip: this
          });
        } else {
          this._changeDetectorRef.markForCheck();
          setTimeout(() => this._ngZone.run(() => this._onBlur.next({
            chip: this
          })));
        }
      }
    });
  }
  static ɵfac = function MatChip_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChip)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatChip,
    selectors: [["mat-basic-chip"], ["", "mat-basic-chip", ""], ["mat-chip"], ["", "mat-chip", ""]],
    contentQueries: function MatChip_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MAT_CHIP_AVATAR, 5);
        ɵɵcontentQuery(dirIndex, MAT_CHIP_TRAILING_ICON, 5);
        ɵɵcontentQuery(dirIndex, MAT_CHIP_REMOVE, 5);
        ɵɵcontentQuery(dirIndex, MAT_CHIP_AVATAR, 5);
        ɵɵcontentQuery(dirIndex, MAT_CHIP_TRAILING_ICON, 5);
        ɵɵcontentQuery(dirIndex, MAT_CHIP_REMOVE, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.leadingIcon = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.trailingIcon = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.removeIcon = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._allLeadingIcons = _t2);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._allTrailingIcons = _t2);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._allRemoveIcons = _t2);
      }
    },
    viewQuery: function MatChip_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(MatChipAction, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.primaryAction = _t2.first);
      }
    },
    hostAttrs: [1, "mat-mdc-chip"],
    hostVars: 31,
    hostBindings: function MatChip_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function MatChip_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
        ɵɵattribute("role", ctx.role)("aria-label", ctx.ariaLabel);
        ɵɵclassMap("mat-" + (ctx.color || "primary"));
        ɵɵclassProp("mdc-evolution-chip", !ctx._isBasicChip)("mdc-evolution-chip--disabled", ctx.disabled)("mdc-evolution-chip--with-trailing-action", ctx._hasTrailingIcon())("mdc-evolution-chip--with-primary-graphic", ctx.leadingIcon)("mdc-evolution-chip--with-primary-icon", ctx.leadingIcon)("mdc-evolution-chip--with-avatar", ctx.leadingIcon)("mat-mdc-chip-with-avatar", ctx.leadingIcon)("mat-mdc-chip-highlighted", ctx.highlighted)("mat-mdc-chip-disabled", ctx.disabled)("mat-mdc-basic-chip", ctx._isBasicChip)("mat-mdc-standard-chip", !ctx._isBasicChip)("mat-mdc-chip-with-trailing-icon", ctx._hasTrailingIcon())("_mat-animation-noopable", ctx._animationsDisabled);
      }
    },
    inputs: {
      role: "role",
      id: "id",
      ariaLabel: [0, "aria-label", "ariaLabel"],
      ariaDescription: [0, "aria-description", "ariaDescription"],
      value: "value",
      color: "color",
      removable: [2, "removable", "removable", booleanAttribute],
      highlighted: [2, "highlighted", "highlighted", booleanAttribute],
      disableRipple: [2, "disableRipple", "disableRipple", booleanAttribute],
      disabled: [2, "disabled", "disabled", booleanAttribute]
    },
    outputs: {
      removed: "removed",
      destroyed: "destroyed"
    },
    exportAs: ["matChip"],
    features: [ɵɵProvidersFeature([{
      provide: MAT_CHIP,
      useExisting: _MatChip
    }])],
    ngContentSelectors: _c17,
    decls: 8,
    vars: 3,
    consts: [[1, "mat-mdc-chip-focus-overlay"], [1, "mdc-evolution-chip__cell", "mdc-evolution-chip__cell--primary"], ["matChipAction", "", 3, "isInteractive"], [1, "mdc-evolution-chip__graphic", "mat-mdc-chip-graphic"], [1, "mdc-evolution-chip__text-label", "mat-mdc-chip-action-label"], [1, "mat-mdc-chip-primary-focus-indicator", "mat-focus-indicator"], [1, "mdc-evolution-chip__cell", "mdc-evolution-chip__cell--trailing"]],
    template: function MatChip_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c07);
        ɵɵelement(0, "span", 0);
        ɵɵelementStart(1, "span", 1)(2, "span", 2);
        ɵɵtemplate(3, MatChip_Conditional_3_Template, 2, 0, "span", 3);
        ɵɵelementStart(4, "span", 4);
        ɵɵprojection(5);
        ɵɵelement(6, "span", 5);
        ɵɵelementEnd()()();
        ɵɵtemplate(7, MatChip_Conditional_7_Template, 2, 0, "span", 6);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("isInteractive", false);
        ɵɵadvance();
        ɵɵconditional(ctx.leadingIcon ? 3 : -1);
        ɵɵadvance(4);
        ɵɵconditional(ctx._hasTrailingIcon() ? 7 : -1);
      }
    },
    dependencies: [MatChipAction],
    styles: ['.mdc-evolution-chip,.mdc-evolution-chip__cell,.mdc-evolution-chip__action{display:inline-flex;align-items:center}.mdc-evolution-chip{position:relative;max-width:100%}.mdc-evolution-chip__cell,.mdc-evolution-chip__action{height:100%}.mdc-evolution-chip__cell--primary{flex-basis:100%;overflow-x:hidden}.mdc-evolution-chip__cell--trailing{flex:1 0 auto}.mdc-evolution-chip__action{align-items:center;background:none;border:none;box-sizing:content-box;cursor:pointer;display:inline-flex;justify-content:center;outline:none;padding:0;text-decoration:none;color:inherit}.mdc-evolution-chip__action--presentational{cursor:auto}.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{pointer-events:none}@media(forced-colors: active){.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{forced-color-adjust:none}}.mdc-evolution-chip__action--primary{font:inherit;letter-spacing:inherit;white-space:inherit;overflow-x:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-outline-width, 1px);border-radius:var(--mdc-chip-container-shape-radius, 8px);box-sizing:border-box;content:"";height:100%;left:0;position:absolute;pointer-events:none;top:0;width:100%;z-index:1;border-style:solid}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-outline-color, var(--mat-sys-outline))}.mdc-evolution-chip__action--primary:not(.mdc-evolution-chip__action--presentational):not(.mdc-ripple-upgraded):focus::before{border-color:var(--mdc-chip-focus-outline-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-basic-chip .mdc-evolution-chip__action--primary{font:inherit}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip__action--trailing{position:relative;overflow:visible}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-trailing-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip__text-label{-webkit-user-select:none;user-select:none;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__text-label{font-family:var(--mdc-chip-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mdc-chip-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mdc-chip-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mdc-chip-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mdc-chip-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-label-text-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label,.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-evolution-chip__graphic{align-items:center;display:inline-flex;justify-content:center;overflow:hidden;pointer-events:none;position:relative;flex:1 0 auto}.mat-mdc-standard-chip .mdc-evolution-chip__graphic{width:var(--mdc-chip-with-avatar-avatar-size, 24px);height:var(--mdc-chip-with-avatar-avatar-size, 24px);font-size:var(--mdc-chip-with-avatar-avatar-size, 24px)}.mdc-evolution-chip--selecting .mdc-evolution-chip__graphic{transition:width 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--selected):not(.mdc-evolution-chip--with-primary-icon) .mdc-evolution-chip__graphic{width:0}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mdc-evolution-chip__checkmark{position:absolute;opacity:0;top:50%;left:50%;height:20px;width:20px}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark{transition:transform 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{transform:translate(-50%, -50%);opacity:1}.mdc-evolution-chip__checkmark-svg{display:block}.mdc-evolution-chip__checkmark-path{stroke-width:2px;stroke-dasharray:29.7833385;stroke-dashoffset:29.7833385;stroke:currentColor}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}@media(forced-colors: active){.mdc-evolution-chip__checkmark-path{stroke:CanvasText !important}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--trailing{height:18px;width:18px;font-size:18px}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove{opacity:calc(var(--mat-chip-trailing-action-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove:focus{opacity:calc(var(--mat-chip-trailing-action-focus-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mat-mdc-standard-chip{border-radius:var(--mdc-chip-container-shape-radius, 8px);height:var(--mdc-chip-container-height, 32px)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-container-color, transparent)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-flat-disabled-selected-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}@media(forced-colors: active){.mat-mdc-standard-chip{outline:solid 1px}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{border-radius:var(--mdc-chip-with-avatar-avatar-shape-radius, 24px);width:var(--mdc-chip-with-icon-icon-size, 18px);height:var(--mdc-chip-with-icon-icon-size, 18px);font-size:var(--mdc-chip-with-icon-icon-size, 18px)}.mdc-evolution-chip--selected .mdc-evolution-chip__icon--primary{opacity:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-highlighted{--mdc-chip-with-icon-icon-color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container));--mdc-chip-elevated-container-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container));--mdc-chip-label-text-color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container));--mdc-chip-outline-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-selected .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-chip:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-hover-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-focus-overlay .mat-mdc-chip-selected:hover,.mat-mdc-chip-highlighted:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-hover-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected.cdk-focused .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-evolution-chip--disabled:not(.mdc-evolution-chip--selected) .mat-mdc-chip-avatar{opacity:var(--mdc-chip-with-avatar-disabled-avatar-opacity, 0.38)}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{opacity:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38)}.mdc-evolution-chip--disabled.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{opacity:var(--mdc-chip-with-icon-disabled-icon-opacity, 0.38)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{opacity:var(--mat-chip-disabled-container-opacity, 1)}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-trailing-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-remove{opacity:var(--mat-chip-trailing-action-opacity, 1)}.mat-mdc-chip-remove:focus{opacity:var(--mat-chip-trailing-action-focus-opacity, 1)}.mat-mdc-chip-remove::after{background-color:var(--mat-chip-trailing-action-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-remove:hover::after{opacity:var(--mat-chip-trailing-action-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-remove:focus::after{opacity:var(--mat-chip-trailing-action-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected .mat-mdc-chip-remove::after,.mat-mdc-chip-highlighted .mat-mdc-chip-remove::after{background-color:var(--mat-chip-selected-trailing-action-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mat-mdc-chip-action-label{overflow:visible}.mat-mdc-standard-chip .mat-mdc-chip-graphic,.mat-mdc-standard-chip .mat-mdc-chip-trailing-icon{box-sizing:content-box}.mat-mdc-standard-chip._mat-animation-noopable,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__graphic,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark-path{transition-duration:1ms;animation-duration:1ms}.mat-mdc-chip-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;opacity:0;border-radius:inherit;transition:opacity 150ms linear}._mat-animation-noopable .mat-mdc-chip-focus-overlay{transition:none}.mat-mdc-basic-chip .mat-mdc-chip-focus-overlay{display:none}.mat-mdc-chip .mat-ripple.mat-mdc-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-chip-avatar{text-align:center;line-height:1;color:var(--mdc-chip-with-icon-icon-color, currentColor)}.mat-mdc-chip{position:relative;z-index:0}.mat-mdc-chip-action-label{text-align:left;z-index:1}[dir=rtl] .mat-mdc-chip-action-label{text-align:right}.mat-mdc-chip.mdc-evolution-chip--with-trailing-action .mat-mdc-chip-action-label{position:relative}.mat-mdc-chip-action-label .mat-mdc-chip-primary-focus-indicator{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.mat-mdc-chip-action-label .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-chip-remove::before{margin:calc(var(--mat-focus-indicator-border-width, 3px)*-1);left:8px;right:8px}.mat-mdc-chip-remove::after{content:"";display:block;opacity:0;position:absolute;top:-3px;bottom:-3px;left:5px;right:5px;border-radius:50%;box-sizing:border-box;padding:12px;margin:-12px;background-clip:content-box}.mat-mdc-chip-remove .mat-icon{width:18px;height:18px;font-size:18px;box-sizing:content-box}.mat-chip-edit-input{cursor:text;display:inline-block;color:inherit;outline:0}@media(forced-colors: active){.mat-mdc-chip-selected:not(.mat-mdc-chip-multiple){outline-width:3px}}.mat-mdc-chip-action:focus .mat-focus-indicator::before{content:""}'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChip, [{
    type: Component,
    args: [{
      selector: "mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]",
      exportAs: "matChip",
      host: {
        "class": "mat-mdc-chip",
        "[class]": '"mat-" + (color || "primary")',
        "[class.mdc-evolution-chip]": "!_isBasicChip",
        "[class.mdc-evolution-chip--disabled]": "disabled",
        "[class.mdc-evolution-chip--with-trailing-action]": "_hasTrailingIcon()",
        "[class.mdc-evolution-chip--with-primary-graphic]": "leadingIcon",
        "[class.mdc-evolution-chip--with-primary-icon]": "leadingIcon",
        "[class.mdc-evolution-chip--with-avatar]": "leadingIcon",
        "[class.mat-mdc-chip-with-avatar]": "leadingIcon",
        "[class.mat-mdc-chip-highlighted]": "highlighted",
        "[class.mat-mdc-chip-disabled]": "disabled",
        "[class.mat-mdc-basic-chip]": "_isBasicChip",
        "[class.mat-mdc-standard-chip]": "!_isBasicChip",
        "[class.mat-mdc-chip-with-trailing-icon]": "_hasTrailingIcon()",
        "[class._mat-animation-noopable]": "_animationsDisabled",
        "[id]": "id",
        "[attr.role]": "role",
        "[attr.aria-label]": "ariaLabel",
        "(keydown)": "_handleKeydown($event)"
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: MAT_CHIP,
        useExisting: MatChip
      }],
      imports: [MatChipAction],
      template: '<span class="mat-mdc-chip-focus-overlay"></span>\n\n<span class="mdc-evolution-chip__cell mdc-evolution-chip__cell--primary">\n  <span matChipAction [isInteractive]="false">\n    @if (leadingIcon) {\n      <span class="mdc-evolution-chip__graphic mat-mdc-chip-graphic">\n        <ng-content select="mat-chip-avatar, [matChipAvatar]"></ng-content>\n      </span>\n    }\n    <span class="mdc-evolution-chip__text-label mat-mdc-chip-action-label">\n      <ng-content></ng-content>\n      <span class="mat-mdc-chip-primary-focus-indicator mat-focus-indicator"></span>\n    </span>\n  </span>\n</span>\n\n@if (_hasTrailingIcon()) {\n  <span class="mdc-evolution-chip__cell mdc-evolution-chip__cell--trailing">\n    <ng-content select="mat-chip-trailing-icon,[matChipRemove],[matChipTrailingIcon]"></ng-content>\n  </span>\n}\n',
      styles: ['.mdc-evolution-chip,.mdc-evolution-chip__cell,.mdc-evolution-chip__action{display:inline-flex;align-items:center}.mdc-evolution-chip{position:relative;max-width:100%}.mdc-evolution-chip__cell,.mdc-evolution-chip__action{height:100%}.mdc-evolution-chip__cell--primary{flex-basis:100%;overflow-x:hidden}.mdc-evolution-chip__cell--trailing{flex:1 0 auto}.mdc-evolution-chip__action{align-items:center;background:none;border:none;box-sizing:content-box;cursor:pointer;display:inline-flex;justify-content:center;outline:none;padding:0;text-decoration:none;color:inherit}.mdc-evolution-chip__action--presentational{cursor:auto}.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{pointer-events:none}@media(forced-colors: active){.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{forced-color-adjust:none}}.mdc-evolution-chip__action--primary{font:inherit;letter-spacing:inherit;white-space:inherit;overflow-x:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-outline-width, 1px);border-radius:var(--mdc-chip-container-shape-radius, 8px);box-sizing:border-box;content:"";height:100%;left:0;position:absolute;pointer-events:none;top:0;width:100%;z-index:1;border-style:solid}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-outline-color, var(--mat-sys-outline))}.mdc-evolution-chip__action--primary:not(.mdc-evolution-chip__action--presentational):not(.mdc-ripple-upgraded):focus::before{border-color:var(--mdc-chip-focus-outline-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-basic-chip .mdc-evolution-chip__action--primary{font:inherit}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip__action--trailing{position:relative;overflow:visible}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-trailing-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip__text-label{-webkit-user-select:none;user-select:none;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__text-label{font-family:var(--mdc-chip-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mdc-chip-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mdc-chip-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mdc-chip-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mdc-chip-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-label-text-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label,.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-evolution-chip__graphic{align-items:center;display:inline-flex;justify-content:center;overflow:hidden;pointer-events:none;position:relative;flex:1 0 auto}.mat-mdc-standard-chip .mdc-evolution-chip__graphic{width:var(--mdc-chip-with-avatar-avatar-size, 24px);height:var(--mdc-chip-with-avatar-avatar-size, 24px);font-size:var(--mdc-chip-with-avatar-avatar-size, 24px)}.mdc-evolution-chip--selecting .mdc-evolution-chip__graphic{transition:width 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--selected):not(.mdc-evolution-chip--with-primary-icon) .mdc-evolution-chip__graphic{width:0}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mdc-evolution-chip__checkmark{position:absolute;opacity:0;top:50%;left:50%;height:20px;width:20px}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark{transition:transform 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{transform:translate(-50%, -50%);opacity:1}.mdc-evolution-chip__checkmark-svg{display:block}.mdc-evolution-chip__checkmark-path{stroke-width:2px;stroke-dasharray:29.7833385;stroke-dashoffset:29.7833385;stroke:currentColor}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}@media(forced-colors: active){.mdc-evolution-chip__checkmark-path{stroke:CanvasText !important}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--trailing{height:18px;width:18px;font-size:18px}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove{opacity:calc(var(--mat-chip-trailing-action-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove:focus{opacity:calc(var(--mat-chip-trailing-action-focus-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mat-mdc-standard-chip{border-radius:var(--mdc-chip-container-shape-radius, 8px);height:var(--mdc-chip-container-height, 32px)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-container-color, transparent)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-flat-disabled-selected-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}@media(forced-colors: active){.mat-mdc-standard-chip{outline:solid 1px}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{border-radius:var(--mdc-chip-with-avatar-avatar-shape-radius, 24px);width:var(--mdc-chip-with-icon-icon-size, 18px);height:var(--mdc-chip-with-icon-icon-size, 18px);font-size:var(--mdc-chip-with-icon-icon-size, 18px)}.mdc-evolution-chip--selected .mdc-evolution-chip__icon--primary{opacity:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-highlighted{--mdc-chip-with-icon-icon-color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container));--mdc-chip-elevated-container-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container));--mdc-chip-label-text-color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container));--mdc-chip-outline-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-selected .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-chip:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-hover-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-focus-overlay .mat-mdc-chip-selected:hover,.mat-mdc-chip-highlighted:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-hover-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected.cdk-focused .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-evolution-chip--disabled:not(.mdc-evolution-chip--selected) .mat-mdc-chip-avatar{opacity:var(--mdc-chip-with-avatar-disabled-avatar-opacity, 0.38)}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{opacity:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38)}.mdc-evolution-chip--disabled.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{opacity:var(--mdc-chip-with-icon-disabled-icon-opacity, 0.38)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{opacity:var(--mat-chip-disabled-container-opacity, 1)}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-trailing-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-remove{opacity:var(--mat-chip-trailing-action-opacity, 1)}.mat-mdc-chip-remove:focus{opacity:var(--mat-chip-trailing-action-focus-opacity, 1)}.mat-mdc-chip-remove::after{background-color:var(--mat-chip-trailing-action-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-remove:hover::after{opacity:var(--mat-chip-trailing-action-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-remove:focus::after{opacity:var(--mat-chip-trailing-action-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected .mat-mdc-chip-remove::after,.mat-mdc-chip-highlighted .mat-mdc-chip-remove::after{background-color:var(--mat-chip-selected-trailing-action-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mat-mdc-chip-action-label{overflow:visible}.mat-mdc-standard-chip .mat-mdc-chip-graphic,.mat-mdc-standard-chip .mat-mdc-chip-trailing-icon{box-sizing:content-box}.mat-mdc-standard-chip._mat-animation-noopable,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__graphic,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark-path{transition-duration:1ms;animation-duration:1ms}.mat-mdc-chip-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;opacity:0;border-radius:inherit;transition:opacity 150ms linear}._mat-animation-noopable .mat-mdc-chip-focus-overlay{transition:none}.mat-mdc-basic-chip .mat-mdc-chip-focus-overlay{display:none}.mat-mdc-chip .mat-ripple.mat-mdc-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-chip-avatar{text-align:center;line-height:1;color:var(--mdc-chip-with-icon-icon-color, currentColor)}.mat-mdc-chip{position:relative;z-index:0}.mat-mdc-chip-action-label{text-align:left;z-index:1}[dir=rtl] .mat-mdc-chip-action-label{text-align:right}.mat-mdc-chip.mdc-evolution-chip--with-trailing-action .mat-mdc-chip-action-label{position:relative}.mat-mdc-chip-action-label .mat-mdc-chip-primary-focus-indicator{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.mat-mdc-chip-action-label .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-chip-remove::before{margin:calc(var(--mat-focus-indicator-border-width, 3px)*-1);left:8px;right:8px}.mat-mdc-chip-remove::after{content:"";display:block;opacity:0;position:absolute;top:-3px;bottom:-3px;left:5px;right:5px;border-radius:50%;box-sizing:border-box;padding:12px;margin:-12px;background-clip:content-box}.mat-mdc-chip-remove .mat-icon{width:18px;height:18px;font-size:18px;box-sizing:content-box}.mat-chip-edit-input{cursor:text;display:inline-block;color:inherit;outline:0}@media(forced-colors: active){.mat-mdc-chip-selected:not(.mat-mdc-chip-multiple){outline-width:3px}}.mat-mdc-chip-action:focus .mat-focus-indicator::before{content:""}']
    }]
  }], () => [], {
    role: [{
      type: Input
    }],
    _allLeadingIcons: [{
      type: ContentChildren,
      args: [MAT_CHIP_AVATAR, {
        descendants: true
      }]
    }],
    _allTrailingIcons: [{
      type: ContentChildren,
      args: [MAT_CHIP_TRAILING_ICON, {
        descendants: true
      }]
    }],
    _allRemoveIcons: [{
      type: ContentChildren,
      args: [MAT_CHIP_REMOVE, {
        descendants: true
      }]
    }],
    id: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaDescription: [{
      type: Input,
      args: ["aria-description"]
    }],
    value: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    removable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    highlighted: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    removed: [{
      type: Output
    }],
    destroyed: [{
      type: Output
    }],
    leadingIcon: [{
      type: ContentChild,
      args: [MAT_CHIP_AVATAR]
    }],
    trailingIcon: [{
      type: ContentChild,
      args: [MAT_CHIP_TRAILING_ICON]
    }],
    removeIcon: [{
      type: ContentChild,
      args: [MAT_CHIP_REMOVE]
    }],
    primaryAction: [{
      type: ViewChild,
      args: [MatChipAction]
    }]
  });
})();
var MatChipOption = class _MatChipOption extends MatChip {
  /** Default chip options. */
  _defaultOptions = inject(MAT_CHIPS_DEFAULT_OPTIONS, {
    optional: true
  });
  /** Whether the chip list is selectable. */
  chipListSelectable = true;
  /** Whether the chip list is in multi-selection mode. */
  _chipListMultiple = false;
  /** Whether the chip list hides single-selection indicator. */
  _chipListHideSingleSelectionIndicator = this._defaultOptions?.hideSingleSelectionIndicator ?? false;
  /**
   * Whether or not the chip is selectable.
   *
   * When a chip is not selectable, changes to its selected state are always
   * ignored. By default an option chip is selectable, and it becomes
   * non-selectable if its parent chip list is not selectable.
   */
  get selectable() {
    return this._selectable && this.chipListSelectable;
  }
  set selectable(value) {
    this._selectable = value;
    this._changeDetectorRef.markForCheck();
  }
  _selectable = true;
  /** Whether the chip is selected. */
  get selected() {
    return this._selected;
  }
  set selected(value) {
    this._setSelectedState(value, false, true);
  }
  _selected = false;
  /**
   * The ARIA selected applied to the chip. Conforms to WAI ARIA best practices for listbox
   * interaction patterns.
   *
   * From [WAI ARIA Listbox authoring practices guide](
   * https://www.w3.org/WAI/ARIA/apg/patterns/listbox/):
   *  "If any options are selected, each selected option has either aria-selected or aria-checked
   *  set to true. All options that are selectable but not selected have either aria-selected or
   *  aria-checked set to false."
   *
   * Set `aria-selected="false"` on not-selected listbox options that are selectable to fix
   * VoiceOver reading every option as "selected" (#25736).
   */
  get ariaSelected() {
    return this.selectable ? this.selected.toString() : null;
  }
  /** The unstyled chip selector for this component. */
  basicChipAttrName = "mat-basic-chip-option";
  /** Emitted when the chip is selected or deselected. */
  selectionChange = new EventEmitter();
  ngOnInit() {
    super.ngOnInit();
    this.role = "presentation";
  }
  /** Selects the chip. */
  select() {
    this._setSelectedState(true, false, true);
  }
  /** Deselects the chip. */
  deselect() {
    this._setSelectedState(false, false, true);
  }
  /** Selects this chip and emits userInputSelection event */
  selectViaInteraction() {
    this._setSelectedState(true, true, true);
  }
  /** Toggles the current selected state of this chip. */
  toggleSelected(isUserInput = false) {
    this._setSelectedState(!this.selected, isUserInput, true);
    return this.selected;
  }
  _handlePrimaryActionInteraction() {
    if (!this.disabled) {
      this.focus();
      if (this.selectable) {
        this.toggleSelected(true);
      }
    }
  }
  _hasLeadingGraphic() {
    if (this.leadingIcon) {
      return true;
    }
    return !this._chipListHideSingleSelectionIndicator || this._chipListMultiple;
  }
  _setSelectedState(isSelected, isUserInput, emitEvent) {
    if (isSelected !== this.selected) {
      this._selected = isSelected;
      if (emitEvent) {
        this.selectionChange.emit({
          source: this,
          isUserInput,
          selected: this.selected
        });
      }
      this._changeDetectorRef.markForCheck();
    }
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatChipOption_BaseFactory;
    return function MatChipOption_Factory(__ngFactoryType__) {
      return (ɵMatChipOption_BaseFactory || (ɵMatChipOption_BaseFactory = ɵɵgetInheritedFactory(_MatChipOption)))(__ngFactoryType__ || _MatChipOption);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatChipOption,
    selectors: [["mat-basic-chip-option"], ["", "mat-basic-chip-option", ""], ["mat-chip-option"], ["", "mat-chip-option", ""]],
    hostAttrs: [1, "mat-mdc-chip", "mat-mdc-chip-option"],
    hostVars: 37,
    hostBindings: function MatChipOption_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
        ɵɵattribute("tabindex", null)("aria-label", null)("aria-description", null)("role", ctx.role);
        ɵɵclassProp("mdc-evolution-chip", !ctx._isBasicChip)("mdc-evolution-chip--filter", !ctx._isBasicChip)("mdc-evolution-chip--selectable", !ctx._isBasicChip)("mat-mdc-chip-selected", ctx.selected)("mat-mdc-chip-multiple", ctx._chipListMultiple)("mat-mdc-chip-disabled", ctx.disabled)("mat-mdc-chip-with-avatar", ctx.leadingIcon)("mdc-evolution-chip--disabled", ctx.disabled)("mdc-evolution-chip--selected", ctx.selected)("mdc-evolution-chip--selecting", !ctx._animationsDisabled)("mdc-evolution-chip--with-trailing-action", ctx._hasTrailingIcon())("mdc-evolution-chip--with-primary-icon", ctx.leadingIcon)("mdc-evolution-chip--with-primary-graphic", ctx._hasLeadingGraphic())("mdc-evolution-chip--with-avatar", ctx.leadingIcon)("mat-mdc-chip-highlighted", ctx.highlighted)("mat-mdc-chip-with-trailing-icon", ctx._hasTrailingIcon());
      }
    },
    inputs: {
      selectable: [2, "selectable", "selectable", booleanAttribute],
      selected: [2, "selected", "selected", booleanAttribute]
    },
    outputs: {
      selectionChange: "selectionChange"
    },
    features: [ɵɵProvidersFeature([{
      provide: MatChip,
      useExisting: _MatChipOption
    }, {
      provide: MAT_CHIP,
      useExisting: _MatChipOption
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c17,
    decls: 10,
    vars: 8,
    consts: [[1, "mat-mdc-chip-focus-overlay"], [1, "mdc-evolution-chip__cell", "mdc-evolution-chip__cell--primary"], ["matChipAction", "", "role", "option", 3, "_allowFocusWhenDisabled"], [1, "mdc-evolution-chip__graphic", "mat-mdc-chip-graphic"], [1, "mdc-evolution-chip__text-label", "mat-mdc-chip-action-label"], [1, "mat-mdc-chip-primary-focus-indicator", "mat-focus-indicator"], [1, "mdc-evolution-chip__cell", "mdc-evolution-chip__cell--trailing"], [1, "cdk-visually-hidden", 3, "id"], [1, "mdc-evolution-chip__checkmark"], ["viewBox", "-2 -3 30 30", "focusable", "false", "aria-hidden", "true", 1, "mdc-evolution-chip__checkmark-svg"], ["fill", "none", "stroke", "currentColor", "d", "M1.73,12.91 8.1,19.28 22.79,4.59", 1, "mdc-evolution-chip__checkmark-path"]],
    template: function MatChipOption_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c07);
        ɵɵelement(0, "span", 0);
        ɵɵelementStart(1, "span", 1)(2, "button", 2);
        ɵɵtemplate(3, MatChipOption_Conditional_3_Template, 5, 0, "span", 3);
        ɵɵelementStart(4, "span", 4);
        ɵɵprojection(5);
        ɵɵelement(6, "span", 5);
        ɵɵelementEnd()()();
        ɵɵtemplate(7, MatChipOption_Conditional_7_Template, 2, 0, "span", 6);
        ɵɵelementStart(8, "span", 7);
        ɵɵtext(9);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("_allowFocusWhenDisabled", true);
        ɵɵattribute("aria-selected", ctx.ariaSelected)("aria-label", ctx.ariaLabel)("aria-describedby", ctx._ariaDescriptionId);
        ɵɵadvance();
        ɵɵconditional(ctx._hasLeadingGraphic() ? 3 : -1);
        ɵɵadvance(4);
        ɵɵconditional(ctx._hasTrailingIcon() ? 7 : -1);
        ɵɵadvance();
        ɵɵproperty("id", ctx._ariaDescriptionId);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.ariaDescription);
      }
    },
    dependencies: [MatChipAction],
    styles: [_c23],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipOption, [{
    type: Component,
    args: [{
      selector: "mat-basic-chip-option, [mat-basic-chip-option], mat-chip-option, [mat-chip-option]",
      host: {
        "class": "mat-mdc-chip mat-mdc-chip-option",
        "[class.mdc-evolution-chip]": "!_isBasicChip",
        "[class.mdc-evolution-chip--filter]": "!_isBasicChip",
        "[class.mdc-evolution-chip--selectable]": "!_isBasicChip",
        "[class.mat-mdc-chip-selected]": "selected",
        "[class.mat-mdc-chip-multiple]": "_chipListMultiple",
        "[class.mat-mdc-chip-disabled]": "disabled",
        "[class.mat-mdc-chip-with-avatar]": "leadingIcon",
        "[class.mdc-evolution-chip--disabled]": "disabled",
        "[class.mdc-evolution-chip--selected]": "selected",
        // This class enables the transition on the checkmark. Usually MDC adds it when selection
        // starts and removes it once the animation is finished. We don't need to go through all
        // the trouble, because we only care about the selection animation. MDC needs to do it,
        // because they also have an exit animation that we don't care about.
        "[class.mdc-evolution-chip--selecting]": "!_animationsDisabled",
        "[class.mdc-evolution-chip--with-trailing-action]": "_hasTrailingIcon()",
        "[class.mdc-evolution-chip--with-primary-icon]": "leadingIcon",
        "[class.mdc-evolution-chip--with-primary-graphic]": "_hasLeadingGraphic()",
        "[class.mdc-evolution-chip--with-avatar]": "leadingIcon",
        "[class.mat-mdc-chip-highlighted]": "highlighted",
        "[class.mat-mdc-chip-with-trailing-icon]": "_hasTrailingIcon()",
        "[attr.tabindex]": "null",
        "[attr.aria-label]": "null",
        "[attr.aria-description]": "null",
        "[attr.role]": "role",
        "[id]": "id"
      },
      providers: [{
        provide: MatChip,
        useExisting: MatChipOption
      }, {
        provide: MAT_CHIP,
        useExisting: MatChipOption
      }],
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [MatChipAction],
      template: '<span class="mat-mdc-chip-focus-overlay"></span>\n\n<span class="mdc-evolution-chip__cell mdc-evolution-chip__cell--primary">\n  <button\n    matChipAction\n    [_allowFocusWhenDisabled]="true"\n    [attr.aria-selected]="ariaSelected"\n    [attr.aria-label]="ariaLabel"\n    [attr.aria-describedby]="_ariaDescriptionId"\n    role="option">\n    @if (_hasLeadingGraphic()) {\n      <span class="mdc-evolution-chip__graphic mat-mdc-chip-graphic">\n        <ng-content select="mat-chip-avatar, [matChipAvatar]"></ng-content>\n        <span class="mdc-evolution-chip__checkmark">\n          <svg\n            class="mdc-evolution-chip__checkmark-svg"\n            viewBox="-2 -3 30 30"\n            focusable="false"\n            aria-hidden="true">\n            <path class="mdc-evolution-chip__checkmark-path"\n                  fill="none" stroke="currentColor" d="M1.73,12.91 8.1,19.28 22.79,4.59" />\n          </svg>\n        </span>\n      </span>\n    }\n    <span class="mdc-evolution-chip__text-label mat-mdc-chip-action-label">\n      <ng-content></ng-content>\n      <span class="mat-mdc-chip-primary-focus-indicator mat-focus-indicator"></span>\n    </span>\n  </button>\n</span>\n\n@if (_hasTrailingIcon()) {\n  <span class="mdc-evolution-chip__cell mdc-evolution-chip__cell--trailing">\n    <ng-content select="mat-chip-trailing-icon,[matChipRemove],[matChipTrailingIcon]"></ng-content>\n  </span>\n}\n\n<span class="cdk-visually-hidden" [id]="_ariaDescriptionId">{{ariaDescription}}</span>\n',
      styles: ['.mdc-evolution-chip,.mdc-evolution-chip__cell,.mdc-evolution-chip__action{display:inline-flex;align-items:center}.mdc-evolution-chip{position:relative;max-width:100%}.mdc-evolution-chip__cell,.mdc-evolution-chip__action{height:100%}.mdc-evolution-chip__cell--primary{flex-basis:100%;overflow-x:hidden}.mdc-evolution-chip__cell--trailing{flex:1 0 auto}.mdc-evolution-chip__action{align-items:center;background:none;border:none;box-sizing:content-box;cursor:pointer;display:inline-flex;justify-content:center;outline:none;padding:0;text-decoration:none;color:inherit}.mdc-evolution-chip__action--presentational{cursor:auto}.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{pointer-events:none}@media(forced-colors: active){.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{forced-color-adjust:none}}.mdc-evolution-chip__action--primary{font:inherit;letter-spacing:inherit;white-space:inherit;overflow-x:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-outline-width, 1px);border-radius:var(--mdc-chip-container-shape-radius, 8px);box-sizing:border-box;content:"";height:100%;left:0;position:absolute;pointer-events:none;top:0;width:100%;z-index:1;border-style:solid}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-outline-color, var(--mat-sys-outline))}.mdc-evolution-chip__action--primary:not(.mdc-evolution-chip__action--presentational):not(.mdc-ripple-upgraded):focus::before{border-color:var(--mdc-chip-focus-outline-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-basic-chip .mdc-evolution-chip__action--primary{font:inherit}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip__action--trailing{position:relative;overflow:visible}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-trailing-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip__text-label{-webkit-user-select:none;user-select:none;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__text-label{font-family:var(--mdc-chip-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mdc-chip-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mdc-chip-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mdc-chip-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mdc-chip-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-label-text-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label,.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-evolution-chip__graphic{align-items:center;display:inline-flex;justify-content:center;overflow:hidden;pointer-events:none;position:relative;flex:1 0 auto}.mat-mdc-standard-chip .mdc-evolution-chip__graphic{width:var(--mdc-chip-with-avatar-avatar-size, 24px);height:var(--mdc-chip-with-avatar-avatar-size, 24px);font-size:var(--mdc-chip-with-avatar-avatar-size, 24px)}.mdc-evolution-chip--selecting .mdc-evolution-chip__graphic{transition:width 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--selected):not(.mdc-evolution-chip--with-primary-icon) .mdc-evolution-chip__graphic{width:0}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mdc-evolution-chip__checkmark{position:absolute;opacity:0;top:50%;left:50%;height:20px;width:20px}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark{transition:transform 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{transform:translate(-50%, -50%);opacity:1}.mdc-evolution-chip__checkmark-svg{display:block}.mdc-evolution-chip__checkmark-path{stroke-width:2px;stroke-dasharray:29.7833385;stroke-dashoffset:29.7833385;stroke:currentColor}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}@media(forced-colors: active){.mdc-evolution-chip__checkmark-path{stroke:CanvasText !important}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--trailing{height:18px;width:18px;font-size:18px}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove{opacity:calc(var(--mat-chip-trailing-action-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove:focus{opacity:calc(var(--mat-chip-trailing-action-focus-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mat-mdc-standard-chip{border-radius:var(--mdc-chip-container-shape-radius, 8px);height:var(--mdc-chip-container-height, 32px)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-container-color, transparent)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-flat-disabled-selected-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}@media(forced-colors: active){.mat-mdc-standard-chip{outline:solid 1px}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{border-radius:var(--mdc-chip-with-avatar-avatar-shape-radius, 24px);width:var(--mdc-chip-with-icon-icon-size, 18px);height:var(--mdc-chip-with-icon-icon-size, 18px);font-size:var(--mdc-chip-with-icon-icon-size, 18px)}.mdc-evolution-chip--selected .mdc-evolution-chip__icon--primary{opacity:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-highlighted{--mdc-chip-with-icon-icon-color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container));--mdc-chip-elevated-container-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container));--mdc-chip-label-text-color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container));--mdc-chip-outline-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-selected .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-chip:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-hover-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-focus-overlay .mat-mdc-chip-selected:hover,.mat-mdc-chip-highlighted:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-hover-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected.cdk-focused .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-evolution-chip--disabled:not(.mdc-evolution-chip--selected) .mat-mdc-chip-avatar{opacity:var(--mdc-chip-with-avatar-disabled-avatar-opacity, 0.38)}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{opacity:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38)}.mdc-evolution-chip--disabled.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{opacity:var(--mdc-chip-with-icon-disabled-icon-opacity, 0.38)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{opacity:var(--mat-chip-disabled-container-opacity, 1)}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-trailing-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-remove{opacity:var(--mat-chip-trailing-action-opacity, 1)}.mat-mdc-chip-remove:focus{opacity:var(--mat-chip-trailing-action-focus-opacity, 1)}.mat-mdc-chip-remove::after{background-color:var(--mat-chip-trailing-action-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-remove:hover::after{opacity:var(--mat-chip-trailing-action-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-remove:focus::after{opacity:var(--mat-chip-trailing-action-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected .mat-mdc-chip-remove::after,.mat-mdc-chip-highlighted .mat-mdc-chip-remove::after{background-color:var(--mat-chip-selected-trailing-action-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mat-mdc-chip-action-label{overflow:visible}.mat-mdc-standard-chip .mat-mdc-chip-graphic,.mat-mdc-standard-chip .mat-mdc-chip-trailing-icon{box-sizing:content-box}.mat-mdc-standard-chip._mat-animation-noopable,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__graphic,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark-path{transition-duration:1ms;animation-duration:1ms}.mat-mdc-chip-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;opacity:0;border-radius:inherit;transition:opacity 150ms linear}._mat-animation-noopable .mat-mdc-chip-focus-overlay{transition:none}.mat-mdc-basic-chip .mat-mdc-chip-focus-overlay{display:none}.mat-mdc-chip .mat-ripple.mat-mdc-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-chip-avatar{text-align:center;line-height:1;color:var(--mdc-chip-with-icon-icon-color, currentColor)}.mat-mdc-chip{position:relative;z-index:0}.mat-mdc-chip-action-label{text-align:left;z-index:1}[dir=rtl] .mat-mdc-chip-action-label{text-align:right}.mat-mdc-chip.mdc-evolution-chip--with-trailing-action .mat-mdc-chip-action-label{position:relative}.mat-mdc-chip-action-label .mat-mdc-chip-primary-focus-indicator{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.mat-mdc-chip-action-label .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-chip-remove::before{margin:calc(var(--mat-focus-indicator-border-width, 3px)*-1);left:8px;right:8px}.mat-mdc-chip-remove::after{content:"";display:block;opacity:0;position:absolute;top:-3px;bottom:-3px;left:5px;right:5px;border-radius:50%;box-sizing:border-box;padding:12px;margin:-12px;background-clip:content-box}.mat-mdc-chip-remove .mat-icon{width:18px;height:18px;font-size:18px;box-sizing:content-box}.mat-chip-edit-input{cursor:text;display:inline-block;color:inherit;outline:0}@media(forced-colors: active){.mat-mdc-chip-selected:not(.mat-mdc-chip-multiple){outline-width:3px}}.mat-mdc-chip-action:focus .mat-focus-indicator::before{content:""}']
    }]
  }], null, {
    selectable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    selected: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    selectionChange: [{
      type: Output
    }]
  });
})();
var MatChipEditInput = class _MatChipEditInput {
  _elementRef = inject(ElementRef);
  _document = inject(DOCUMENT);
  constructor() {}
  initialize(initialValue) {
    this.getNativeElement().focus();
    this.setValue(initialValue);
  }
  getNativeElement() {
    return this._elementRef.nativeElement;
  }
  setValue(value) {
    this.getNativeElement().textContent = value;
    this._moveCursorToEndOfInput();
  }
  getValue() {
    return this.getNativeElement().textContent || "";
  }
  _moveCursorToEndOfInput() {
    const range2 = this._document.createRange();
    range2.selectNodeContents(this.getNativeElement());
    range2.collapse(false);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range2);
  }
  static ɵfac = function MatChipEditInput_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChipEditInput)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatChipEditInput,
    selectors: [["span", "matChipEditInput", ""]],
    hostAttrs: ["role", "textbox", "tabindex", "-1", "contenteditable", "true", 1, "mat-chip-edit-input"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipEditInput, [{
    type: Directive,
    args: [{
      selector: "span[matChipEditInput]",
      host: {
        "class": "mat-chip-edit-input",
        "role": "textbox",
        "tabindex": "-1",
        "contenteditable": "true"
      }
    }]
  }], () => [], null);
})();
var MatChipRow = class _MatChipRow extends MatChip {
  basicChipAttrName = "mat-basic-chip-row";
  /**
   * The editing action has to be triggered in a timeout. While we're waiting on it, a blur
   * event might occur which will interrupt the editing. This flag is used to avoid interruptions
   * while the editing action is being initialized.
   */
  _editStartPending = false;
  editable = false;
  /** Emitted when the chip is edited. */
  edited = new EventEmitter();
  /** The default chip edit input that is used if none is projected into this chip row. */
  defaultEditInput;
  /** The projected chip edit input. */
  contentEditInput;
  _isEditing = false;
  constructor() {
    super();
    this.role = "row";
    this._onBlur.pipe(takeUntil(this.destroyed)).subscribe(() => {
      if (this._isEditing && !this._editStartPending) {
        this._onEditFinish();
      }
    });
  }
  _hasTrailingIcon() {
    return !this._isEditing && super._hasTrailingIcon();
  }
  /** Sends focus to the first gridcell when the user clicks anywhere inside the chip. */
  _handleFocus() {
    if (!this._isEditing && !this.disabled) {
      this.focus();
    }
  }
  _handleKeydown(event) {
    if (event.keyCode === ENTER && !this.disabled) {
      if (this._isEditing) {
        event.preventDefault();
        this._onEditFinish();
      } else if (this.editable) {
        this._startEditing(event);
      }
    } else if (this._isEditing) {
      event.stopPropagation();
    } else {
      super._handleKeydown(event);
    }
  }
  _handleDoubleclick(event) {
    if (!this.disabled && this.editable) {
      this._startEditing(event);
    }
  }
  _startEditing(event) {
    if (!this.primaryAction || this.removeIcon && this._getSourceAction(event.target) === this.removeIcon) {
      return;
    }
    const value = this.value;
    this._isEditing = this._editStartPending = true;
    afterNextRender(() => {
      this._getEditInput().initialize(value);
      this._editStartPending = false;
    }, {
      injector: this._injector
    });
  }
  _onEditFinish() {
    this._isEditing = this._editStartPending = false;
    this.edited.emit({
      chip: this,
      value: this._getEditInput().getValue()
    });
    if (this._document.activeElement === this._getEditInput().getNativeElement() || this._document.activeElement === this._document.body) {
      this.primaryAction.focus();
    }
  }
  _isRippleDisabled() {
    return super._isRippleDisabled() || this._isEditing;
  }
  /**
   * Gets the projected chip edit input, or the default input if none is projected in. One of these
   * two values is guaranteed to be defined.
   */
  _getEditInput() {
    return this.contentEditInput || this.defaultEditInput;
  }
  static ɵfac = function MatChipRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChipRow)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatChipRow,
    selectors: [["mat-chip-row"], ["", "mat-chip-row", ""], ["mat-basic-chip-row"], ["", "mat-basic-chip-row", ""]],
    contentQueries: function MatChipRow_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatChipEditInput, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.contentEditInput = _t2.first);
      }
    },
    viewQuery: function MatChipRow_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(MatChipEditInput, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.defaultEditInput = _t2.first);
      }
    },
    hostAttrs: [1, "mat-mdc-chip", "mat-mdc-chip-row", "mdc-evolution-chip"],
    hostVars: 27,
    hostBindings: function MatChipRow_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function MatChipRow_focus_HostBindingHandler() {
          return ctx._handleFocus();
        })("dblclick", function MatChipRow_dblclick_HostBindingHandler($event) {
          return ctx._handleDoubleclick($event);
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
        ɵɵattribute("tabindex", ctx.disabled ? null : -1)("aria-label", null)("aria-description", null)("role", ctx.role);
        ɵɵclassProp("mat-mdc-chip-with-avatar", ctx.leadingIcon)("mat-mdc-chip-disabled", ctx.disabled)("mat-mdc-chip-editing", ctx._isEditing)("mat-mdc-chip-editable", ctx.editable)("mdc-evolution-chip--disabled", ctx.disabled)("mdc-evolution-chip--with-trailing-action", ctx._hasTrailingIcon())("mdc-evolution-chip--with-primary-graphic", ctx.leadingIcon)("mdc-evolution-chip--with-primary-icon", ctx.leadingIcon)("mdc-evolution-chip--with-avatar", ctx.leadingIcon)("mat-mdc-chip-highlighted", ctx.highlighted)("mat-mdc-chip-with-trailing-icon", ctx._hasTrailingIcon());
      }
    },
    inputs: {
      editable: "editable"
    },
    outputs: {
      edited: "edited"
    },
    features: [ɵɵProvidersFeature([{
      provide: MatChip,
      useExisting: _MatChipRow
    }, {
      provide: MAT_CHIP,
      useExisting: _MatChipRow
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c42,
    decls: 10,
    vars: 9,
    consts: [[1, "mat-mdc-chip-focus-overlay"], ["role", "gridcell", "matChipAction", "", 1, "mdc-evolution-chip__cell", "mdc-evolution-chip__cell--primary", 3, "disabled"], [1, "mdc-evolution-chip__graphic", "mat-mdc-chip-graphic"], [1, "mdc-evolution-chip__text-label", "mat-mdc-chip-action-label"], ["aria-hidden", "true", 1, "mat-mdc-chip-primary-focus-indicator", "mat-focus-indicator"], ["role", "gridcell", 1, "mdc-evolution-chip__cell", "mdc-evolution-chip__cell--trailing"], [1, "cdk-visually-hidden", 3, "id"], ["matChipEditInput", ""]],
    template: function MatChipRow_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c33);
        ɵɵtemplate(0, MatChipRow_Conditional_0_Template, 1, 0, "span", 0);
        ɵɵelementStart(1, "span", 1);
        ɵɵtemplate(2, MatChipRow_Conditional_2_Template, 2, 0, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵtemplate(4, MatChipRow_Conditional_4_Template, 2, 1)(5, MatChipRow_Conditional_5_Template, 1, 0);
        ɵɵelement(6, "span", 4);
        ɵɵelementEnd()();
        ɵɵtemplate(7, MatChipRow_Conditional_7_Template, 2, 0, "span", 5);
        ɵɵelementStart(8, "span", 6);
        ɵɵtext(9);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵconditional(!ctx._isEditing ? 0 : -1);
        ɵɵadvance();
        ɵɵproperty("disabled", ctx.disabled);
        ɵɵattribute("aria-label", ctx.ariaLabel)("aria-describedby", ctx._ariaDescriptionId);
        ɵɵadvance();
        ɵɵconditional(ctx.leadingIcon ? 2 : -1);
        ɵɵadvance(2);
        ɵɵconditional(ctx._isEditing ? 4 : 5);
        ɵɵadvance(3);
        ɵɵconditional(ctx._hasTrailingIcon() ? 7 : -1);
        ɵɵadvance();
        ɵɵproperty("id", ctx._ariaDescriptionId);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.ariaDescription);
      }
    },
    dependencies: [MatChipAction, MatChipEditInput],
    styles: [_c23],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipRow, [{
    type: Component,
    args: [{
      selector: "mat-chip-row, [mat-chip-row], mat-basic-chip-row, [mat-basic-chip-row]",
      host: {
        "class": "mat-mdc-chip mat-mdc-chip-row mdc-evolution-chip",
        "[class.mat-mdc-chip-with-avatar]": "leadingIcon",
        "[class.mat-mdc-chip-disabled]": "disabled",
        "[class.mat-mdc-chip-editing]": "_isEditing",
        "[class.mat-mdc-chip-editable]": "editable",
        "[class.mdc-evolution-chip--disabled]": "disabled",
        "[class.mdc-evolution-chip--with-trailing-action]": "_hasTrailingIcon()",
        "[class.mdc-evolution-chip--with-primary-graphic]": "leadingIcon",
        "[class.mdc-evolution-chip--with-primary-icon]": "leadingIcon",
        "[class.mdc-evolution-chip--with-avatar]": "leadingIcon",
        "[class.mat-mdc-chip-highlighted]": "highlighted",
        "[class.mat-mdc-chip-with-trailing-icon]": "_hasTrailingIcon()",
        "[id]": "id",
        // Has to have a negative tabindex in order to capture
        // focus and redirect it to the primary action.
        "[attr.tabindex]": "disabled ? null : -1",
        "[attr.aria-label]": "null",
        "[attr.aria-description]": "null",
        "[attr.role]": "role",
        "(focus)": "_handleFocus()",
        "(dblclick)": "_handleDoubleclick($event)"
      },
      providers: [{
        provide: MatChip,
        useExisting: MatChipRow
      }, {
        provide: MAT_CHIP,
        useExisting: MatChipRow
      }],
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [MatChipAction, MatChipEditInput],
      template: '@if (!_isEditing) {\n  <span class="mat-mdc-chip-focus-overlay"></span>\n}\n\n<span class="mdc-evolution-chip__cell mdc-evolution-chip__cell--primary" role="gridcell"\n    matChipAction\n    [disabled]="disabled"\n    [attr.aria-label]="ariaLabel"\n    [attr.aria-describedby]="_ariaDescriptionId">\n  @if (leadingIcon) {\n    <span class="mdc-evolution-chip__graphic mat-mdc-chip-graphic">\n      <ng-content select="mat-chip-avatar, [matChipAvatar]"></ng-content>\n    </span>\n  }\n\n  <span class="mdc-evolution-chip__text-label mat-mdc-chip-action-label">\n    @if (_isEditing) {\n      @if (contentEditInput) {\n        <ng-content select="[matChipEditInput]"></ng-content>\n      } @else {\n        <span matChipEditInput></span>\n      }\n    } @else {\n      <ng-content></ng-content>\n    }\n\n    <span class="mat-mdc-chip-primary-focus-indicator mat-focus-indicator" aria-hidden="true"></span>\n  </span>\n</span>\n\n@if (_hasTrailingIcon()) {\n  <span\n    class="mdc-evolution-chip__cell mdc-evolution-chip__cell--trailing"\n    role="gridcell">\n    <ng-content select="mat-chip-trailing-icon,[matChipRemove],[matChipTrailingIcon]"></ng-content>\n  </span>\n}\n\n<span class="cdk-visually-hidden" [id]="_ariaDescriptionId">{{ariaDescription}}</span>\n',
      styles: ['.mdc-evolution-chip,.mdc-evolution-chip__cell,.mdc-evolution-chip__action{display:inline-flex;align-items:center}.mdc-evolution-chip{position:relative;max-width:100%}.mdc-evolution-chip__cell,.mdc-evolution-chip__action{height:100%}.mdc-evolution-chip__cell--primary{flex-basis:100%;overflow-x:hidden}.mdc-evolution-chip__cell--trailing{flex:1 0 auto}.mdc-evolution-chip__action{align-items:center;background:none;border:none;box-sizing:content-box;cursor:pointer;display:inline-flex;justify-content:center;outline:none;padding:0;text-decoration:none;color:inherit}.mdc-evolution-chip__action--presentational{cursor:auto}.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{pointer-events:none}@media(forced-colors: active){.mdc-evolution-chip--disabled,.mdc-evolution-chip__action:disabled{forced-color-adjust:none}}.mdc-evolution-chip__action--primary{font:inherit;letter-spacing:inherit;white-space:inherit;overflow-x:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-outline-width, 1px);border-radius:var(--mdc-chip-container-shape-radius, 8px);box-sizing:border-box;content:"";height:100%;left:0;position:absolute;pointer-events:none;top:0;width:100%;z-index:1;border-style:solid}.mat-mdc-standard-chip .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-outline-color, var(--mat-sys-outline))}.mdc-evolution-chip__action--primary:not(.mdc-evolution-chip__action--presentational):not(.mdc-ripple-upgraded):focus::before{border-color:var(--mdc-chip-focus-outline-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--primary::before{border-color:var(--mdc-chip-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__action--primary::before{border-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-basic-chip .mdc-evolution-chip__action--primary{font:inherit}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:0;padding-right:12px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__action--primary{padding-left:12px;padding-right:0}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--primary{padding-left:0;padding-right:0}.mdc-evolution-chip__action--trailing{position:relative;overflow:visible}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-trailing-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__action--trailing{color:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-standard-chip.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__action--trailing{padding-left:8px;padding-right:8px}.mdc-evolution-chip__text-label{-webkit-user-select:none;user-select:none;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.mat-mdc-standard-chip .mdc-evolution-chip__text-label{font-family:var(--mdc-chip-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mdc-chip-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mdc-chip-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mdc-chip-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mdc-chip-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-label-text-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__text-label{color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label,.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__text-label{color:var(--mdc-chip-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-evolution-chip__graphic{align-items:center;display:inline-flex;justify-content:center;overflow:hidden;pointer-events:none;position:relative;flex:1 0 auto}.mat-mdc-standard-chip .mdc-evolution-chip__graphic{width:var(--mdc-chip-with-avatar-avatar-size, 24px);height:var(--mdc-chip-with-avatar-avatar-size, 24px);font-size:var(--mdc-chip-with-avatar-avatar-size, 24px)}.mdc-evolution-chip--selecting .mdc-evolution-chip__graphic{transition:width 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selectable:not(.mdc-evolution-chip--selected):not(.mdc-evolution-chip--with-primary-icon) .mdc-evolution-chip__graphic{width:0}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mat-mdc-standard-chip.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:6px;padding-right:6px}.mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:4px;padding-right:8px}[dir=rtl] .mdc-evolution-chip--with-avatar.mdc-evolution-chip--with-primary-graphic.mdc-evolution-chip--with-trailing-action .mdc-evolution-chip__graphic{padding-left:8px;padding-right:4px}.mdc-evolution-chip__checkmark{position:absolute;opacity:0;top:50%;left:50%;height:20px;width:20px}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__checkmark{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark{transition:transform 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);transform:translate(-75%, -50%)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{transform:translate(-50%, -50%);opacity:1}.mdc-evolution-chip__checkmark-svg{display:block}.mdc-evolution-chip__checkmark-path{stroke-width:2px;stroke-dasharray:29.7833385;stroke-dashoffset:29.7833385;stroke:currentColor}.mdc-evolution-chip--selecting .mdc-evolution-chip__checkmark-path{transition:stroke-dashoffset 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark-path{stroke-dashoffset:0}@media(forced-colors: active){.mdc-evolution-chip__checkmark-path{stroke:CanvasText !important}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--trailing{height:18px;width:18px;font-size:18px}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove{opacity:calc(var(--mat-chip-trailing-action-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing.mat-mdc-chip-remove:focus{opacity:calc(var(--mat-chip-trailing-action-focus-opacity, 1)*var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38))}.mat-mdc-standard-chip{border-radius:var(--mdc-chip-container-shape-radius, 8px);height:var(--mdc-chip-container-height, 32px)}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-container-color, transparent)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-elevated-disabled-container-color)}.mat-mdc-standard-chip.mdc-evolution-chip--selected:not(.mdc-evolution-chip--disabled){background-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled{background-color:var(--mdc-chip-flat-disabled-selected-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}@media(forced-colors: active){.mat-mdc-standard-chip{outline:solid 1px}}.mat-mdc-standard-chip .mdc-evolution-chip__icon--primary{border-radius:var(--mdc-chip-with-avatar-avatar-shape-radius, 24px);width:var(--mdc-chip-with-icon-icon-size, 18px);height:var(--mdc-chip-with-icon-icon-size, 18px);font-size:var(--mdc-chip-with-icon-icon-size, 18px)}.mdc-evolution-chip--selected .mdc-evolution-chip__icon--primary{opacity:0}.mat-mdc-standard-chip:not(.mdc-evolution-chip--disabled) .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-standard-chip.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--primary{color:var(--mdc-chip-with-icon-disabled-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-highlighted{--mdc-chip-with-icon-icon-color:var(--mdc-chip-with-icon-selected-icon-color, var(--mat-sys-on-secondary-container));--mdc-chip-elevated-container-color:var(--mdc-chip-elevated-selected-container-color, var(--mat-sys-secondary-container));--mdc-chip-label-text-color:var(--mdc-chip-selected-label-text-color, var(--mat-sys-on-secondary-container));--mdc-chip-outline-width:var(--mdc-chip-flat-selected-outline-width, 0)}.mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-selected .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-chip:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-hover-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-focus-overlay .mat-mdc-chip-selected:hover,.mat-mdc-chip-highlighted:hover .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-hover-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-focus-state-layer-color, var(--mat-sys-on-surface-variant));opacity:var(--mdc-chip-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected.cdk-focused .mat-mdc-chip-focus-overlay,.mat-mdc-chip-highlighted.cdk-focused .mat-mdc-chip-focus-overlay{background:var(--mdc-chip-selected-focus-state-layer-color, var(--mat-sys-on-secondary-container));opacity:var(--mdc-chip-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-evolution-chip--disabled:not(.mdc-evolution-chip--selected) .mat-mdc-chip-avatar{opacity:var(--mdc-chip-with-avatar-disabled-avatar-opacity, 0.38)}.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{opacity:var(--mdc-chip-with-trailing-icon-disabled-trailing-icon-opacity, 0.38)}.mdc-evolution-chip--disabled.mdc-evolution-chip--selected .mdc-evolution-chip__checkmark{opacity:var(--mdc-chip-with-icon-disabled-icon-opacity, 0.38)}.mat-mdc-standard-chip.mdc-evolution-chip--disabled{opacity:var(--mat-chip-disabled-container-opacity, 1)}.mat-mdc-standard-chip.mdc-evolution-chip--selected .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-trailing-icon-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip.mdc-evolution-chip--selected.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing,.mat-mdc-standard-chip.mat-mdc-chip-highlighted.mdc-evolution-chip--disabled .mdc-evolution-chip__icon--trailing{color:var(--mat-chip-selected-disabled-trailing-icon-color, var(--mat-sys-on-surface))}.mat-mdc-chip-remove{opacity:var(--mat-chip-trailing-action-opacity, 1)}.mat-mdc-chip-remove:focus{opacity:var(--mat-chip-trailing-action-focus-opacity, 1)}.mat-mdc-chip-remove::after{background-color:var(--mat-chip-trailing-action-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-chip-remove:hover::after{opacity:var(--mat-chip-trailing-action-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-chip-remove:focus::after{opacity:var(--mat-chip-trailing-action-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-chip-selected .mat-mdc-chip-remove::after,.mat-mdc-chip-highlighted .mat-mdc-chip-remove::after{background-color:var(--mat-chip-selected-trailing-action-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-mdc-standard-chip{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-standard-chip .mdc-evolution-chip__cell--primary,.mat-mdc-standard-chip .mdc-evolution-chip__action--primary,.mat-mdc-standard-chip .mat-mdc-chip-action-label{overflow:visible}.mat-mdc-standard-chip .mat-mdc-chip-graphic,.mat-mdc-standard-chip .mat-mdc-chip-trailing-icon{box-sizing:content-box}.mat-mdc-standard-chip._mat-animation-noopable,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__graphic,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark,.mat-mdc-standard-chip._mat-animation-noopable .mdc-evolution-chip__checkmark-path{transition-duration:1ms;animation-duration:1ms}.mat-mdc-chip-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;opacity:0;border-radius:inherit;transition:opacity 150ms linear}._mat-animation-noopable .mat-mdc-chip-focus-overlay{transition:none}.mat-mdc-basic-chip .mat-mdc-chip-focus-overlay{display:none}.mat-mdc-chip .mat-ripple.mat-mdc-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-chip-avatar{text-align:center;line-height:1;color:var(--mdc-chip-with-icon-icon-color, currentColor)}.mat-mdc-chip{position:relative;z-index:0}.mat-mdc-chip-action-label{text-align:left;z-index:1}[dir=rtl] .mat-mdc-chip-action-label{text-align:right}.mat-mdc-chip.mdc-evolution-chip--with-trailing-action .mat-mdc-chip-action-label{position:relative}.mat-mdc-chip-action-label .mat-mdc-chip-primary-focus-indicator{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}.mat-mdc-chip-action-label .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-chip-remove::before{margin:calc(var(--mat-focus-indicator-border-width, 3px)*-1);left:8px;right:8px}.mat-mdc-chip-remove::after{content:"";display:block;opacity:0;position:absolute;top:-3px;bottom:-3px;left:5px;right:5px;border-radius:50%;box-sizing:border-box;padding:12px;margin:-12px;background-clip:content-box}.mat-mdc-chip-remove .mat-icon{width:18px;height:18px;font-size:18px;box-sizing:content-box}.mat-chip-edit-input{cursor:text;display:inline-block;color:inherit;outline:0}@media(forced-colors: active){.mat-mdc-chip-selected:not(.mat-mdc-chip-multiple){outline-width:3px}}.mat-mdc-chip-action:focus .mat-focus-indicator::before{content:""}']
    }]
  }], () => [], {
    editable: [{
      type: Input
    }],
    edited: [{
      type: Output
    }],
    defaultEditInput: [{
      type: ViewChild,
      args: [MatChipEditInput]
    }],
    contentEditInput: [{
      type: ContentChild,
      args: [MatChipEditInput]
    }]
  });
})();
var MatChipSet = class _MatChipSet {
  _elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _dir = inject(Directionality, {
    optional: true
  });
  /** Index of the last destroyed chip that had focus. */
  _lastDestroyedFocusedChipIndex = null;
  /** Used to manage focus within the chip list. */
  _keyManager;
  /** Subject that emits when the component has been destroyed. */
  _destroyed = new Subject();
  /** Role to use if it hasn't been overwritten by the user. */
  _defaultRole = "presentation";
  /** Combined stream of all of the child chips' focus events. */
  get chipFocusChanges() {
    return this._getChipStream(chip => chip._onFocus);
  }
  /** Combined stream of all of the child chips' destroy events. */
  get chipDestroyedChanges() {
    return this._getChipStream(chip => chip.destroyed);
  }
  /** Combined stream of all of the child chips' remove events. */
  get chipRemovedChanges() {
    return this._getChipStream(chip => chip.removed);
  }
  /** Whether the chip set is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._syncChipsState();
  }
  _disabled = false;
  /** Whether the chip list contains chips or not. */
  get empty() {
    return !this._chips || this._chips.length === 0;
  }
  /** The ARIA role applied to the chip set. */
  get role() {
    if (this._explicitRole) {
      return this._explicitRole;
    }
    return this.empty ? null : this._defaultRole;
  }
  /** Tabindex of the chip set. */
  tabIndex = 0;
  set role(value) {
    this._explicitRole = value;
  }
  _explicitRole = null;
  /** Whether any of the chips inside of this chip-set has focus. */
  get focused() {
    return this._hasFocusedChip();
  }
  /** The chips that are part of this chip set. */
  _chips;
  /** Flat list of all the actions contained within the chips. */
  _chipActions = new QueryList();
  constructor() {}
  ngAfterViewInit() {
    this._setUpFocusManagement();
    this._trackChipSetChanges();
    this._trackDestroyedFocusedChip();
  }
  ngOnDestroy() {
    this._keyManager?.destroy();
    this._chipActions.destroy();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Checks whether any of the chips is focused. */
  _hasFocusedChip() {
    return this._chips && this._chips.some(chip => chip._hasFocus());
  }
  /** Syncs the chip-set's state with the individual chips. */
  _syncChipsState() {
    this._chips?.forEach(chip => {
      chip._chipListDisabled = this._disabled;
      chip._changeDetectorRef.markForCheck();
    });
  }
  /** Dummy method for subclasses to override. Base chip set cannot be focused. */
  focus() {}
  /** Handles keyboard events on the chip set. */
  _handleKeydown(event) {
    if (this._originatesFromChip(event)) {
      this._keyManager.onKeydown(event);
    }
  }
  /**
   * Utility to ensure all indexes are valid.
   *
   * @param index The index to be checked.
   * @returns True if the index is valid for our list of chips.
   */
  _isValidIndex(index) {
    return index >= 0 && index < this._chips.length;
  }
  /**
   * Removes the `tabindex` from the chip set and resets it back afterwards, allowing the
   * user to tab out of it. This prevents the set from capturing focus and redirecting
   * it back to the first chip, creating a focus trap, if it user tries to tab away.
   */
  _allowFocusEscape() {
    const previous = this._elementRef.nativeElement.tabIndex;
    if (previous !== -1) {
      this._elementRef.nativeElement.tabIndex = -1;
      setTimeout(() => this._elementRef.nativeElement.tabIndex = previous);
    }
  }
  /**
   * Gets a stream of events from all the chips within the set.
   * The stream will automatically incorporate any newly-added chips.
   */
  _getChipStream(mappingFunction) {
    return this._chips.changes.pipe(startWith(null), switchMap(() => merge(...this._chips.map(mappingFunction))));
  }
  /** Checks whether an event comes from inside a chip element. */
  _originatesFromChip(event) {
    let currentElement = event.target;
    while (currentElement && currentElement !== this._elementRef.nativeElement) {
      if (currentElement.classList.contains("mat-mdc-chip")) {
        return true;
      }
      currentElement = currentElement.parentElement;
    }
    return false;
  }
  /** Sets up the chip set's focus management logic. */
  _setUpFocusManagement() {
    this._chips.changes.pipe(startWith(this._chips)).subscribe(chips => {
      const actions = [];
      chips.forEach(chip => chip._getActions().forEach(action => actions.push(action)));
      this._chipActions.reset(actions);
      this._chipActions.notifyOnChanges();
    });
    this._keyManager = new FocusKeyManager(this._chipActions).withVerticalOrientation().withHorizontalOrientation(this._dir ? this._dir.value : "ltr").withHomeAndEnd().skipPredicate(action => this._skipPredicate(action));
    this.chipFocusChanges.pipe(takeUntil(this._destroyed)).subscribe(({
      chip
    }) => {
      const action = chip._getSourceAction(document.activeElement);
      if (action) {
        this._keyManager.updateActiveItem(action);
      }
    });
    this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(direction => this._keyManager.withHorizontalOrientation(direction));
  }
  /**
   * Determines if key manager should avoid putting a given chip action in the tab index. Skip
   * non-interactive and disabled actions since the user can't do anything with them.
   */
  _skipPredicate(action) {
    return !action.isInteractive || action.disabled;
  }
  /** Listens to changes in the chip set and syncs up the state of the individual chips. */
  _trackChipSetChanges() {
    this._chips.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {
      if (this.disabled) {
        Promise.resolve().then(() => this._syncChipsState());
      }
      this._redirectDestroyedChipFocus();
    });
  }
  /** Starts tracking the destroyed chips in order to capture the focused one. */
  _trackDestroyedFocusedChip() {
    this.chipDestroyedChanges.pipe(takeUntil(this._destroyed)).subscribe(event => {
      const chipArray = this._chips.toArray();
      const chipIndex = chipArray.indexOf(event.chip);
      if (this._isValidIndex(chipIndex) && event.chip._hasFocus()) {
        this._lastDestroyedFocusedChipIndex = chipIndex;
      }
    });
  }
  /**
   * Finds the next appropriate chip to move focus to,
   * if the currently-focused chip is destroyed.
   */
  _redirectDestroyedChipFocus() {
    if (this._lastDestroyedFocusedChipIndex == null) {
      return;
    }
    if (this._chips.length) {
      const newIndex = Math.min(this._lastDestroyedFocusedChipIndex, this._chips.length - 1);
      const chipToFocus = this._chips.toArray()[newIndex];
      if (chipToFocus.disabled) {
        if (this._chips.length === 1) {
          this.focus();
        } else {
          this._keyManager.setPreviousItemActive();
        }
      } else {
        chipToFocus.focus();
      }
    } else {
      this.focus();
    }
    this._lastDestroyedFocusedChipIndex = null;
  }
  static ɵfac = function MatChipSet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChipSet)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatChipSet,
    selectors: [["mat-chip-set"]],
    contentQueries: function MatChipSet_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatChip, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._chips = _t2);
      }
    },
    hostAttrs: [1, "mat-mdc-chip-set", "mdc-evolution-chip-set"],
    hostVars: 1,
    hostBindings: function MatChipSet_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function MatChipSet_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.role);
      }
    },
    inputs: {
      disabled: [2, "disabled", "disabled", booleanAttribute],
      role: "role",
      tabIndex: [2, "tabIndex", "tabIndex", value => value == null ? 0 : numberAttribute(value)]
    },
    ngContentSelectors: _c5,
    decls: 2,
    vars: 0,
    consts: [["role", "presentation", 1, "mdc-evolution-chip-set__chips"]],
    template: function MatChipSet_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵprojection(1);
        ɵɵelementEnd();
      }
    },
    styles: [".mat-mdc-chip-set{display:flex}.mat-mdc-chip-set:focus{outline:none}.mat-mdc-chip-set .mdc-evolution-chip-set__chips{min-width:100%;margin-left:-8px;margin-right:0}.mat-mdc-chip-set .mdc-evolution-chip{margin:4px 0 4px 8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip-set__chips{margin-left:0;margin-right:-8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip{margin-left:0;margin-right:8px}.mdc-evolution-chip-set__chips{display:flex;flex-flow:wrap;min-width:0}.mat-mdc-chip-set-stacked{flex-direction:column;align-items:flex-start}.mat-mdc-chip-set-stacked .mat-mdc-chip{width:100%}.mat-mdc-chip-set-stacked .mdc-evolution-chip__graphic{flex-grow:0}.mat-mdc-chip-set-stacked .mdc-evolution-chip__action--primary{flex-basis:100%;justify-content:start}input.mat-mdc-chip-input{flex:1 0 150px;margin-left:8px}[dir=rtl] input.mat-mdc-chip-input{margin-left:0;margin-right:8px}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipSet, [{
    type: Component,
    args: [{
      selector: "mat-chip-set",
      template: `
    <div class="mdc-evolution-chip-set__chips" role="presentation">
      <ng-content></ng-content>
    </div>
  `,
      host: {
        "class": "mat-mdc-chip-set mdc-evolution-chip-set",
        "(keydown)": "_handleKeydown($event)",
        "[attr.role]": "role"
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".mat-mdc-chip-set{display:flex}.mat-mdc-chip-set:focus{outline:none}.mat-mdc-chip-set .mdc-evolution-chip-set__chips{min-width:100%;margin-left:-8px;margin-right:0}.mat-mdc-chip-set .mdc-evolution-chip{margin:4px 0 4px 8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip-set__chips{margin-left:0;margin-right:-8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip{margin-left:0;margin-right:8px}.mdc-evolution-chip-set__chips{display:flex;flex-flow:wrap;min-width:0}.mat-mdc-chip-set-stacked{flex-direction:column;align-items:flex-start}.mat-mdc-chip-set-stacked .mat-mdc-chip{width:100%}.mat-mdc-chip-set-stacked .mdc-evolution-chip__graphic{flex-grow:0}.mat-mdc-chip-set-stacked .mdc-evolution-chip__action--primary{flex-basis:100%;justify-content:start}input.mat-mdc-chip-input{flex:1 0 150px;margin-left:8px}[dir=rtl] input.mat-mdc-chip-input{margin-left:0;margin-right:8px}"]
    }]
  }], () => [], {
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    role: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: [{
        transform: value => value == null ? 0 : numberAttribute(value)
      }]
    }],
    _chips: [{
      type: ContentChildren,
      args: [MatChip, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var MatChipListboxChange = class {
  source;
  value;
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
};
var MAT_CHIP_LISTBOX_CONTROL_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatChipListbox),
  multi: true
};
var MatChipListbox = class _MatChipListbox extends MatChipSet {
  /**
   * Function when touched. Set as part of ControlValueAccessor implementation.
   * @docs-private
   */
  _onTouched = () => {};
  /**
   * Function when changed. Set as part of ControlValueAccessor implementation.
   * @docs-private
   */
  _onChange = () => {};
  // TODO: MDC uses `grid` here
  _defaultRole = "listbox";
  /** Default chip options. */
  _defaultOptions = inject(MAT_CHIPS_DEFAULT_OPTIONS, {
    optional: true
  });
  /** Whether the user should be allowed to select multiple chips. */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = value;
    this._syncListboxProperties();
  }
  _multiple = false;
  /** The array of selected chips inside the chip listbox. */
  get selected() {
    const selectedChips = this._chips.toArray().filter(chip => chip.selected);
    return this.multiple ? selectedChips : selectedChips[0];
  }
  /** Orientation of the chip list. */
  ariaOrientation = "horizontal";
  /**
   * Whether or not this chip listbox is selectable.
   *
   * When a chip listbox is not selectable, the selected states for all
   * the chips inside the chip listbox are always ignored.
   */
  get selectable() {
    return this._selectable;
  }
  set selectable(value) {
    this._selectable = value;
    this._syncListboxProperties();
  }
  _selectable = true;
  /**
   * A function to compare the option values with the selected values. The first argument
   * is a value from an option. The second is a value from the selection. A boolean
   * should be returned.
   */
  compareWith = (o1, o2) => o1 === o2;
  /** Whether this chip listbox is required. */
  required = false;
  /** Whether checkmark indicator for single-selection options is hidden. */
  get hideSingleSelectionIndicator() {
    return this._hideSingleSelectionIndicator;
  }
  set hideSingleSelectionIndicator(value) {
    this._hideSingleSelectionIndicator = value;
    this._syncListboxProperties();
  }
  _hideSingleSelectionIndicator = this._defaultOptions?.hideSingleSelectionIndicator ?? false;
  /** Combined stream of all of the child chips' selection change events. */
  get chipSelectionChanges() {
    return this._getChipStream(chip => chip.selectionChange);
  }
  /** Combined stream of all of the child chips' blur events. */
  get chipBlurChanges() {
    return this._getChipStream(chip => chip._onBlur);
  }
  /** The value of the listbox, which is the combined value of the selected chips. */
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._chips && this._chips.length) {
      this._setSelectionByValue(value, false);
    }
    this._value = value;
  }
  _value;
  /** Event emitted when the selected chip listbox value has been changed by the user. */
  change = new EventEmitter();
  _chips = void 0;
  ngAfterContentInit() {
    this._chips.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {
      if (this.value !== void 0) {
        Promise.resolve().then(() => {
          this._setSelectionByValue(this.value, false);
        });
      }
      this._syncListboxProperties();
    });
    this.chipBlurChanges.pipe(takeUntil(this._destroyed)).subscribe(() => this._blur());
    this.chipSelectionChanges.pipe(takeUntil(this._destroyed)).subscribe(event => {
      if (!this.multiple) {
        this._chips.forEach(chip => {
          if (chip !== event.source) {
            chip._setSelectedState(false, false, false);
          }
        });
      }
      if (event.isUserInput) {
        this._propagateChanges();
      }
    });
  }
  /**
   * Focuses the first selected chip in this chip listbox, or the first non-disabled chip when there
   * are no selected chips.
   */
  focus() {
    if (this.disabled) {
      return;
    }
    const firstSelectedChip = this._getFirstSelectedChip();
    if (firstSelectedChip && !firstSelectedChip.disabled) {
      firstSelectedChip.focus();
    } else if (this._chips.length > 0) {
      this._keyManager.setFirstItemActive();
    } else {
      this._elementRef.nativeElement.focus();
    }
  }
  /**
   * Implemented as part of ControlValueAccessor.
   * @docs-private
   */
  writeValue(value) {
    if (value != null) {
      this.value = value;
    } else {
      this.value = void 0;
    }
  }
  /**
   * Implemented as part of ControlValueAccessor.
   * @docs-private
   */
  registerOnChange(fn) {
    this._onChange = fn;
  }
  /**
   * Implemented as part of ControlValueAccessor.
   * @docs-private
   */
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  /**
   * Implemented as part of ControlValueAccessor.
   * @docs-private
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /** Selects all chips with value. */
  _setSelectionByValue(value, isUserInput = true) {
    this._clearSelection();
    if (Array.isArray(value)) {
      value.forEach(currentValue => this._selectValue(currentValue, isUserInput));
    } else {
      this._selectValue(value, isUserInput);
    }
  }
  /** When blurred, marks the field as touched when focus moved outside the chip listbox. */
  _blur() {
    if (!this.disabled) {
      setTimeout(() => {
        if (!this.focused) {
          this._markAsTouched();
        }
      });
    }
  }
  _keydown(event) {
    if (event.keyCode === TAB) {
      super._allowFocusEscape();
    }
  }
  /** Marks the field as touched */
  _markAsTouched() {
    this._onTouched();
    this._changeDetectorRef.markForCheck();
  }
  /** Emits change event to set the model value. */
  _propagateChanges() {
    let valueToEmit = null;
    if (Array.isArray(this.selected)) {
      valueToEmit = this.selected.map(chip => chip.value);
    } else {
      valueToEmit = this.selected ? this.selected.value : void 0;
    }
    this._value = valueToEmit;
    this.change.emit(new MatChipListboxChange(this, valueToEmit));
    this._onChange(valueToEmit);
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Deselects every chip in the listbox.
   * @param skip Chip that should not be deselected.
   */
  _clearSelection(skip) {
    this._chips.forEach(chip => {
      if (chip !== skip) {
        chip.deselect();
      }
    });
  }
  /**
   * Finds and selects the chip based on its value.
   * @returns Chip that has the corresponding value.
   */
  _selectValue(value, isUserInput) {
    const correspondingChip = this._chips.find(chip => {
      return chip.value != null && this.compareWith(chip.value, value);
    });
    if (correspondingChip) {
      isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
    }
    return correspondingChip;
  }
  /** Syncs the chip-listbox selection state with the individual chips. */
  _syncListboxProperties() {
    if (this._chips) {
      Promise.resolve().then(() => {
        this._chips.forEach(chip => {
          chip._chipListMultiple = this.multiple;
          chip.chipListSelectable = this._selectable;
          chip._chipListHideSingleSelectionIndicator = this.hideSingleSelectionIndicator;
          chip._changeDetectorRef.markForCheck();
        });
      });
    }
  }
  /** Returns the first selected chip in this listbox, or undefined if no chips are selected. */
  _getFirstSelectedChip() {
    if (Array.isArray(this.selected)) {
      return this.selected.length ? this.selected[0] : void 0;
    } else {
      return this.selected;
    }
  }
  /**
   * Determines if key manager should avoid putting a given chip action in the tab index. Skip
   * non-interactive actions since the user can't do anything with them.
   */
  _skipPredicate(action) {
    return !action.isInteractive;
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatChipListbox_BaseFactory;
    return function MatChipListbox_Factory(__ngFactoryType__) {
      return (ɵMatChipListbox_BaseFactory || (ɵMatChipListbox_BaseFactory = ɵɵgetInheritedFactory(_MatChipListbox)))(__ngFactoryType__ || _MatChipListbox);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatChipListbox,
    selectors: [["mat-chip-listbox"]],
    contentQueries: function MatChipListbox_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatChipOption, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._chips = _t2);
      }
    },
    hostAttrs: [1, "mdc-evolution-chip-set", "mat-mdc-chip-listbox"],
    hostVars: 10,
    hostBindings: function MatChipListbox_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function MatChipListbox_focus_HostBindingHandler() {
          return ctx.focus();
        })("blur", function MatChipListbox_blur_HostBindingHandler() {
          return ctx._blur();
        })("keydown", function MatChipListbox_keydown_HostBindingHandler($event) {
          return ctx._keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("tabIndex", ctx.disabled || ctx.empty ? -1 : ctx.tabIndex);
        ɵɵattribute("role", ctx.role)("aria-required", ctx.role ? ctx.required : null)("aria-disabled", ctx.disabled.toString())("aria-multiselectable", ctx.multiple)("aria-orientation", ctx.ariaOrientation);
        ɵɵclassProp("mat-mdc-chip-list-disabled", ctx.disabled)("mat-mdc-chip-list-required", ctx.required);
      }
    },
    inputs: {
      multiple: [2, "multiple", "multiple", booleanAttribute],
      ariaOrientation: [0, "aria-orientation", "ariaOrientation"],
      selectable: [2, "selectable", "selectable", booleanAttribute],
      compareWith: "compareWith",
      required: [2, "required", "required", booleanAttribute],
      hideSingleSelectionIndicator: [2, "hideSingleSelectionIndicator", "hideSingleSelectionIndicator", booleanAttribute],
      value: "value"
    },
    outputs: {
      change: "change"
    },
    features: [ɵɵProvidersFeature([MAT_CHIP_LISTBOX_CONTROL_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c5,
    decls: 2,
    vars: 0,
    consts: [["role", "presentation", 1, "mdc-evolution-chip-set__chips"]],
    template: function MatChipListbox_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵprojection(1);
        ɵɵelementEnd();
      }
    },
    styles: [_c6],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipListbox, [{
    type: Component,
    args: [{
      selector: "mat-chip-listbox",
      template: `
    <div class="mdc-evolution-chip-set__chips" role="presentation">
      <ng-content></ng-content>
    </div>
  `,
      host: {
        "class": "mdc-evolution-chip-set mat-mdc-chip-listbox",
        "[attr.role]": "role",
        "[tabIndex]": "(disabled || empty) ? -1 : tabIndex",
        "[attr.aria-required]": "role ? required : null",
        "[attr.aria-disabled]": "disabled.toString()",
        "[attr.aria-multiselectable]": "multiple",
        "[attr.aria-orientation]": "ariaOrientation",
        "[class.mat-mdc-chip-list-disabled]": "disabled",
        "[class.mat-mdc-chip-list-required]": "required",
        "(focus)": "focus()",
        "(blur)": "_blur()",
        "(keydown)": "_keydown($event)"
      },
      providers: [MAT_CHIP_LISTBOX_CONTROL_VALUE_ACCESSOR],
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".mat-mdc-chip-set{display:flex}.mat-mdc-chip-set:focus{outline:none}.mat-mdc-chip-set .mdc-evolution-chip-set__chips{min-width:100%;margin-left:-8px;margin-right:0}.mat-mdc-chip-set .mdc-evolution-chip{margin:4px 0 4px 8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip-set__chips{margin-left:0;margin-right:-8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip{margin-left:0;margin-right:8px}.mdc-evolution-chip-set__chips{display:flex;flex-flow:wrap;min-width:0}.mat-mdc-chip-set-stacked{flex-direction:column;align-items:flex-start}.mat-mdc-chip-set-stacked .mat-mdc-chip{width:100%}.mat-mdc-chip-set-stacked .mdc-evolution-chip__graphic{flex-grow:0}.mat-mdc-chip-set-stacked .mdc-evolution-chip__action--primary{flex-basis:100%;justify-content:start}input.mat-mdc-chip-input{flex:1 0 150px;margin-left:8px}[dir=rtl] input.mat-mdc-chip-input{margin-left:0;margin-right:8px}"]
    }]
  }], null, {
    multiple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    ariaOrientation: [{
      type: Input,
      args: ["aria-orientation"]
    }],
    selectable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    compareWith: [{
      type: Input
    }],
    required: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    hideSingleSelectionIndicator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    value: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    _chips: [{
      type: ContentChildren,
      args: [MatChipOption, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var MatChipGridChange = class {
  source;
  value;
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
};
var MatChipGrid = class _MatChipGrid extends MatChipSet {
  ngControl = inject(NgControl, {
    optional: true,
    self: true
  });
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  controlType = "mat-chip-grid";
  /** The chip input to add more chips */
  _chipInput;
  _defaultRole = "grid";
  _errorStateTracker;
  /**
   * List of element ids to propagate to the chipInput's aria-describedby attribute.
   */
  _ariaDescribedbyIds = [];
  /**
   * Function when touched. Set as part of ControlValueAccessor implementation.
   * @docs-private
   */
  _onTouched = () => {};
  /**
   * Function when changed. Set as part of ControlValueAccessor implementation.
   * @docs-private
   */
  _onChange = () => {};
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get disabled() {
    return this.ngControl ? !!this.ngControl.disabled : this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._syncChipsState();
    this.stateChanges.next();
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get id() {
    return this._chipInput.id;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get empty() {
    return (!this._chipInput || this._chipInput.empty) && (!this._chips || this._chips.length === 0);
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get placeholder() {
    return this._chipInput ? this._chipInput.placeholder : this._placeholder;
  }
  set placeholder(value) {
    this._placeholder = value;
    this.stateChanges.next();
  }
  _placeholder;
  /** Whether any chips or the matChipInput inside of this chip-grid has focus. */
  get focused() {
    return this._chipInput.focused || this._hasFocusedChip();
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get required() {
    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;
  }
  set required(value) {
    this._required = value;
    this.stateChanges.next();
  }
  _required;
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get shouldLabelFloat() {
    return !this.empty || this.focused;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  _value = [];
  /** An object used to control when error messages are shown. */
  get errorStateMatcher() {
    return this._errorStateTracker.matcher;
  }
  set errorStateMatcher(value) {
    this._errorStateTracker.matcher = value;
  }
  /** Combined stream of all of the child chips' blur events. */
  get chipBlurChanges() {
    return this._getChipStream(chip => chip._onBlur);
  }
  /** Emits when the chip grid value has been changed by the user. */
  change = new EventEmitter();
  /**
   * Emits whenever the raw value of the chip-grid changes. This is here primarily
   * to facilitate the two-way binding for the `value` input.
   * @docs-private
   */
  valueChange = new EventEmitter();
  _chips = void 0;
  /**
   * Emits whenever the component state changes and should cause the parent
   * form-field to update. Implemented as part of `MatFormFieldControl`.
   * @docs-private
   */
  stateChanges = new Subject();
  /** Whether the chip grid is in an error state. */
  get errorState() {
    return this._errorStateTracker.errorState;
  }
  set errorState(value) {
    this._errorStateTracker.errorState = value;
  }
  constructor() {
    super();
    const parentForm = inject(NgForm, {
      optional: true
    });
    const parentFormGroup = inject(FormGroupDirective, {
      optional: true
    });
    const defaultErrorStateMatcher = inject(ErrorStateMatcher);
    if (this.ngControl) {
      this.ngControl.valueAccessor = this;
    }
    this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, this.ngControl, parentFormGroup, parentForm, this.stateChanges);
  }
  ngAfterContentInit() {
    this.chipBlurChanges.pipe(takeUntil(this._destroyed)).subscribe(() => {
      this._blur();
      this.stateChanges.next();
    });
    merge(this.chipFocusChanges, this._chips.changes).pipe(takeUntil(this._destroyed)).subscribe(() => this.stateChanges.next());
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    if (!this._chipInput && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("mat-chip-grid must be used in combination with matChipInputFor.");
    }
  }
  ngDoCheck() {
    if (this.ngControl) {
      this.updateErrorState();
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.stateChanges.complete();
  }
  /** Associates an HTML input element with this chip grid. */
  registerInput(inputElement) {
    this._chipInput = inputElement;
    this._chipInput.setDescribedByIds(this._ariaDescribedbyIds);
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  onContainerClick(event) {
    if (!this.disabled && !this._originatesFromChip(event)) {
      this.focus();
    }
  }
  /**
   * Focuses the first chip in this chip grid, or the associated input when there
   * are no eligible chips.
   */
  focus() {
    if (this.disabled || this._chipInput.focused) {
      return;
    }
    if (!this._chips.length || this._chips.first.disabled) {
      Promise.resolve().then(() => this._chipInput.focus());
    } else {
      const activeItem = this._keyManager.activeItem;
      if (activeItem) {
        activeItem.focus();
      } else {
        this._keyManager.setFirstItemActive();
      }
    }
    this.stateChanges.next();
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  setDescribedByIds(ids) {
    this._ariaDescribedbyIds = ids;
    this._chipInput?.setDescribedByIds(ids);
  }
  /**
   * Implemented as part of ControlValueAccessor.
   * @docs-private
   */
  writeValue(value) {
    this._value = value;
  }
  /**
   * Implemented as part of ControlValueAccessor.
   * @docs-private
   */
  registerOnChange(fn) {
    this._onChange = fn;
  }
  /**
   * Implemented as part of ControlValueAccessor.
   * @docs-private
   */
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  /**
   * Implemented as part of ControlValueAccessor.
   * @docs-private
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.stateChanges.next();
  }
  /** Refreshes the error state of the chip grid. */
  updateErrorState() {
    this._errorStateTracker.updateErrorState();
  }
  /** When blurred, mark the field as touched when focus moved outside the chip grid. */
  _blur() {
    if (!this.disabled) {
      setTimeout(() => {
        if (!this.focused) {
          this._propagateChanges();
          this._markAsTouched();
        }
      });
    }
  }
  /**
   * Removes the `tabindex` from the chip grid and resets it back afterwards, allowing the
   * user to tab out of it. This prevents the grid from capturing focus and redirecting
   * it back to the first chip, creating a focus trap, if it user tries to tab away.
   */
  _allowFocusEscape() {
    if (!this._chipInput.focused) {
      super._allowFocusEscape();
    }
  }
  /** Handles custom keyboard events. */
  _handleKeydown(event) {
    const keyCode = event.keyCode;
    const activeItem = this._keyManager.activeItem;
    if (keyCode === TAB) {
      if (this._chipInput.focused && hasModifierKey(event, "shiftKey") && this._chips.length && !this._chips.last.disabled) {
        event.preventDefault();
        if (activeItem) {
          this._keyManager.setActiveItem(activeItem);
        } else {
          this._focusLastChip();
        }
      } else {
        super._allowFocusEscape();
      }
    } else if (!this._chipInput.focused) {
      if ((keyCode === UP_ARROW || keyCode === DOWN_ARROW) && activeItem) {
        const eligibleActions = this._chipActions.filter(action => action._isPrimary === activeItem._isPrimary && !this._skipPredicate(action));
        const currentIndex = eligibleActions.indexOf(activeItem);
        const delta = event.keyCode === UP_ARROW ? -1 : 1;
        event.preventDefault();
        if (currentIndex > -1 && this._isValidIndex(currentIndex + delta)) {
          this._keyManager.setActiveItem(eligibleActions[currentIndex + delta]);
        }
      } else {
        super._handleKeydown(event);
      }
    }
    this.stateChanges.next();
  }
  _focusLastChip() {
    if (this._chips.length) {
      this._chips.last.focus();
    }
  }
  /** Emits change event to set the model value. */
  _propagateChanges() {
    const valueToEmit = this._chips.length ? this._chips.toArray().map(chip => chip.value) : [];
    this._value = valueToEmit;
    this.change.emit(new MatChipGridChange(this, valueToEmit));
    this.valueChange.emit(valueToEmit);
    this._onChange(valueToEmit);
    this._changeDetectorRef.markForCheck();
  }
  /** Mark the field as touched */
  _markAsTouched() {
    this._onTouched();
    this._changeDetectorRef.markForCheck();
    this.stateChanges.next();
  }
  static ɵfac = function MatChipGrid_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChipGrid)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatChipGrid,
    selectors: [["mat-chip-grid"]],
    contentQueries: function MatChipGrid_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatChipRow, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._chips = _t2);
      }
    },
    hostAttrs: [1, "mat-mdc-chip-set", "mat-mdc-chip-grid", "mdc-evolution-chip-set"],
    hostVars: 10,
    hostBindings: function MatChipGrid_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function MatChipGrid_focus_HostBindingHandler() {
          return ctx.focus();
        })("blur", function MatChipGrid_blur_HostBindingHandler() {
          return ctx._blur();
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.role)("tabindex", ctx.disabled || ctx._chips && ctx._chips.length === 0 ? -1 : ctx.tabIndex)("aria-disabled", ctx.disabled.toString())("aria-invalid", ctx.errorState);
        ɵɵclassProp("mat-mdc-chip-list-disabled", ctx.disabled)("mat-mdc-chip-list-invalid", ctx.errorState)("mat-mdc-chip-list-required", ctx.required);
      }
    },
    inputs: {
      disabled: [2, "disabled", "disabled", booleanAttribute],
      placeholder: "placeholder",
      required: [2, "required", "required", booleanAttribute],
      value: "value",
      errorStateMatcher: "errorStateMatcher"
    },
    outputs: {
      change: "change",
      valueChange: "valueChange"
    },
    features: [ɵɵProvidersFeature([{
      provide: MatFormFieldControl,
      useExisting: _MatChipGrid
    }]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c5,
    decls: 2,
    vars: 0,
    consts: [["role", "presentation", 1, "mdc-evolution-chip-set__chips"]],
    template: function MatChipGrid_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵprojection(1);
        ɵɵelementEnd();
      }
    },
    styles: [_c6],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipGrid, [{
    type: Component,
    args: [{
      selector: "mat-chip-grid",
      template: `
    <div class="mdc-evolution-chip-set__chips" role="presentation">
      <ng-content></ng-content>
    </div>
  `,
      host: {
        "class": "mat-mdc-chip-set mat-mdc-chip-grid mdc-evolution-chip-set",
        "[attr.role]": "role",
        "[attr.tabindex]": "(disabled || (_chips && _chips.length === 0)) ? -1 : tabIndex",
        "[attr.aria-disabled]": "disabled.toString()",
        "[attr.aria-invalid]": "errorState",
        "[class.mat-mdc-chip-list-disabled]": "disabled",
        "[class.mat-mdc-chip-list-invalid]": "errorState",
        "[class.mat-mdc-chip-list-required]": "required",
        "(focus)": "focus()",
        "(blur)": "_blur()"
      },
      providers: [{
        provide: MatFormFieldControl,
        useExisting: MatChipGrid
      }],
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".mat-mdc-chip-set{display:flex}.mat-mdc-chip-set:focus{outline:none}.mat-mdc-chip-set .mdc-evolution-chip-set__chips{min-width:100%;margin-left:-8px;margin-right:0}.mat-mdc-chip-set .mdc-evolution-chip{margin:4px 0 4px 8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip-set__chips{margin-left:0;margin-right:-8px}[dir=rtl] .mat-mdc-chip-set .mdc-evolution-chip{margin-left:0;margin-right:8px}.mdc-evolution-chip-set__chips{display:flex;flex-flow:wrap;min-width:0}.mat-mdc-chip-set-stacked{flex-direction:column;align-items:flex-start}.mat-mdc-chip-set-stacked .mat-mdc-chip{width:100%}.mat-mdc-chip-set-stacked .mdc-evolution-chip__graphic{flex-grow:0}.mat-mdc-chip-set-stacked .mdc-evolution-chip__action--primary{flex-basis:100%;justify-content:start}input.mat-mdc-chip-input{flex:1 0 150px;margin-left:8px}[dir=rtl] input.mat-mdc-chip-input{margin-left:0;margin-right:8px}"]
    }]
  }], () => [], {
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    placeholder: [{
      type: Input
    }],
    required: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    value: [{
      type: Input
    }],
    errorStateMatcher: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    _chips: [{
      type: ContentChildren,
      args: [MatChipRow, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var MatChipInput = class _MatChipInput {
  _elementRef = inject(ElementRef);
  /** Whether the control is focused. */
  focused = false;
  /** Register input for chip list */
  get chipGrid() {
    return this._chipGrid;
  }
  set chipGrid(value) {
    if (value) {
      this._chipGrid = value;
      this._chipGrid.registerInput(this);
    }
  }
  _chipGrid;
  /**
   * Whether or not the chipEnd event will be emitted when the input is blurred.
   */
  addOnBlur = false;
  /**
   * The list of key codes that will trigger a chipEnd event.
   *
   * Defaults to `[ENTER]`.
   */
  separatorKeyCodes;
  /** Emitted when a chip is to be added. */
  chipEnd = new EventEmitter();
  /** The input's placeholder text. */
  placeholder = "";
  /** Unique id for the input. */
  id = inject(_IdGenerator).getId("mat-mdc-chip-list-input-");
  /** Whether the input is disabled. */
  get disabled() {
    return this._disabled || this._chipGrid && this._chipGrid.disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  _disabled = false;
  /** Whether the input is empty. */
  get empty() {
    return !this.inputElement.value;
  }
  /** The native input element to which this directive is attached. */
  inputElement;
  constructor() {
    const defaultOptions = inject(MAT_CHIPS_DEFAULT_OPTIONS);
    const formField = inject(MAT_FORM_FIELD, {
      optional: true
    });
    this.inputElement = this._elementRef.nativeElement;
    this.separatorKeyCodes = defaultOptions.separatorKeyCodes;
    if (formField) {
      this.inputElement.classList.add("mat-mdc-form-field-input-control");
    }
  }
  ngOnChanges() {
    this._chipGrid.stateChanges.next();
  }
  ngOnDestroy() {
    this.chipEnd.complete();
  }
  /** Utility method to make host definition/tests more clear. */
  _keydown(event) {
    if (this.empty && event.keyCode === BACKSPACE) {
      if (!event.repeat) {
        this._chipGrid._focusLastChip();
      }
      event.preventDefault();
    } else {
      this._emitChipEnd(event);
    }
  }
  /** Checks to see if the blur should emit the (chipEnd) event. */
  _blur() {
    if (this.addOnBlur) {
      this._emitChipEnd();
    }
    this.focused = false;
    if (!this._chipGrid.focused) {
      this._chipGrid._blur();
    }
    this._chipGrid.stateChanges.next();
  }
  _focus() {
    this.focused = true;
    this._chipGrid.stateChanges.next();
  }
  /** Checks to see if the (chipEnd) event needs to be emitted. */
  _emitChipEnd(event) {
    if (!event || this._isSeparatorKey(event) && !event.repeat) {
      this.chipEnd.emit({
        input: this.inputElement,
        value: this.inputElement.value,
        chipInput: this
      });
      event?.preventDefault();
    }
  }
  _onInput() {
    this._chipGrid.stateChanges.next();
  }
  /** Focuses the input. */
  focus() {
    this.inputElement.focus();
  }
  /** Clears the input */
  clear() {
    this.inputElement.value = "";
  }
  setDescribedByIds(ids) {
    const element = this._elementRef.nativeElement;
    if (ids.length) {
      element.setAttribute("aria-describedby", ids.join(" "));
    } else {
      element.removeAttribute("aria-describedby");
    }
  }
  /** Checks whether a keycode is one of the configured separators. */
  _isSeparatorKey(event) {
    return !hasModifierKey(event) && new Set(this.separatorKeyCodes).has(event.keyCode);
  }
  static ɵfac = function MatChipInput_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChipInput)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatChipInput,
    selectors: [["input", "matChipInputFor", ""]],
    hostAttrs: [1, "mat-mdc-chip-input", "mat-mdc-input-element", "mdc-text-field__input", "mat-input-element"],
    hostVars: 6,
    hostBindings: function MatChipInput_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function MatChipInput_keydown_HostBindingHandler($event) {
          return ctx._keydown($event);
        })("blur", function MatChipInput_blur_HostBindingHandler() {
          return ctx._blur();
        })("focus", function MatChipInput_focus_HostBindingHandler() {
          return ctx._focus();
        })("input", function MatChipInput_input_HostBindingHandler() {
          return ctx._onInput();
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
        ɵɵattribute("disabled", ctx.disabled || null)("placeholder", ctx.placeholder || null)("aria-invalid", ctx._chipGrid && ctx._chipGrid.ngControl ? ctx._chipGrid.ngControl.invalid : null)("aria-required", ctx._chipGrid && ctx._chipGrid.required || null)("required", ctx._chipGrid && ctx._chipGrid.required || null);
      }
    },
    inputs: {
      chipGrid: [0, "matChipInputFor", "chipGrid"],
      addOnBlur: [2, "matChipInputAddOnBlur", "addOnBlur", booleanAttribute],
      separatorKeyCodes: [0, "matChipInputSeparatorKeyCodes", "separatorKeyCodes"],
      placeholder: "placeholder",
      id: "id",
      disabled: [2, "disabled", "disabled", booleanAttribute]
    },
    outputs: {
      chipEnd: "matChipInputTokenEnd"
    },
    exportAs: ["matChipInput", "matChipInputFor"],
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipInput, [{
    type: Directive,
    args: [{
      selector: "input[matChipInputFor]",
      exportAs: "matChipInput, matChipInputFor",
      host: {
        // TODO: eventually we should remove `mat-input-element` from here since it comes from the
        // non-MDC version of the input. It's currently being kept for backwards compatibility, because
        // the MDC chips were landed initially with it.
        "class": "mat-mdc-chip-input mat-mdc-input-element mdc-text-field__input mat-input-element",
        "(keydown)": "_keydown($event)",
        "(blur)": "_blur()",
        "(focus)": "_focus()",
        "(input)": "_onInput()",
        "[id]": "id",
        "[attr.disabled]": "disabled || null",
        "[attr.placeholder]": "placeholder || null",
        "[attr.aria-invalid]": "_chipGrid && _chipGrid.ngControl ? _chipGrid.ngControl.invalid : null",
        "[attr.aria-required]": "_chipGrid && _chipGrid.required || null",
        "[attr.required]": "_chipGrid && _chipGrid.required || null"
      }
    }]
  }], () => [], {
    chipGrid: [{
      type: Input,
      args: ["matChipInputFor"]
    }],
    addOnBlur: [{
      type: Input,
      args: [{
        alias: "matChipInputAddOnBlur",
        transform: booleanAttribute
      }]
    }],
    separatorKeyCodes: [{
      type: Input,
      args: ["matChipInputSeparatorKeyCodes"]
    }],
    chipEnd: [{
      type: Output,
      args: ["matChipInputTokenEnd"]
    }],
    placeholder: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CHIP_DECLARATIONS = [MatChip, MatChipAvatar, MatChipEditInput, MatChipGrid, MatChipInput, MatChipListbox, MatChipOption, MatChipRemove, MatChipRow, MatChipSet, MatChipTrailingIcon];
var MatChipsModule = class _MatChipsModule {
  static ɵfac = function MatChipsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatChipsModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatChipsModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [ErrorStateMatcher, {
      provide: MAT_CHIPS_DEFAULT_OPTIONS,
      useValue: {
        separatorKeyCodes: [ENTER]
      }
    }],
    imports: [MatCommonModule, MatRippleModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipsModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, MatRippleModule, MatChipAction, CHIP_DECLARATIONS],
      exports: [MatCommonModule, CHIP_DECLARATIONS],
      providers: [ErrorStateMatcher, {
        provide: MAT_CHIPS_DEFAULT_OPTIONS,
        useValue: {
          separatorKeyCodes: [ENTER]
        }
      }]
    }]
  }], null, null);
})();

// node_modules/overlayscrollbars/overlayscrollbars.mjs
var createCache = (t2, n2) => {
  const {
    o: o2,
    i: s2,
    u: e2
  } = t2;
  let c2 = o2;
  let r2;
  const cacheUpdateContextual = (t3, n3) => {
    const o3 = c2;
    const l2 = t3;
    const i2 = n3 || (s2 ? !s2(o3, l2) : o3 !== l2);
    if (i2 || e2) {
      c2 = l2;
      r2 = o3;
    }
    return [c2, i2, r2];
  };
  const cacheUpdateIsolated = t3 => cacheUpdateContextual(n2(c2, r2), t3);
  const getCurrentCache = t3 => [c2, !!t3, r2];
  return [n2 ? cacheUpdateIsolated : cacheUpdateContextual, getCurrentCache];
};
var t = typeof window !== "undefined" && typeof HTMLElement !== "undefined" && !!window.document;
var n = t ? window : {};
var o = Math.max;
var s = Math.min;
var e = Math.round;
var c = Math.abs;
var r = Math.sign;
var l = n.cancelAnimationFrame;
var i = n.requestAnimationFrame;
var a = n.setTimeout;
var u = n.clearTimeout;
var getApi = t2 => typeof n[t2] !== "undefined" ? n[t2] : void 0;
var _ = getApi("MutationObserver");
var d = getApi("IntersectionObserver");
var f = getApi("ResizeObserver");
var v = getApi("ScrollTimeline");
var isUndefined = t2 => t2 === void 0;
var isNull = t2 => t2 === null;
var isNumber = t2 => typeof t2 === "number";
var isString = t2 => typeof t2 === "string";
var isBoolean = t2 => typeof t2 === "boolean";
var isFunction = t2 => typeof t2 === "function";
var isArray = t2 => Array.isArray(t2);
var isObject = t2 => typeof t2 === "object" && !isArray(t2) && !isNull(t2);
var isArrayLike = t2 => {
  const n2 = !!t2 && t2.length;
  const o2 = isNumber(n2) && n2 > -1 && n2 % 1 == 0;
  return isArray(t2) || !isFunction(t2) && o2 ? n2 > 0 && isObject(t2) ? n2 - 1 in t2 : true : false;
};
var isPlainObject = t2 => !!t2 && t2.constructor === Object;
var isHTMLElement = t2 => t2 instanceof HTMLElement;
var isElement = t2 => t2 instanceof Element;
function each(t2, n2) {
  if (isArrayLike(t2)) {
    for (let o2 = 0; o2 < t2.length; o2++) {
      if (n2(t2[o2], o2, t2) === false) {
        break;
      }
    }
  } else if (t2) {
    each(Object.keys(t2), o2 => n2(t2[o2], o2, t2));
  }
  return t2;
}
var inArray = (t2, n2) => t2.indexOf(n2) >= 0;
var concat2 = (t2, n2) => t2.concat(n2);
var push = (t2, n2, o2) => {
  !o2 && !isString(n2) && isArrayLike(n2) ? Array.prototype.push.apply(t2, n2) : t2.push(n2);
  return t2;
};
var from = t2 => Array.from(t2 || []);
var createOrKeepArray = t2 => {
  if (isArray(t2)) {
    return t2;
  }
  return !isString(t2) && isArrayLike(t2) ? from(t2) : [t2];
};
var isEmptyArray = t2 => !!t2 && !t2.length;
var deduplicateArray = t2 => from(new Set(t2));
var runEachAndClear = (t2, n2, o2) => {
  const runFn = t3 => t3 ? t3.apply(void 0, n2 || []) : true;
  each(t2, runFn);
  !o2 && (t2.length = 0);
};
var p = "paddingTop";
var h = "paddingRight";
var g = "paddingLeft";
var b = "paddingBottom";
var w = "marginLeft";
var y = "marginRight";
var S = "marginBottom";
var m = "overflowX";
var O = "overflowY";
var $ = "width";
var C = "height";
var x = "visible";
var H = "hidden";
var E = "scroll";
var capitalizeFirstLetter = t2 => {
  const n2 = String(t2 || "");
  return n2 ? n2[0].toUpperCase() + n2.slice(1) : "";
};
var equal = (t2, n2, o2, s2) => {
  if (t2 && n2) {
    let e2 = true;
    each(o2, o3 => {
      const c2 = s2 ? s2(t2[o3]) : t2[o3];
      const r2 = s2 ? s2(n2[o3]) : n2[o3];
      if (c2 !== r2) {
        e2 = false;
      }
    });
    return e2;
  }
  return false;
};
var equalWH = (t2, n2) => equal(t2, n2, ["w", "h"]);
var equalXY = (t2, n2) => equal(t2, n2, ["x", "y"]);
var equalTRBL = (t2, n2) => equal(t2, n2, ["t", "r", "b", "l"]);
var noop = () => {};
var bind = (t2, ...n2) => t2.bind(0, ...n2);
var selfClearTimeout = t2 => {
  let n2;
  const o2 = t2 ? a : i;
  const s2 = t2 ? u : l;
  return [e2 => {
    s2(n2);
    n2 = o2(() => e2(), isFunction(t2) ? t2() : t2);
  }, () => s2(n2)];
};
var debounce = (t2, n2) => {
  const {
    _: o2,
    v: s2,
    p: e2,
    S: c2
  } = n2 || {};
  let r2;
  let _2;
  let d2;
  let f2;
  let v2 = noop;
  const p2 = function invokeFunctionToDebounce(n3) {
    v2();
    u(r2);
    f2 = r2 = _2 = void 0;
    v2 = noop;
    t2.apply(this, n3);
  };
  const mergeParms = t3 => c2 && _2 ? c2(_2, t3) : t3;
  const flush = () => {
    if (v2 !== noop) {
      p2(mergeParms(d2) || d2);
    }
  };
  const h2 = function debouncedFn() {
    const t3 = from(arguments);
    const n3 = isFunction(o2) ? o2() : o2;
    const c3 = isNumber(n3) && n3 >= 0;
    if (c3) {
      const o3 = isFunction(s2) ? s2() : s2;
      const c4 = isNumber(o3) && o3 >= 0;
      const h3 = n3 > 0 ? a : i;
      const g2 = n3 > 0 ? u : l;
      const b2 = mergeParms(t3);
      const w2 = b2 || t3;
      const y2 = p2.bind(0, w2);
      let S2;
      v2();
      if (e2 && !f2) {
        y2();
        f2 = true;
        S2 = h3(() => f2 = void 0, n3);
      } else {
        S2 = h3(y2, n3);
        if (c4 && !r2) {
          r2 = a(flush, o3);
        }
      }
      v2 = () => g2(S2);
      _2 = d2 = w2;
    } else {
      p2(t3);
    }
  };
  h2.m = flush;
  return h2;
};
var hasOwnProperty = (t2, n2) => Object.prototype.hasOwnProperty.call(t2, n2);
var keys = t2 => t2 ? Object.keys(t2) : [];
var assignDeep = (t2, n2, o2, s2, e2, c2, r2) => {
  const l2 = [n2, o2, s2, e2, c2, r2];
  if ((typeof t2 !== "object" || isNull(t2)) && !isFunction(t2)) {
    t2 = {};
  }
  each(l2, n3 => {
    each(n3, (o3, s3) => {
      const e3 = n3[s3];
      if (t2 === e3) {
        return true;
      }
      const c3 = isArray(e3);
      if (e3 && isPlainObject(e3)) {
        const n4 = t2[s3];
        let o4 = n4;
        if (c3 && !isArray(n4)) {
          o4 = [];
        } else if (!c3 && !isPlainObject(n4)) {
          o4 = {};
        }
        t2[s3] = assignDeep(o4, e3);
      } else {
        t2[s3] = c3 ? e3.slice() : e3;
      }
    });
  });
  return t2;
};
var removeUndefinedProperties = (t2, n2) => each(assignDeep({}, t2), (t3, o2, s2) => {
  if (t3 === void 0) {
    delete s2[o2];
  } else if (n2 && t3 && isPlainObject(t3)) {
    s2[o2] = removeUndefinedProperties(t3, n2);
  }
});
var isEmptyObject = t2 => !keys(t2).length;
var capNumber = (t2, n2, e2) => o(t2, s(n2, e2));
var getDomTokensArray = t2 => deduplicateArray((isArray(t2) ? t2 : (t2 || "").split(" ")).filter(t3 => t3));
var getAttr = (t2, n2) => t2 && t2.getAttribute(n2);
var hasAttr = (t2, n2) => t2 && t2.hasAttribute(n2);
var setAttrs = (t2, n2, o2) => {
  each(getDomTokensArray(n2), n3 => {
    t2 && t2.setAttribute(n3, String(o2 || ""));
  });
};
var removeAttrs = (t2, n2) => {
  each(getDomTokensArray(n2), n3 => t2 && t2.removeAttribute(n3));
};
var domTokenListAttr = (t2, n2) => {
  const o2 = getDomTokensArray(getAttr(t2, n2));
  const s2 = bind(setAttrs, t2, n2);
  const domTokenListOperation = (t3, n3) => {
    const s3 = new Set(o2);
    each(getDomTokensArray(t3), t4 => {
      s3[n3](t4);
    });
    return from(s3).join(" ");
  };
  return {
    O: t3 => s2(domTokenListOperation(t3, "delete")),
    $: t3 => s2(domTokenListOperation(t3, "add")),
    C: t3 => {
      const n3 = getDomTokensArray(t3);
      return n3.reduce((t4, n4) => t4 && o2.includes(n4), n3.length > 0);
    }
  };
};
var removeAttrClass = (t2, n2, o2) => {
  domTokenListAttr(t2, n2).O(o2);
  return bind(addAttrClass, t2, n2, o2);
};
var addAttrClass = (t2, n2, o2) => {
  domTokenListAttr(t2, n2).$(o2);
  return bind(removeAttrClass, t2, n2, o2);
};
var addRemoveAttrClass = (t2, n2, o2, s2) => (s2 ? addAttrClass : removeAttrClass)(t2, n2, o2);
var hasAttrClass = (t2, n2, o2) => domTokenListAttr(t2, n2).C(o2);
var createDomTokenListClass = t2 => domTokenListAttr(t2, "class");
var removeClass = (t2, n2) => {
  createDomTokenListClass(t2).O(n2);
};
var addClass = (t2, n2) => {
  createDomTokenListClass(t2).$(n2);
  return bind(removeClass, t2, n2);
};
var find = (t2, n2) => {
  const o2 = n2 ? isElement(n2) && n2 : document;
  return o2 ? from(o2.querySelectorAll(t2)) : [];
};
var findFirst = (t2, n2) => {
  const o2 = n2 ? isElement(n2) && n2 : document;
  return o2 && o2.querySelector(t2);
};
var is = (t2, n2) => isElement(t2) && t2.matches(n2);
var isBodyElement = t2 => is(t2, "body");
var contents = t2 => t2 ? from(t2.childNodes) : [];
var parent = t2 => t2 && t2.parentElement;
var closest = (t2, n2) => isElement(t2) && t2.closest(n2);
var getFocusedElement = t2 => (t2 || document).activeElement;
var liesBetween = (t2, n2, o2) => {
  const s2 = closest(t2, n2);
  const e2 = t2 && findFirst(o2, s2);
  const c2 = closest(e2, n2) === s2;
  return s2 && e2 ? s2 === t2 || e2 === t2 || c2 && closest(closest(t2, o2), n2) !== s2 : false;
};
var removeElements = t2 => {
  each(createOrKeepArray(t2), t3 => {
    const n2 = parent(t3);
    t3 && n2 && n2.removeChild(t3);
  });
};
var appendChildren = (t2, n2) => bind(removeElements, t2 && n2 && each(createOrKeepArray(n2), n3 => {
  n3 && t2.appendChild(n3);
}));
var createDiv = t2 => {
  const n2 = document.createElement("div");
  setAttrs(n2, "class", t2);
  return n2;
};
var createDOM = t2 => {
  const n2 = createDiv();
  n2.innerHTML = t2.trim();
  return each(contents(n2), t3 => removeElements(t3));
};
var getCSSVal = (t2, n2) => t2.getPropertyValue(n2) || t2[n2] || "";
var validFiniteNumber = t2 => {
  const n2 = t2 || 0;
  return isFinite(n2) ? n2 : 0;
};
var parseToZeroOrNumber = t2 => validFiniteNumber(parseFloat(t2 || ""));
var roundCssNumber = t2 => Math.round(t2 * 1e4) / 1e4;
var numberToCssPx = t2 => `${roundCssNumber(validFiniteNumber(t2))}px`;
function setStyles(t2, n2) {
  t2 && n2 && each(n2, (n3, o2) => {
    try {
      const s2 = t2.style;
      const e2 = isNull(n3) || isBoolean(n3) ? "" : isNumber(n3) ? numberToCssPx(n3) : n3;
      if (o2.indexOf("--") === 0) {
        s2.setProperty(o2, e2);
      } else {
        s2[o2] = e2;
      }
    } catch (s2) {}
  });
}
function getStyles(t2, o2, s2) {
  const e2 = isString(o2);
  let c2 = e2 ? "" : {};
  if (t2) {
    const r2 = n.getComputedStyle(t2, s2) || t2.style;
    c2 = e2 ? getCSSVal(r2, o2) : from(o2).reduce((t3, n2) => {
      t3[n2] = getCSSVal(r2, n2);
      return t3;
    }, c2);
  }
  return c2;
}
var topRightBottomLeft = (t2, n2, o2) => {
  const s2 = n2 ? `${n2}-` : "";
  const e2 = o2 ? `-${o2}` : "";
  const c2 = `${s2}top${e2}`;
  const r2 = `${s2}right${e2}`;
  const l2 = `${s2}bottom${e2}`;
  const i2 = `${s2}left${e2}`;
  const a2 = getStyles(t2, [c2, r2, l2, i2]);
  return {
    t: parseToZeroOrNumber(a2[c2]),
    r: parseToZeroOrNumber(a2[r2]),
    b: parseToZeroOrNumber(a2[l2]),
    l: parseToZeroOrNumber(a2[i2])
  };
};
var getTrasformTranslateValue = (t2, n2) => `translate${isObject(t2) ? `(${t2.x},${t2.y})` : `${n2 ? "X" : "Y"}(${t2})`}`;
var elementHasDimensions = t2 => !!(t2.offsetWidth || t2.offsetHeight || t2.getClientRects().length);
var z = {
  w: 0,
  h: 0
};
var getElmWidthHeightProperty = (t2, n2) => n2 ? {
  w: n2[`${t2}Width`],
  h: n2[`${t2}Height`]
} : z;
var getWindowSize = t2 => getElmWidthHeightProperty("inner", t2 || n);
var I = bind(getElmWidthHeightProperty, "offset");
var A2 = bind(getElmWidthHeightProperty, "client");
var D = bind(getElmWidthHeightProperty, "scroll");
var getFractionalSize = t2 => {
  const n2 = parseFloat(getStyles(t2, $)) || 0;
  const o2 = parseFloat(getStyles(t2, C)) || 0;
  return {
    w: n2 - e(n2),
    h: o2 - e(o2)
  };
};
var getBoundingClientRect = t2 => t2.getBoundingClientRect();
var hasDimensions = t2 => !!t2 && elementHasDimensions(t2);
var domRectHasDimensions = t2 => !!(t2 && (t2[C] || t2[$]));
var domRectAppeared = (t2, n2) => {
  const o2 = domRectHasDimensions(t2);
  const s2 = domRectHasDimensions(n2);
  return !s2 && o2;
};
var removeEventListener = (t2, n2, o2, s2) => {
  each(getDomTokensArray(n2), n3 => {
    t2 && t2.removeEventListener(n3, o2, s2);
  });
};
var addEventListener = (t2, n2, o2, s2) => {
  var e2;
  const c2 = (e2 = s2 && s2.H) != null ? e2 : true;
  const r2 = s2 && s2.I || false;
  const l2 = s2 && s2.A || false;
  const i2 = {
    passive: c2,
    capture: r2
  };
  return bind(runEachAndClear, getDomTokensArray(n2).map(n3 => {
    const s3 = l2 ? e3 => {
      removeEventListener(t2, n3, s3, r2);
      o2 && o2(e3);
    } : o2;
    t2 && t2.addEventListener(n3, s3, i2);
    return bind(removeEventListener, t2, n3, s3, r2);
  }));
};
var stopPropagation = t2 => t2.stopPropagation();
var preventDefault = t2 => t2.preventDefault();
var stopAndPrevent = t2 => stopPropagation(t2) || preventDefault(t2);
var scrollElementTo = (t2, n2) => {
  const {
    x: o2,
    y: s2
  } = isNumber(n2) ? {
    x: n2,
    y: n2
  } : n2 || {};
  isNumber(o2) && (t2.scrollLeft = o2);
  isNumber(s2) && (t2.scrollTop = s2);
};
var getElementScroll = t2 => ({
  x: t2.scrollLeft,
  y: t2.scrollTop
});
var getZeroScrollCoordinates = () => ({
  D: {
    x: 0,
    y: 0
  },
  M: {
    x: 0,
    y: 0
  }
});
var sanitizeScrollCoordinates = (t2, n2) => {
  const {
    D: o2,
    M: s2
  } = t2;
  const {
    w: e2,
    h: l2
  } = n2;
  const sanitizeAxis = (t3, n3, o3) => {
    let s3 = r(t3) * o3;
    let e3 = r(n3) * o3;
    if (s3 === e3) {
      const o4 = c(t3);
      const r2 = c(n3);
      e3 = o4 > r2 ? 0 : e3;
      s3 = o4 < r2 ? 0 : s3;
    }
    s3 = s3 === e3 ? 0 : s3;
    return [s3 + 0, e3 + 0];
  };
  const [i2, a2] = sanitizeAxis(o2.x, s2.x, e2);
  const [u2, _2] = sanitizeAxis(o2.y, s2.y, l2);
  return {
    D: {
      x: i2,
      y: u2
    },
    M: {
      x: a2,
      y: _2
    }
  };
};
var isDefaultDirectionScrollCoordinates = ({
  D: t2,
  M: n2
}) => {
  const getAxis = (t3, n3) => t3 === 0 && t3 <= n3;
  return {
    x: getAxis(t2.x, n2.x),
    y: getAxis(t2.y, n2.y)
  };
};
var getScrollCoordinatesPercent = ({
  D: t2,
  M: n2
}, o2) => {
  const getAxis = (t3, n3, o3) => capNumber(0, 1, (t3 - o3) / (t3 - n3) || 0);
  return {
    x: getAxis(t2.x, n2.x, o2.x),
    y: getAxis(t2.y, n2.y, o2.y)
  };
};
var focusElement = t2 => {
  if (t2 && t2.focus) {
    t2.focus({
      preventScroll: true
    });
  }
};
var manageListener = (t2, n2) => {
  each(createOrKeepArray(n2), t2);
};
var createEventListenerHub = t2 => {
  const n2 = /* @__PURE__ */new Map();
  const removeEvent = (t3, o2) => {
    if (t3) {
      const s2 = n2.get(t3);
      manageListener(t4 => {
        if (s2) {
          s2[t4 ? "delete" : "clear"](t4);
        }
      }, o2);
    } else {
      n2.forEach(t4 => {
        t4.clear();
      });
      n2.clear();
    }
  };
  const addEvent = (t3, o2) => {
    if (isString(t3)) {
      const s3 = n2.get(t3) || /* @__PURE__ */new Set();
      n2.set(t3, s3);
      manageListener(t4 => {
        isFunction(t4) && s3.add(t4);
      }, o2);
      return bind(removeEvent, t3, o2);
    }
    if (isBoolean(o2) && o2) {
      removeEvent();
    }
    const s2 = keys(t3);
    const e2 = [];
    each(s2, n3 => {
      const o3 = t3[n3];
      o3 && push(e2, addEvent(n3, o3));
    });
    return bind(runEachAndClear, e2);
  };
  const triggerEvent = (t3, o2) => {
    each(from(n2.get(t3)), t4 => {
      if (o2 && !isEmptyArray(o2)) {
        t4.apply(0, o2);
      } else {
        t4();
      }
    });
  };
  addEvent(t2 || {});
  return [addEvent, removeEvent, triggerEvent];
};
var opsStringify = t2 => JSON.stringify(t2, (t3, n2) => {
  if (isFunction(n2)) {
    throw 0;
  }
  return n2;
});
var getPropByPath = (t2, n2) => t2 ? `${n2}`.split(".").reduce((t3, n3) => t3 && hasOwnProperty(t3, n3) ? t3[n3] : void 0, t2) : void 0;
var M = {
  paddingAbsolute: false,
  showNativeOverlaidScrollbars: false,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    autoHideSuspend: false,
    dragScroll: true,
    clickScroll: false,
    pointers: ["mouse", "touch", "pen"]
  }
};
var getOptionsDiff = (t2, n2) => {
  const o2 = {};
  const s2 = concat2(keys(n2), keys(t2));
  each(s2, s3 => {
    const e2 = t2[s3];
    const c2 = n2[s3];
    if (isObject(e2) && isObject(c2)) {
      assignDeep(o2[s3] = {}, getOptionsDiff(e2, c2));
      if (isEmptyObject(o2[s3])) {
        delete o2[s3];
      }
    } else if (hasOwnProperty(n2, s3) && c2 !== e2) {
      let t3 = true;
      if (isArray(e2) || isArray(c2)) {
        try {
          if (opsStringify(e2) === opsStringify(c2)) {
            t3 = false;
          }
        } catch (r2) {}
      }
      if (t3) {
        o2[s3] = c2;
      }
    }
  });
  return o2;
};
var createOptionCheck = (t2, n2, o2) => s2 => [getPropByPath(t2, s2), o2 || getPropByPath(n2, s2) !== void 0];
var T = `data-overlayscrollbars`;
var k = "os-environment";
var R = `${k}-scrollbar-hidden`;
var V = `${T}-initialize`;
var L = "noClipping";
var U = `${T}-body`;
var P = T;
var N = "host";
var q = `${T}-viewport`;
var B = m;
var F = O;
var j = "arrange";
var X = "measuring";
var Y = "scrolling";
var W = "scrollbarHidden";
var J = "noContent";
var G = `${T}-padding`;
var K = `${T}-content`;
var Q = "os-size-observer";
var Z = `${Q}-appear`;
var tt = `${Q}-listener`;
var nt = `${tt}-scroll`;
var ot = `${tt}-item`;
var st = `${ot}-final`;
var et = "os-trinsic-observer";
var ct = "os-theme-none";
var rt = "os-scrollbar";
var lt = `${rt}-rtl`;
var it = `${rt}-horizontal`;
var at = `${rt}-vertical`;
var ut = `${rt}-track`;
var _t = `${rt}-handle`;
var dt = `${rt}-visible`;
var ft = `${rt}-cornerless`;
var vt = `${rt}-interaction`;
var pt = `${rt}-unusable`;
var ht = `${rt}-auto-hide`;
var gt = `${ht}-hidden`;
var bt = `${rt}-wheel`;
var wt = `${ut}-interactive`;
var yt = `${_t}-interactive`;
var St;
var getNonce = () => St;
var setNonce = t2 => {
  St = t2;
};
var mt;
var createEnvironment = () => {
  const getNativeScrollbarSize = (t3, n2, o3) => {
    appendChildren(document.body, t3);
    appendChildren(document.body, t3);
    const s3 = A2(t3);
    const e3 = I(t3);
    const c3 = getFractionalSize(n2);
    o3 && removeElements(t3);
    return {
      x: e3.h - s3.h + c3.h,
      y: e3.w - s3.w + c3.w
    };
  };
  const getNativeScrollbarsHiding = t3 => {
    let n2 = false;
    const o3 = addClass(t3, R);
    try {
      n2 = getStyles(t3, "scrollbar-width") === "none" || getStyles(t3, "display", "::-webkit-scrollbar") === "none";
    } catch (s3) {}
    o3();
    return n2;
  };
  const t2 = `.${k}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${k} div{width:200%;height:200%;margin:10px 0}.${R}{scrollbar-width:none!important}.${R}::-webkit-scrollbar,.${R}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`;
  const o2 = createDOM(`<div class="${k}"><div></div><style>${t2}</style></div>`);
  const s2 = o2[0];
  const e2 = s2.firstChild;
  const c2 = s2.lastChild;
  const r2 = getNonce();
  if (r2) {
    c2.nonce = r2;
  }
  const [l2,, i2] = createEventListenerHub();
  const [a2, u2] = createCache({
    o: getNativeScrollbarSize(s2, e2),
    i: equalXY
  }, bind(getNativeScrollbarSize, s2, e2, true));
  const [_2] = u2();
  const d2 = getNativeScrollbarsHiding(s2);
  const f2 = {
    x: _2.x === 0,
    y: _2.y === 0
  };
  const p2 = {
    elements: {
      host: null,
      padding: !d2,
      viewport: t3 => d2 && isBodyElement(t3) && t3,
      content: false
    },
    scrollbars: {
      slot: true
    },
    cancel: {
      nativeScrollbarsOverlaid: false,
      body: null
    }
  };
  const h2 = assignDeep({}, M);
  const g2 = bind(assignDeep, {}, h2);
  const b2 = bind(assignDeep, {}, p2);
  const w2 = {
    T: _2,
    k: f2,
    R: d2,
    V: !!v,
    L: bind(l2, "r"),
    U: b2,
    P: t3 => assignDeep(p2, t3) && b2(),
    N: g2,
    q: t3 => assignDeep(h2, t3) && g2(),
    B: assignDeep({}, p2),
    F: assignDeep({}, h2)
  };
  removeAttrs(s2, "style");
  removeElements(s2);
  addEventListener(n, "resize", () => {
    i2("r", []);
  });
  if (isFunction(n.matchMedia) && !d2 && (!f2.x || !f2.y)) {
    const addZoomListener = t3 => {
      const o3 = n.matchMedia(`(resolution: ${n.devicePixelRatio}dppx)`);
      addEventListener(o3, "change", () => {
        t3();
        addZoomListener(t3);
      }, {
        A: true
      });
    };
    addZoomListener(() => {
      const [t3, n2] = a2();
      assignDeep(w2.T, t3);
      i2("r", [n2]);
    });
  }
  return w2;
};
var getEnvironment = () => {
  if (!mt) {
    mt = createEnvironment();
  }
  return mt;
};
var resolveInitialization = (t2, n2) => isFunction(n2) ? n2.apply(0, t2) : n2;
var staticInitializationElement = (t2, n2, o2, s2) => {
  const e2 = isUndefined(s2) ? o2 : s2;
  const c2 = resolveInitialization(t2, e2);
  return c2 || n2.apply(0, t2);
};
var dynamicInitializationElement = (t2, n2, o2, s2) => {
  const e2 = isUndefined(s2) ? o2 : s2;
  const c2 = resolveInitialization(t2, e2);
  return !!c2 && (isHTMLElement(c2) ? c2 : n2.apply(0, t2));
};
var cancelInitialization = (t2, n2) => {
  const {
    nativeScrollbarsOverlaid: o2,
    body: s2
  } = n2 || {};
  const {
    k: e2,
    R: c2,
    U: r2
  } = getEnvironment();
  const {
    nativeScrollbarsOverlaid: l2,
    body: i2
  } = r2().cancel;
  const a2 = o2 != null ? o2 : l2;
  const u2 = isUndefined(s2) ? i2 : s2;
  const _2 = (e2.x || e2.y) && a2;
  const d2 = t2 && (isNull(u2) ? !c2 : u2);
  return !!_2 || !!d2;
};
var Ot = /* @__PURE__ */new WeakMap();
var addInstance = (t2, n2) => {
  Ot.set(t2, n2);
};
var removeInstance = t2 => {
  Ot.delete(t2);
};
var getInstance = t2 => Ot.get(t2);
var createEventContentChange = (t2, n2, o2) => {
  let s2 = false;
  const e2 = o2 ? /* @__PURE__ */new WeakMap() : false;
  const destroy = () => {
    s2 = true;
  };
  const updateElements = c2 => {
    if (e2 && o2) {
      const r2 = o2.map(n3 => {
        const [o3, s3] = n3 || [];
        const e3 = s3 && o3 ? (c2 || find)(o3, t2) : [];
        return [e3, s3];
      });
      each(r2, o3 => each(o3[0], c3 => {
        const r3 = o3[1];
        const l2 = e2.get(c3) || [];
        const i2 = t2.contains(c3);
        if (i2 && r3) {
          const t3 = addEventListener(c3, r3, o4 => {
            if (s2) {
              t3();
              e2.delete(c3);
            } else {
              n2(o4);
            }
          });
          e2.set(c3, push(l2, t3));
        } else {
          runEachAndClear(l2);
          e2.delete(c3);
        }
      }));
    }
  };
  updateElements();
  return [destroy, updateElements];
};
var createDOMObserver = (t2, n2, o2, s2) => {
  let e2 = false;
  const {
    j: c2,
    X: r2,
    Y: l2,
    W: i2,
    J: a2,
    G: u2
  } = s2 || {};
  const d2 = debounce(() => e2 && o2(true), {
    _: 33,
    v: 99
  });
  const [f2, v2] = createEventContentChange(t2, d2, l2);
  const p2 = c2 || [];
  const h2 = r2 || [];
  const g2 = concat2(p2, h2);
  const observerCallback = (e3, c3) => {
    if (!isEmptyArray(c3)) {
      const r3 = a2 || noop;
      const l3 = u2 || noop;
      const _2 = [];
      const d3 = [];
      let f3 = false;
      let p3 = false;
      each(c3, o3 => {
        const {
          attributeName: e4,
          target: c4,
          type: a3,
          oldValue: u3,
          addedNodes: v3,
          removedNodes: g3
        } = o3;
        const b3 = a3 === "attributes";
        const w2 = a3 === "childList";
        const y2 = t2 === c4;
        const S2 = b3 && e4;
        const m2 = S2 && getAttr(c4, e4 || "");
        const O2 = isString(m2) ? m2 : null;
        const $2 = S2 && u3 !== O2;
        const C2 = inArray(h2, e4) && $2;
        if (n2 && (w2 || !y2)) {
          const n3 = b3 && $2;
          const a4 = n3 && i2 && is(c4, i2);
          const d4 = a4 ? !r3(c4, e4, u3, O2) : !b3 || n3;
          const f4 = d4 && !l3(o3, !!a4, t2, s2);
          each(v3, t3 => push(_2, t3));
          each(g3, t3 => push(_2, t3));
          p3 = p3 || f4;
        }
        if (!n2 && y2 && $2 && !r3(c4, e4, u3, O2)) {
          push(d3, e4);
          f3 = f3 || C2;
        }
      });
      v2(t3 => deduplicateArray(_2).reduce((n3, o3) => {
        push(n3, find(t3, o3));
        return is(o3, t3) ? push(n3, o3) : n3;
      }, []));
      if (n2) {
        !e3 && p3 && o2(false);
        return [false];
      }
      if (!isEmptyArray(d3) || f3) {
        const t3 = [deduplicateArray(d3), f3];
        !e3 && o2.apply(0, t3);
        return t3;
      }
    }
  };
  const b2 = new _(bind(observerCallback, false));
  return [() => {
    b2.observe(t2, {
      attributes: true,
      attributeOldValue: true,
      attributeFilter: g2,
      subtree: n2,
      childList: n2,
      characterData: n2
    });
    e2 = true;
    return () => {
      if (e2) {
        f2();
        b2.disconnect();
        e2 = false;
      }
    };
  }, () => {
    if (e2) {
      d2.m();
      return observerCallback(true, b2.takeRecords());
    }
  }];
};
var $t = {};
var Ct = {};
var addPlugins = t2 => {
  each(t2, t3 => each(t3, (n2, o2) => {
    $t[o2] = t3[o2];
  }));
};
var registerPluginModuleInstances = (t2, n2, o2) => keys(t2).map(s2 => {
  const {
    static: e2,
    instance: c2
  } = t2[s2];
  const [r2, l2, i2] = o2 || [];
  const a2 = o2 ? c2 : e2;
  if (a2) {
    const t3 = o2 ? a2(r2, l2, n2) : a2(n2);
    return (i2 || Ct)[s2] = t3;
  }
});
var getStaticPluginModuleInstance = t2 => Ct[t2];
var xt = "__osOptionsValidationPlugin";
var Ht = "__osSizeObserverPlugin";
var getShowNativeOverlaidScrollbars = (t2, n2) => {
  const {
    k: o2
  } = n2;
  const [s2, e2] = t2("showNativeOverlaidScrollbars");
  return [s2 && o2.x && o2.y, e2];
};
var overflowIsVisible = t2 => t2.indexOf(x) === 0;
var createViewportOverflowState = (t2, n2) => {
  const getAxisOverflowStyle = (t3, n3, o3, s2) => {
    const e2 = t3 === x ? H : t3.replace(`${x}-`, "");
    const c2 = overflowIsVisible(t3);
    const r2 = overflowIsVisible(o3);
    if (!n3 && !s2) {
      return H;
    }
    if (c2 && r2) {
      return x;
    }
    if (c2) {
      const t4 = n3 ? x : H;
      return n3 && s2 ? e2 : t4;
    }
    const l2 = r2 && s2 ? x : H;
    return n3 ? e2 : l2;
  };
  const o2 = {
    x: getAxisOverflowStyle(n2.x, t2.x, n2.y, t2.y),
    y: getAxisOverflowStyle(n2.y, t2.y, n2.x, t2.x)
  };
  return {
    K: o2,
    Z: {
      x: o2.x === E,
      y: o2.y === E
    }
  };
};
var zt = "__osScrollbarsHidingPlugin";
var At = "__osClickScrollPlugin";
var createSizeObserver = (t2, n2, o2) => {
  const {
    dt: s2
  } = o2 || {};
  const e2 = getStaticPluginModuleInstance(Ht);
  const [c2] = createCache({
    o: false,
    u: true
  });
  return () => {
    const o3 = [];
    const r2 = createDOM(`<div class="${Q}"><div class="${tt}"></div></div>`);
    const l2 = r2[0];
    const i2 = l2.firstChild;
    const onSizeChangedCallbackProxy = t3 => {
      const o4 = t3 instanceof ResizeObserverEntry;
      let s3 = false;
      let e3 = false;
      if (o4) {
        const [n3,, o5] = c2(t3.contentRect);
        const r3 = domRectHasDimensions(n3);
        e3 = domRectAppeared(n3, o5);
        s3 = !e3 && !r3;
      } else {
        e3 = t3 === true;
      }
      if (!s3) {
        n2({
          ft: true,
          dt: e3
        });
      }
    };
    if (f) {
      const t3 = new f(t4 => onSizeChangedCallbackProxy(t4.pop()));
      t3.observe(i2);
      push(o3, () => {
        t3.disconnect();
      });
    } else if (e2) {
      const [t3, n3] = e2(i2, onSizeChangedCallbackProxy, s2);
      push(o3, concat2([addClass(l2, Z), addEventListener(l2, "animationstart", t3)], n3));
    } else {
      return noop;
    }
    return bind(runEachAndClear, push(o3, appendChildren(t2, l2)));
  };
};
var createTrinsicObserver = (t2, n2) => {
  let o2;
  const isHeightIntrinsic = t3 => t3.h === 0 || t3.isIntersecting || t3.intersectionRatio > 0;
  const s2 = createDiv(et);
  const [e2] = createCache({
    o: false
  });
  const triggerOnTrinsicChangedCallback = (t3, o3) => {
    if (t3) {
      const s3 = e2(isHeightIntrinsic(t3));
      const [, c2] = s3;
      return c2 && !o3 && n2(s3) && [s3];
    }
  };
  const intersectionObserverCallback = (t3, n3) => triggerOnTrinsicChangedCallback(n3.pop(), t3);
  return [() => {
    const n3 = [];
    if (d) {
      o2 = new d(bind(intersectionObserverCallback, false), {
        root: t2
      });
      o2.observe(s2);
      push(n3, () => {
        o2.disconnect();
      });
    } else {
      const onSizeChanged = () => {
        const t3 = I(s2);
        triggerOnTrinsicChangedCallback(t3);
      };
      push(n3, createSizeObserver(s2, onSizeChanged)());
      onSizeChanged();
    }
    return bind(runEachAndClear, push(n3, appendChildren(t2, s2)));
  }, () => o2 && intersectionObserverCallback(true, o2.takeRecords())];
};
var createObserversSetup = (t2, n2, o2, s2) => {
  let e2;
  let c2;
  let r2;
  let l2;
  let i2;
  let a2;
  const u2 = `[${P}]`;
  const _2 = `[${q}]`;
  const d2 = ["id", "class", "style", "open", "wrap", "cols", "rows"];
  const {
    vt: v2,
    ht: p2,
    ot: h2,
    gt: g2,
    bt: b2,
    nt: w2,
    wt: y2,
    yt: S2,
    St: m2,
    Ot: O2
  } = t2;
  const getDirectionIsRTL = t3 => getStyles(t3, "direction") === "rtl";
  const $2 = {
    $t: false,
    ct: getDirectionIsRTL(v2)
  };
  const C2 = getEnvironment();
  const x2 = getStaticPluginModuleInstance(zt);
  const [H2] = createCache({
    i: equalWH,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const s3 = x2 && x2.tt(t2, n2, $2, C2, o2).ut;
    const e3 = y2 && w2;
    const c3 = !e3 && hasAttrClass(p2, P, L);
    const r3 = !w2 && S2(j);
    const l3 = r3 && getElementScroll(g2);
    const i3 = l3 && O2();
    const a3 = m2(X, c3);
    const u3 = r3 && s3 && s3()[0];
    const _3 = D(h2);
    const d3 = getFractionalSize(h2);
    u3 && u3();
    scrollElementTo(g2, l3);
    i3 && i3();
    c3 && a3();
    return {
      w: _3.w + d3.w,
      h: _3.h + d3.h
    };
  });
  const E2 = debounce(s2, {
    _: () => e2,
    v: () => c2,
    S(t3, n3) {
      const [o3] = t3;
      const [s3] = n3;
      return [concat2(keys(o3), keys(s3)).reduce((t4, n4) => {
        t4[n4] = o3[n4] || s3[n4];
        return t4;
      }, {})];
    }
  });
  const setDirection = t3 => {
    const n3 = getDirectionIsRTL(v2);
    assignDeep(t3, {
      Ct: a2 !== n3
    });
    assignDeep($2, {
      ct: n3
    });
    a2 = n3;
  };
  const onTrinsicChanged = (t3, n3) => {
    const [o3, e3] = t3;
    const c3 = {
      xt: e3
    };
    assignDeep($2, {
      $t: o3
    });
    !n3 && s2(c3);
    return c3;
  };
  const onSizeChanged = ({
    ft: t3,
    dt: n3
  }) => {
    const o3 = t3 && !n3;
    const e3 = !o3 && C2.R ? E2 : s2;
    const c3 = {
      ft: t3 || n3,
      dt: n3
    };
    setDirection(c3);
    e3(c3);
  };
  const onContentMutation = (t3, n3) => {
    const [, o3] = H2();
    const e3 = {
      Ht: o3
    };
    setDirection(e3);
    const c3 = t3 ? s2 : E2;
    o3 && !n3 && c3(e3);
    return e3;
  };
  const onHostMutation = (t3, n3, o3) => {
    const s3 = {
      Et: n3
    };
    setDirection(s3);
    if (n3 && !o3) {
      E2(s3);
    }
    return s3;
  };
  const [z2, I2] = b2 ? createTrinsicObserver(p2, onTrinsicChanged) : [];
  const A3 = !w2 && createSizeObserver(p2, onSizeChanged, {
    dt: true
  });
  const [M2, T2] = createDOMObserver(p2, false, onHostMutation, {
    X: d2,
    j: d2
  });
  const k2 = w2 && f && new f(t3 => {
    const n3 = t3[t3.length - 1].contentRect;
    onSizeChanged({
      ft: true,
      dt: domRectAppeared(n3, i2)
    });
    i2 = n3;
  });
  const R2 = debounce(() => {
    const [, t3] = H2();
    s2({
      Ht: t3
    });
  }, {
    _: 222,
    p: true
  });
  return [() => {
    k2 && k2.observe(p2);
    const t3 = A3 && A3();
    const n3 = z2 && z2();
    const o3 = M2();
    const s3 = C2.L(t4 => {
      if (t4) {
        E2({
          zt: t4
        });
      } else {
        R2();
      }
    });
    return () => {
      k2 && k2.disconnect();
      t3 && t3();
      n3 && n3();
      l2 && l2();
      o3();
      s3();
    };
  }, ({
    It: t3,
    At: n3,
    Dt: o3
  }) => {
    const s3 = {};
    const [i3] = t3("update.ignoreMutation");
    const [a3, f2] = t3("update.attributes");
    const [v3, p3] = t3("update.elementEvents");
    const [g3, y3] = t3("update.debounce");
    const S3 = p3 || f2;
    const m3 = n3 || o3;
    const ignoreMutationFromOptions = t4 => isFunction(i3) && i3(t4);
    if (S3) {
      r2 && r2();
      l2 && l2();
      const [t4, n4] = createDOMObserver(b2 || h2, true, onContentMutation, {
        j: concat2(d2, a3 || []),
        Y: v3,
        W: u2,
        G: (t5, n5) => {
          const {
            target: o4,
            attributeName: s4
          } = t5;
          const e3 = !n5 && s4 && !w2 ? liesBetween(o4, u2, _2) : false;
          return e3 || !!closest(o4, `.${rt}`) || !!ignoreMutationFromOptions(t5);
        }
      });
      l2 = t4();
      r2 = n4;
    }
    if (y3) {
      E2.m();
      if (isArray(g3)) {
        const t4 = g3[0];
        const n4 = g3[1];
        e2 = isNumber(t4) && t4;
        c2 = isNumber(n4) && n4;
      } else if (isNumber(g3)) {
        e2 = g3;
        c2 = false;
      } else {
        e2 = false;
        c2 = false;
      }
    }
    if (m3) {
      const t4 = T2();
      const n4 = I2 && I2();
      const o4 = r2 && r2();
      t4 && assignDeep(s3, onHostMutation(t4[0], t4[1], m3));
      n4 && assignDeep(s3, onTrinsicChanged(n4[0], m3));
      o4 && assignDeep(s3, onContentMutation(o4[0], m3));
    }
    setDirection(s3);
    return s3;
  }, $2];
};
var createScrollbarsSetupElements = (t2, n2, o2, s2) => {
  const e2 = "--os-viewport-percent";
  const c2 = "--os-scroll-percent";
  const r2 = "--os-scroll-direction";
  const {
    U: l2
  } = getEnvironment();
  const {
    scrollbars: i2
  } = l2();
  const {
    slot: a2
  } = i2;
  const {
    vt: u2,
    ht: _2,
    ot: d2,
    Mt: f2,
    gt: p2,
    wt: h2,
    nt: g2
  } = n2;
  const {
    scrollbars: b2
  } = f2 ? {} : t2;
  const {
    slot: w2
  } = b2 || {};
  const y2 = [];
  const S2 = [];
  const m2 = [];
  const O2 = dynamicInitializationElement([u2, _2, d2], () => g2 && h2 ? u2 : _2, a2, w2);
  const initScrollTimeline = t3 => {
    if (v) {
      const n3 = new v({
        source: p2,
        axis: t3
      });
      const _addScrollPercentAnimation = t4 => {
        const o3 = t4.Tt.animate({
          clear: ["left"],
          [c2]: [0, 1]
        }, {
          timeline: n3
        });
        return () => o3.cancel();
      };
      return {
        kt: _addScrollPercentAnimation
      };
    }
  };
  const $2 = {
    x: initScrollTimeline("x"),
    y: initScrollTimeline("y")
  };
  const getViewportPercent = () => {
    const {
      Rt: t3,
      Vt: n3
    } = o2;
    const getAxisValue = (t4, n4) => capNumber(0, 1, t4 / (t4 + n4) || 0);
    return {
      x: getAxisValue(n3.x, t3.x),
      y: getAxisValue(n3.y, t3.y)
    };
  };
  const scrollbarStructureAddRemoveClass = (t3, n3, o3) => {
    const s3 = o3 ? addClass : removeClass;
    each(t3, t4 => {
      s3(t4.Tt, n3);
    });
  };
  const scrollbarStyle = (t3, n3) => {
    each(t3, t4 => {
      const [o3, s3] = n3(t4);
      setStyles(o3, s3);
    });
  };
  const scrollbarsAddRemoveClass = (t3, n3, o3) => {
    const s3 = isBoolean(o3);
    const e3 = s3 ? o3 : true;
    const c3 = s3 ? !o3 : true;
    e3 && scrollbarStructureAddRemoveClass(S2, t3, n3);
    c3 && scrollbarStructureAddRemoveClass(m2, t3, n3);
  };
  const refreshScrollbarsHandleLength = () => {
    const t3 = getViewportPercent();
    const createScrollbarStyleFn = t4 => n3 => [n3.Tt, {
      [e2]: roundCssNumber(t4) + ""
    }];
    scrollbarStyle(S2, createScrollbarStyleFn(t3.x));
    scrollbarStyle(m2, createScrollbarStyleFn(t3.y));
  };
  const refreshScrollbarsHandleOffset = () => {
    if (!v) {
      const {
        Lt: t3
      } = o2;
      const n3 = getScrollCoordinatesPercent(t3, getElementScroll(p2));
      const createScrollbarStyleFn = t4 => n4 => [n4.Tt, {
        [c2]: roundCssNumber(t4) + ""
      }];
      scrollbarStyle(S2, createScrollbarStyleFn(n3.x));
      scrollbarStyle(m2, createScrollbarStyleFn(n3.y));
    }
  };
  const refreshScrollbarsScrollCoordinates = () => {
    const {
      Lt: t3
    } = o2;
    const n3 = isDefaultDirectionScrollCoordinates(t3);
    const createScrollbarStyleFn = t4 => n4 => [n4.Tt, {
      [r2]: t4 ? "0" : "1"
    }];
    scrollbarStyle(S2, createScrollbarStyleFn(n3.x));
    scrollbarStyle(m2, createScrollbarStyleFn(n3.y));
  };
  const refreshScrollbarsScrollbarOffset = () => {
    if (g2 && !h2) {
      const {
        Rt: t3,
        Lt: n3
      } = o2;
      const s3 = isDefaultDirectionScrollCoordinates(n3);
      const e3 = getScrollCoordinatesPercent(n3, getElementScroll(p2));
      const styleScrollbarPosition = n4 => {
        const {
          Tt: o3
        } = n4;
        const c3 = parent(o3) === d2 && o3;
        const getTranslateValue = (t4, n5, o4) => {
          const s4 = n5 * t4;
          return numberToCssPx(o4 ? s4 : -s4);
        };
        return [c3, c3 && {
          transform: getTrasformTranslateValue({
            x: getTranslateValue(e3.x, t3.x, s3.x),
            y: getTranslateValue(e3.y, t3.y, s3.y)
          })
        }];
      };
      scrollbarStyle(S2, styleScrollbarPosition);
      scrollbarStyle(m2, styleScrollbarPosition);
    }
  };
  const generateScrollbarDOM = t3 => {
    const n3 = t3 ? "x" : "y";
    const o3 = t3 ? it : at;
    const e3 = createDiv(`${rt} ${o3}`);
    const c3 = createDiv(ut);
    const r3 = createDiv(_t);
    const l3 = {
      Tt: e3,
      Ut: c3,
      Pt: r3
    };
    const i3 = $2[n3];
    push(t3 ? S2 : m2, l3);
    push(y2, [appendChildren(e3, c3), appendChildren(c3, r3), bind(removeElements, e3), i3 && i3.kt(l3), s2(l3, scrollbarsAddRemoveClass, t3)]);
    return l3;
  };
  const C2 = bind(generateScrollbarDOM, true);
  const x2 = bind(generateScrollbarDOM, false);
  const appendElements = () => {
    appendChildren(O2, S2[0].Tt);
    appendChildren(O2, m2[0].Tt);
    return bind(runEachAndClear, y2);
  };
  C2();
  x2();
  return [{
    Nt: refreshScrollbarsHandleLength,
    qt: refreshScrollbarsHandleOffset,
    Bt: refreshScrollbarsScrollCoordinates,
    Ft: refreshScrollbarsScrollbarOffset,
    jt: scrollbarsAddRemoveClass,
    Xt: {
      Yt: S2,
      Wt: C2,
      Jt: bind(scrollbarStyle, S2)
    },
    Gt: {
      Yt: m2,
      Wt: x2,
      Jt: bind(scrollbarStyle, m2)
    }
  }, appendElements];
};
var createScrollbarsSetupEvents = (t2, n2, o2, s2) => (r2, l2, i2) => {
  const {
    ht: u2,
    ot: _2,
    nt: d2,
    gt: f2,
    Kt: v2,
    Ot: p2
  } = n2;
  const {
    Tt: h2,
    Ut: g2,
    Pt: b2
  } = r2;
  const [w2, y2] = selfClearTimeout(333);
  const [S2, m2] = selfClearTimeout(444);
  const scrollOffsetElementScrollBy = t3 => {
    isFunction(f2.scrollBy) && f2.scrollBy({
      behavior: "smooth",
      left: t3.x,
      top: t3.y
    });
  };
  const createInteractiveScrollEvents = () => {
    const n3 = "pointerup pointercancel lostpointercapture";
    const s3 = `client${i2 ? "X" : "Y"}`;
    const r3 = i2 ? $ : C;
    const l3 = i2 ? "left" : "top";
    const a2 = i2 ? "w" : "h";
    const u3 = i2 ? "x" : "y";
    const createRelativeHandleMove = (t3, n4) => s4 => {
      const {
        Rt: e2
      } = o2;
      const c2 = I(g2)[a2] - I(b2)[a2];
      const r4 = n4 * s4 / c2;
      const l4 = r4 * e2[u3];
      scrollElementTo(f2, {
        [u3]: t3 + l4
      });
    };
    const _3 = [];
    return addEventListener(g2, "pointerdown", o3 => {
      const i3 = closest(o3.target, `.${_t}`) === b2;
      const d3 = i3 ? b2 : g2;
      const h3 = t2.scrollbars;
      const w3 = h3[i3 ? "dragScroll" : "clickScroll"];
      const {
        button: y3,
        isPrimary: O3,
        pointerType: $2
      } = o3;
      const {
        pointers: C2
      } = h3;
      const x2 = y3 === 0 && O3 && w3 && (C2 || []).includes($2);
      if (x2) {
        runEachAndClear(_3);
        m2();
        const t3 = !i3 && (o3.shiftKey || w3 === "instant");
        const h4 = bind(getBoundingClientRect, b2);
        const y4 = bind(getBoundingClientRect, g2);
        const getHandleOffset = (t4, n4) => (t4 || h4())[l3] - (n4 || y4())[l3];
        const O4 = e(getBoundingClientRect(f2)[r3]) / I(f2)[a2] || 1;
        const $3 = createRelativeHandleMove(getElementScroll(f2)[u3], 1 / O4);
        const C3 = o3[s3];
        const x3 = h4();
        const H2 = y4();
        const E2 = x3[r3];
        const z2 = getHandleOffset(x3, H2) + E2 / 2;
        const A3 = C3 - H2[l3];
        const D2 = i3 ? 0 : A3 - z2;
        const releasePointerCapture = t4 => {
          runEachAndClear(k2);
          d3.releasePointerCapture(t4.pointerId);
        };
        const M2 = i3 || t3;
        const T2 = p2();
        const k2 = [addEventListener(v2, n3, releasePointerCapture), addEventListener(v2, "selectstart", t4 => preventDefault(t4), {
          H: false
        }), addEventListener(g2, n3, releasePointerCapture), M2 && addEventListener(g2, "pointermove", t4 => $3(D2 + (t4[s3] - C3))), M2 && (() => {
          const t4 = getElementScroll(f2);
          T2();
          const n4 = getElementScroll(f2);
          const o4 = {
            x: n4.x - t4.x,
            y: n4.y - t4.y
          };
          if (c(o4.x) > 3 || c(o4.y) > 3) {
            p2();
            scrollElementTo(f2, t4);
            scrollOffsetElementScrollBy(o4);
            S2(T2);
          }
        })];
        d3.setPointerCapture(o3.pointerId);
        if (t3) {
          $3(D2);
        } else if (!i3) {
          const t4 = getStaticPluginModuleInstance(At);
          if (t4) {
            const n4 = t4($3, D2, E2, t5 => {
              if (t5) {
                T2();
              } else {
                push(k2, T2);
              }
            });
            push(k2, n4);
            push(_3, bind(n4, true));
          }
        }
      }
    });
  };
  let O2 = true;
  return bind(runEachAndClear, [addEventListener(b2, "pointermove pointerleave", s2), addEventListener(h2, "pointerenter", () => {
    l2(vt, true);
  }), addEventListener(h2, "pointerleave pointercancel", () => {
    l2(vt, false);
  }), !d2 && addEventListener(h2, "mousedown", () => {
    const t3 = getFocusedElement();
    if (hasAttr(t3, q) || hasAttr(t3, P) || t3 === document.body) {
      a(bind(focusElement, _2), 25);
    }
  }), addEventListener(h2, "wheel", t3 => {
    const {
      deltaX: n3,
      deltaY: o3,
      deltaMode: s3
    } = t3;
    if (O2 && s3 === 0 && parent(h2) === u2) {
      scrollOffsetElementScrollBy({
        x: n3,
        y: o3
      });
    }
    O2 = false;
    l2(bt, true);
    w2(() => {
      O2 = true;
      l2(bt);
    });
    preventDefault(t3);
  }, {
    H: false,
    I: true
  }), addEventListener(h2, "pointerdown", bind(addEventListener, v2, "click", stopAndPrevent, {
    A: true,
    I: true,
    H: false
  }), {
    I: true
  }), createInteractiveScrollEvents(), y2, m2]);
};
var createScrollbarsSetup = (t2, n2, o2, s2, e2, c2) => {
  let r2;
  let l2;
  let i2;
  let a2;
  let u2;
  let _2 = noop;
  let d2 = 0;
  const isHoverablePointerType = t3 => t3.pointerType === "mouse";
  const [f2, v2] = selfClearTimeout();
  const [p2, h2] = selfClearTimeout(100);
  const [g2, b2] = selfClearTimeout(100);
  const [w2, y2] = selfClearTimeout(() => d2);
  const [S2, m2] = createScrollbarsSetupElements(t2, e2, s2, createScrollbarsSetupEvents(n2, e2, s2, t3 => isHoverablePointerType(t3) && manageScrollbarsAutoHideInstantInteraction()));
  const {
    ht: O2,
    Qt: $2,
    wt: C2
  } = e2;
  const {
    jt: H2,
    Nt: z2,
    qt: I2,
    Bt: A3,
    Ft: D2
  } = S2;
  const manageScrollbarsAutoHide = (t3, n3) => {
    y2();
    if (t3) {
      H2(gt);
    } else {
      const t4 = bind(H2, gt, true);
      if (d2 > 0 && !n3) {
        w2(t4);
      } else {
        t4();
      }
    }
  };
  const manageScrollbarsAutoHideInstantInteraction = () => {
    if (i2 ? !r2 : !a2) {
      manageScrollbarsAutoHide(true);
      p2(() => {
        manageScrollbarsAutoHide(false);
      });
    }
  };
  const manageAutoHideSuspension = t3 => {
    H2(ht, t3, true);
    H2(ht, t3, false);
  };
  const onHostMouseEnter = t3 => {
    if (isHoverablePointerType(t3)) {
      r2 = i2;
      i2 && manageScrollbarsAutoHide(true);
    }
  };
  const M2 = [y2, h2, b2, v2, () => _2(), addEventListener(O2, "pointerover", onHostMouseEnter, {
    A: true
  }), addEventListener(O2, "pointerenter", onHostMouseEnter), addEventListener(O2, "pointerleave", t3 => {
    if (isHoverablePointerType(t3)) {
      r2 = false;
      i2 && manageScrollbarsAutoHide(false);
    }
  }), addEventListener(O2, "pointermove", t3 => {
    isHoverablePointerType(t3) && l2 && manageScrollbarsAutoHideInstantInteraction();
  }), addEventListener($2, "scroll", t3 => {
    f2(() => {
      I2();
      manageScrollbarsAutoHideInstantInteraction();
    });
    c2(t3);
    D2();
  })];
  return [() => bind(runEachAndClear, push(M2, m2())), ({
    It: t3,
    Dt: n3,
    Zt: e3,
    tn: c3
  }) => {
    const {
      nn: r3,
      sn: f3,
      en: v3,
      cn: p3
    } = c3 || {};
    const {
      Ct: h3,
      dt: b3
    } = e3 || {};
    const {
      ct: w3
    } = o2;
    const {
      k: y3
    } = getEnvironment();
    const {
      K: S3,
      rn: m3
    } = s2;
    const [O3, M3] = t3("showNativeOverlaidScrollbars");
    const [T2, k2] = t3("scrollbars.theme");
    const [R2, V2] = t3("scrollbars.visibility");
    const [L2, U2] = t3("scrollbars.autoHide");
    const [P2, N2] = t3("scrollbars.autoHideSuspend");
    const [q2] = t3("scrollbars.autoHideDelay");
    const [B2, F2] = t3("scrollbars.dragScroll");
    const [j2, X2] = t3("scrollbars.clickScroll");
    const [Y2, W2] = t3("overflow");
    const J2 = b3 && !n3;
    const G2 = m3.x || m3.y;
    const K2 = r3 || f3 || p3 || h3 || n3;
    const Q2 = v3 || V2 || W2;
    const Z2 = O3 && y3.x && y3.y;
    const setScrollbarVisibility = (t4, n4, o3) => {
      const s3 = t4.includes(E) && (R2 === x || R2 === "auto" && n4 === E);
      H2(dt, s3, o3);
      return s3;
    };
    d2 = q2;
    if (J2) {
      if (P2 && G2) {
        manageAutoHideSuspension(false);
        _2();
        g2(() => {
          _2 = addEventListener($2, "scroll", bind(manageAutoHideSuspension, true), {
            A: true
          });
        });
      } else {
        manageAutoHideSuspension(true);
      }
    }
    if (M3) {
      H2(ct, Z2);
    }
    if (k2) {
      H2(u2);
      H2(T2, true);
      u2 = T2;
    }
    if (N2 && !P2) {
      manageAutoHideSuspension(true);
    }
    if (U2) {
      l2 = L2 === "move";
      i2 = L2 === "leave";
      a2 = L2 === "never";
      manageScrollbarsAutoHide(a2, true);
    }
    if (F2) {
      H2(yt, B2);
    }
    if (X2) {
      H2(wt, !!j2);
    }
    if (Q2) {
      const t4 = setScrollbarVisibility(Y2.x, S3.x, true);
      const n4 = setScrollbarVisibility(Y2.y, S3.y, false);
      const o3 = t4 && n4;
      H2(ft, !o3);
    }
    if (K2) {
      I2();
      z2();
      D2();
      p3 && A3();
      H2(pt, !m3.x, true);
      H2(pt, !m3.y, false);
      H2(lt, w3 && !C2);
    }
  }, {}, S2];
};
var createStructureSetupElements = t2 => {
  const o2 = getEnvironment();
  const {
    U: s2,
    R: e2
  } = o2;
  const {
    elements: c2
  } = s2();
  const {
    padding: r2,
    viewport: l2,
    content: i2
  } = c2;
  const a2 = isHTMLElement(t2);
  const u2 = a2 ? {} : t2;
  const {
    elements: _2
  } = u2;
  const {
    padding: d2,
    viewport: f2,
    content: v2
  } = _2 || {};
  const p2 = a2 ? t2 : u2.target;
  const h2 = isBodyElement(p2);
  const g2 = p2.ownerDocument;
  const b2 = g2.documentElement;
  const getDocumentWindow = () => g2.defaultView || n;
  const w2 = bind(staticInitializationElement, [p2]);
  const y2 = bind(dynamicInitializationElement, [p2]);
  const S2 = bind(createDiv, "");
  const $2 = bind(w2, S2, l2);
  const C2 = bind(y2, S2, i2);
  const elementHasOverflow = t3 => {
    const n2 = I(t3);
    const o3 = D(t3);
    const s3 = getStyles(t3, m);
    const e3 = getStyles(t3, O);
    return o3.w - n2.w > 0 && !overflowIsVisible(s3) || o3.h - n2.h > 0 && !overflowIsVisible(e3);
  };
  const x2 = $2(f2);
  const H2 = x2 === p2;
  const E2 = H2 && h2;
  const z2 = !H2 && C2(v2);
  const A3 = !H2 && x2 === z2;
  const M2 = E2 ? b2 : x2;
  const T2 = E2 ? M2 : p2;
  const k2 = !H2 && y2(S2, r2, d2);
  const R2 = !A3 && z2;
  const L2 = [R2, M2, k2, T2].map(t3 => isHTMLElement(t3) && !parent(t3) && t3);
  const elementIsGenerated = t3 => t3 && inArray(L2, t3);
  const B2 = !elementIsGenerated(M2) && elementHasOverflow(M2) ? M2 : p2;
  const F2 = E2 ? b2 : M2;
  const j2 = E2 ? g2 : M2;
  const X2 = {
    vt: p2,
    ht: T2,
    ot: M2,
    ln: k2,
    bt: R2,
    gt: F2,
    Qt: j2,
    an: h2 ? b2 : B2,
    Kt: g2,
    wt: h2,
    Mt: a2,
    nt: H2,
    un: getDocumentWindow,
    yt: t3 => hasAttrClass(M2, q, t3),
    St: (t3, n2) => addRemoveAttrClass(M2, q, t3, n2),
    Ot: () => addRemoveAttrClass(F2, q, Y, true)
  };
  const {
    vt: J2,
    ht: Q2,
    ln: Z2,
    ot: tt2,
    bt: nt2
  } = X2;
  const ot2 = [() => {
    removeAttrs(Q2, [P, V]);
    removeAttrs(J2, V);
    if (h2) {
      removeAttrs(b2, [V, P]);
    }
  }];
  let st2 = contents([nt2, tt2, Z2, Q2, J2].find(t3 => t3 && !elementIsGenerated(t3)));
  const et2 = E2 ? J2 : nt2 || tt2;
  const ct2 = bind(runEachAndClear, ot2);
  const appendElements = () => {
    const t3 = getDocumentWindow();
    const n2 = getFocusedElement();
    const unwrap = t4 => {
      appendChildren(parent(t4), contents(t4));
      removeElements(t4);
    };
    const prepareWrapUnwrapFocus = t4 => addEventListener(t4, "focusin focusout focus blur", stopAndPrevent, {
      I: true,
      H: false
    });
    const o3 = "tabindex";
    const s3 = getAttr(tt2, o3);
    const c3 = prepareWrapUnwrapFocus(n2);
    setAttrs(Q2, P, H2 ? "" : N);
    setAttrs(Z2, G, "");
    setAttrs(tt2, q, "");
    setAttrs(nt2, K, "");
    if (!H2) {
      setAttrs(tt2, o3, s3 || "-1");
      h2 && setAttrs(b2, U, "");
    }
    appendChildren(et2, st2);
    appendChildren(Q2, Z2);
    appendChildren(Z2 || Q2, !H2 && tt2);
    appendChildren(tt2, nt2);
    push(ot2, [c3, () => {
      const t4 = getFocusedElement();
      const n3 = elementIsGenerated(tt2);
      const e3 = n3 && t4 === tt2 ? J2 : t4;
      const c4 = prepareWrapUnwrapFocus(e3);
      removeAttrs(Z2, G);
      removeAttrs(nt2, K);
      removeAttrs(tt2, q);
      h2 && removeAttrs(b2, U);
      s3 ? setAttrs(tt2, o3, s3) : removeAttrs(tt2, o3);
      elementIsGenerated(nt2) && unwrap(nt2);
      n3 && unwrap(tt2);
      elementIsGenerated(Z2) && unwrap(Z2);
      focusElement(e3);
      c4();
    }]);
    if (e2 && !H2) {
      addAttrClass(tt2, q, W);
      push(ot2, bind(removeAttrs, tt2, q));
    }
    focusElement(!H2 && h2 && n2 === J2 && t3.top === t3 ? tt2 : n2);
    c3();
    st2 = 0;
    return ct2;
  };
  return [X2, appendElements, ct2];
};
var createTrinsicUpdateSegment = ({
  bt: t2
}) => ({
  Zt: n2,
  _n: o2,
  Dt: s2
}) => {
  const {
    xt: e2
  } = n2 || {};
  const {
    $t: c2
  } = o2;
  const r2 = t2 && (e2 || s2);
  if (r2) {
    setStyles(t2, {
      [C]: c2 && "100%"
    });
  }
};
var createPaddingUpdateSegment = ({
  ht: t2,
  ln: n2,
  ot: o2,
  nt: s2
}, e2) => {
  const [c2, r2] = createCache({
    i: equalTRBL,
    o: topRightBottomLeft()
  }, bind(topRightBottomLeft, t2, "padding", ""));
  return ({
    It: t3,
    Zt: l2,
    _n: i2,
    Dt: a2
  }) => {
    let [u2, _2] = r2(a2);
    const {
      R: d2
    } = getEnvironment();
    const {
      ft: f2,
      Ht: v2,
      Ct: m2
    } = l2 || {};
    const {
      ct: O2
    } = i2;
    const [C2, x2] = t3("paddingAbsolute");
    const H2 = a2 || v2;
    if (f2 || _2 || H2) {
      [u2, _2] = c2(a2);
    }
    const E2 = !s2 && (x2 || m2 || _2);
    if (E2) {
      const t4 = !C2 || !n2 && !d2;
      const s3 = u2.r + u2.l;
      const c3 = u2.t + u2.b;
      const r3 = {
        [y]: t4 && !O2 ? -s3 : 0,
        [S]: t4 ? -c3 : 0,
        [w]: t4 && O2 ? -s3 : 0,
        top: t4 ? -u2.t : 0,
        right: t4 ? O2 ? -u2.r : "auto" : 0,
        left: t4 ? O2 ? "auto" : -u2.l : 0,
        [$]: t4 && `calc(100% + ${s3}px)`
      };
      const l3 = {
        [p]: t4 ? u2.t : 0,
        [h]: t4 ? u2.r : 0,
        [b]: t4 ? u2.b : 0,
        [g]: t4 ? u2.l : 0
      };
      setStyles(n2 || o2, r3);
      setStyles(o2, l3);
      assignDeep(e2, {
        ln: u2,
        dn: !t4,
        rt: n2 ? l3 : assignDeep({}, r3, l3)
      });
    }
    return {
      fn: E2
    };
  };
};
var createOverflowUpdateSegment = (t2, s2) => {
  const e2 = getEnvironment();
  const {
    ht: c2,
    ln: r2,
    ot: l2,
    nt: a2,
    Qt: u2,
    gt: _2,
    wt: d2,
    St: f2,
    un: v2
  } = t2;
  const {
    R: p2
  } = e2;
  const h2 = d2 && a2;
  const g2 = bind(o, 0);
  const b2 = {
    display: () => false,
    direction: t3 => t3 !== "ltr",
    flexDirection: t3 => t3.endsWith("-reverse"),
    writingMode: t3 => t3 !== "horizontal-tb"
  };
  const w2 = keys(b2);
  const y2 = {
    i: equalWH,
    o: {
      w: 0,
      h: 0
    }
  };
  const S2 = {
    i: equalXY,
    o: {}
  };
  const setMeasuringMode = t3 => {
    f2(X, !h2 && t3);
  };
  const getMeasuredScrollCoordinates = t3 => {
    const n2 = w2.some(n3 => {
      const o3 = t3[n3];
      return o3 && b2[n3](o3);
    });
    if (!n2) {
      return {
        D: {
          x: 0,
          y: 0
        },
        M: {
          x: 1,
          y: 1
        }
      };
    }
    setMeasuringMode(true);
    const o2 = getElementScroll(_2);
    const s3 = f2(J, true);
    const e3 = addEventListener(u2, E, t4 => {
      const n3 = getElementScroll(_2);
      if (t4.isTrusted && n3.x === o2.x && n3.y === o2.y) {
        stopPropagation(t4);
      }
    }, {
      I: true,
      A: true
    });
    scrollElementTo(_2, {
      x: 0,
      y: 0
    });
    s3();
    const c3 = getElementScroll(_2);
    const r3 = D(_2);
    scrollElementTo(_2, {
      x: r3.w,
      y: r3.h
    });
    const l3 = getElementScroll(_2);
    scrollElementTo(_2, {
      x: l3.x - c3.x < 1 && -r3.w,
      y: l3.y - c3.y < 1 && -r3.h
    });
    const a3 = getElementScroll(_2);
    scrollElementTo(_2, o2);
    i(() => e3());
    return {
      D: c3,
      M: a3
    };
  };
  const getOverflowAmount = (t3, o2) => {
    const s3 = n.devicePixelRatio % 1 !== 0 ? 1 : 0;
    const e3 = {
      w: g2(t3.w - o2.w),
      h: g2(t3.h - o2.h)
    };
    return {
      w: e3.w > s3 ? e3.w : 0,
      h: e3.h > s3 ? e3.h : 0
    };
  };
  const [m2, O2] = createCache(y2, bind(getFractionalSize, l2));
  const [$2, C2] = createCache(y2, bind(D, l2));
  const [z2, I2] = createCache(y2);
  const [M2] = createCache(S2);
  const [T2, k2] = createCache(y2);
  const [R2] = createCache(S2);
  const [V2] = createCache({
    i: (t3, n2) => equal(t3, n2, w2),
    o: {}
  }, () => hasDimensions(l2) ? getStyles(l2, w2) : {});
  const [U2, N2] = createCache({
    i: (t3, n2) => equalXY(t3.D, n2.D) && equalXY(t3.M, n2.M),
    o: getZeroScrollCoordinates()
  });
  const q2 = getStaticPluginModuleInstance(zt);
  const createViewportOverflowStyleClassName = (t3, n2) => {
    const o2 = n2 ? B : F;
    return `${o2}${capitalizeFirstLetter(t3)}`;
  };
  const setViewportOverflowStyle = t3 => {
    const createAllOverflowStyleClassNames = t4 => [x, H, E].map(n3 => createViewportOverflowStyleClassName(n3, t4));
    const n2 = createAllOverflowStyleClassNames(true).concat(createAllOverflowStyleClassNames()).join(" ");
    f2(n2);
    f2(keys(t3).map(n3 => createViewportOverflowStyleClassName(t3[n3], n3 === "x")).join(" "), true);
  };
  return ({
    It: n2,
    Zt: o2,
    _n: i2,
    Dt: a3
  }, {
    fn: u3
  }) => {
    const {
      ft: _3,
      Ht: d3,
      Ct: b3,
      dt: w3,
      zt: y3
    } = o2 || {};
    const S3 = q2 && q2.tt(t2, s2, i2, e2, n2);
    const {
      it: x2,
      ut: H2,
      _t: E2
    } = S3 || {};
    const [D2, B2] = getShowNativeOverlaidScrollbars(n2, e2);
    const [F2, j2] = n2("overflow");
    const X2 = overflowIsVisible(F2.x);
    const Y2 = overflowIsVisible(F2.y);
    const J2 = true;
    let K2 = O2(a3);
    let Q2 = C2(a3);
    let Z2 = I2(a3);
    let tt2 = k2(a3);
    if (B2 && p2) {
      f2(W, !D2);
    }
    {
      if (hasAttrClass(c2, P, L)) {
        setMeasuringMode(true);
      }
      const [t3] = H2 ? H2() : [];
      const [n3] = K2 = m2(a3);
      const [o3] = Q2 = $2(a3);
      const s3 = A2(l2);
      const e3 = h2 && getWindowSize(v2());
      const r3 = {
        w: g2(o3.w + n3.w),
        h: g2(o3.h + n3.h)
      };
      const i3 = {
        w: g2((e3 ? e3.w : s3.w + g2(s3.w - o3.w)) + n3.w),
        h: g2((e3 ? e3.h : s3.h + g2(s3.h - o3.h)) + n3.h)
      };
      t3 && t3();
      tt2 = T2(i3);
      Z2 = z2(getOverflowAmount(r3, i3), a3);
    }
    const [nt2, ot2] = tt2;
    const [st2, et2] = Z2;
    const [ct2, rt2] = Q2;
    const [lt2, it2] = K2;
    const [at2, ut2] = M2({
      x: st2.w > 0,
      y: st2.h > 0
    });
    const _t2 = X2 && Y2 && (at2.x || at2.y) || X2 && at2.x && !at2.y || Y2 && at2.y && !at2.x;
    const dt2 = u3 || b3 || y3 || it2 || rt2 || ot2 || et2 || j2 || B2 || J2;
    const ft2 = createViewportOverflowState(at2, F2);
    const [vt2, pt2] = R2(ft2.K);
    const [ht2, gt2] = V2(a3);
    const bt2 = b3 || w3 || gt2 || ut2 || a3;
    const [wt2, yt2] = bt2 ? U2(getMeasuredScrollCoordinates(ht2), a3) : N2();
    if (dt2) {
      pt2 && setViewportOverflowStyle(ft2.K);
      if (E2 && x2) {
        setStyles(l2, E2(ft2, i2, x2(ft2, ct2, lt2)));
      }
    }
    setMeasuringMode(false);
    addRemoveAttrClass(c2, P, L, _t2);
    addRemoveAttrClass(r2, G, L, _t2);
    assignDeep(s2, {
      K: vt2,
      Vt: {
        x: nt2.w,
        y: nt2.h
      },
      Rt: {
        x: st2.w,
        y: st2.h
      },
      rn: at2,
      Lt: sanitizeScrollCoordinates(wt2, st2)
    });
    return {
      en: pt2,
      nn: ot2,
      sn: et2,
      cn: yt2 || et2,
      vn: bt2
    };
  };
};
var createStructureSetup = t2 => {
  const [n2, o2, s2] = createStructureSetupElements(t2);
  const e2 = {
    ln: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    },
    dn: false,
    rt: {
      [y]: 0,
      [S]: 0,
      [w]: 0,
      [p]: 0,
      [h]: 0,
      [b]: 0,
      [g]: 0
    },
    Vt: {
      x: 0,
      y: 0
    },
    Rt: {
      x: 0,
      y: 0
    },
    K: {
      x: H,
      y: H
    },
    rn: {
      x: false,
      y: false
    },
    Lt: getZeroScrollCoordinates()
  };
  const {
    vt: c2,
    gt: r2,
    nt: l2,
    Ot: i2
  } = n2;
  const {
    R: a2,
    k: u2
  } = getEnvironment();
  const _2 = !a2 && (u2.x || u2.y);
  const d2 = [createTrinsicUpdateSegment(n2), createPaddingUpdateSegment(n2, e2), createOverflowUpdateSegment(n2, e2)];
  return [o2, t3 => {
    const n3 = {};
    const o3 = _2;
    const s3 = o3 && getElementScroll(r2);
    const e3 = s3 && i2();
    each(d2, o4 => {
      assignDeep(n3, o4(t3, n3) || {});
    });
    scrollElementTo(r2, s3);
    e3 && e3();
    !l2 && scrollElementTo(c2, 0);
    return n3;
  }, e2, n2, s2];
};
var createSetups = (t2, n2, o2, s2, e2) => {
  let c2 = false;
  const r2 = createOptionCheck(n2, {});
  const [l2, i2, a2, u2, _2] = createStructureSetup(t2);
  const [d2, f2, v2] = createObserversSetup(u2, a2, r2, t3 => {
    update({}, t3);
  });
  const [p2, h2,, g2] = createScrollbarsSetup(t2, n2, v2, a2, u2, e2);
  const updateHintsAreTruthy = t3 => keys(t3).some(n3 => !!t3[n3]);
  const update = (t3, e3) => {
    if (o2()) {
      return false;
    }
    const {
      pn: r3,
      Dt: l3,
      At: a3,
      hn: u3
    } = t3;
    const _3 = r3 || {};
    const d3 = !!l3 || !c2;
    const p3 = {
      It: createOptionCheck(n2, _3, d3),
      pn: _3,
      Dt: d3
    };
    if (u3) {
      h2(p3);
      return false;
    }
    const g3 = e3 || f2(assignDeep({}, p3, {
      At: a3
    }));
    const b2 = i2(assignDeep({}, p3, {
      _n: v2,
      Zt: g3
    }));
    h2(assignDeep({}, p3, {
      Zt: g3,
      tn: b2
    }));
    const w2 = updateHintsAreTruthy(g3);
    const y2 = updateHintsAreTruthy(b2);
    const S2 = w2 || y2 || !isEmptyObject(_3) || d3;
    c2 = true;
    S2 && s2(t3, {
      Zt: g3,
      tn: b2
    });
    return S2;
  };
  return [() => {
    const {
      an: t3,
      gt: n3,
      Ot: o3
    } = u2;
    const s3 = getElementScroll(t3);
    const e3 = [d2(), l2(), p2()];
    const c3 = o3();
    scrollElementTo(n3, s3);
    c3();
    return bind(runEachAndClear, e3);
  }, update, () => ({
    gn: v2,
    bn: a2
  }), {
    wn: u2,
    yn: g2
  }, _2];
};
var OverlayScrollbars = (t2, n2, o2) => {
  const {
    N: s2
  } = getEnvironment();
  const e2 = isHTMLElement(t2);
  const c2 = e2 ? t2 : t2.target;
  const r2 = getInstance(c2);
  if (n2 && !r2) {
    let r3 = false;
    const l2 = [];
    const i2 = {};
    const validateOptions = t3 => {
      const n3 = removeUndefinedProperties(t3, true);
      const o3 = getStaticPluginModuleInstance(xt);
      return o3 ? o3(n3, true) : n3;
    };
    const a2 = assignDeep({}, s2(), validateOptions(n2));
    const [u2, _2, d2] = createEventListenerHub();
    const [f2, v2, p2] = createEventListenerHub(o2);
    const triggerEvent = (t3, n3) => {
      p2(t3, n3);
      d2(t3, n3);
    };
    const [h2, g2, b2, w2, y2] = createSetups(t2, a2, () => r3, ({
      pn: t3,
      Dt: n3
    }, {
      Zt: o3,
      tn: s3
    }) => {
      const {
        ft: e3,
        Ct: c3,
        xt: r4,
        Ht: l3,
        Et: i3,
        dt: a3
      } = o3;
      const {
        nn: u3,
        sn: _3,
        en: d3,
        cn: f3
      } = s3;
      triggerEvent("updated", [S2, {
        updateHints: {
          sizeChanged: !!e3,
          directionChanged: !!c3,
          heightIntrinsicChanged: !!r4,
          overflowEdgeChanged: !!u3,
          overflowAmountChanged: !!_3,
          overflowStyleChanged: !!d3,
          scrollCoordinatesChanged: !!f3,
          contentMutation: !!l3,
          hostMutation: !!i3,
          appear: !!a3
        },
        changedOptions: t3 || {},
        force: !!n3
      }]);
    }, t3 => triggerEvent("scroll", [S2, t3]));
    const destroy = t3 => {
      removeInstance(c2);
      runEachAndClear(l2);
      r3 = true;
      triggerEvent("destroyed", [S2, t3]);
      _2();
      v2();
    };
    const S2 = {
      options(t3, n3) {
        if (t3) {
          const o3 = n3 ? s2() : {};
          const e3 = getOptionsDiff(a2, assignDeep(o3, validateOptions(t3)));
          if (!isEmptyObject(e3)) {
            assignDeep(a2, e3);
            g2({
              pn: e3
            });
          }
        }
        return assignDeep({}, a2);
      },
      on: f2,
      off: (t3, n3) => {
        t3 && n3 && v2(t3, n3);
      },
      state() {
        const {
          gn: t3,
          bn: n3
        } = b2();
        const {
          ct: o3
        } = t3;
        const {
          Vt: s3,
          Rt: e3,
          K: c3,
          rn: l3,
          ln: i3,
          dn: a3,
          Lt: u3
        } = n3;
        return assignDeep({}, {
          overflowEdge: s3,
          overflowAmount: e3,
          overflowStyle: c3,
          hasOverflow: l3,
          scrollCoordinates: {
            start: u3.D,
            end: u3.M
          },
          padding: i3,
          paddingAbsolute: a3,
          directionRTL: o3,
          destroyed: r3
        });
      },
      elements() {
        const {
          vt: t3,
          ht: n3,
          ln: o3,
          ot: s3,
          bt: e3,
          gt: c3,
          Qt: r4
        } = w2.wn;
        const {
          Xt: l3,
          Gt: i3
        } = w2.yn;
        const translateScrollbarStructure = t4 => {
          const {
            Pt: n4,
            Ut: o4,
            Tt: s4
          } = t4;
          return {
            scrollbar: s4,
            track: o4,
            handle: n4
          };
        };
        const translateScrollbarsSetupElement = t4 => {
          const {
            Yt: n4,
            Wt: o4
          } = t4;
          const s4 = translateScrollbarStructure(n4[0]);
          return assignDeep({}, s4, {
            clone: () => {
              const t5 = translateScrollbarStructure(o4());
              g2({
                hn: true
              });
              return t5;
            }
          });
        };
        return assignDeep({}, {
          target: t3,
          host: n3,
          padding: o3 || s3,
          viewport: s3,
          content: e3 || s3,
          scrollOffsetElement: c3,
          scrollEventElement: r4,
          scrollbarHorizontal: translateScrollbarsSetupElement(l3),
          scrollbarVertical: translateScrollbarsSetupElement(i3)
        });
      },
      update: t3 => g2({
        Dt: t3,
        At: true
      }),
      destroy: bind(destroy, false),
      plugin: t3 => i2[keys(t3)[0]]
    };
    push(l2, [y2]);
    addInstance(c2, S2);
    registerPluginModuleInstances($t, OverlayScrollbars, [S2, u2, i2]);
    if (cancelInitialization(w2.wn.wt, !e2 && t2.cancel)) {
      destroy(true);
      return S2;
    }
    push(l2, h2());
    triggerEvent("initialized", [S2]);
    S2.update();
    return S2;
  }
  return r2;
};
OverlayScrollbars.plugin = t2 => {
  const n2 = isArray(t2);
  const o2 = n2 ? t2 : [t2];
  const s2 = o2.map(t3 => registerPluginModuleInstances(t3, OverlayScrollbars)[0]);
  addPlugins(o2);
  return n2 ? s2 : s2[0];
};
OverlayScrollbars.valid = t2 => {
  const n2 = t2 && t2.elements;
  const o2 = isFunction(n2) && n2();
  return isPlainObject(o2) && !!getInstance(o2.target);
};
OverlayScrollbars.env = () => {
  const {
    T: t2,
    k: n2,
    R: o2,
    V: s2,
    B: e2,
    F: c2,
    U: r2,
    P: l2,
    N: i2,
    q: a2
  } = getEnvironment();
  return assignDeep({}, {
    scrollbarsSize: t2,
    scrollbarsOverlaid: n2,
    scrollbarsHiding: o2,
    scrollTimeline: s2,
    staticDefaultInitialization: e2,
    staticDefaultOptions: c2,
    getDefaultInitialization: r2,
    setDefaultInitialization: l2,
    getDefaultOptions: i2,
    setDefaultOptions: a2
  });
};
OverlayScrollbars.nonce = setNonce;

// node_modules/overlayscrollbars-ngx/fesm2020/overlayscrollbars-ngx.mjs
var _c08 = ["content"];
var _c18 = ["*"];
var createDefer = () => {
  if (typeof window === "undefined") {
    const noop2 = () => {};
    return [noop2, noop2];
  }
  let idleId;
  let rafId;
  const wnd = window;
  const idleSupported = typeof wnd.requestIdleCallback === "function";
  const rAF = wnd.requestAnimationFrame;
  const cAF = wnd.cancelAnimationFrame;
  const rIdle = idleSupported ? wnd.requestIdleCallback : rAF;
  const cIdle = idleSupported ? wnd.cancelIdleCallback : cAF;
  const clear = () => {
    cIdle(idleId);
    cAF(rafId);
  };
  return [(callback, options) => {
    clear();
    idleId = rIdle(idleSupported ? () => {
      clear();
      rafId = rAF(callback);
    } : callback,
    // @ts-ignore
    typeof options === "object" ? options : {
      timeout: 2233
    });
  }, clear];
};
var OverlayScrollbarsDirective = class {
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.instanceRef = null;
    const [requestDefer, cancelDefer] = createDefer();
    this.requestDefer = requestDefer;
    this.cancelDefer = cancelDefer;
  }
  osInitialize(target) {
    this.ngZone.runOutsideAngular(() => {
      const init = () => {
        this.instanceRef = OverlayScrollbars(target, this.options || {}, /* istanbul ignore next */
        this.events || {});
      };
      if (this.defer) {
        this.requestDefer(init, this.defer);
      } else {
        init();
      }
    });
  }
  osInstance() {
    return this.instanceRef;
  }
  ngOnChanges(changes) {
    const optionsChange = changes.options;
    const eventsChange = changes.events;
    if (optionsChange) {
      const curr = optionsChange.currentValue;
      this.options = curr;
      if (OverlayScrollbars.valid(this.instanceRef)) {
        this.instanceRef.options(curr || {}, true);
      }
    }
    if (eventsChange) {
      const curr = eventsChange.currentValue;
      this.events = curr;
      if (OverlayScrollbars.valid(this.instanceRef)) {
        this.instanceRef.on(/* istanbul ignore next */
        curr || {}, true);
      }
    }
  }
  ngOnDestroy() {
    this.cancelDefer();
  }
};
OverlayScrollbarsDirective.ɵfac = function OverlayScrollbarsDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OverlayScrollbarsDirective)(ɵɵdirectiveInject(NgZone));
};
OverlayScrollbarsDirective.ɵdir = /* @__PURE__ */ɵɵdefineDirective({
  type: OverlayScrollbarsDirective,
  selectors: [["", "overlayScrollbars", ""]],
  inputs: {
    options: "options",
    events: "events",
    defer: "defer"
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayScrollbarsDirective, [{
    type: Directive,
    args: [{
      selector: "[overlayScrollbars]"
      // https://angular.io/guide/styleguide#directive-selectors
    }]
  }], function () {
    return [{
      type: NgZone
    }];
  }, {
    options: [{
      type: Input,
      args: ["options"]
    }],
    events: [{
      type: Input,
      args: ["events"]
    }],
    defer: [{
      type: Input,
      args: ["defer"]
    }]
  });
})();
var mergeEventListeners = (emits, events) => Object.keys(emits).reduce((obj, name) => {
  const emitListener = emits[name];
  const eventListener = events[name];
  obj[name] = [emitListener, ...(Array.isArray(eventListener) ? eventListener : [eventListener]).filter(Boolean)];
  return obj;
}, {});
var OverlayScrollbarsComponent = class {
  constructor(ngZone, targetRef) {
    this.ngZone = ngZone;
    this.targetRef = targetRef;
    this.onInitialized = new EventEmitter();
    this.onUpdated = new EventEmitter();
    this.onDestroyed = new EventEmitter();
    this.onScroll = new EventEmitter();
  }
  osInstance() {
    return this.osDirective.osInstance();
  }
  getElement() {
    return this.targetRef.nativeElement;
  }
  ngAfterViewInit() {
    const targetElm = this.getElement();
    const contentElm = this.contentRef.nativeElement;
    if (targetElm && contentElm) {
      this.osDirective.osInitialize({
        target: targetElm,
        elements: {
          viewport: contentElm,
          content: contentElm
        }
      });
    }
  }
  ngOnDestroy() {
    this.osDirective?.osInstance()?.destroy();
  }
  mergeEvents(originalEvents) {
    return mergeEventListeners({
      initialized: (...args) => this.dispatchEventIfHasObservers(this.onInitialized, args),
      updated: (...args) => this.dispatchEventIfHasObservers(this.onUpdated, args),
      destroyed: (...args) => this.dispatchEventIfHasObservers(this.onDestroyed, args),
      scroll: (...args) => this.dispatchEventIfHasObservers(this.onScroll, args)
    }, originalEvents || {});
  }
  dispatchEventIfHasObservers(eventEmitter, args) {
    if (eventEmitter.observed || eventEmitter.observers.length > 0) {
      this.ngZone.run(() => eventEmitter.emit(args));
    }
  }
};
OverlayScrollbarsComponent.ɵfac = function OverlayScrollbarsComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OverlayScrollbarsComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef));
};
OverlayScrollbarsComponent.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
  type: OverlayScrollbarsComponent,
  selectors: [["overlay-scrollbars"], ["", "overlay-scrollbars", ""]],
  viewQuery: function OverlayScrollbarsComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c08, 5);
      ɵɵviewQuery(_c08, 5, OverlayScrollbarsDirective);
    }
    if (rf & 2) {
      let _t2;
      ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.contentRef = _t2.first);
      ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.osDirective = _t2.first);
    }
  },
  hostAttrs: ["data-overlayscrollbars-initialize", ""],
  inputs: {
    options: "options",
    events: "events",
    defer: "defer"
  },
  outputs: {
    onInitialized: "osInitialized",
    onUpdated: "osUpdated",
    onDestroyed: "osDestroyed",
    onScroll: "osScroll"
  },
  standalone: false,
  ngContentSelectors: _c18,
  decls: 3,
  vars: 3,
  consts: [["content", ""], ["overlayScrollbars", "", "data-overlayscrollbars-contents", "", 3, "options", "events", "defer"]],
  template: function OverlayScrollbarsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵprojection(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("options", ctx.options)("events", ctx.mergeEvents(ctx.events))("defer", ctx.defer);
    }
  },
  dependencies: [OverlayScrollbarsDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayScrollbarsComponent, [{
    type: Component,
    args: [{
      selector: "overlay-scrollbars, [overlay-scrollbars]",
      host: {
        "data-overlayscrollbars-initialize": ""
      },
      template: `
    <div
      overlayScrollbars
      data-overlayscrollbars-contents=""
      [options]="options"
      [events]="mergeEvents(events)"
      [defer]="defer"
      #content
    >
      <ng-content></ng-content>
    </div>
  `
    }]
  }], function () {
    return [{
      type: NgZone
    }, {
      type: ElementRef
    }];
  }, {
    options: [{
      type: Input,
      args: ["options"]
    }],
    events: [{
      type: Input,
      args: ["events"]
    }],
    defer: [{
      type: Input,
      args: ["defer"]
    }],
    onInitialized: [{
      type: Output,
      args: ["osInitialized"]
    }],
    onUpdated: [{
      type: Output,
      args: ["osUpdated"]
    }],
    onDestroyed: [{
      type: Output,
      args: ["osDestroyed"]
    }],
    onScroll: [{
      type: Output,
      args: ["osScroll"]
    }],
    contentRef: [{
      type: ViewChild,
      args: ["content"]
    }],
    osDirective: [{
      type: ViewChild,
      args: ["content", {
        read: OverlayScrollbarsDirective
      }]
    }]
  });
})();
var OverlayscrollbarsModule = class {};
OverlayscrollbarsModule.ɵfac = function OverlayscrollbarsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OverlayscrollbarsModule)();
};
OverlayscrollbarsModule.ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
  type: OverlayscrollbarsModule
});
OverlayscrollbarsModule.ɵinj = /* @__PURE__ */ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayscrollbarsModule, [{
    type: NgModule,
    args: [{
      declarations: [OverlayScrollbarsComponent, OverlayScrollbarsDirective],
      exports: [OverlayScrollbarsComponent, OverlayScrollbarsDirective]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/internal-form-field-5960ea2e.mjs
var _c09 = ["mat-internal-form-field", ""];
var _c19 = ["*"];
var _MatInternalFormField = class __MatInternalFormField {
  /** Position of the label relative to the content. */
  labelPosition;
  static ɵfac = function _MatInternalFormField_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __MatInternalFormField)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: __MatInternalFormField,
    selectors: [["div", "mat-internal-form-field", ""]],
    hostAttrs: [1, "mdc-form-field", "mat-internal-form-field"],
    hostVars: 2,
    hostBindings: function _MatInternalFormField_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("mdc-form-field--align-end", ctx.labelPosition === "before");
      }
    },
    inputs: {
      labelPosition: "labelPosition"
    },
    attrs: _c09,
    ngContentSelectors: _c19,
    decls: 1,
    vars: 0,
    template: function _MatInternalFormField_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    styles: [".mat-internal-form-field{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-flex;align-items:center;vertical-align:middle}.mat-internal-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mat-internal-form-field>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end .mdc-form-field--align-end label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatInternalFormField, [{
    type: Component,
    args: [{
      selector: "div[mat-internal-form-field]",
      template: "<ng-content></ng-content>",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "class": "mdc-form-field mat-internal-form-field",
        "[class.mdc-form-field--align-end]": 'labelPosition === "before"'
      },
      styles: [".mat-internal-form-field{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-flex;align-items:center;vertical-align:middle}.mat-internal-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mat-internal-form-field>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end .mdc-form-field--align-end label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0}"]
    }]
  }], null, {
    labelPosition: [{
      type: Input,
      args: [{
        required: true
      }]
    }]
  });
})();

// node_modules/@angular/material/fesm2022/date-formats-b618acb8.mjs
var MAT_DATE_LOCALE = new InjectionToken("MAT_DATE_LOCALE", {
  providedIn: "root",
  factory: MAT_DATE_LOCALE_FACTORY
});
function MAT_DATE_LOCALE_FACTORY() {
  return inject(LOCALE_ID);
}
var NOT_IMPLEMENTED = "Method not implemented";
var DateAdapter = class {
  /** The locale to use for all dates. */
  locale;
  _localeChanges = new Subject();
  /** A stream that emits when the locale changes. */
  localeChanges = this._localeChanges;
  /**
   * Sets the time of one date to the time of another.
   * @param target Date whose time will be set.
   * @param hours New hours to set on the date object.
   * @param minutes New minutes to set on the date object.
   * @param seconds New seconds to set on the date object.
   */
  setTime(target, hours, minutes, seconds) {
    throw new Error(NOT_IMPLEMENTED);
  }
  /**
   * Gets the hours component of the given date.
   * @param date The date to extract the hours from.
   */
  getHours(date) {
    throw new Error(NOT_IMPLEMENTED);
  }
  /**
   * Gets the minutes component of the given date.
   * @param date The date to extract the minutes from.
   */
  getMinutes(date) {
    throw new Error(NOT_IMPLEMENTED);
  }
  /**
   * Gets the seconds component of the given date.
   * @param date The date to extract the seconds from.
   */
  getSeconds(date) {
    throw new Error(NOT_IMPLEMENTED);
  }
  /**
   * Parses a date with a specific time from a user-provided value.
   * @param value The value to parse.
   * @param parseFormat The expected format of the value being parsed
   *     (type is implementation-dependent).
   */
  parseTime(value, parseFormat) {
    throw new Error(NOT_IMPLEMENTED);
  }
  /**
   * Adds an amount of seconds to the specified date.
   * @param date Date to which to add the seconds.
   * @param amount Amount of seconds to add to the date.
   */
  addSeconds(date, amount) {
    throw new Error(NOT_IMPLEMENTED);
  }
  /**
   * Given a potential date object, returns that same date object if it is
   * a valid date, or `null` if it's not a valid date.
   * @param obj The object to check.
   * @returns A date or `null`.
   */
  getValidDateOrNull(obj) {
    return this.isDateInstance(obj) && this.isValid(obj) ? obj : null;
  }
  /**
   * Attempts to deserialize a value to a valid date object. This is different from parsing in that
   * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
   * string). The default implementation does not allow any deserialization, it simply checks that
   * the given value is already a valid date object or null. The `<mat-datepicker>` will call this
   * method on all of its `@Input()` properties that accept dates. It is therefore possible to
   * support passing values from your backend directly to these properties by overriding this method
   * to also deserialize the format used by your backend.
   * @param value The value to be deserialized into a date object.
   * @returns The deserialized date object, either a valid date, null if the value can be
   *     deserialized into a null date (e.g. the empty string), or an invalid date.
   */
  deserialize(value) {
    if (value == null || this.isDateInstance(value) && this.isValid(value)) {
      return value;
    }
    return this.invalid();
  }
  /**
   * Sets the locale used for all dates.
   * @param locale The new locale.
   */
  setLocale(locale) {
    this.locale = locale;
    this._localeChanges.next();
  }
  /**
   * Compares two dates.
   * @param first The first date to compare.
   * @param second The second date to compare.
   * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,
   *     a number greater than 0 if the first date is later.
   */
  compareDate(first, second) {
    return this.getYear(first) - this.getYear(second) || this.getMonth(first) - this.getMonth(second) || this.getDate(first) - this.getDate(second);
  }
  /**
   * Compares the time values of two dates.
   * @param first First date to compare.
   * @param second Second date to compare.
   * @returns 0 if the times are equal, a number less than 0 if the first time is earlier,
   *     a number greater than 0 if the first time is later.
   */
  compareTime(first, second) {
    return this.getHours(first) - this.getHours(second) || this.getMinutes(first) - this.getMinutes(second) || this.getSeconds(first) - this.getSeconds(second);
  }
  /**
   * Checks if two dates are equal.
   * @param first The first date to check.
   * @param second The second date to check.
   * @returns Whether the two dates are equal.
   *     Null dates are considered equal to other null dates.
   */
  sameDate(first, second) {
    if (first && second) {
      let firstValid = this.isValid(first);
      let secondValid = this.isValid(second);
      if (firstValid && secondValid) {
        return !this.compareDate(first, second);
      }
      return firstValid == secondValid;
    }
    return first == second;
  }
  /**
   * Checks if the times of two dates are equal.
   * @param first The first date to check.
   * @param second The second date to check.
   * @returns Whether the times of the two dates are equal.
   *     Null dates are considered equal to other null dates.
   */
  sameTime(first, second) {
    if (first && second) {
      const firstValid = this.isValid(first);
      const secondValid = this.isValid(second);
      if (firstValid && secondValid) {
        return !this.compareTime(first, second);
      }
      return firstValid == secondValid;
    }
    return first == second;
  }
  /**
   * Clamp the given date between min and max dates.
   * @param date The date to clamp.
   * @param min The minimum value to allow. If null or omitted no min is enforced.
   * @param max The maximum value to allow. If null or omitted no max is enforced.
   * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,
   *     otherwise `date`.
   */
  clampDate(date, min, max) {
    if (min && this.compareDate(date, min) < 0) {
      return min;
    }
    if (max && this.compareDate(date, max) > 0) {
      return max;
    }
    return date;
  }
};
var MAT_DATE_FORMATS = new InjectionToken("mat-date-formats");

// node_modules/@angular/material/fesm2022/core.mjs
var VERSION = new Version("19.2.6");
var ISO_8601_REGEX = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/;
var TIME_REGEX = /^(\d?\d)[:.](\d?\d)(?:[:.](\d?\d))?\s*(AM|PM)?$/i;
function range(length, valueFunction) {
  const valuesArray = Array(length);
  for (let i2 = 0; i2 < length; i2++) {
    valuesArray[i2] = valueFunction(i2);
  }
  return valuesArray;
}
var NativeDateAdapter = class _NativeDateAdapter extends DateAdapter {
  /**
   * @deprecated No longer being used. To be removed.
   * @breaking-change 14.0.0
   */
  useUtcForDisplay = false;
  /** The injected locale. */
  _matDateLocale = inject(MAT_DATE_LOCALE, {
    optional: true
  });
  constructor() {
    super();
    const matDateLocale = inject(MAT_DATE_LOCALE, {
      optional: true
    });
    if (matDateLocale !== void 0) {
      this._matDateLocale = matDateLocale;
    }
    super.setLocale(this._matDateLocale);
  }
  getYear(date) {
    return date.getFullYear();
  }
  getMonth(date) {
    return date.getMonth();
  }
  getDate(date) {
    return date.getDate();
  }
  getDayOfWeek(date) {
    return date.getDay();
  }
  getMonthNames(style2) {
    const dtf = new Intl.DateTimeFormat(this.locale, {
      month: style2,
      timeZone: "utc"
    });
    return range(12, i2 => this._format(dtf, new Date(2017, i2, 1)));
  }
  getDateNames() {
    const dtf = new Intl.DateTimeFormat(this.locale, {
      day: "numeric",
      timeZone: "utc"
    });
    return range(31, i2 => this._format(dtf, new Date(2017, 0, i2 + 1)));
  }
  getDayOfWeekNames(style2) {
    const dtf = new Intl.DateTimeFormat(this.locale, {
      weekday: style2,
      timeZone: "utc"
    });
    return range(7, i2 => this._format(dtf, new Date(2017, 0, i2 + 1)));
  }
  getYearName(date) {
    const dtf = new Intl.DateTimeFormat(this.locale, {
      year: "numeric",
      timeZone: "utc"
    });
    return this._format(dtf, date);
  }
  getFirstDayOfWeek() {
    if (typeof Intl !== "undefined" && Intl.Locale) {
      const locale = new Intl.Locale(this.locale);
      const firstDay = (locale.getWeekInfo?.() || locale.weekInfo)?.firstDay ?? 0;
      return firstDay === 7 ? 0 : firstDay;
    }
    return 0;
  }
  getNumDaysInMonth(date) {
    return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));
  }
  clone(date) {
    return new Date(date.getTime());
  }
  createDate(year, month, date) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (month < 0 || month > 11) {
        throw Error(`Invalid month index "${month}". Month index has to be between 0 and 11.`);
      }
      if (date < 1) {
        throw Error(`Invalid date "${date}". Date has to be greater than 0.`);
      }
    }
    let result = this._createDateWithOverflow(year, month, date);
    if (result.getMonth() != month && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Invalid date "${date}" for month with index "${month}".`);
    }
    return result;
  }
  today() {
    return /* @__PURE__ */new Date();
  }
  parse(value, parseFormat) {
    if (typeof value == "number") {
      return new Date(value);
    }
    return value ? new Date(Date.parse(value)) : null;
  }
  format(date, displayFormat) {
    if (!this.isValid(date)) {
      throw Error("NativeDateAdapter: Cannot format invalid date.");
    }
    const dtf = new Intl.DateTimeFormat(this.locale, __spreadProps(__spreadValues({}, displayFormat), {
      timeZone: "utc"
    }));
    return this._format(dtf, date);
  }
  addCalendarYears(date, years) {
    return this.addCalendarMonths(date, years * 12);
  }
  addCalendarMonths(date, months) {
    let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));
    if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {
      newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);
    }
    return newDate;
  }
  addCalendarDays(date, days) {
    return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);
  }
  toIso8601(date) {
    return [date.getUTCFullYear(), this._2digit(date.getUTCMonth() + 1), this._2digit(date.getUTCDate())].join("-");
  }
  /**
   * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
   * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
   * invalid date for all other values.
   */
  deserialize(value) {
    if (typeof value === "string") {
      if (!value) {
        return null;
      }
      if (ISO_8601_REGEX.test(value)) {
        let date = new Date(value);
        if (this.isValid(date)) {
          return date;
        }
      }
    }
    return super.deserialize(value);
  }
  isDateInstance(obj) {
    return obj instanceof Date;
  }
  isValid(date) {
    return !isNaN(date.getTime());
  }
  invalid() {
    return /* @__PURE__ */new Date(NaN);
  }
  setTime(target, hours, minutes, seconds) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!inRange(hours, 0, 23)) {
        throw Error(`Invalid hours "${hours}". Hours value must be between 0 and 23.`);
      }
      if (!inRange(minutes, 0, 59)) {
        throw Error(`Invalid minutes "${minutes}". Minutes value must be between 0 and 59.`);
      }
      if (!inRange(seconds, 0, 59)) {
        throw Error(`Invalid seconds "${seconds}". Seconds value must be between 0 and 59.`);
      }
    }
    const clone = this.clone(target);
    clone.setHours(hours, minutes, seconds, 0);
    return clone;
  }
  getHours(date) {
    return date.getHours();
  }
  getMinutes(date) {
    return date.getMinutes();
  }
  getSeconds(date) {
    return date.getSeconds();
  }
  parseTime(userValue, parseFormat) {
    if (typeof userValue !== "string") {
      return userValue instanceof Date ? new Date(userValue.getTime()) : null;
    }
    const value = userValue.trim();
    if (value.length === 0) {
      return null;
    }
    let result = this._parseTimeString(value);
    if (result === null) {
      const withoutExtras = value.replace(/[^0-9:(AM|PM)]/gi, "").trim();
      if (withoutExtras.length > 0) {
        result = this._parseTimeString(withoutExtras);
      }
    }
    return result || this.invalid();
  }
  addSeconds(date, amount) {
    return new Date(date.getTime() + amount * 1e3);
  }
  /** Creates a date but allows the month and date to overflow. */
  _createDateWithOverflow(year, month, date) {
    const d2 = /* @__PURE__ */new Date();
    d2.setFullYear(year, month, date);
    d2.setHours(0, 0, 0, 0);
    return d2;
  }
  /**
   * Pads a number to make it two digits.
   * @param n The number to pad.
   * @returns The padded number.
   */
  _2digit(n2) {
    return ("00" + n2).slice(-2);
  }
  /**
   * When converting Date object to string, javascript built-in functions may return wrong
   * results because it applies its internal DST rules. The DST rules around the world change
   * very frequently, and the current valid rule is not always valid in previous years though.
   * We work around this problem building a new Date object which has its internal UTC
   * representation with the local date and time.
   * @param dtf Intl.DateTimeFormat object, containing the desired string format. It must have
   *    timeZone set to 'utc' to work fine.
   * @param date Date from which we want to get the string representation according to dtf
   * @returns A Date object with its UTC representation based on the passed in date info
   */
  _format(dtf, date) {
    const d2 = /* @__PURE__ */new Date();
    d2.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    d2.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    return dtf.format(d2);
  }
  /**
   * Attempts to parse a time string into a date object. Returns null if it cannot be parsed.
   * @param value Time string to parse.
   */
  _parseTimeString(value) {
    const parsed = value.toUpperCase().match(TIME_REGEX);
    if (parsed) {
      let hours = parseInt(parsed[1]);
      const minutes = parseInt(parsed[2]);
      let seconds = parsed[3] == null ? void 0 : parseInt(parsed[3]);
      const amPm = parsed[4];
      if (hours === 12) {
        hours = amPm === "AM" ? 0 : hours;
      } else if (amPm === "PM") {
        hours += 12;
      }
      if (inRange(hours, 0, 23) && inRange(minutes, 0, 59) && (seconds == null || inRange(seconds, 0, 59))) {
        return this.setTime(this.today(), hours, minutes, seconds || 0);
      }
    }
    return null;
  }
  static ɵfac = function NativeDateAdapter_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NativeDateAdapter)();
  };
  static ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
    token: _NativeDateAdapter,
    factory: _NativeDateAdapter.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NativeDateAdapter, [{
    type: Injectable
  }], () => [], null);
})();
function inRange(value, min, max) {
  return !isNaN(value) && value >= min && value <= max;
}
var MAT_NATIVE_DATE_FORMATS = {
  parse: {
    dateInput: null,
    timeInput: null
  },
  display: {
    dateInput: {
      year: "numeric",
      month: "numeric",
      day: "numeric"
    },
    timeInput: {
      hour: "numeric",
      minute: "numeric"
    },
    monthYearLabel: {
      year: "numeric",
      month: "short"
    },
    dateA11yLabel: {
      year: "numeric",
      month: "long",
      day: "numeric"
    },
    monthYearA11yLabel: {
      year: "numeric",
      month: "long"
    },
    timeOptionLabel: {
      hour: "numeric",
      minute: "numeric"
    }
  }
};
var NativeDateModule = class _NativeDateModule {
  static ɵfac = function NativeDateModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NativeDateModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _NativeDateModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [{
      provide: DateAdapter,
      useClass: NativeDateAdapter
    }]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NativeDateModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: DateAdapter,
        useClass: NativeDateAdapter
      }]
    }]
  }], null, null);
})();
var MatNativeDateModule = class _MatNativeDateModule {
  static ɵfac = function MatNativeDateModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatNativeDateModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatNativeDateModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [provideNativeDateAdapter()]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatNativeDateModule, [{
    type: NgModule,
    args: [{
      providers: [provideNativeDateAdapter()]
    }]
  }], null, null);
})();
function provideNativeDateAdapter(formats = MAT_NATIVE_DATE_FORMATS) {
  return [{
    provide: DateAdapter,
    useClass: NativeDateAdapter
  }, {
    provide: MAT_DATE_FORMATS,
    useValue: formats
  }];
}

// node_modules/@angular/material/fesm2022/checkbox.mjs
var _c010 = ["input"];
var _c110 = ["label"];
var _c24 = ["*"];
var MAT_CHECKBOX_DEFAULT_OPTIONS = new InjectionToken("mat-checkbox-default-options", {
  providedIn: "root",
  factory: MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY
});
function MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY() {
  return {
    color: "accent",
    clickAction: "check-indeterminate",
    disabledInteractive: false
  };
}
var TransitionCheckState;
(function (TransitionCheckState2) {
  TransitionCheckState2[TransitionCheckState2["Init"] = 0] = "Init";
  TransitionCheckState2[TransitionCheckState2["Checked"] = 1] = "Checked";
  TransitionCheckState2[TransitionCheckState2["Unchecked"] = 2] = "Unchecked";
  TransitionCheckState2[TransitionCheckState2["Indeterminate"] = 3] = "Indeterminate";
})(TransitionCheckState || (TransitionCheckState = {}));
var MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatCheckbox),
  multi: true
};
var MatCheckboxChange = class {
  /** The source checkbox of the event. */
  source;
  /** The new `checked` value of the checkbox. */
  checked;
};
var defaults = MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY();
var MatCheckbox = class _MatCheckbox {
  _elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _ngZone = inject(NgZone);
  _animationMode = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _options = inject(MAT_CHECKBOX_DEFAULT_OPTIONS, {
    optional: true
  });
  /** Focuses the checkbox. */
  focus() {
    this._inputElement.nativeElement.focus();
  }
  /** Creates the change event that will be emitted by the checkbox. */
  _createChangeEvent(isChecked) {
    const event = new MatCheckboxChange();
    event.source = this;
    event.checked = isChecked;
    return event;
  }
  /** Gets the element on which to add the animation CSS classes. */
  _getAnimationTargetElement() {
    return this._inputElement?.nativeElement;
  }
  /** CSS classes to add when transitioning between the different checkbox states. */
  _animationClasses = {
    uncheckedToChecked: "mdc-checkbox--anim-unchecked-checked",
    uncheckedToIndeterminate: "mdc-checkbox--anim-unchecked-indeterminate",
    checkedToUnchecked: "mdc-checkbox--anim-checked-unchecked",
    checkedToIndeterminate: "mdc-checkbox--anim-checked-indeterminate",
    indeterminateToChecked: "mdc-checkbox--anim-indeterminate-checked",
    indeterminateToUnchecked: "mdc-checkbox--anim-indeterminate-unchecked"
  };
  /**
   * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will
   * take precedence so this may be omitted.
   */
  ariaLabel = "";
  /**
   * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
   */
  ariaLabelledby = null;
  /** The 'aria-describedby' attribute is read after the element's label and field type. */
  ariaDescribedby;
  /**
   * Users can specify the `aria-expanded` attribute which will be forwarded to the input element
   */
  ariaExpanded;
  /**
   * Users can specify the `aria-controls` attribute which will be forwarded to the input element
   */
  ariaControls;
  /** Users can specify the `aria-owns` attribute which will be forwarded to the input element */
  ariaOwns;
  _uniqueId;
  /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */
  id;
  /** Returns the unique id for the visual hidden input. */
  get inputId() {
    return `${this.id || this._uniqueId}-input`;
  }
  /** Whether the checkbox is required. */
  required;
  /** Whether the label should appear after or before the checkbox. Defaults to 'after' */
  labelPosition = "after";
  /** Name value will be applied to the input element if present */
  name = null;
  /** Event emitted when the checkbox's `checked` value changes. */
  change = new EventEmitter();
  /** Event emitted when the checkbox's `indeterminate` value changes. */
  indeterminateChange = new EventEmitter();
  /** The value attribute of the native input element */
  value;
  /** Whether the checkbox has a ripple. */
  disableRipple;
  /** The native `<input type="checkbox">` element */
  _inputElement;
  /** The native `<label>` element */
  _labelElement;
  /** Tabindex for the checkbox. */
  tabIndex;
  // TODO(crisbeto): this should be a ThemePalette, but some internal apps were abusing
  // the lack of type checking previously and assigning random strings.
  /**
   * Theme color of the checkbox. This API is supported in M2 themes only, it
   * has no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/checkbox/styling.
   *
   * For information on applying color variants in M3, see
   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
   */
  color;
  /** Whether the checkbox should remain interactive when it is disabled. */
  disabledInteractive;
  /**
   * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
   * @docs-private
   */
  _onTouched = () => {};
  _currentAnimationClass = "";
  _currentCheckState = TransitionCheckState.Init;
  _controlValueAccessorChangeFn = () => {};
  _validatorChangeFn = () => {};
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
    const tabIndex = inject(new HostAttributeToken("tabindex"), {
      optional: true
    });
    this._options = this._options || defaults;
    this.color = this._options.color || defaults.color;
    this.tabIndex = tabIndex == null ? 0 : parseInt(tabIndex) || 0;
    this.id = this._uniqueId = inject(_IdGenerator).getId("mat-mdc-checkbox-");
    this.disabledInteractive = this._options?.disabledInteractive ?? false;
  }
  ngOnChanges(changes) {
    if (changes["required"]) {
      this._validatorChangeFn();
    }
  }
  ngAfterViewInit() {
    this._syncIndeterminate(this._indeterminate);
  }
  /** Whether the checkbox is checked. */
  get checked() {
    return this._checked;
  }
  set checked(value) {
    if (value != this.checked) {
      this._checked = value;
      this._changeDetectorRef.markForCheck();
    }
  }
  _checked = false;
  /** Whether the checkbox is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (value !== this.disabled) {
      this._disabled = value;
      this._changeDetectorRef.markForCheck();
    }
  }
  _disabled = false;
  /**
   * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
   * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
   * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately
   * set to false.
   */
  get indeterminate() {
    return this._indeterminate;
  }
  set indeterminate(value) {
    const changed = value != this._indeterminate;
    this._indeterminate = value;
    if (changed) {
      if (this._indeterminate) {
        this._transitionCheckState(TransitionCheckState.Indeterminate);
      } else {
        this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
      }
      this.indeterminateChange.emit(this._indeterminate);
    }
    this._syncIndeterminate(this._indeterminate);
  }
  _indeterminate = false;
  _isRippleDisabled() {
    return this.disableRipple || this.disabled;
  }
  /** Method being called whenever the label text changes. */
  _onLabelTextChange() {
    this._changeDetectorRef.detectChanges();
  }
  // Implemented as part of ControlValueAccessor.
  writeValue(value) {
    this.checked = !!value;
  }
  // Implemented as part of ControlValueAccessor.
  registerOnChange(fn) {
    this._controlValueAccessorChangeFn = fn;
  }
  // Implemented as part of ControlValueAccessor.
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  // Implemented as part of ControlValueAccessor.
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  // Implemented as a part of Validator.
  validate(control) {
    return this.required && control.value !== true ? {
      "required": true
    } : null;
  }
  // Implemented as a part of Validator.
  registerOnValidatorChange(fn) {
    this._validatorChangeFn = fn;
  }
  _transitionCheckState(newState) {
    let oldState = this._currentCheckState;
    let element = this._getAnimationTargetElement();
    if (oldState === newState || !element) {
      return;
    }
    if (this._currentAnimationClass) {
      element.classList.remove(this._currentAnimationClass);
    }
    this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);
    this._currentCheckState = newState;
    if (this._currentAnimationClass.length > 0) {
      element.classList.add(this._currentAnimationClass);
      const animationClass = this._currentAnimationClass;
      this._ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          element.classList.remove(animationClass);
        }, 1e3);
      });
    }
  }
  _emitChangeEvent() {
    this._controlValueAccessorChangeFn(this.checked);
    this.change.emit(this._createChangeEvent(this.checked));
    if (this._inputElement) {
      this._inputElement.nativeElement.checked = this.checked;
    }
  }
  /** Toggles the `checked` state of the checkbox. */
  toggle() {
    this.checked = !this.checked;
    this._controlValueAccessorChangeFn(this.checked);
  }
  _handleInputClick() {
    const clickAction = this._options?.clickAction;
    if (!this.disabled && clickAction !== "noop") {
      if (this.indeterminate && clickAction !== "check") {
        Promise.resolve().then(() => {
          this._indeterminate = false;
          this.indeterminateChange.emit(this._indeterminate);
        });
      }
      this._checked = !this._checked;
      this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
      this._emitChangeEvent();
    } else if (this.disabled && this.disabledInteractive || !this.disabled && clickAction === "noop") {
      this._inputElement.nativeElement.checked = this.checked;
      this._inputElement.nativeElement.indeterminate = this.indeterminate;
    }
  }
  _onInteractionEvent(event) {
    event.stopPropagation();
  }
  _onBlur() {
    Promise.resolve().then(() => {
      this._onTouched();
      this._changeDetectorRef.markForCheck();
    });
  }
  _getAnimationClassForCheckStateTransition(oldState, newState) {
    if (this._animationMode === "NoopAnimations") {
      return "";
    }
    switch (oldState) {
      case TransitionCheckState.Init:
        if (newState === TransitionCheckState.Checked) {
          return this._animationClasses.uncheckedToChecked;
        } else if (newState == TransitionCheckState.Indeterminate) {
          return this._checked ? this._animationClasses.checkedToIndeterminate : this._animationClasses.uncheckedToIndeterminate;
        }
        break;
      case TransitionCheckState.Unchecked:
        return newState === TransitionCheckState.Checked ? this._animationClasses.uncheckedToChecked : this._animationClasses.uncheckedToIndeterminate;
      case TransitionCheckState.Checked:
        return newState === TransitionCheckState.Unchecked ? this._animationClasses.checkedToUnchecked : this._animationClasses.checkedToIndeterminate;
      case TransitionCheckState.Indeterminate:
        return newState === TransitionCheckState.Checked ? this._animationClasses.indeterminateToChecked : this._animationClasses.indeterminateToUnchecked;
    }
    return "";
  }
  /**
   * Syncs the indeterminate value with the checkbox DOM node.
   *
   * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a
   * property is supported on an element boils down to `if (propName in element)`. Domino's
   * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during
   * server-side rendering.
   */
  _syncIndeterminate(value) {
    const nativeCheckbox = this._inputElement;
    if (nativeCheckbox) {
      nativeCheckbox.nativeElement.indeterminate = value;
    }
  }
  _onInputClick() {
    this._handleInputClick();
  }
  _onTouchTargetClick() {
    this._handleInputClick();
    if (!this.disabled) {
      this._inputElement.nativeElement.focus();
    }
  }
  /**
   *  Prevent click events that come from the `<label/>` element from bubbling. This prevents the
   *  click handler on the host from triggering twice when clicking on the `<label/>` element. After
   *  the click event on the `<label/>` propagates, the browsers dispatches click on the associated
   *  `<input/>`. By preventing clicks on the label by bubbling, we ensure only one click event
   *  bubbles when the label is clicked.
   */
  _preventBubblingFromLabel(event) {
    if (!!event.target && this._labelElement.nativeElement.contains(event.target)) {
      event.stopPropagation();
    }
  }
  static ɵfac = function MatCheckbox_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatCheckbox)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatCheckbox,
    selectors: [["mat-checkbox"]],
    viewQuery: function MatCheckbox_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c010, 5);
        ɵɵviewQuery(_c110, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._inputElement = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._labelElement = _t2.first);
      }
    },
    hostAttrs: [1, "mat-mdc-checkbox"],
    hostVars: 16,
    hostBindings: function MatCheckbox_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
        ɵɵattribute("tabindex", null)("aria-label", null)("aria-labelledby", null);
        ɵɵclassMap(ctx.color ? "mat-" + ctx.color : "mat-accent");
        ɵɵclassProp("_mat-animation-noopable", ctx._animationMode === "NoopAnimations")("mdc-checkbox--disabled", ctx.disabled)("mat-mdc-checkbox-disabled", ctx.disabled)("mat-mdc-checkbox-checked", ctx.checked)("mat-mdc-checkbox-disabled-interactive", ctx.disabledInteractive);
      }
    },
    inputs: {
      ariaLabel: [0, "aria-label", "ariaLabel"],
      ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
      ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"],
      ariaExpanded: [2, "aria-expanded", "ariaExpanded", booleanAttribute],
      ariaControls: [0, "aria-controls", "ariaControls"],
      ariaOwns: [0, "aria-owns", "ariaOwns"],
      id: "id",
      required: [2, "required", "required", booleanAttribute],
      labelPosition: "labelPosition",
      name: "name",
      value: "value",
      disableRipple: [2, "disableRipple", "disableRipple", booleanAttribute],
      tabIndex: [2, "tabIndex", "tabIndex", value => value == null ? void 0 : numberAttribute(value)],
      color: "color",
      disabledInteractive: [2, "disabledInteractive", "disabledInteractive", booleanAttribute],
      checked: [2, "checked", "checked", booleanAttribute],
      disabled: [2, "disabled", "disabled", booleanAttribute],
      indeterminate: [2, "indeterminate", "indeterminate", booleanAttribute]
    },
    outputs: {
      change: "change",
      indeterminateChange: "indeterminateChange"
    },
    exportAs: ["matCheckbox"],
    features: [ɵɵProvidersFeature([MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, {
      provide: NG_VALIDATORS,
      useExisting: _MatCheckbox,
      multi: true
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c24,
    decls: 15,
    vars: 23,
    consts: [["checkbox", ""], ["input", ""], ["label", ""], ["mat-internal-form-field", "", 3, "click", "labelPosition"], [1, "mdc-checkbox"], [1, "mat-mdc-checkbox-touch-target", 3, "click"], ["type", "checkbox", 1, "mdc-checkbox__native-control", 3, "blur", "click", "change", "checked", "indeterminate", "disabled", "id", "required", "tabIndex"], [1, "mdc-checkbox__ripple"], [1, "mdc-checkbox__background"], ["focusable", "false", "viewBox", "0 0 24 24", "aria-hidden", "true", 1, "mdc-checkbox__checkmark"], ["fill", "none", "d", "M1.73,12.91 8.1,19.28 22.79,4.59", 1, "mdc-checkbox__checkmark-path"], [1, "mdc-checkbox__mixedmark"], ["mat-ripple", "", 1, "mat-mdc-checkbox-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered"], [1, "mdc-label", 3, "for"]],
    template: function MatCheckbox_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 3);
        ɵɵlistener("click", function MatCheckbox_Template_div_click_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._preventBubblingFromLabel($event));
        });
        ɵɵelementStart(1, "div", 4, 0)(3, "div", 5);
        ɵɵlistener("click", function MatCheckbox_Template_div_click_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._onTouchTargetClick());
        });
        ɵɵelementEnd();
        ɵɵelementStart(4, "input", 6, 1);
        ɵɵlistener("blur", function MatCheckbox_Template_input_blur_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._onBlur());
        })("click", function MatCheckbox_Template_input_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._onInputClick());
        })("change", function MatCheckbox_Template_input_change_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._onInteractionEvent($event));
        });
        ɵɵelementEnd();
        ɵɵelement(6, "div", 7);
        ɵɵelementStart(7, "div", 8);
        ɵɵnamespaceSVG();
        ɵɵelementStart(8, "svg", 9);
        ɵɵelement(9, "path", 10);
        ɵɵelementEnd();
        ɵɵnamespaceHTML();
        ɵɵelement(10, "div", 11);
        ɵɵelementEnd();
        ɵɵelement(11, "div", 12);
        ɵɵelementEnd();
        ɵɵelementStart(12, "label", 13, 2);
        ɵɵprojection(14);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        const checkbox_r2 = ɵɵreference(2);
        ɵɵproperty("labelPosition", ctx.labelPosition);
        ɵɵadvance(4);
        ɵɵclassProp("mdc-checkbox--selected", ctx.checked);
        ɵɵproperty("checked", ctx.checked)("indeterminate", ctx.indeterminate)("disabled", ctx.disabled && !ctx.disabledInteractive)("id", ctx.inputId)("required", ctx.required)("tabIndex", ctx.disabled && !ctx.disabledInteractive ? -1 : ctx.tabIndex);
        ɵɵattribute("aria-label", ctx.ariaLabel || null)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedby)("aria-checked", ctx.indeterminate ? "mixed" : null)("aria-controls", ctx.ariaControls)("aria-disabled", ctx.disabled && ctx.disabledInteractive ? true : null)("aria-expanded", ctx.ariaExpanded)("aria-owns", ctx.ariaOwns)("name", ctx.name)("value", ctx.value);
        ɵɵadvance(7);
        ɵɵproperty("matRippleTrigger", checkbox_r2)("matRippleDisabled", ctx.disableRipple || ctx.disabled)("matRippleCentered", true);
        ɵɵadvance();
        ɵɵproperty("for", ctx.inputId);
      }
    },
    dependencies: [MatRipple, _MatInternalFormField],
    styles: ['.mdc-checkbox{display:inline-block;position:relative;flex:0 0 18px;box-sizing:content-box;width:18px;height:18px;line-height:0;white-space:nowrap;cursor:pointer;vertical-align:bottom;padding:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);margin:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox:hover>.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:hover>.mat-mdc-checkbox-ripple>.mat-ripple-element{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control+.mdc-checkbox__ripple{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;z-index:1;width:var(--mdc-checkbox-state-layer-size, 40px);height:var(--mdc-checkbox-state-layer-size, 40px);top:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);right:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox--disabled{cursor:default;pointer-events:none}@media(forced-colors: active){.mdc-checkbox--disabled{opacity:.5}}.mdc-checkbox__background{display:inline-flex;position:absolute;align-items:center;justify-content:center;box-sizing:border-box;width:18px;height:18px;border:2px solid currentColor;border-radius:2px;background-color:rgba(0,0,0,0);pointer-events:none;will-change:background-color,border-color;transition:background-color 90ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-print-color-adjust:exact;color-adjust:exact;border-color:var(--mdc-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));top:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2)}.mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox__native-control:disabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:disabled:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:checked)~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-hover-icon-color, var(--mat-sys-on-surface));background-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary))}.mdc-checkbox__native-control:focus:focus:not(:checked)~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-focus-icon-color, var(--mat-sys-on-surface))}.mdc-checkbox__native-control:focus:focus:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox:hover>.mdc-checkbox__native-control~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox__checkmark{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;opacity:0;transition:opacity 180ms cubic-bezier(0.4, 0, 0.6, 1);color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}@media(forced-colors: active){.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox__checkmark-path{transition:stroke-dashoffset 180ms cubic-bezier(0.4, 0, 0.6, 1);stroke:currentColor;stroke-width:3.12px;stroke-dashoffset:29.7833385;stroke-dasharray:29.7833385}.mdc-checkbox__mixedmark{width:100%;height:0;transform:scaleX(0) rotate(0deg);border-width:1px;border-style:solid;opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1);border-color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__mixedmark{margin:0 1px}}.mdc-checkbox--disabled .mdc-checkbox__mixedmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__background,.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__background,.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__background,.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__background{animation-duration:180ms;animation-timing-function:linear}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-unchecked-checked-checkmark-path 180ms linear;transition:none}.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-unchecked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-checked-unchecked-checkmark-path 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__checkmark{animation:mdc-checkbox-checked-indeterminate-checkmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-checked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__checkmark{animation:mdc-checkbox-indeterminate-checked-checkmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-checked-mixedmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-unchecked-mixedmark 300ms linear;transition:none}.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{transition:border-color 90ms cubic-bezier(0, 0, 0.2, 1),background-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path{stroke-dashoffset:0}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark{transition:opacity 180ms cubic-bezier(0, 0, 0.2, 1),transform 180ms cubic-bezier(0, 0, 0.2, 1);opacity:1}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(-45deg)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark{transform:rotate(45deg);opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(0deg);opacity:1}@keyframes mdc-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:29.7833385}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 1)}100%{stroke-dashoffset:0}}@keyframes mdc-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mdc-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);opacity:1;stroke-dashoffset:0}to{opacity:0;stroke-dashoffset:-29.7833385}}@keyframes mdc-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(45deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(45deg);opacity:0}to{transform:rotate(360deg);opacity:1}}@keyframes mdc-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(-45deg);opacity:0}to{transform:rotate(0deg);opacity:1}}@keyframes mdc-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(315deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;transform:scaleX(1);opacity:1}32.8%,100%{transform:scaleX(0);opacity:0}}.mat-mdc-checkbox{display:inline-block;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-touch-target,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__native-control,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__ripple,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-ripple::before,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__mixedmark{transition:none !important;animation:none !important}.mat-mdc-checkbox label{cursor:pointer}.mat-mdc-checkbox .mat-internal-form-field{color:var(--mat-checkbox-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-checkbox-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-checkbox-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-checkbox-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-checkbox-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-checkbox-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive{pointer-events:auto}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive input{cursor:default}.mat-mdc-checkbox.mat-mdc-checkbox-disabled label{cursor:default;color:var(--mat-checkbox-disabled-label-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-checkbox label:empty{display:none}.mat-mdc-checkbox .mdc-checkbox__ripple{opacity:0}.mat-mdc-checkbox .mat-mdc-checkbox-ripple,.mdc-checkbox__ripple{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-checkbox .mat-mdc-checkbox-ripple:not(:empty),.mdc-checkbox__ripple:not(:empty){transform:translateZ(0)}.mat-mdc-checkbox-ripple .mat-ripple-element{opacity:.1}.mat-mdc-checkbox-touch-target{position:absolute;top:50%;left:50%;height:48px;width:48px;transform:translate(-50%, -50%);display:var(--mat-checkbox-touch-target-display, block)}.mat-mdc-checkbox .mat-mdc-checkbox-ripple::before{border-radius:50%}.mdc-checkbox__native-control:focus~.mat-focus-indicator::before{content:""}'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatCheckbox, [{
    type: Component,
    args: [{
      selector: "mat-checkbox",
      host: {
        "class": "mat-mdc-checkbox",
        "[attr.tabindex]": "null",
        "[attr.aria-label]": "null",
        "[attr.aria-labelledby]": "null",
        "[class._mat-animation-noopable]": `_animationMode === 'NoopAnimations'`,
        "[class.mdc-checkbox--disabled]": "disabled",
        "[id]": "id",
        // Add classes that users can use to more easily target disabled or checked checkboxes.
        "[class.mat-mdc-checkbox-disabled]": "disabled",
        "[class.mat-mdc-checkbox-checked]": "checked",
        "[class.mat-mdc-checkbox-disabled-interactive]": "disabledInteractive",
        "[class]": 'color ? "mat-" + color : "mat-accent"'
      },
      providers: [MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, {
        provide: NG_VALIDATORS,
        useExisting: MatCheckbox,
        multi: true
      }],
      exportAs: "matCheckbox",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [MatRipple, _MatInternalFormField],
      template: `<div mat-internal-form-field [labelPosition]="labelPosition" (click)="_preventBubblingFromLabel($event)">
  <div #checkbox class="mdc-checkbox">
    <!-- Render this element first so the input is on top. -->
    <div class="mat-mdc-checkbox-touch-target" (click)="_onTouchTargetClick()"></div>
    <input #input
           type="checkbox"
           class="mdc-checkbox__native-control"
           [class.mdc-checkbox--selected]="checked"
           [attr.aria-label]="ariaLabel || null"
           [attr.aria-labelledby]="ariaLabelledby"
           [attr.aria-describedby]="ariaDescribedby"
           [attr.aria-checked]="indeterminate ? 'mixed' : null"
           [attr.aria-controls]="ariaControls"
           [attr.aria-disabled]="disabled && disabledInteractive ? true : null"
           [attr.aria-expanded]="ariaExpanded"
           [attr.aria-owns]="ariaOwns"
           [attr.name]="name"
           [attr.value]="value"
           [checked]="checked"
           [indeterminate]="indeterminate"
           [disabled]="disabled && !disabledInteractive"
           [id]="inputId"
           [required]="required"
           [tabIndex]="disabled && !disabledInteractive ? -1 : tabIndex"
           (blur)="_onBlur()"
           (click)="_onInputClick()"
           (change)="_onInteractionEvent($event)"/>
    <div class="mdc-checkbox__ripple"></div>
    <div class="mdc-checkbox__background">
      <svg class="mdc-checkbox__checkmark"
           focusable="false"
           viewBox="0 0 24 24"
           aria-hidden="true">
        <path class="mdc-checkbox__checkmark-path"
              fill="none"
              d="M1.73,12.91 8.1,19.28 22.79,4.59"/>
      </svg>
      <div class="mdc-checkbox__mixedmark"></div>
    </div>
    <div class="mat-mdc-checkbox-ripple mat-focus-indicator" mat-ripple
      [matRippleTrigger]="checkbox"
      [matRippleDisabled]="disableRipple || disabled"
      [matRippleCentered]="true"></div>
  </div>
  <!--
    Avoid putting a click handler on the <label/> to fix duplicate navigation stop on Talk Back
    (#14385). Putting a click handler on the <label/> caused this bug because the browser produced
    an unnecessary accessibility tree node.
  -->
  <label class="mdc-label" #label [for]="inputId">
    <ng-content></ng-content>
  </label>
</div>
`,
      styles: ['.mdc-checkbox{display:inline-block;position:relative;flex:0 0 18px;box-sizing:content-box;width:18px;height:18px;line-height:0;white-space:nowrap;cursor:pointer;vertical-align:bottom;padding:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);margin:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox:hover>.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:hover>.mat-mdc-checkbox-ripple>.mat-ripple-element{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control+.mdc-checkbox__ripple{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;z-index:1;width:var(--mdc-checkbox-state-layer-size, 40px);height:var(--mdc-checkbox-state-layer-size, 40px);top:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);right:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox--disabled{cursor:default;pointer-events:none}@media(forced-colors: active){.mdc-checkbox--disabled{opacity:.5}}.mdc-checkbox__background{display:inline-flex;position:absolute;align-items:center;justify-content:center;box-sizing:border-box;width:18px;height:18px;border:2px solid currentColor;border-radius:2px;background-color:rgba(0,0,0,0);pointer-events:none;will-change:background-color,border-color;transition:background-color 90ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-print-color-adjust:exact;color-adjust:exact;border-color:var(--mdc-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));top:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2)}.mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox__native-control:disabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:disabled:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:checked)~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-hover-icon-color, var(--mat-sys-on-surface));background-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary))}.mdc-checkbox__native-control:focus:focus:not(:checked)~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-focus-icon-color, var(--mat-sys-on-surface))}.mdc-checkbox__native-control:focus:focus:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox:hover>.mdc-checkbox__native-control~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox__checkmark{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;opacity:0;transition:opacity 180ms cubic-bezier(0.4, 0, 0.6, 1);color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}@media(forced-colors: active){.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox__checkmark-path{transition:stroke-dashoffset 180ms cubic-bezier(0.4, 0, 0.6, 1);stroke:currentColor;stroke-width:3.12px;stroke-dashoffset:29.7833385;stroke-dasharray:29.7833385}.mdc-checkbox__mixedmark{width:100%;height:0;transform:scaleX(0) rotate(0deg);border-width:1px;border-style:solid;opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1);border-color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__mixedmark{margin:0 1px}}.mdc-checkbox--disabled .mdc-checkbox__mixedmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__background,.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__background,.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__background,.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__background{animation-duration:180ms;animation-timing-function:linear}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-unchecked-checked-checkmark-path 180ms linear;transition:none}.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-unchecked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-checked-unchecked-checkmark-path 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__checkmark{animation:mdc-checkbox-checked-indeterminate-checkmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-checked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__checkmark{animation:mdc-checkbox-indeterminate-checked-checkmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-checked-mixedmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-unchecked-mixedmark 300ms linear;transition:none}.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{transition:border-color 90ms cubic-bezier(0, 0, 0.2, 1),background-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path{stroke-dashoffset:0}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark{transition:opacity 180ms cubic-bezier(0, 0, 0.2, 1),transform 180ms cubic-bezier(0, 0, 0.2, 1);opacity:1}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(-45deg)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark{transform:rotate(45deg);opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(0deg);opacity:1}@keyframes mdc-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:29.7833385}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 1)}100%{stroke-dashoffset:0}}@keyframes mdc-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mdc-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);opacity:1;stroke-dashoffset:0}to{opacity:0;stroke-dashoffset:-29.7833385}}@keyframes mdc-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(45deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(45deg);opacity:0}to{transform:rotate(360deg);opacity:1}}@keyframes mdc-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(-45deg);opacity:0}to{transform:rotate(0deg);opacity:1}}@keyframes mdc-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(315deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;transform:scaleX(1);opacity:1}32.8%,100%{transform:scaleX(0);opacity:0}}.mat-mdc-checkbox{display:inline-block;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-touch-target,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__native-control,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__ripple,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-ripple::before,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__mixedmark{transition:none !important;animation:none !important}.mat-mdc-checkbox label{cursor:pointer}.mat-mdc-checkbox .mat-internal-form-field{color:var(--mat-checkbox-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-checkbox-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-checkbox-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-checkbox-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-checkbox-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-checkbox-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive{pointer-events:auto}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive input{cursor:default}.mat-mdc-checkbox.mat-mdc-checkbox-disabled label{cursor:default;color:var(--mat-checkbox-disabled-label-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-checkbox label:empty{display:none}.mat-mdc-checkbox .mdc-checkbox__ripple{opacity:0}.mat-mdc-checkbox .mat-mdc-checkbox-ripple,.mdc-checkbox__ripple{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-checkbox .mat-mdc-checkbox-ripple:not(:empty),.mdc-checkbox__ripple:not(:empty){transform:translateZ(0)}.mat-mdc-checkbox-ripple .mat-ripple-element{opacity:.1}.mat-mdc-checkbox-touch-target{position:absolute;top:50%;left:50%;height:48px;width:48px;transform:translate(-50%, -50%);display:var(--mat-checkbox-touch-target-display, block)}.mat-mdc-checkbox .mat-mdc-checkbox-ripple::before{border-radius:50%}.mdc-checkbox__native-control:focus~.mat-focus-indicator::before{content:""}']
    }]
  }], () => [], {
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    ariaDescribedby: [{
      type: Input,
      args: ["aria-describedby"]
    }],
    ariaExpanded: [{
      type: Input,
      args: [{
        alias: "aria-expanded",
        transform: booleanAttribute
      }]
    }],
    ariaControls: [{
      type: Input,
      args: ["aria-controls"]
    }],
    ariaOwns: [{
      type: Input,
      args: ["aria-owns"]
    }],
    id: [{
      type: Input
    }],
    required: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    labelPosition: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    indeterminateChange: [{
      type: Output
    }],
    value: [{
      type: Input
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    _inputElement: [{
      type: ViewChild,
      args: ["input"]
    }],
    _labelElement: [{
      type: ViewChild,
      args: ["label"]
    }],
    tabIndex: [{
      type: Input,
      args: [{
        transform: value => value == null ? void 0 : numberAttribute(value)
      }]
    }],
    color: [{
      type: Input
    }],
    disabledInteractive: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    checked: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    indeterminate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var MAT_CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MatCheckboxRequiredValidator),
  multi: true
};
var MatCheckboxRequiredValidator = class _MatCheckboxRequiredValidator extends CheckboxRequiredValidator {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatCheckboxRequiredValidator_BaseFactory;
    return function MatCheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (ɵMatCheckboxRequiredValidator_BaseFactory || (ɵMatCheckboxRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_MatCheckboxRequiredValidator)))(__ngFactoryType__ || _MatCheckboxRequiredValidator);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatCheckboxRequiredValidator,
    selectors: [["mat-checkbox", "required", "", "formControlName", ""], ["mat-checkbox", "required", "", "formControl", ""], ["mat-checkbox", "required", "", "ngModel", ""]],
    features: [ɵɵProvidersFeature([MAT_CHECKBOX_REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatCheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: `mat-checkbox[required][formControlName],
             mat-checkbox[required][formControl], mat-checkbox[required][ngModel]`,
      providers: [MAT_CHECKBOX_REQUIRED_VALIDATOR]
    }]
  }], null, null);
})();
var _MatCheckboxRequiredValidatorModule = class __MatCheckboxRequiredValidatorModule {
  static ɵfac = function _MatCheckboxRequiredValidatorModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __MatCheckboxRequiredValidatorModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: __MatCheckboxRequiredValidatorModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatCheckboxRequiredValidatorModule, [{
    type: NgModule,
    args: [{
      imports: [MatCheckboxRequiredValidator],
      exports: [MatCheckboxRequiredValidator]
    }]
  }], null, null);
})();
var MatCheckboxModule = class _MatCheckboxModule {
  static ɵfac = function MatCheckboxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatCheckboxModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatCheckboxModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [MatCheckbox, MatCommonModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [MatCheckbox, MatCommonModule],
      exports: [MatCheckbox, MatCommonModule]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/progress-spinner.mjs
var _c011 = ["determinateSpinner"];
function MatProgressSpinner_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 11);
    ɵɵelement(1, "circle", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("viewBox", ctx_r0._viewBox());
    ɵɵadvance();
    ɵɵstyleProp("stroke-dasharray", ctx_r0._strokeCircumference(), "px")("stroke-dashoffset", ctx_r0._strokeCircumference() / 2, "px")("stroke-width", ctx_r0._circleStrokeWidth(), "%");
    ɵɵattribute("r", ctx_r0._circleRadius());
  }
}
var MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS = new InjectionToken("mat-progress-spinner-default-options", {
  providedIn: "root",
  factory: MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY
});
function MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY() {
  return {
    diameter: BASE_SIZE
  };
}
var BASE_SIZE = 100;
var BASE_STROKE_WIDTH = 10;
var MatProgressSpinner = class _MatProgressSpinner {
  _elementRef = inject(ElementRef);
  /** Whether the _mat-animation-noopable class should be applied, disabling animations.  */
  _noopAnimations;
  // TODO: should be typed as `ThemePalette` but internal apps pass in arbitrary strings.
  /**
   * Theme color of the progress spinner. This API is supported in M2 themes only, it
   * has no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/progress-spinner/styling.
   *
   * For information on applying color variants in M3, see
   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
   */
  get color() {
    return this._color || this._defaultColor;
  }
  set color(value) {
    this._color = value;
  }
  _color;
  _defaultColor = "primary";
  /** The element of the determinate spinner. */
  _determinateCircle;
  constructor() {
    const animationMode = inject(ANIMATION_MODULE_TYPE, {
      optional: true
    });
    const defaults2 = inject(MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS);
    this._noopAnimations = animationMode === "NoopAnimations" && !!defaults2 && !defaults2._forceAnimations;
    this.mode = this._elementRef.nativeElement.nodeName.toLowerCase() === "mat-spinner" ? "indeterminate" : "determinate";
    if (defaults2) {
      if (defaults2.color) {
        this.color = this._defaultColor = defaults2.color;
      }
      if (defaults2.diameter) {
        this.diameter = defaults2.diameter;
      }
      if (defaults2.strokeWidth) {
        this.strokeWidth = defaults2.strokeWidth;
      }
    }
  }
  /**
   * Mode of the progress bar.
   *
   * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to
   * 'determinate'.
   * Mirrored to mode attribute.
   */
  mode;
  /** Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow. */
  get value() {
    return this.mode === "determinate" ? this._value : 0;
  }
  set value(v2) {
    this._value = Math.max(0, Math.min(100, v2 || 0));
  }
  _value = 0;
  /** The diameter of the progress spinner (will set width and height of svg). */
  get diameter() {
    return this._diameter;
  }
  set diameter(size) {
    this._diameter = size || 0;
  }
  _diameter = BASE_SIZE;
  /** Stroke width of the progress spinner. */
  get strokeWidth() {
    return this._strokeWidth ?? this.diameter / 10;
  }
  set strokeWidth(value) {
    this._strokeWidth = value || 0;
  }
  _strokeWidth;
  /** The radius of the spinner, adjusted for stroke width. */
  _circleRadius() {
    return (this.diameter - BASE_STROKE_WIDTH) / 2;
  }
  /** The view box of the spinner's svg element. */
  _viewBox() {
    const viewBox = this._circleRadius() * 2 + this.strokeWidth;
    return `0 0 ${viewBox} ${viewBox}`;
  }
  /** The stroke circumference of the svg circle. */
  _strokeCircumference() {
    return 2 * Math.PI * this._circleRadius();
  }
  /** The dash offset of the svg circle. */
  _strokeDashOffset() {
    if (this.mode === "determinate") {
      return this._strokeCircumference() * (100 - this._value) / 100;
    }
    return null;
  }
  /** Stroke width of the circle in percent. */
  _circleStrokeWidth() {
    return this.strokeWidth / this.diameter * 100;
  }
  static ɵfac = function MatProgressSpinner_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatProgressSpinner)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatProgressSpinner,
    selectors: [["mat-progress-spinner"], ["mat-spinner"]],
    viewQuery: function MatProgressSpinner_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c011, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._determinateCircle = _t2.first);
      }
    },
    hostAttrs: ["role", "progressbar", "tabindex", "-1", 1, "mat-mdc-progress-spinner", "mdc-circular-progress"],
    hostVars: 18,
    hostBindings: function MatProgressSpinner_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-valuemin", 0)("aria-valuemax", 100)("aria-valuenow", ctx.mode === "determinate" ? ctx.value : null)("mode", ctx.mode);
        ɵɵclassMap("mat-" + ctx.color);
        ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px")("--mdc-circular-progress-size", ctx.diameter + "px")("--mdc-circular-progress-active-indicator-width", ctx.diameter + "px");
        ɵɵclassProp("_mat-animation-noopable", ctx._noopAnimations)("mdc-circular-progress--indeterminate", ctx.mode === "indeterminate");
      }
    },
    inputs: {
      color: "color",
      mode: "mode",
      value: [2, "value", "value", numberAttribute],
      diameter: [2, "diameter", "diameter", numberAttribute],
      strokeWidth: [2, "strokeWidth", "strokeWidth", numberAttribute]
    },
    exportAs: ["matProgressSpinner"],
    decls: 14,
    vars: 11,
    consts: [["circle", ""], ["determinateSpinner", ""], ["aria-hidden", "true", 1, "mdc-circular-progress__determinate-container"], ["xmlns", "http://www.w3.org/2000/svg", "focusable", "false", 1, "mdc-circular-progress__determinate-circle-graphic"], ["cx", "50%", "cy", "50%", 1, "mdc-circular-progress__determinate-circle"], ["aria-hidden", "true", 1, "mdc-circular-progress__indeterminate-container"], [1, "mdc-circular-progress__spinner-layer"], [1, "mdc-circular-progress__circle-clipper", "mdc-circular-progress__circle-left"], [3, "ngTemplateOutlet"], [1, "mdc-circular-progress__gap-patch"], [1, "mdc-circular-progress__circle-clipper", "mdc-circular-progress__circle-right"], ["xmlns", "http://www.w3.org/2000/svg", "focusable", "false", 1, "mdc-circular-progress__indeterminate-circle-graphic"], ["cx", "50%", "cy", "50%"]],
    template: function MatProgressSpinner_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, MatProgressSpinner_ng_template_0_Template, 2, 8, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementStart(2, "div", 2, 1);
        ɵɵnamespaceSVG();
        ɵɵelementStart(4, "svg", 3);
        ɵɵelement(5, "circle", 4);
        ɵɵelementEnd()();
        ɵɵnamespaceHTML();
        ɵɵelementStart(6, "div", 5)(7, "div", 6)(8, "div", 7);
        ɵɵelementContainer(9, 8);
        ɵɵelementEnd();
        ɵɵelementStart(10, "div", 9);
        ɵɵelementContainer(11, 8);
        ɵɵelementEnd();
        ɵɵelementStart(12, "div", 10);
        ɵɵelementContainer(13, 8);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        const circle_r2 = ɵɵreference(1);
        ɵɵadvance(4);
        ɵɵattribute("viewBox", ctx._viewBox());
        ɵɵadvance();
        ɵɵstyleProp("stroke-dasharray", ctx._strokeCircumference(), "px")("stroke-dashoffset", ctx._strokeDashOffset(), "px")("stroke-width", ctx._circleStrokeWidth(), "%");
        ɵɵattribute("r", ctx._circleRadius());
        ɵɵadvance(4);
        ɵɵproperty("ngTemplateOutlet", circle_r2);
        ɵɵadvance(2);
        ɵɵproperty("ngTemplateOutlet", circle_r2);
        ɵɵadvance(2);
        ɵɵproperty("ngTemplateOutlet", circle_r2);
      }
    },
    dependencies: [NgTemplateOutlet],
    styles: [".mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0;position:relative;direction:ltr;transition:opacity 250ms cubic-bezier(0.4, 0, 0.6, 1)}.mat-mdc-progress-spinner circle{stroke-width:var(--mdc-circular-progress-active-indicator-width, 4px)}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none !important}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none !important}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}@media(forced-colors: active){.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1;animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color, var(--mat-sys-primary))}@media(forced-colors: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatProgressSpinner, [{
    type: Component,
    args: [{
      selector: "mat-progress-spinner, mat-spinner",
      exportAs: "matProgressSpinner",
      host: {
        "role": "progressbar",
        "class": "mat-mdc-progress-spinner mdc-circular-progress",
        // set tab index to -1 so screen readers will read the aria-label
        // Note: there is a known issue with JAWS that does not read progressbar aria labels on FireFox
        "tabindex": "-1",
        "[class]": '"mat-" + color',
        "[class._mat-animation-noopable]": `_noopAnimations`,
        "[class.mdc-circular-progress--indeterminate]": 'mode === "indeterminate"',
        "[style.width.px]": "diameter",
        "[style.height.px]": "diameter",
        "[style.--mdc-circular-progress-size]": 'diameter + "px"',
        "[style.--mdc-circular-progress-active-indicator-width]": 'diameter + "px"',
        "[attr.aria-valuemin]": "0",
        "[attr.aria-valuemax]": "100",
        "[attr.aria-valuenow]": 'mode === "determinate" ? value : null',
        "[attr.mode]": "mode"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      imports: [NgTemplateOutlet],
      template: '<ng-template #circle>\n  <svg [attr.viewBox]="_viewBox()" class="mdc-circular-progress__indeterminate-circle-graphic"\n       xmlns="http://www.w3.org/2000/svg" focusable="false">\n    <circle [attr.r]="_circleRadius()"\n            [style.stroke-dasharray.px]="_strokeCircumference()"\n            [style.stroke-dashoffset.px]="_strokeCircumference() / 2"\n            [style.stroke-width.%]="_circleStrokeWidth()"\n            cx="50%" cy="50%"/>\n  </svg>\n</ng-template>\n\n<!--\n  All children need to be hidden for screen readers in order to support ChromeVox.\n  More context in the issue: https://github.com/angular/components/issues/22165.\n-->\n<div class="mdc-circular-progress__determinate-container" aria-hidden="true" #determinateSpinner>\n  <svg [attr.viewBox]="_viewBox()" class="mdc-circular-progress__determinate-circle-graphic"\n       xmlns="http://www.w3.org/2000/svg" focusable="false">\n    <circle [attr.r]="_circleRadius()"\n            [style.stroke-dasharray.px]="_strokeCircumference()"\n            [style.stroke-dashoffset.px]="_strokeDashOffset()"\n            [style.stroke-width.%]="_circleStrokeWidth()"\n            class="mdc-circular-progress__determinate-circle"\n            cx="50%" cy="50%"/>\n  </svg>\n</div>\n<!--TODO: figure out why there are 3 separate svgs-->\n<div class="mdc-circular-progress__indeterminate-container" aria-hidden="true">\n  <div class="mdc-circular-progress__spinner-layer">\n    <div class="mdc-circular-progress__circle-clipper mdc-circular-progress__circle-left">\n      <ng-container [ngTemplateOutlet]="circle"></ng-container>\n    </div>\n    <div class="mdc-circular-progress__gap-patch">\n      <ng-container [ngTemplateOutlet]="circle"></ng-container>\n    </div>\n    <div class="mdc-circular-progress__circle-clipper mdc-circular-progress__circle-right">\n      <ng-container [ngTemplateOutlet]="circle"></ng-container>\n    </div>\n  </div>\n</div>\n',
      styles: [".mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0;position:relative;direction:ltr;transition:opacity 250ms cubic-bezier(0.4, 0, 0.6, 1)}.mat-mdc-progress-spinner circle{stroke-width:var(--mdc-circular-progress-active-indicator-width, 4px)}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none !important}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none !important}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}@media(forced-colors: active){.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1;animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color, var(--mat-sys-primary))}@media(forced-colors: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}"]
    }]
  }], () => [], {
    color: [{
      type: Input
    }],
    _determinateCircle: [{
      type: ViewChild,
      args: ["determinateSpinner"]
    }],
    mode: [{
      type: Input
    }],
    value: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    diameter: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    strokeWidth: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }]
  });
})();
var MatSpinner = MatProgressSpinner;
var MatProgressSpinnerModule = class _MatProgressSpinnerModule {
  static ɵfac = function MatProgressSpinnerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatProgressSpinnerModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatProgressSpinnerModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatProgressSpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [MatProgressSpinner, MatSpinner],
      exports: [MatProgressSpinner, MatSpinner, MatCommonModule]
    }]
  }], null, null);
})();

// node_modules/ngx-mat-select-search/fesm2022/ngx-mat-select-search.mjs
var _c012 = ["searchSelectInput"];
var _c111 = ["innerSelectSearch"];
var _c25 = [[["", 8, "mat-select-search-custom-header-content"]], [["", "ngxMatSelectSearchClear", ""]], [["", "ngxMatSelectNoEntriesFound", ""]]];
var _c34 = [".mat-select-search-custom-header-content", "[ngxMatSelectSearchClear]", "[ngxMatSelectNoEntriesFound]"];
var _c43 = (a0, a1) => ({
  "mat-select-search-inner-multiple": a0,
  "mat-select-search-inner-toggle-all": a1
});
function MatSelectSearchComponent_mat_checkbox_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-checkbox", 12);
    ɵɵlistener("change", function MatSelectSearchComponent_mat_checkbox_4_Template_mat_checkbox_change_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._emitSelectAllBooleanToParent($event.checked));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("color", ctx_r2.matFormField == null ? null : ctx_r2.matFormField.color)("checked", ctx_r2.toggleAllCheckboxChecked)("indeterminate", ctx_r2.toggleAllCheckboxIndeterminate)("matTooltip", ctx_r2.toggleAllCheckboxTooltipMessage)("matTooltipPosition", ctx_r2.toggleAllCheckboxTooltipPosition);
  }
}
function MatSelectSearchComponent_mat_spinner_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-spinner", 13);
  }
}
function MatSelectSearchComponent_button_8_ng_content_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1, ["*ngIf", "clearIcon; else defaultIcon"]);
  }
}
function MatSelectSearchComponent_button_8_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r2.closeSvgIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", !ctx_r2.closeSvgIcon ? ctx_r2.closeIcon : null, " ");
  }
}
function MatSelectSearchComponent_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 14);
    ɵɵlistener("click", function MatSelectSearchComponent_button_8_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._reset(true));
    });
    ɵɵtemplate(1, MatSelectSearchComponent_button_8_ng_content_1_Template, 1, 0, "ng-content", 15)(2, MatSelectSearchComponent_button_8_ng_template_2_Template, 2, 2, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const defaultIcon_r5 = ɵɵreference(3);
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.clearIcon)("ngIfElse", defaultIcon_r5);
  }
}
function MatSelectSearchComponent_div_11_ng_content_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "noEntriesFound; else defaultNoEntriesFound"]);
  }
}
function MatSelectSearchComponent_div_11_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r2.noEntriesFoundLabel);
  }
}
function MatSelectSearchComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtemplate(1, MatSelectSearchComponent_div_11_ng_content_1_Template, 1, 0, "ng-content", 15)(2, MatSelectSearchComponent_div_11_ng_template_2_Template, 1, 1, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const defaultNoEntriesFound_r6 = ɵɵreference(3);
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.noEntriesFound)("ngIfElse", defaultNoEntriesFound_r6);
  }
}
var MatSelectSearchClearDirective = class _MatSelectSearchClearDirective {
  static ɵfac = function MatSelectSearchClearDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSelectSearchClearDirective)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatSelectSearchClearDirective,
    selectors: [["", "ngxMatSelectSearchClear", ""]],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSelectSearchClearDirective, [{
    type: Directive,
    args: [{
      selector: "[ngxMatSelectSearchClear]",
      standalone: false
    }]
  }], null, null);
})();
var configurableDefaultOptions = ["ariaLabel", "clearSearchInput", "closeIcon", "closeSvgIcon", "disableInitialFocus", "disableScrollToActiveOnOptionsChanged", "enableClearOnEscapePressed", "hideClearSearchButton", "noEntriesFoundLabel", "placeholderLabel", "preventHomeEndKeyPropagation", "searching"];
var MAT_SELECTSEARCH_DEFAULT_OPTIONS = new InjectionToken("mat-selectsearch-default-options");
var MatSelectNoEntriesFoundDirective = class _MatSelectNoEntriesFoundDirective {
  static ɵfac = function MatSelectNoEntriesFoundDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSelectNoEntriesFoundDirective)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatSelectNoEntriesFoundDirective,
    selectors: [["", "ngxMatSelectNoEntriesFound", ""]],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSelectNoEntriesFoundDirective, [{
    type: Directive,
    args: [{
      selector: "[ngxMatSelectNoEntriesFound]",
      standalone: false
    }]
  }], null, null);
})();
var MatSelectSearchComponent = class _MatSelectSearchComponent {
  matSelect;
  changeDetectorRef;
  _viewportRuler;
  matOption;
  matFormField;
  /** Label of the search placeholder */
  placeholderLabel = "Suche";
  /** Type of the search input field */
  type = "text";
  /** Font-based icon used for displaying Close-Icon */
  closeIcon = "close";
  /** SVG-based icon used for displaying Close-Icon. If set, closeIcon is overridden */
  closeSvgIcon;
  /** Label to be shown when no entries are found. Set to null if no message should be shown. */
  noEntriesFoundLabel = "Keine Optionen gefunden";
  /**
    * Whether the search field should be cleared after the dropdown menu is closed.
    * Useful for server-side filtering. See [#3](https://github.com/bithost-gmbh/ngx-mat-select-search/issues/3)
    */
  clearSearchInput = true;
  /** Whether to show the search-in-progress indicator */
  searching = false;
  /** Disables initial focusing of the input field */
  disableInitialFocus = false;
  /** Enable clear input on escape pressed */
  enableClearOnEscapePressed = false;
  /**
   * Prevents home / end key being propagated to mat-select,
   * allowing to move the cursor within the search input instead of navigating the options
   */
  preventHomeEndKeyPropagation = false;
  /** Disables scrolling to active options when option list changes. Useful for server-side search */
  disableScrollToActiveOnOptionsChanged = false;
  /** Adds 508 screen reader support for search box */
  ariaLabel = "dropdown search";
  /** Whether to show Select All Checkbox (for mat-select[multi=true]) */
  showToggleAllCheckbox = false;
  /** Select all checkbox checked state */
  toggleAllCheckboxChecked = false;
  /** select all checkbox indeterminate state */
  toggleAllCheckboxIndeterminate = false;
  /** Display a message in a tooltip on the toggle-all checkbox */
  toggleAllCheckboxTooltipMessage = "";
  /** Define the position of the tooltip on the toggle-all checkbox. */
  toggleAllCheckboxTooltipPosition = "below";
  /** Show/Hide the search clear button of the search input */
  hideClearSearchButton = false;
  /**
   * Always restore selected options on selectionChange for mode multi (e.g. for lazy loading/infinity scrolling).
   * Defaults to false, so selected options are only restored while filtering is active.
   */
  alwaysRestoreSelectedOptionsMulti = false;
  /**
   * Recreate array of selected values for multi-selects.
   *
   * This is useful if the selected values are stored in an immutable data structure.
   */
  recreateValuesArray = false;
  /** Output emitter to send to parent component with the toggle all boolean */
  toggleAll = new EventEmitter();
  /** Reference to the search input field */
  searchSelectInput;
  /** Reference to the search input field */
  innerSelectSearch;
  /** Reference to custom search input clear icon */
  clearIcon;
  /** Reference to custom no entries found element */
  noEntriesFound;
  /** Current search value */
  get value() {
    return this._formControl.value;
  }
  _lastExternalInputValue;
  onTouched = _2 => {};
  /** Reference to the MatSelect options */
  set _options(_options) {
    this._options$.next(_options);
  }
  get _options() {
    return this._options$.getValue();
  }
  _options$ = new BehaviorSubject(null);
  optionsList$ = this._options$.pipe(switchMap(_options => _options ? _options.changes.pipe(map(options => options.toArray()), startWith(_options.toArray())) : of(null)));
  optionsLength$ = this.optionsList$.pipe(map(options => options ? options.length : 0));
  /** Previously selected values when using <mat-select [multiple]="true">*/
  previousSelectedValues;
  _formControl = new FormControl("", {
    nonNullable: true
  });
  /** Whether to show the no entries found message */
  _showNoEntriesFound$ = combineLatest([this._formControl.valueChanges, this.optionsLength$]).pipe(map(([value, optionsLength]) => !!(this.noEntriesFoundLabel && value && optionsLength === this.getOptionsLengthOffset())));
  /** Subject that emits when the component has been destroyed. */
  _onDestroy = new Subject();
  /** Reference to active descendant for ARIA Support. */
  activeDescendant;
  constructor(matSelect, changeDetectorRef, _viewportRuler, matOption, matFormField, defaultOptions) {
    this.matSelect = matSelect;
    this.changeDetectorRef = changeDetectorRef;
    this._viewportRuler = _viewportRuler;
    this.matOption = matOption;
    this.matFormField = matFormField;
    this.applyDefaultOptions(defaultOptions);
  }
  applyDefaultOptions(defaultOptions) {
    if (!defaultOptions) {
      return;
    }
    for (const key of configurableDefaultOptions) {
      if (defaultOptions.hasOwnProperty(key)) {
        this[key] = defaultOptions[key];
      }
    }
  }
  ngOnInit() {
    if (this.matOption) {
      this.matOption.disabled = true;
      this.matOption._getHostElement().classList.add("contains-mat-select-search");
      this.matOption._getHostElement().setAttribute("role", "presentation");
    } else {
      console.error("<ngx-mat-select-search> must be placed inside a <mat-option> element");
    }
    this.matSelect.openedChange.pipe(delay(1), takeUntil(this._onDestroy)).subscribe(opened => {
      if (opened) {
        this.updateInputWidth();
        if (!this.disableInitialFocus) {
          this._focus();
        }
      } else {
        if (this.clearSearchInput) {
          this._reset();
        }
      }
    });
    this.matSelect.openedChange.pipe(take(1), switchMap(_2 => {
      this._options = this.matSelect.options;
      let previousFirstOption = this._options.toArray()[this.getOptionsLengthOffset()];
      return this._options.changes.pipe(tap(() => {
        setTimeout(() => {
          const options = this._options.toArray();
          const currentFirstOption = options[this.getOptionsLengthOffset()];
          const keyManager = this.matSelect._keyManager;
          if (keyManager && this.matSelect.panelOpen && currentFirstOption) {
            const firstOptionIsChanged = !previousFirstOption || !this.matSelect.compareWith(previousFirstOption.value, currentFirstOption.value);
            if (firstOptionIsChanged || !keyManager.activeItem || !options.find(option => this.matSelect.compareWith(option.value, keyManager.activeItem?.value))) {
              keyManager.setActiveItem(this.getOptionsLengthOffset());
            }
            setTimeout(() => {
              this.updateInputWidth();
            });
          }
          previousFirstOption = currentFirstOption;
        });
      }));
    })).pipe(takeUntil(this._onDestroy)).subscribe();
    this._showNoEntriesFound$.pipe(takeUntil(this._onDestroy)).subscribe(showNoEntriesFound => {
      if (this.matOption) {
        if (showNoEntriesFound) {
          this.matOption._getHostElement().classList.add("mat-select-search-no-entries-found");
        } else {
          this.matOption._getHostElement().classList.remove("mat-select-search-no-entries-found");
        }
      }
    });
    this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {
      if (this.matSelect.panelOpen) {
        this.updateInputWidth();
      }
    });
    this.initMultipleHandling();
    this.optionsList$.pipe(takeUntil(this._onDestroy)).subscribe(() => {
      this.changeDetectorRef.markForCheck();
    });
  }
  _emitSelectAllBooleanToParent(state2) {
    this.toggleAll.emit(state2);
  }
  ngOnDestroy() {
    this._onDestroy.next();
    this._onDestroy.complete();
  }
  _isToggleAllCheckboxVisible() {
    return this.matSelect.multiple && this.showToggleAllCheckbox;
  }
  /**
   * Handles the key down event with MatSelect.
   * Allows e.g. selecting with enter key, navigation with arrow keys, etc.
   * @param event
   */
  _handleKeydown(event) {
    if (event.key && event.key.length === 1 || this.preventHomeEndKeyPropagation && (event.key === "Home" || event.key === "End")) {
      event.stopPropagation();
    }
    if (this.matSelect.multiple && event.key && event.key === "Enter") {
      setTimeout(() => this._focus());
    }
    if (this.enableClearOnEscapePressed && event.key === "Escape" && this.value) {
      this._reset(true);
      event.stopPropagation();
    }
  }
  /**
   * Handles the key up event with MatSelect.
   * Allows e.g. the announcing of the currently activeDescendant by screen readers.
   */
  _handleKeyup(event) {
    if (event.key === "ArrowUp" || event.key === "ArrowDown") {
      const ariaActiveDescendantId = this.matSelect._getAriaActiveDescendant();
      const index = this._options.toArray().findIndex(item => item.id === ariaActiveDescendantId);
      if (index !== -1) {
        this.unselectActiveDescendant();
        this.activeDescendant = this._options.toArray()[index]._getHostElement();
        this.activeDescendant.setAttribute("aria-selected", "true");
        this.searchSelectInput.nativeElement.setAttribute("aria-activedescendant", ariaActiveDescendantId);
      }
    }
  }
  writeValue(value) {
    this._lastExternalInputValue = value;
    this._formControl.setValue(value);
    this.changeDetectorRef.markForCheck();
  }
  onBlur() {
    this.unselectActiveDescendant();
    this.onTouched();
  }
  registerOnChange(fn) {
    this._formControl.valueChanges.pipe(filter(value => value !== this._lastExternalInputValue), tap(() => this._lastExternalInputValue = void 0), takeUntil(this._onDestroy)).subscribe(fn);
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Focuses the search input field
   */
  _focus() {
    if (!this.searchSelectInput || !this.matSelect.panel) {
      return;
    }
    const panel = this.matSelect.panel.nativeElement;
    const scrollTop = panel.scrollTop;
    this.searchSelectInput.nativeElement.focus();
    panel.scrollTop = scrollTop;
  }
  /**
   * Resets the current search value
   * @param focus whether to focus after resetting
   */
  _reset(focus) {
    this._formControl.setValue("");
    if (focus) {
      this._focus();
    }
  }
  /**
   * Initializes handling <mat-select [multiple]="true">
   * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
   */
  initMultipleHandling() {
    if (!this.matSelect.ngControl) {
      if (this.matSelect.multiple) {
        console.error("the mat-select containing ngx-mat-select-search must have a ngModel or formControl directive when multiple=true");
      }
      return;
    }
    this.previousSelectedValues = this.matSelect.ngControl.value;
    if (!this.matSelect.ngControl.valueChanges) {
      return;
    }
    this.matSelect.ngControl.valueChanges.pipe(takeUntil(this._onDestroy)).subscribe(values => {
      let restoreSelectedValues = false;
      if (this.matSelect.multiple) {
        if ((this.alwaysRestoreSelectedOptionsMulti || this._formControl.value && this._formControl.value.length) && this.previousSelectedValues && Array.isArray(this.previousSelectedValues)) {
          if (!values || !Array.isArray(values)) {
            values = [];
          }
          const optionValues = this.matSelect.options.map(option => option.value);
          this.previousSelectedValues.forEach(previousValue => {
            if (!values.some(v2 => this.matSelect.compareWith(v2, previousValue)) && !optionValues.some(v2 => this.matSelect.compareWith(v2, previousValue))) {
              if (this.recreateValuesArray) {
                values = [...values, previousValue];
              } else {
                values.push(previousValue);
              }
              restoreSelectedValues = true;
            }
          });
        }
      }
      this.previousSelectedValues = values;
      if (restoreSelectedValues) {
        this.matSelect._onChange(values);
      }
    });
  }
  /**
   *  Set the width of the innerSelectSearch to fit even custom scrollbars
   *  And support all Operating Systems
   */
  updateInputWidth() {
    if (!this.innerSelectSearch || !this.innerSelectSearch.nativeElement) {
      return;
    }
    let element = this.innerSelectSearch.nativeElement;
    let panelElement = null;
    while (element && element.parentElement) {
      element = element.parentElement;
      if (element.classList.contains("mat-select-panel")) {
        panelElement = element;
        break;
      }
    }
    if (panelElement) {
      this.innerSelectSearch.nativeElement.style.width = panelElement.clientWidth + "px";
    }
  }
  /**
   * Determine the offset to length that can be caused by the optional matOption used as a search input.
   */
  getOptionsLengthOffset() {
    if (this.matOption) {
      return 1;
    } else {
      return 0;
    }
  }
  unselectActiveDescendant() {
    this.activeDescendant?.removeAttribute("aria-selected");
    this.searchSelectInput.nativeElement.removeAttribute("aria-activedescendant");
  }
  static ɵfac = function MatSelectSearchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSelectSearchComponent)(ɵɵdirectiveInject(MatSelect), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(MatOption, 8), ɵɵdirectiveInject(MatFormField, 8), ɵɵdirectiveInject(MAT_SELECTSEARCH_DEFAULT_OPTIONS, 8));
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatSelectSearchComponent,
    selectors: [["ngx-mat-select-search"]],
    contentQueries: function MatSelectSearchComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatSelectSearchClearDirective, 5);
        ɵɵcontentQuery(dirIndex, MatSelectNoEntriesFoundDirective, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.clearIcon = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.noEntriesFound = _t2.first);
      }
    },
    viewQuery: function MatSelectSearchComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c012, 7, ElementRef);
        ɵɵviewQuery(_c111, 7, ElementRef);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.searchSelectInput = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.innerSelectSearch = _t2.first);
      }
    },
    inputs: {
      placeholderLabel: "placeholderLabel",
      type: "type",
      closeIcon: "closeIcon",
      closeSvgIcon: "closeSvgIcon",
      noEntriesFoundLabel: "noEntriesFoundLabel",
      clearSearchInput: "clearSearchInput",
      searching: "searching",
      disableInitialFocus: "disableInitialFocus",
      enableClearOnEscapePressed: "enableClearOnEscapePressed",
      preventHomeEndKeyPropagation: "preventHomeEndKeyPropagation",
      disableScrollToActiveOnOptionsChanged: "disableScrollToActiveOnOptionsChanged",
      ariaLabel: "ariaLabel",
      showToggleAllCheckbox: "showToggleAllCheckbox",
      toggleAllCheckboxChecked: "toggleAllCheckboxChecked",
      toggleAllCheckboxIndeterminate: "toggleAllCheckboxIndeterminate",
      toggleAllCheckboxTooltipMessage: "toggleAllCheckboxTooltipMessage",
      toggleAllCheckboxTooltipPosition: "toggleAllCheckboxTooltipPosition",
      hideClearSearchButton: "hideClearSearchButton",
      alwaysRestoreSelectedOptionsMulti: "alwaysRestoreSelectedOptionsMulti",
      recreateValuesArray: "recreateValuesArray"
    },
    outputs: {
      toggleAll: "toggleAll"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _MatSelectSearchComponent),
      multi: true
    }])],
    ngContentSelectors: _c34,
    decls: 13,
    vars: 14,
    consts: [["innerSelectSearch", ""], ["searchSelectInput", ""], ["defaultIcon", ""], ["defaultNoEntriesFound", ""], ["matInput", "", 1, "mat-select-search-input", "mat-select-search-hidden"], [1, "mat-select-search-inner", "mat-typography", "mat-datepicker-content", "mat-tab-header", 3, "ngClass"], [1, "mat-select-search-inner-row"], ["class", "mat-select-search-toggle-all-checkbox", "matTooltipClass", "ngx-mat-select-search-toggle-all-tooltip", 3, "color", "checked", "indeterminate", "matTooltip", "matTooltipPosition", "change", 4, "ngIf"], ["autocomplete", "off", 1, "mat-select-search-input", 3, "keydown", "keyup", "blur", "type", "formControl", "placeholder"], ["class", "mat-select-search-spinner", "diameter", "16", 4, "ngIf"], ["mat-icon-button", "", "aria-label", "Clear", "class", "mat-select-search-clear", 3, "click", 4, "ngIf"], ["class", "mat-select-search-no-entries-found", 4, "ngIf"], ["matTooltipClass", "ngx-mat-select-search-toggle-all-tooltip", 1, "mat-select-search-toggle-all-checkbox", 3, "change", "color", "checked", "indeterminate", "matTooltip", "matTooltipPosition"], ["diameter", "16", 1, "mat-select-search-spinner"], ["mat-icon-button", "", "aria-label", "Clear", 1, "mat-select-search-clear", 3, "click"], [4, "ngIf", "ngIfElse"], [3, "svgIcon"], [1, "mat-select-search-no-entries-found"]],
    template: function MatSelectSearchComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c25);
        ɵɵelement(0, "input", 4);
        ɵɵelementStart(1, "div", 5, 0)(3, "div", 6);
        ɵɵtemplate(4, MatSelectSearchComponent_mat_checkbox_4_Template, 1, 5, "mat-checkbox", 7);
        ɵɵelementStart(5, "input", 8, 1);
        ɵɵlistener("keydown", function MatSelectSearchComponent_Template_input_keydown_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._handleKeydown($event));
        })("keyup", function MatSelectSearchComponent_Template_input_keyup_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._handleKeyup($event));
        })("blur", function MatSelectSearchComponent_Template_input_blur_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        });
        ɵɵelementEnd();
        ɵɵtemplate(7, MatSelectSearchComponent_mat_spinner_7_Template, 1, 0, "mat-spinner", 9)(8, MatSelectSearchComponent_button_8_Template, 4, 2, "button", 10);
        ɵɵprojection(9);
        ɵɵelementEnd();
        ɵɵelement(10, "mat-divider");
        ɵɵelementEnd();
        ɵɵtemplate(11, MatSelectSearchComponent_div_11_Template, 4, 2, "div", 11);
        ɵɵpipe(12, "async");
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngClass", ɵɵpureFunction2(11, _c43, ctx.matSelect.multiple, ctx._isToggleAllCheckboxVisible()));
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx._isToggleAllCheckboxVisible());
        ɵɵadvance();
        ɵɵproperty("type", ctx.type)("formControl", ctx._formControl)("placeholder", ctx.placeholderLabel);
        ɵɵattribute("aria-label", ctx.ariaLabel);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.searching);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hideClearSearchButton && ctx.value && !ctx.searching);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ɵɵpipeBind1(12, 9, ctx._showNoEntriesFound$));
      }
    },
    dependencies: [NgClass, NgIf, DefaultValueAccessor, NgControlStatus, FormControlDirective, MatIconButton, MatCheckbox, MatIcon, MatProgressSpinner, MatTooltip, MatDivider, AsyncPipe],
    styles: [".mat-select-search-hidden[_ngcontent-%COMP%]{visibility:hidden}.mat-select-search-inner[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;z-index:100;font-size:inherit;box-shadow:none;background-color:var(--mat-select-panel-background-color)}.mat-select-search-inner.mat-select-search-inner-multiple.mat-select-search-inner-toggle-all[_ngcontent-%COMP%]   .mat-select-search-inner-row[_ngcontent-%COMP%]{display:flex;align-items:center}.mat-select-search-input[_ngcontent-%COMP%]{box-sizing:border-box;width:100%;border:none;font-family:inherit;font-size:inherit;color:currentColor;outline:none;background-color:var(--mat-select-panel-background-color);padding:0 44px 0 16px;height:calc(3em - 1px);line-height:calc(3em - 1px)}[dir=rtl][_nghost-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%]{padding-right:16px;padding-left:44px}.mat-select-search-input[_ngcontent-%COMP%]::placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}.mat-select-search-inner-toggle-all[_ngcontent-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%]{padding-left:5px}.mat-select-search-no-entries-found[_ngcontent-%COMP%]{padding-top:8px}.mat-select-search-clear[_ngcontent-%COMP%]{position:absolute;right:4px;top:0}[dir=rtl][_nghost-%COMP%]   .mat-select-search-clear[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-clear[_ngcontent-%COMP%]{right:auto;left:4px}.mat-select-search-spinner[_ngcontent-%COMP%]{position:absolute;right:16px;top:calc(50% - 8px)}[dir=rtl][_nghost-%COMP%]   .mat-select-search-spinner[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-spinner[_ngcontent-%COMP%]{right:auto;left:16px}  .mat-mdc-option[aria-disabled=true].contains-mat-select-search{position:sticky;top:-8px;z-index:1;opacity:1;margin-top:-8px;pointer-events:all}  .mat-mdc-option[aria-disabled=true].contains-mat-select-search .mat-icon{margin-right:0;margin-left:0}  .mat-mdc-option[aria-disabled=true].contains-mat-select-search mat-pseudo-checkbox{display:none}  .mat-mdc-option[aria-disabled=true].contains-mat-select-search .mdc-list-item__primary-text{opacity:1}.mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%]{padding-left:5px}[dir=rtl][_nghost-%COMP%]   .mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%]{padding-left:0;padding-right:5px}"],
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSelectSearchComponent, [{
    type: Component,
    args: [{
      selector: "ngx-mat-select-search",
      standalone: false,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => MatSelectSearchComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<!--
Copyright (c) 2018 Bithost GmbH All Rights Reserved.

Use of this source code is governed by an MIT-style license that can be
found in the LICENSE file at https://angular.io/license
-->
<!-- Placeholder to adjust vertical offset of the mat-option elements -->
<input matInput class="mat-select-search-input mat-select-search-hidden"/>

<!-- Note: the  mat-datepicker-content mat-tab-header are needed to inherit the material theme colors, see PR #22 -->
<div
      #innerSelectSearch
      class="mat-select-search-inner mat-typography mat-datepicker-content mat-tab-header"
      [ngClass]="{'mat-select-search-inner-multiple': matSelect.multiple, 'mat-select-search-inner-toggle-all': _isToggleAllCheckboxVisible() }">

  <div class="mat-select-search-inner-row">
    <mat-checkbox *ngIf="_isToggleAllCheckboxVisible()"
                  [color]="matFormField?.color"
                  class="mat-select-search-toggle-all-checkbox"
                  [checked]="toggleAllCheckboxChecked"
                  [indeterminate]="toggleAllCheckboxIndeterminate"
                  [matTooltip]="toggleAllCheckboxTooltipMessage"
                  matTooltipClass="ngx-mat-select-search-toggle-all-tooltip"
                  [matTooltipPosition]="toggleAllCheckboxTooltipPosition"
                  (change)="_emitSelectAllBooleanToParent($event.checked)"
    ></mat-checkbox>

    <input class="mat-select-search-input"
           autocomplete="off"
           [type]="type"
           [formControl]="_formControl"
           #searchSelectInput
           (keydown)="_handleKeydown($event)"
           (keyup)="_handleKeyup($event)"
           (blur)="onBlur()"
           [placeholder]="placeholderLabel"
           [attr.aria-label]="ariaLabel"
    />
    <mat-spinner *ngIf="searching"
            class="mat-select-search-spinner"
            diameter="16"></mat-spinner>

    <button *ngIf="!hideClearSearchButton && value && !searching"
            mat-icon-button
            aria-label="Clear"
            (click)="_reset(true)"
            class="mat-select-search-clear">
      <ng-content *ngIf="clearIcon; else defaultIcon" select="[ngxMatSelectSearchClear]"></ng-content>
      <ng-template #defaultIcon>
        <mat-icon [svgIcon]="closeSvgIcon">
          {{!closeSvgIcon ? closeIcon : null}}
        </mat-icon>
      </ng-template>
    </button>

    <ng-content select=".mat-select-search-custom-header-content"></ng-content>
  </div>

  <mat-divider></mat-divider>
</div>

<div *ngIf="_showNoEntriesFound$ | async"
     class="mat-select-search-no-entries-found">
  <ng-content *ngIf="noEntriesFound; else defaultNoEntriesFound"
              select="[ngxMatSelectNoEntriesFound]"></ng-content>
  <ng-template #defaultNoEntriesFound>{{noEntriesFoundLabel}}</ng-template>
</div>

`,
      styles: [".mat-select-search-hidden{visibility:hidden}.mat-select-search-inner{position:absolute;top:0;left:0;width:100%;z-index:100;font-size:inherit;box-shadow:none;background-color:var(--mat-select-panel-background-color)}.mat-select-search-inner.mat-select-search-inner-multiple.mat-select-search-inner-toggle-all .mat-select-search-inner-row{display:flex;align-items:center}.mat-select-search-input{box-sizing:border-box;width:100%;border:none;font-family:inherit;font-size:inherit;color:currentColor;outline:none;background-color:var(--mat-select-panel-background-color);padding:0 44px 0 16px;height:calc(3em - 1px);line-height:calc(3em - 1px)}:host-context([dir=rtl]) .mat-select-search-input{padding-right:16px;padding-left:44px}.mat-select-search-input::placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}.mat-select-search-inner-toggle-all .mat-select-search-input{padding-left:5px}.mat-select-search-no-entries-found{padding-top:8px}.mat-select-search-clear{position:absolute;right:4px;top:0}:host-context([dir=rtl]) .mat-select-search-clear{right:auto;left:4px}.mat-select-search-spinner{position:absolute;right:16px;top:calc(50% - 8px)}:host-context([dir=rtl]) .mat-select-search-spinner{right:auto;left:16px}::ng-deep .mat-mdc-option[aria-disabled=true].contains-mat-select-search{position:sticky;top:-8px;z-index:1;opacity:1;margin-top:-8px;pointer-events:all}::ng-deep .mat-mdc-option[aria-disabled=true].contains-mat-select-search .mat-icon{margin-right:0;margin-left:0}::ng-deep .mat-mdc-option[aria-disabled=true].contains-mat-select-search mat-pseudo-checkbox{display:none}::ng-deep .mat-mdc-option[aria-disabled=true].contains-mat-select-search .mdc-list-item__primary-text{opacity:1}.mat-select-search-toggle-all-checkbox{padding-left:5px}:host-context([dir=rtl]) .mat-select-search-toggle-all-checkbox{padding-left:0;padding-right:5px}\n"]
    }]
  }], () => [{
    type: MatSelect,
    decorators: [{
      type: Inject,
      args: [MatSelect]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: ViewportRuler
  }, {
    type: MatOption,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MatOption]
    }]
  }, {
    type: MatFormField,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MatFormField]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [MAT_SELECTSEARCH_DEFAULT_OPTIONS]
    }]
  }], {
    placeholderLabel: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    closeIcon: [{
      type: Input
    }],
    closeSvgIcon: [{
      type: Input
    }],
    noEntriesFoundLabel: [{
      type: Input
    }],
    clearSearchInput: [{
      type: Input
    }],
    searching: [{
      type: Input
    }],
    disableInitialFocus: [{
      type: Input
    }],
    enableClearOnEscapePressed: [{
      type: Input
    }],
    preventHomeEndKeyPropagation: [{
      type: Input
    }],
    disableScrollToActiveOnOptionsChanged: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    showToggleAllCheckbox: [{
      type: Input
    }],
    toggleAllCheckboxChecked: [{
      type: Input
    }],
    toggleAllCheckboxIndeterminate: [{
      type: Input
    }],
    toggleAllCheckboxTooltipMessage: [{
      type: Input
    }],
    toggleAllCheckboxTooltipPosition: [{
      type: Input
    }],
    hideClearSearchButton: [{
      type: Input
    }],
    alwaysRestoreSelectedOptionsMulti: [{
      type: Input
    }],
    recreateValuesArray: [{
      type: Input
    }],
    toggleAll: [{
      type: Output
    }],
    searchSelectInput: [{
      type: ViewChild,
      args: ["searchSelectInput", {
        read: ElementRef,
        static: true
      }]
    }],
    innerSelectSearch: [{
      type: ViewChild,
      args: ["innerSelectSearch", {
        read: ElementRef,
        static: true
      }]
    }],
    clearIcon: [{
      type: ContentChild,
      args: [MatSelectSearchClearDirective]
    }],
    noEntriesFound: [{
      type: ContentChild,
      args: [MatSelectNoEntriesFoundDirective]
    }]
  });
})();
var NgxMatSelectSearchModule = class _NgxMatSelectSearchModule {
  static ɵfac = function NgxMatSelectSearchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgxMatSelectSearchModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _NgxMatSelectSearchModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [CommonModule, ReactiveFormsModule, MatButtonModule, MatCheckboxModule, MatIconModule, MatProgressSpinnerModule, MatTooltipModule, MatDividerModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxMatSelectSearchModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ReactiveFormsModule, MatButtonModule, MatCheckboxModule, MatIconModule, MatProgressSpinnerModule, MatTooltipModule, MatDividerModule],
      declarations: [MatSelectSearchComponent, MatSelectSearchClearDirective, MatSelectNoEntriesFoundDirective],
      exports: [MatSelectSearchComponent, MatSelectSearchClearDirective, MatSelectNoEntriesFoundDirective]
    }]
  }], null, null);
})();

// libs/ui/src/lib/components/client-full-edit-form/client-full-edit-form.component.ts
var _c013 = ["singleSelect"];
var ClientFullEditFormComponent_Conditional_58_Conditional_1_Defer_4_DepsFn = () => [import("./chunk-2T3GQKQJ.js").then(m2 => m2.UploadImageComponent)];
function ClientFullEditFormComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-error");
    ɵɵi18n(1, 14);
    ɵɵelementEnd();
  }
}
function ClientFullEditFormComponent_Conditional_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-error");
    ɵɵi18n(1, 15);
    ɵɵelementEnd();
  }
}
function ClientFullEditFormComponent_Conditional_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-error");
    ɵɵi18n(1, 16);
    ɵɵelementEnd();
  }
}
function ClientFullEditFormComponent_Conditional_26_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-error");
    ɵɵi18n(1, 17);
    ɵɵelementEnd();
  }
}
function ClientFullEditFormComponent_For_56_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-option", 45);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const country_r1 = ctx.$implicit;
    ɵɵproperty("value", country_r1.id);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", country_r1.name, " ");
  }
}
function ClientFullEditFormComponent_Conditional_58_Conditional_1_Defer_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ui-upload-image");
  }
}
function ClientFullEditFormComponent_Conditional_58_Conditional_1_DeferPlaceholder_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 56);
    ɵɵelement(1, "div", 57);
    ɵɵelementEnd();
  }
}
function ClientFullEditFormComponent_Conditional_58_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h3", 28);
    ɵɵi18n(1, 23);
    ɵɵelementEnd();
    ɵɵtemplate(2, ClientFullEditFormComponent_Conditional_58_Conditional_1_Defer_2_Template, 1, 0)(3, ClientFullEditFormComponent_Conditional_58_Conditional_1_DeferPlaceholder_3_Template, 2, 0);
    ɵɵdefer(4, 2, ClientFullEditFormComponent_Conditional_58_Conditional_1_Defer_4_DepsFn, null, 3, null, null, 24, ɵɵdeferEnableTimerScheduling);
    ɵɵdeferOnIdle();
  }
}
function ClientFullEditFormComponent_Conditional_58_For_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-chip-row", 58);
    ɵɵlistener("removed", function ClientFullEditFormComponent_Conditional_58_For_15_Template_mat_chip_row_removed_0_listener() {
      const qualification_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.removeQualification(qualification_r4));
    })("edited", function ClientFullEditFormComponent_Conditional_58_For_15_Template_mat_chip_row_edited_0_listener($event) {
      const qualification_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.editQualification(qualification_r4, $event));
    });
    ɵɵtext(1);
    ɵɵelementStart(2, "button", 59)(3, "mat-icon");
    ɵɵtext(4, "cancel");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const qualification_r4 = ctx.$implicit;
    ɵɵproperty("editable", true);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", qualification_r4, " ");
  }
}
function ClientFullEditFormComponent_Conditional_58_For_23_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-chip-row", 60);
    ɵɵlistener("removed", function ClientFullEditFormComponent_Conditional_58_For_23_Template_mat_chip_row_removed_0_listener() {
      const licence_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.removeLicence(licence_r7));
    })("edited", function ClientFullEditFormComponent_Conditional_58_For_23_Template_mat_chip_row_edited_0_listener($event) {
      const licence_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.editLicence(licence_r7, $event));
    });
    ɵɵtext(1);
    ɵɵelementStart(2, "button", 61)(3, "mat-icon");
    ɵɵtext(4, "cancel");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const licence_r7 = ctx.$implicit;
    ɵɵproperty("editable", true);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", licence_r7, " ");
  }
}
function ClientFullEditFormComponent_Conditional_58_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 46);
    ɵɵtemplate(1, ClientFullEditFormComponent_Conditional_58_Conditional_1_Template, 6, 0);
    ɵɵelementStart(2, "h3", 28);
    ɵɵi18n(3, 18);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 47)(5, "mat-form-field", 30)(6, "mat-label");
    ɵɵi18n(7, 19);
    ɵɵelementEnd();
    ɵɵelement(8, "input", 48);
    ɵɵelementEnd();
    ɵɵelementStart(9, "mat-form-field", 30)(10, "mat-label");
    ɵɵi18n(11, 20);
    ɵɵelementEnd();
    ɵɵelementStart(12, "mat-chip-grid", 49, 1);
    ɵɵrepeaterCreate(14, ClientFullEditFormComponent_Conditional_58_For_15_Template, 5, 2, "mat-chip-row", 50, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
    ɵɵelementStart(16, "input", 51);
    ɵɵlistener("matChipInputTokenEnd", function ClientFullEditFormComponent_Conditional_58_Template_input_matChipInputTokenEnd_16_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.addQualification($event));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(17, "mat-form-field", 30)(18, "mat-label");
    ɵɵi18n(19, 21);
    ɵɵelementEnd();
    ɵɵelementStart(20, "mat-chip-grid", 52, 2);
    ɵɵrepeaterCreate(22, ClientFullEditFormComponent_Conditional_58_For_23_Template, 5, 2, "mat-chip-row", 53, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
    ɵɵelementStart(24, "input", 54);
    ɵɵlistener("matChipInputTokenEnd", function ClientFullEditFormComponent_Conditional_58_Template_input_matChipInputTokenEnd_24_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.addLicence($event));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(25, "mat-form-field", 30)(26, "mat-label");
    ɵɵi18n(27, 22);
    ɵɵelementEnd();
    ɵɵelement(28, "input", 55);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const qualificationsChipGrid_r8 = ɵɵreference(13);
    const licencesChipGrid_r9 = ɵɵreference(21);
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("options", ctx_r4.themeSignal());
    ɵɵadvance();
    ɵɵconditional(ctx_r4.isUserForm ? 1 : -1);
    ɵɵadvance(11);
    ɵɵproperty("formControl", ctx_r4.qualificationsFormCtrl);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r4.qualifications);
    ɵɵadvance(2);
    ɵɵproperty("matChipInputSeparatorKeyCodes", ctx_r4.separatorKeysCodes)("matChipInputAddOnBlur", ctx_r4.addOnBlur)("matChipInputFor", qualificationsChipGrid_r8);
    ɵɵadvance(4);
    ɵɵproperty("formControl", ctx_r4.licencesFormCtrl);
    ɵɵadvance(2);
    ɵɵrepeater(ctx_r4.licences);
    ɵɵadvance(2);
    ɵɵproperty("matChipInputSeparatorKeyCodes", ctx_r4.separatorKeysCodes)("matChipInputAddOnBlur", ctx_r4.addOnBlur)("matChipInputFor", licencesChipGrid_r9);
  }
}
var ClientFullEditFormComponent = class _ClientFullEditFormComponent {
  constructor() {
    this.controlContainer = inject(ControlContainer);
    this.announcer = inject(LiveAnnouncer);
    this.localStorageService = inject(LocalstorageService);
    this.countriesLibService = inject(CountriesLibService);
    this.isClient = false;
    this.countries = [];
    this.countryFilterCtrl = new FormControl();
    this.filteredCountries = new ReplaySubject(1);
    this.isUserForm = false;
    this.qualifications = [];
    this.licences = [];
    this.addOnBlur = true;
    this.separatorKeysCodes = [ENTER, COMMA];
    this._onDestroy = new Subject();
    this.themeManager = inject(ThemeManagerService);
    this.themeSignal = this.themeManager.themeSignal;
  }
  ngOnInit() {
    this._getCountries();
    this.countryFilterCtrl.valueChanges.pipe(takeUntil(this._onDestroy)).subscribe(() => {
      this.filterCountries();
    });
    this._initForm();
  }
  _getCountries() {
    const lang = this.localStorageService.getToken("userLanguage")?.split("-")[0];
    this.countriesLibService.getCountriesLib(lang).pipe(takeUntil(this._onDestroy)).subscribe(countries => {
      this.countries = countries;
      this.countries.sort((a2, b2) => a2.name.localeCompare(b2.name));
      this.filteredCountries.next(this.countries.slice());
    });
  }
  _initForm() {
    const clientInfoForm = this.controlContainer.control?.get("clientInfo");
    if (clientInfoForm) {
      this.form = clientInfoForm;
      this.countryCtrl = this.form.get("address.country");
    } else {
      this.isUserForm = true;
      this.form = this.controlContainer.control;
      this.countryCtrl = this.form.get("address.country");
      this.qualificationsFormCtrl = this.form.get("credentials.qualifications");
      this.licencesFormCtrl = this.form.get("credentials.licences");
      setTimeout(() => {
        this.qualifications = this.qualificationsFormCtrl.value;
        this.licences = this.licencesFormCtrl.value;
      }, 500);
    }
  }
  ngAfterViewInit() {
    this.setInitialValue();
  }
  /**
   * Sets the initial value after the filteredBanks are loaded initially
   */
  setInitialValue() {
    this.filteredCountries.pipe(take(1), takeUntil(this._onDestroy)).subscribe(() => {
      this.singleSelect.compareWith = (a2, b2) => a2 && b2 && a2 === b2;
    });
  }
  filterCountries() {
    if (!this.countries) {
      return;
    }
    let search = this.countryFilterCtrl.value;
    if (!search) {
      this.filteredCountries.next(this.countries.slice());
      return;
    } else {
      search = search.toLowerCase();
    }
    this.filteredCountries.next(this.countries.filter(country => country.name.toLowerCase().indexOf(search) > -1));
  }
  removeQualification(qualification) {
    const index = this.qualifications.indexOf(qualification);
    if (index >= 0) {
      this.qualifications.splice(index, 1);
      this.announcer.announce(`removed ${qualification}`);
    }
  }
  addQualification(event) {
    const value = (event.value || "").trim();
    if (value) {
      this.qualifications.push(value);
    }
    event.chipInput.clear();
  }
  editQualification(qualification, event) {
    const value = event.value.trim();
    if (!value) {
      this.removeQualification(qualification);
      return;
    }
    const index = this.qualifications.indexOf(qualification);
    if (index >= 0) {
      this.qualifications[index] = value;
    }
  }
  removeLicence(licence) {
    const index = this.licences.indexOf(licence);
    if (index >= 0) {
      this.licences.splice(index, 1);
      this.announcer.announce(`removed ${licence}`);
    }
  }
  addLicence(event) {
    const value = (event.value || "").trim();
    console.log(event);
    if (value) {
      this.licences.push(value);
    }
    event.chipInput.clear();
  }
  editLicence(licence, event) {
    const value = event.value.trim();
    if (!value) {
      this.removeQualification(licence);
      return;
    }
    const index = this.licences.indexOf(licence);
    if (index >= 0) {
      this.licences[index] = value;
    }
  }
  ngOnDestroy() {
    this._onDestroy.next();
    this._onDestroy.complete();
  }
  static {
    this.ɵfac = function ClientFullEditFormComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ClientFullEditFormComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _ClientFullEditFormComponent,
      selectors: [["ui-client-full-edit-form"]],
      viewQuery: function ClientFullEditFormComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c013, 7);
        }
        if (rf & 2) {
          let _t2;
          ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.singleSelect = _t2.first);
        }
      },
      inputs: {
        isClient: "isClient"
      },
      decls: 59,
      vars: 12,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_ClientForm_firstnamePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_0 = goog.getMsg("Enter clients first name");
          i18n_0 = MSG_EXTERNAL_ClientForm_firstnamePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_0;
        } else {
          i18n_0 = "Geben Sie den Vornamen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_ClientForm_lastnamePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_1 = goog.getMsg("Enter clients last name");
          i18n_1 = MSG_EXTERNAL_ClientForm_lastnamePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_1;
        } else {
          i18n_1 = "Geben Sie den Nachnamen";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_ClientForm_emailPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_2 = goog.getMsg("Enter clients email");
          i18n_2 = MSG_EXTERNAL_ClientForm_emailPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_2;
        } else {
          i18n_2 = "Geben Sie die E-Mail-Adresse";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_ClientForm_phonePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_3 = goog.getMsg("Enter clients phone number");
          i18n_3 = MSG_EXTERNAL_ClientForm_phonePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_3;
        } else {
          i18n_3 = "Geben Sie die Telefonnummer";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_ClientForm_streetNamePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_4 = goog.getMsg("Enter street name");
          i18n_4 = MSG_EXTERNAL_ClientForm_streetNamePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_4;
        } else {
          i18n_4 = "Stra\xDFennamen eingeben";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_ClientForm_streetNumberPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_5 = goog.getMsg("Street no.");
          i18n_5 = MSG_EXTERNAL_ClientForm_streetNumberPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_5;
        } else {
          i18n_5 = "Stra\xDFe, Nr.";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_ClientForm_cityPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_6 = goog.getMsg("City");
          i18n_6 = MSG_EXTERNAL_ClientForm_cityPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_6;
        } else {
          i18n_6 = "Stadt";
        }
        let i18n_7;
        if (false) {
          const MSG_EXTERNAL_ClientForm_zipCodePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_7 = goog.getMsg("Zip code");
          i18n_7 = MSG_EXTERNAL_ClientForm_zipCodePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_7;
        } else {
          i18n_7 = "PLZ";
        }
        let i18n_8;
        if (false) {
          const MSG_EXTERNAL_ClientForm_countryPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_8 = goog.getMsg("Country");
          i18n_8 = MSG_EXTERNAL_ClientForm_countryPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_8;
        } else {
          i18n_8 = "Land";
        }
        let i18n_9;
        if (false) {
          const MSG_EXTERNAL_ClientForm_findCountryPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_9 = goog.getMsg("Find country...");
          i18n_9 = MSG_EXTERNAL_ClientForm_findCountryPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_9;
        } else {
          i18n_9 = "Land suchen...";
        }
        let i18n_10;
        if (false) {
          const MSG_EXTERNAL_ClientForm_noEntriesFoundLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_10 = goog.getMsg("No matching country found.");
          i18n_10 = MSG_EXTERNAL_ClientForm_noEntriesFoundLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_10;
        } else {
          i18n_10 = "Kein passendes Land gefunden.";
        }
        let i18n_11;
        if (false) {
          const MSG_EXTERNAL_ClientForm_personalInfoSubtitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_11 = goog.getMsg(" Personal info ");
          i18n_11 = MSG_EXTERNAL_ClientForm_personalInfoSubtitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_11;
        } else {
          i18n_11 = "Pers\xF6nliches";
        }
        let i18n_12;
        if (false) {
          const MSG_EXTERNAL_ClientForm_firstnameLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_12 = goog.getMsg("Firstname");
          i18n_12 = MSG_EXTERNAL_ClientForm_firstnameLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_12;
        } else {
          i18n_12 = "Vorname";
        }
        let i18n_13;
        if (false) {
          const MSG_EXTERNAL_ClientForm_lastnameLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_13 = goog.getMsg("Lastname");
          i18n_13 = MSG_EXTERNAL_ClientForm_lastnameLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_13;
        } else {
          i18n_13 = "Nachname";
        }
        let i18n_14;
        if (false) {
          const MSG_EXTERNAL_ClientForm_emailLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_14 = goog.getMsg("Email");
          i18n_14 = MSG_EXTERNAL_ClientForm_emailLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_14;
        } else {
          i18n_14 = "Email";
        }
        let i18n_15;
        if (false) {
          const MSG_EXTERNAL_ClientForm_phoneLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_15 = goog.getMsg("Phone");
          i18n_15 = MSG_EXTERNAL_ClientForm_phoneLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_15;
        } else {
          i18n_15 = "Telefon";
        }
        let i18n_16;
        if (false) {
          const MSG_EXTERNAL_ClientForm_addressSubtitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_16 = goog.getMsg(" Address ");
          i18n_16 = MSG_EXTERNAL_ClientForm_addressSubtitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_16;
        } else {
          i18n_16 = " Adresse ";
        }
        let i18n_17;
        if (false) {
          const MSG_EXTERNAL_ClientForm_streetNameLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_17 = goog.getMsg("Street name");
          i18n_17 = MSG_EXTERNAL_ClientForm_streetNameLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_17;
        } else {
          i18n_17 = "Stra\xDFenname";
        }
        let i18n_18;
        if (false) {
          const MSG_EXTERNAL_ClientForm_streetNumberLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_18 = goog.getMsg("Street no.");
          i18n_18 = MSG_EXTERNAL_ClientForm_streetNumberLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_18;
        } else {
          i18n_18 = "Stra\xDFe, Nr.";
        }
        let i18n_19;
        if (false) {
          const MSG_EXTERNAL_ClientForm_cityLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_19 = goog.getMsg("City");
          i18n_19 = MSG_EXTERNAL_ClientForm_cityLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_19;
        } else {
          i18n_19 = "Stadt";
        }
        let i18n_20;
        if (false) {
          const MSG_EXTERNAL_ClientForm_zipCodeLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_20 = goog.getMsg("Zip code");
          i18n_20 = MSG_EXTERNAL_ClientForm_zipCodeLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_20;
        } else {
          i18n_20 = "PLZ";
        }
        let i18n_21;
        if (false) {
          const MSG_EXTERNAL_ClientForm_countryLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_21 = goog.getMsg("Country");
          i18n_21 = MSG_EXTERNAL_ClientForm_countryLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_21;
        } else {
          i18n_21 = "Land";
        }
        let i18n_22;
        if (false) {
          const MSG_EXTERNAL_ClientForm_firstnameError$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_22 = goog.getMsg("Please enter first name");
          i18n_22 = MSG_EXTERNAL_ClientForm_firstnameError$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_22;
        } else {
          i18n_22 = "Bitte geben Sie den Vornamen ein";
        }
        let i18n_23;
        if (false) {
          const MSG_EXTERNAL_ClientForm_lastnameError$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_23 = goog.getMsg("Please enter last name");
          i18n_23 = MSG_EXTERNAL_ClientForm_lastnameError$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_23;
        } else {
          i18n_23 = "Bitte geben Sie den Nachnamen ein";
        }
        let i18n_24;
        if (false) {
          const MSG_EXTERNAL_ClientForm_emailError$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_24 = goog.getMsg("Please enter email");
          i18n_24 = MSG_EXTERNAL_ClientForm_emailError$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_24;
        } else {
          i18n_24 = "Bitte geben Sie eine E-Mail ein";
        }
        let i18n_25;
        if (false) {
          const MSG_EXTERNAL_ClientForm_phoneError$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_25 = goog.getMsg("Please enter phone number");
          i18n_25 = MSG_EXTERNAL_ClientForm_phoneError$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_25;
        } else {
          i18n_25 = "Bitte geben Sie die Telefonnummer ein";
        }
        let i18n_26;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsTitlePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_26 = goog.getMsg("E.g. 'Physiotherapist'");
          i18n_26 = MSG_EXTERNAL_ClientForm_credentialsTitlePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_26;
        } else {
          i18n_26 = "Z. B. \u201EPhysiotherapeut\u201C";
        }
        let i18n_27;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsQualificationsChipsLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_27 = goog.getMsg("Enter keywords");
          i18n_27 = MSG_EXTERNAL_ClientForm_credentialsQualificationsChipsLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_27;
        } else {
          i18n_27 = "Schl\xFCsselw\xF6rter eingeben";
        }
        let i18n_28;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsQualificationsPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_28 = goog.getMsg("E.g. 'Doctor of Physical Therapy'");
          i18n_28 = MSG_EXTERNAL_ClientForm_credentialsQualificationsPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_28;
        } else {
          i18n_28 = "Z. B. \u201EDoktor der Physiotherapie\u201C";
        }
        let i18n_29;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsLicencesChipLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_29 = goog.getMsg("Enter keywords");
          i18n_29 = MSG_EXTERNAL_ClientForm_credentialsLicencesChipLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_29;
        } else {
          i18n_29 = "Schl\xFCsselw\xF6rter eingeben";
        }
        let i18n_30;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsLicencesPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_30 = goog.getMsg("E.g. 'Orthopedic Manual Therapy Certification'");
          i18n_30 = MSG_EXTERNAL_ClientForm_credentialsLicencesPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_30;
        } else {
          i18n_30 = "Z. B. \u201EZertifizierung f\xFCr orthop\xE4dische manuelle Therapie\u201C";
        }
        let i18n_31;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsCompanyPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_31 = goog.getMsg("Enter company name");
          i18n_31 = MSG_EXTERNAL_ClientForm_credentialsCompanyPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_31;
        } else {
          i18n_31 = "Geben Sie den Firmennamen ein";
        }
        let i18n_32;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsSubtitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_32 = goog.getMsg(" Credentials ");
          i18n_32 = MSG_EXTERNAL_ClientForm_credentialsSubtitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_32;
        } else {
          i18n_32 = "Qualifikationen";
        }
        let i18n_33;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsTitleLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_33 = goog.getMsg("Title");
          i18n_33 = MSG_EXTERNAL_ClientForm_credentialsTitleLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_33;
        } else {
          i18n_33 = "Titel";
        }
        let i18n_34;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsQualificationsLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_34 = goog.getMsg("Qualifications");
          i18n_34 = MSG_EXTERNAL_ClientForm_credentialsQualificationsLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_34;
        } else {
          i18n_34 = "Qualifikationen";
        }
        let i18n_35;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsLicencesLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_35 = goog.getMsg("Licences");
          i18n_35 = MSG_EXTERNAL_ClientForm_credentialsLicencesLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_35;
        } else {
          i18n_35 = "Lizenzen";
        }
        let i18n_36;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsCompanyLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_36 = goog.getMsg("Company");
          i18n_36 = MSG_EXTERNAL_ClientForm_credentialsCompanyLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_36;
        } else {
          i18n_36 = "Unternehmen";
        }
        let i18n_37;
        if (false) {
          const MSG_EXTERNAL_ClientForm_profilePictureSubtitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_37 = goog.getMsg(" Profile picture ");
          i18n_37 = MSG_EXTERNAL_ClientForm_profilePictureSubtitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_37;
        } else {
          i18n_37 = "Profilbild";
        }
        let i18n_38;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsQualificationsRemoveChipLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_38 = goog.getMsg("Remove qualification");
          i18n_38 = MSG_EXTERNAL_ClientForm_credentialsQualificationsRemoveChipLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_38;
        } else {
          i18n_38 = "Qualifizierung entfernen";
        }
        let i18n_39;
        if (false) {
          const MSG_EXTERNAL_ClientForm_credentialsLicencesRemoveChipLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_39 = goog.getMsg("Remove licence");
          i18n_39 = MSG_EXTERNAL_ClientForm_credentialsLicencesRemoveChipLabel$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_FORM_CLIENT_FULL_EDIT_FORM_COMPONENT_TS_39;
        } else {
          i18n_39 = "Lizenz entfernen";
        }
        return [["singleSelect", ""], ["qualificationsChipGrid", ""], ["licencesChipGrid", ""], i18n_11, i18n_12, i18n_13, i18n_14, i18n_15, i18n_16, i18n_17, i18n_18, i18n_19, i18n_20, i18n_21, i18n_22, i18n_23, i18n_24, i18n_25, i18n_32, i18n_33, i18n_34, i18n_35, i18n_36, i18n_37, [1e3], [3, "formGroup"], [1, "inputs-wrapper"], [1, "left-input-column"], [1, "mat-title-medium-margin-plus"], [1, "inputs-flex-group"], ["appearance", "outline"], ["matInput", "", "formControlName", "firstName", "type", "text", "placeholder", i18n_0], ["matInput", "", "formControlName", "lastName", "type", "text", "placeholder", i18n_1], ["matInput", "", "formControlName", "email", "type", "text", "placeholder", i18n_2], ["matInput", "", "formControlName", "phone", "type", "text", "placeholder", i18n_3], [1, "mat-title-medium-margin-plus", "address-margin"], ["formGroupName", "address"], ["appearance", "outline", 1, "street"], ["matInput", "", "formControlName", "street", "type", "text", "placeholder", i18n_4], ["appearance", "outline", 1, "street-number"], ["matInput", "", "formControlName", "streetNumber", "type", "text", "placeholder", i18n_5], ["matInput", "", "formControlName", "city", "type", "text", "placeholder", i18n_6], ["matInput", "", "formControlName", "zipCode", "type", "text", "placeholder", i18n_7], ["placeholder", i18n_8, 3, "formControl"], ["placeholderLabel", i18n_9, "noEntriesFoundLabel", i18n_10, 3, "formControl"], [3, "value"], ["overlay-scrollbars", "", 1, "right-input-column", 3, "options", "defer"], ["formGroupName", "credentials"], ["matInput", "", "formControlName", "title", "type", "text", "placeholder", i18n_26], ["aria-label", i18n_27, 3, "formControl"], ["aria-description", "Press enter to edit qualification", 3, "editable"], ["placeholder", i18n_28, 3, "matChipInputTokenEnd", "matChipInputSeparatorKeyCodes", "matChipInputAddOnBlur", "matChipInputFor"], ["aria-label", i18n_29, 3, "formControl"], ["aria-description", "Press enter to edit licence", 3, "editable"], ["placeholder", i18n_30, 3, "matChipInputTokenEnd", "matChipInputSeparatorKeyCodes", "matChipInputAddOnBlur", "matChipInputFor"], ["matInput", "", "formControlName", "company", "type", "text", "placeholder", i18n_31], [1, "upload-image-placeholder"], [1, "upload-image-skeleton"], ["aria-description", "Press enter to edit qualification", 3, "removed", "edited", "editable"], ["matChipRemove", "", "aria-label", i18n_38], ["aria-description", "Press enter to edit licence", 3, "removed", "edited", "editable"], ["matChipRemove", "", "aria-label", i18n_39]];
      },
      template: function ClientFullEditFormComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "form", 25)(1, "div", 26)(2, "div", 27)(3, "h3", 28);
          ɵɵi18n(4, 3);
          ɵɵelementEnd();
          ɵɵelementStart(5, "div", 29)(6, "mat-form-field", 30)(7, "mat-label");
          ɵɵi18n(8, 4);
          ɵɵelementEnd();
          ɵɵelement(9, "input", 31);
          ɵɵtemplate(10, ClientFullEditFormComponent_Conditional_10_Template, 2, 0, "mat-error");
          ɵɵelementEnd();
          ɵɵelementStart(11, "mat-form-field", 30)(12, "mat-label");
          ɵɵi18n(13, 5);
          ɵɵelementEnd();
          ɵɵelement(14, "input", 32);
          ɵɵtemplate(15, ClientFullEditFormComponent_Conditional_15_Template, 2, 0, "mat-error");
          ɵɵelementEnd()();
          ɵɵelementStart(16, "div", 29)(17, "mat-form-field", 30)(18, "mat-label");
          ɵɵi18n(19, 6);
          ɵɵelementEnd();
          ɵɵelement(20, "input", 33);
          ɵɵtemplate(21, ClientFullEditFormComponent_Conditional_21_Template, 2, 0, "mat-error");
          ɵɵelementEnd();
          ɵɵelementStart(22, "mat-form-field", 30)(23, "mat-label");
          ɵɵi18n(24, 7);
          ɵɵelementEnd();
          ɵɵelement(25, "input", 34);
          ɵɵtemplate(26, ClientFullEditFormComponent_Conditional_26_Template, 2, 0, "mat-error");
          ɵɵelementEnd()();
          ɵɵelementStart(27, "h3", 35);
          ɵɵi18n(28, 8);
          ɵɵelementEnd();
          ɵɵelementStart(29, "div", 36)(30, "div", 29)(31, "mat-form-field", 37)(32, "mat-label");
          ɵɵi18n(33, 9);
          ɵɵelementEnd();
          ɵɵelement(34, "input", 38);
          ɵɵelementEnd();
          ɵɵelementStart(35, "mat-form-field", 39)(36, "mat-label");
          ɵɵi18n(37, 10);
          ɵɵelementEnd();
          ɵɵelement(38, "input", 40);
          ɵɵelementEnd()();
          ɵɵelementStart(39, "div", 29)(40, "mat-form-field", 30)(41, "mat-label");
          ɵɵi18n(42, 11);
          ɵɵelementEnd();
          ɵɵelement(43, "input", 41);
          ɵɵelementEnd();
          ɵɵelementStart(44, "mat-form-field", 30)(45, "mat-label");
          ɵɵi18n(46, 12);
          ɵɵelementEnd();
          ɵɵelement(47, "input", 42);
          ɵɵelementEnd();
          ɵɵelementStart(48, "mat-form-field", 30)(49, "mat-label");
          ɵɵi18n(50, 13);
          ɵɵelementEnd();
          ɵɵelementStart(51, "mat-select", 43, 0)(53, "mat-option");
          ɵɵelement(54, "ngx-mat-select-search", 44);
          ɵɵelementEnd();
          ɵɵrepeaterCreate(55, ClientFullEditFormComponent_For_56_Template, 2, 2, "mat-option", 45, ɵɵrepeaterTrackByIdentity);
          ɵɵpipe(57, "async");
          ɵɵelementEnd()()()()();
          ɵɵtemplate(58, ClientFullEditFormComponent_Conditional_58_Template, 29, 10, "div", 46);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          let tmp_3_0;
          let tmp_4_0;
          let tmp_5_0;
          let tmp_6_0;
          ɵɵproperty("formGroup", ctx.form);
          ɵɵadvance();
          ɵɵclassProp("small-width", ctx.isClient);
          ɵɵadvance(9);
          ɵɵconditional(((tmp_3_0 = ctx.form.get("firstName")) == null ? null : tmp_3_0.invalid) ? 10 : -1);
          ɵɵadvance(5);
          ɵɵconditional(((tmp_4_0 = ctx.form.get("lastName")) == null ? null : tmp_4_0.invalid) ? 15 : -1);
          ɵɵadvance(6);
          ɵɵconditional(((tmp_5_0 = ctx.form.get("email")) == null ? null : tmp_5_0.invalid) ? 21 : -1);
          ɵɵadvance(5);
          ɵɵconditional(((tmp_6_0 = ctx.form.get("phone")) == null ? null : tmp_6_0.invalid) ? 26 : -1);
          ɵɵadvance(25);
          ɵɵproperty("formControl", ctx.countryCtrl);
          ɵɵadvance(3);
          ɵɵproperty("formControl", ctx.countryFilterCtrl);
          ɵɵadvance();
          ɵɵrepeater(ɵɵpipeBind1(57, 10, ctx.filteredCountries));
          ɵɵadvance(3);
          ɵɵconditional(ctx.isUserForm ? 58 : -1);
        }
      },
      dependencies: [FormsModule, ɵNgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, ReactiveFormsModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, MatFormField, MatLabel, MatInput, MatError, MatSelect, MatOption, NgxMatSelectSearchModule, MatSelectSearchComponent, OverlayscrollbarsModule, OverlayScrollbarsComponent, MatChipGrid, MatChipRow, MatChipRemove, MatIcon, MatChipInput, AsyncPipe],
      styles: ['.inputs-wrapper[_ngcontent-%COMP%]{padding:32px 0 16px 16px;display:flex;gap:16px}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]{flex:2;order:1}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]   .inputs-flex-group[_ngcontent-%COMP%]{display:flex;gap:16px;width:100%}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]   .inputs-flex-group[_ngcontent-%COMP%]   .street[_ngcontent-%COMP%]{flex:4}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]   .inputs-flex-group[_ngcontent-%COMP%]   .street-number[_ngcontent-%COMP%]{flex:1}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]   .inputs-flex-group[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{align-self:flex-start}.inputs-wrapper[_ngcontent-%COMP%]   .right-input-column[_ngcontent-%COMP%]{height:calc(100vh - 186px);overflow-y:scroll;flex:1;order:2;border-radius:16px;padding:16px 16px 0;margin-bottom:16px;margin-top:-16px}@media (max-width: 599px){.inputs-wrapper[_ngcontent-%COMP%]{flex-direction:column;height:100%;padding:0;gap:0}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]{flex:1;order:2}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]   .address-margin[_ngcontent-%COMP%]{margin-top:16px}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]   .inputs-flex-group[_ngcontent-%COMP%]{display:block}.inputs-wrapper[_ngcontent-%COMP%]   .right-input-column[_ngcontent-%COMP%]{flex:1;order:1;height:auto;overflow-y:visible;padding:16px 0 0}}.small-width[_ngcontent-%COMP%]{max-width:920px}.upload-image-placeholder[_ngcontent-%COMP%]{width:100%;height:130px;overflow-y:hidden;display:flex;align-items:center;justify-content:center;margin-bottom:25px}.upload-image-placeholder[_ngcontent-%COMP%]   .upload-image-skeleton[_ngcontent-%COMP%]{border-radius:50%;height:120px;width:120px;overflow:hidden;position:relative}.upload-image-placeholder[_ngcontent-%COMP%]   .upload-image-skeleton[_ngcontent-%COMP%]:after{position:absolute;inset:0;transform:translate(-100%);animation:_ngcontent-%COMP%_shimmer 1s infinite;content:""}@keyframes _ngcontent-%COMP%_shimmer{to{transform:translate(100%)}}@media (min-width: 600px) and (max-width: 1048px){.inputs-wrapper[_ngcontent-%COMP%]{flex-direction:column;height:calc(100vh - 132px);overflow-y:scroll}.inputs-wrapper[_ngcontent-%COMP%]   .left-input-column[_ngcontent-%COMP%]{flex:1;order:2}.inputs-wrapper[_ngcontent-%COMP%]   .right-input-column[_ngcontent-%COMP%]{flex:1;order:1;height:auto;overflow-y:visible}}\n/*# sourceMappingURL=client-full-edit-form.component-TTKGVEFN.css.map */']
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(ClientFullEditFormComponent, {
    className: "ClientFullEditFormComponent",
    filePath: "libs/ui/src/lib/components/client-full-edit-form/client-full-edit-form.component.ts",
    lineNumber: 70
  });
})();

// libs/ui/src/lib/components/deleteConfirmationDialog/deleteConfirmationDialog.component.ts
var DeleteConfirmationDialogComponent = class _DeleteConfirmationDialogComponent {
  constructor() {
    this.dialogRef = inject(MatDialogRef);
    this.data = inject(MAT_DIALOG_DATA);
  }
  onConfirm() {
    this.dialogRef.close(true);
  }
  onClose() {
    this.dialogRef.close();
  }
  static {
    this.ɵfac = function DeleteConfirmationDialogComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DeleteConfirmationDialogComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _DeleteConfirmationDialogComponent,
      selectors: [["ui-delete-confirmation-dialog"]],
      decls: 13,
      vars: 2,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_DeleteConfirmationDialog_cancelButton$$LIBS_UI_SRC_LIB_COMPONENTS_DELETECONFIRMATIONDIALOG_DELETECONFIRMATIONDIALOG_COMPONENT_TS_0 = goog.getMsg(" Cancel ");
          i18n_0 = MSG_EXTERNAL_DeleteConfirmationDialog_cancelButton$$LIBS_UI_SRC_LIB_COMPONENTS_DELETECONFIRMATIONDIALOG_DELETECONFIRMATIONDIALOG_COMPONENT_TS_0;
        } else {
          i18n_0 = " Stornieren ";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_DeleteConfirmationDialog_deleteButton$$LIBS_UI_SRC_LIB_COMPONENTS_DELETECONFIRMATIONDIALOG_DELETECONFIRMATIONDIALOG_COMPONENT_TS_1 = goog.getMsg(" Delete ");
          i18n_1 = MSG_EXTERNAL_DeleteConfirmationDialog_deleteButton$$LIBS_UI_SRC_LIB_COMPONENTS_DELETECONFIRMATIONDIALOG_DELETECONFIRMATIONDIALOG_COMPONENT_TS_1;
        } else {
          i18n_1 = " L\xF6schen";
        }
        return [i18n_0, i18n_1, [1, "confirmation-dialog-wrapper"], [1, "dialog-icon"], ["mat-dialog-title", "", 1, "dialog-title", "mat-title-large"], ["mat-dialog-content", "", 1, "dialog-content"], ["mat-dialog-actions", "", 1, "dialog-actions"], ["mat-button", "", 1, "dialog-buttons", 3, "click"]];
      },
      template: function DeleteConfirmationDialogComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 2)(1, "div", 3)(2, "mat-icon");
          ɵɵtext(3, "delete_outline");
          ɵɵelementEnd()();
          ɵɵelementStart(4, "h1", 4);
          ɵɵtext(5);
          ɵɵelementEnd();
          ɵɵelementStart(6, "div", 5);
          ɵɵtext(7);
          ɵɵelementEnd();
          ɵɵelementStart(8, "div", 6)(9, "button", 7);
          ɵɵlistener("click", function DeleteConfirmationDialogComponent_Template_button_click_9_listener() {
            return ctx.onClose();
          });
          ɵɵi18n(10, 0);
          ɵɵelementEnd();
          ɵɵelementStart(11, "button", 7);
          ɵɵlistener("click", function DeleteConfirmationDialogComponent_Template_button_click_11_listener() {
            return ctx.onConfirm();
          });
          ɵɵi18n(12, 1);
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵadvance(5);
          ɵɵtextInterpolate1(" ", ctx.data.title, " ");
          ɵɵadvance(2);
          ɵɵtextInterpolate(ctx.data.message);
        }
      },
      dependencies: [MatIcon, MatDialogTitle, MatDialogContent, MatDialogActions, MatButton],
      styles: [".confirmation-dialog-wrapper[_ngcontent-%COMP%]{padding-top:24px;border-radius:28px;height:auto}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-title[_ngcontent-%COMP%]{text-align:center;padding-bottom:0}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-icon[_ngcontent-%COMP%]{text-align:center;margin-bottom:-8px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]{padding-bottom:0;padding-top:0}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-actions[_ngcontent-%COMP%]{text-align:right;display:flex;justify-content:flex-end}\n/*# sourceMappingURL=deleteConfirmationDialog.component-TLQRQOAC.css.map */"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(DeleteConfirmationDialogComponent, {
    className: "DeleteConfirmationDialogComponent",
    filePath: "libs/ui/src/lib/components/deleteConfirmationDialog/deleteConfirmationDialog.component.ts",
    lineNumber: 31
  });
})();

// node_modules/@angular/cdk/fesm2022/accordion.mjs
var CDK_ACCORDION = new InjectionToken("CdkAccordion");
var CdkAccordion = class _CdkAccordion {
  /** Emits when the state of the accordion changes */
  _stateChanges = new Subject();
  /** Stream that emits true/false when openAll/closeAll is triggered. */
  _openCloseAllActions = new Subject();
  /** A readonly id value to use for unique selection coordination. */
  id = inject(_IdGenerator).getId("cdk-accordion-");
  /** Whether the accordion should allow multiple expanded accordion items simultaneously. */
  multi = false;
  /** Opens all enabled accordion items in an accordion where multi is enabled. */
  openAll() {
    if (this.multi) {
      this._openCloseAllActions.next(true);
    }
  }
  /** Closes all enabled accordion items. */
  closeAll() {
    this._openCloseAllActions.next(false);
  }
  ngOnChanges(changes) {
    this._stateChanges.next(changes);
  }
  ngOnDestroy() {
    this._stateChanges.complete();
    this._openCloseAllActions.complete();
  }
  static ɵfac = function CdkAccordion_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkAccordion)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkAccordion,
    selectors: [["cdk-accordion"], ["", "cdkAccordion", ""]],
    inputs: {
      multi: [2, "multi", "multi", booleanAttribute]
    },
    exportAs: ["cdkAccordion"],
    features: [ɵɵProvidersFeature([{
      provide: CDK_ACCORDION,
      useExisting: _CdkAccordion
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAccordion, [{
    type: Directive,
    args: [{
      selector: "cdk-accordion, [cdkAccordion]",
      exportAs: "cdkAccordion",
      providers: [{
        provide: CDK_ACCORDION,
        useExisting: CdkAccordion
      }]
    }]
  }], null, {
    multi: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkAccordionItem = class _CdkAccordionItem {
  accordion = inject(CDK_ACCORDION, {
    optional: true,
    skipSelf: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  _expansionDispatcher = inject(UniqueSelectionDispatcher);
  /** Subscription to openAll/closeAll events. */
  _openCloseAllSubscription = Subscription.EMPTY;
  /** Event emitted every time the AccordionItem is closed. */
  closed = new EventEmitter();
  /** Event emitted every time the AccordionItem is opened. */
  opened = new EventEmitter();
  /** Event emitted when the AccordionItem is destroyed. */
  destroyed = new EventEmitter();
  /**
   * Emits whenever the expanded state of the accordion changes.
   * Primarily used to facilitate two-way binding.
   * @docs-private
   */
  expandedChange = new EventEmitter();
  /** The unique AccordionItem id. */
  id = inject(_IdGenerator).getId("cdk-accordion-child-");
  /** Whether the AccordionItem is expanded. */
  get expanded() {
    return this._expanded;
  }
  set expanded(expanded) {
    if (this._expanded !== expanded) {
      this._expanded = expanded;
      this.expandedChange.emit(expanded);
      if (expanded) {
        this.opened.emit();
        const accordionId = this.accordion ? this.accordion.id : this.id;
        this._expansionDispatcher.notify(this.id, accordionId);
      } else {
        this.closed.emit();
      }
      this._changeDetectorRef.markForCheck();
    }
  }
  _expanded = false;
  /** Whether the AccordionItem is disabled. */
  disabled = false;
  /** Unregister function for _expansionDispatcher. */
  _removeUniqueSelectionListener = () => {};
  constructor() {}
  ngOnInit() {
    this._removeUniqueSelectionListener = this._expansionDispatcher.listen((id, accordionId) => {
      if (this.accordion && !this.accordion.multi && this.accordion.id === accordionId && this.id !== id) {
        this.expanded = false;
      }
    });
    if (this.accordion) {
      this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();
    }
  }
  /** Emits an event for the accordion item being destroyed. */
  ngOnDestroy() {
    this.opened.complete();
    this.closed.complete();
    this.destroyed.emit();
    this.destroyed.complete();
    this._removeUniqueSelectionListener();
    this._openCloseAllSubscription.unsubscribe();
  }
  /** Toggles the expanded state of the accordion item. */
  toggle() {
    if (!this.disabled) {
      this.expanded = !this.expanded;
    }
  }
  /** Sets the expanded state of the accordion item to false. */
  close() {
    if (!this.disabled) {
      this.expanded = false;
    }
  }
  /** Sets the expanded state of the accordion item to true. */
  open() {
    if (!this.disabled) {
      this.expanded = true;
    }
  }
  _subscribeToOpenCloseAllActions() {
    return this.accordion._openCloseAllActions.subscribe(expanded => {
      if (!this.disabled) {
        this.expanded = expanded;
      }
    });
  }
  static ɵfac = function CdkAccordionItem_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkAccordionItem)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkAccordionItem,
    selectors: [["cdk-accordion-item"], ["", "cdkAccordionItem", ""]],
    inputs: {
      expanded: [2, "expanded", "expanded", booleanAttribute],
      disabled: [2, "disabled", "disabled", booleanAttribute]
    },
    outputs: {
      closed: "closed",
      opened: "opened",
      destroyed: "destroyed",
      expandedChange: "expandedChange"
    },
    exportAs: ["cdkAccordionItem"],
    features: [ɵɵProvidersFeature([
    // Provide `CDK_ACCORDION` as undefined to prevent nested accordion items from
    // registering to the same accordion.
    {
      provide: CDK_ACCORDION,
      useValue: void 0
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAccordionItem, [{
    type: Directive,
    args: [{
      selector: "cdk-accordion-item, [cdkAccordionItem]",
      exportAs: "cdkAccordionItem",
      providers: [
      // Provide `CDK_ACCORDION` as undefined to prevent nested accordion items from
      // registering to the same accordion.
      {
        provide: CDK_ACCORDION,
        useValue: void 0
      }]
    }]
  }], () => [], {
    closed: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    destroyed: [{
      type: Output
    }],
    expandedChange: [{
      type: Output
    }],
    expanded: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkAccordionModule = class _CdkAccordionModule {
  static ɵfac = function CdkAccordionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkAccordionModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _CdkAccordionModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CdkAccordion, CdkAccordionItem],
      exports: [CdkAccordion, CdkAccordionItem]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/expansion.mjs
var _c014 = ["body"];
var _c112 = ["bodyWrapper"];
var _c26 = [[["mat-expansion-panel-header"]], "*", [["mat-action-row"]]];
var _c35 = ["mat-expansion-panel-header", "*", "mat-action-row"];
function MatExpansionPanel_ng_template_7_Template(rf, ctx) {}
var _c44 = [[["mat-panel-title"]], [["mat-panel-description"]], "*"];
var _c52 = ["mat-panel-title", "mat-panel-description", "*"];
function MatExpansionPanelHeader_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 2);
    ɵɵelement(2, "path", 3);
    ɵɵelementEnd()();
  }
}
var MAT_ACCORDION = new InjectionToken("MAT_ACCORDION");
var MAT_EXPANSION_PANEL = new InjectionToken("MAT_EXPANSION_PANEL");
var MatExpansionPanelContent = class _MatExpansionPanelContent {
  _template = inject(TemplateRef);
  _expansionPanel = inject(MAT_EXPANSION_PANEL, {
    optional: true
  });
  constructor() {}
  static ɵfac = function MatExpansionPanelContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatExpansionPanelContent)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatExpansionPanelContent,
    selectors: [["ng-template", "matExpansionPanelContent", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelContent, [{
    type: Directive,
    args: [{
      selector: "ng-template[matExpansionPanelContent]"
    }]
  }], () => [], null);
})();
var MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new InjectionToken("MAT_EXPANSION_PANEL_DEFAULT_OPTIONS");
var MatExpansionPanel = class _MatExpansionPanel extends CdkAccordionItem {
  _viewContainerRef = inject(ViewContainerRef);
  _animationsDisabled = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  }) === "NoopAnimations";
  _document = inject(DOCUMENT);
  _ngZone = inject(NgZone);
  _elementRef = inject(ElementRef);
  _renderer = inject(Renderer2);
  _cleanupTransitionEnd;
  /** Whether the toggle indicator should be hidden. */
  get hideToggle() {
    return this._hideToggle || this.accordion && this.accordion.hideToggle;
  }
  set hideToggle(value) {
    this._hideToggle = value;
  }
  _hideToggle = false;
  /** The position of the expansion indicator. */
  get togglePosition() {
    return this._togglePosition || this.accordion && this.accordion.togglePosition;
  }
  set togglePosition(value) {
    this._togglePosition = value;
  }
  _togglePosition;
  /** An event emitted after the body's expansion animation happens. */
  afterExpand = new EventEmitter();
  /** An event emitted after the body's collapse animation happens. */
  afterCollapse = new EventEmitter();
  /** Stream that emits for changes in `@Input` properties. */
  _inputChanges = new Subject();
  /** Optionally defined accordion the expansion panel belongs to. */
  accordion = inject(MAT_ACCORDION, {
    optional: true,
    skipSelf: true
  });
  /** Content that will be rendered lazily. */
  _lazyContent;
  /** Element containing the panel's user-provided content. */
  _body;
  /** Element wrapping the panel body. */
  _bodyWrapper;
  /** Portal holding the user's content. */
  _portal;
  /** ID for the associated header element. Used for a11y labelling. */
  _headerId = inject(_IdGenerator).getId("mat-expansion-panel-header-");
  constructor() {
    super();
    const defaultOptions = inject(MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, {
      optional: true
    });
    this._expansionDispatcher = inject(UniqueSelectionDispatcher);
    if (defaultOptions) {
      this.hideToggle = defaultOptions.hideToggle;
    }
  }
  /** Determines whether the expansion panel should have spacing between it and its siblings. */
  _hasSpacing() {
    if (this.accordion) {
      return this.expanded && this.accordion.displayMode === "default";
    }
    return false;
  }
  /** Gets the expanded state string. */
  _getExpandedState() {
    return this.expanded ? "expanded" : "collapsed";
  }
  /** Toggles the expanded state of the expansion panel. */
  toggle() {
    this.expanded = !this.expanded;
  }
  /** Sets the expanded state of the expansion panel to false. */
  close() {
    this.expanded = false;
  }
  /** Sets the expanded state of the expansion panel to true. */
  open() {
    this.expanded = true;
  }
  ngAfterContentInit() {
    if (this._lazyContent && this._lazyContent._expansionPanel === this) {
      this.opened.pipe(startWith(null), filter(() => this.expanded && !this._portal), take(1)).subscribe(() => {
        this._portal = new TemplatePortal(this._lazyContent._template, this._viewContainerRef);
      });
    }
    this._setupAnimationEvents();
  }
  ngOnChanges(changes) {
    this._inputChanges.next(changes);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._cleanupTransitionEnd?.();
    this._inputChanges.complete();
  }
  /** Checks whether the expansion panel's content contains the currently-focused element. */
  _containsFocus() {
    if (this._body) {
      const focusedElement = this._document.activeElement;
      const bodyElement = this._body.nativeElement;
      return focusedElement === bodyElement || bodyElement.contains(focusedElement);
    }
    return false;
  }
  _transitionEndListener = ({
    target,
    propertyName
  }) => {
    if (target === this._bodyWrapper?.nativeElement && propertyName === "grid-template-rows") {
      this._ngZone.run(() => {
        if (this.expanded) {
          this.afterExpand.emit();
        } else {
          this.afterCollapse.emit();
        }
      });
    }
  };
  _setupAnimationEvents() {
    this._ngZone.runOutsideAngular(() => {
      if (this._animationsDisabled) {
        this.opened.subscribe(() => this._ngZone.run(() => this.afterExpand.emit()));
        this.closed.subscribe(() => this._ngZone.run(() => this.afterCollapse.emit()));
      } else {
        setTimeout(() => {
          const element = this._elementRef.nativeElement;
          this._cleanupTransitionEnd = this._renderer.listen(element, "transitionend", this._transitionEndListener);
          element.classList.add("mat-expansion-panel-animations-enabled");
        }, 200);
      }
    });
  }
  static ɵfac = function MatExpansionPanel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatExpansionPanel)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatExpansionPanel,
    selectors: [["mat-expansion-panel"]],
    contentQueries: function MatExpansionPanel_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatExpansionPanelContent, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._lazyContent = _t2.first);
      }
    },
    viewQuery: function MatExpansionPanel_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c014, 5);
        ɵɵviewQuery(_c112, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._body = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._bodyWrapper = _t2.first);
      }
    },
    hostAttrs: [1, "mat-expansion-panel"],
    hostVars: 4,
    hostBindings: function MatExpansionPanel_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("mat-expanded", ctx.expanded)("mat-expansion-panel-spacing", ctx._hasSpacing());
      }
    },
    inputs: {
      hideToggle: [2, "hideToggle", "hideToggle", booleanAttribute],
      togglePosition: "togglePosition"
    },
    outputs: {
      afterExpand: "afterExpand",
      afterCollapse: "afterCollapse"
    },
    exportAs: ["matExpansionPanel"],
    features: [ɵɵProvidersFeature([
    // Provide MatAccordion as undefined to prevent nested expansion panels from registering
    // to the same accordion.
    {
      provide: MAT_ACCORDION,
      useValue: void 0
    }, {
      provide: MAT_EXPANSION_PANEL,
      useExisting: _MatExpansionPanel
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    ngContentSelectors: _c35,
    decls: 9,
    vars: 4,
    consts: [["bodyWrapper", ""], ["body", ""], [1, "mat-expansion-panel-content-wrapper"], ["role", "region", 1, "mat-expansion-panel-content", 3, "id"], [1, "mat-expansion-panel-body"], [3, "cdkPortalOutlet"]],
    template: function MatExpansionPanel_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c26);
        ɵɵprojection(0);
        ɵɵelementStart(1, "div", 2, 0)(3, "div", 3, 1)(5, "div", 4);
        ɵɵprojection(6, 1);
        ɵɵtemplate(7, MatExpansionPanel_ng_template_7_Template, 0, 0, "ng-template", 5);
        ɵɵelementEnd();
        ɵɵprojection(8, 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵattribute("inert", ctx.expanded ? null : "");
        ɵɵadvance(2);
        ɵɵproperty("id", ctx.id);
        ɵɵattribute("aria-labelledby", ctx._headerId);
        ɵɵadvance(4);
        ɵɵproperty("cdkPortalOutlet", ctx._portal);
      }
    },
    dependencies: [CdkPortalOutlet],
    styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;overflow:hidden;position:relative;background:var(--mat-expansion-container-background-color, var(--mat-sys-surface));color:var(--mat-expansion-container-text-color, var(--mat-sys-on-surface));border-radius:var(--mat-expansion-container-shape, 12px)}.mat-expansion-panel.mat-expansion-panel-animations-enabled{transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:var(--mat-expansion-container-shape, 12px);border-top-left-radius:var(--mat-expansion-container-shape, 12px)}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:var(--mat-expansion-container-shape, 12px);border-bottom-left-radius:var(--mat-expansion-container-shape, 12px)}@media(forced-colors: active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel-content-wrapper{display:grid;grid-template-rows:0fr;grid-template-columns:100%}.mat-expansion-panel-animations-enabled .mat-expansion-panel-content-wrapper{transition:grid-template-rows 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel.mat-expanded>.mat-expansion-panel-content-wrapper{grid-template-rows:1fr}@supports not (grid-template-rows: 0fr){.mat-expansion-panel-content-wrapper{height:0}.mat-expansion-panel.mat-expanded>.mat-expansion-panel-content-wrapper{height:auto}}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible;min-height:0;visibility:hidden;font-family:var(--mat-expansion-container-text-font, var(--mat-sys-body-large-font));font-size:var(--mat-expansion-container-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-expansion-container-text-weight, var(--mat-sys-body-large-weight));line-height:var(--mat-expansion-container-text-line-height, var(--mat-sys-body-large-line-height));letter-spacing:var(--mat-expansion-container-text-tracking, var(--mat-sys-body-large-tracking))}.mat-expansion-panel-animations-enabled .mat-expansion-panel-content{transition:visibility 190ms linear}.mat-expansion-panel.mat-expanded>.mat-expansion-panel-content-wrapper>.mat-expansion-panel-content{visibility:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px;border-top-color:var(--mat-expansion-actions-divider-color, var(--mat-sys-outline))}.mat-action-row .mat-button-base,.mat-action-row .mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row .mat-button-base,[dir=rtl] .mat-action-row .mat-mdc-button-base{margin-left:0;margin-right:8px}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanel, [{
    type: Component,
    args: [{
      selector: "mat-expansion-panel",
      exportAs: "matExpansionPanel",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [
      // Provide MatAccordion as undefined to prevent nested expansion panels from registering
      // to the same accordion.
      {
        provide: MAT_ACCORDION,
        useValue: void 0
      }, {
        provide: MAT_EXPANSION_PANEL,
        useExisting: MatExpansionPanel
      }],
      host: {
        "class": "mat-expansion-panel",
        "[class.mat-expanded]": "expanded",
        "[class.mat-expansion-panel-spacing]": "_hasSpacing()"
      },
      imports: [CdkPortalOutlet],
      template: `<ng-content select="mat-expansion-panel-header"></ng-content>
<div class="mat-expansion-panel-content-wrapper" [attr.inert]="expanded ? null : ''" #bodyWrapper>
  <div class="mat-expansion-panel-content"
       role="region"
       [attr.aria-labelledby]="_headerId"
       [id]="id"
       #body>
    <div class="mat-expansion-panel-body">
      <ng-content></ng-content>
      <ng-template [cdkPortalOutlet]="_portal"></ng-template>
    </div>
    <ng-content select="mat-action-row"></ng-content>
  </div>
</div>
`,
      styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;overflow:hidden;position:relative;background:var(--mat-expansion-container-background-color, var(--mat-sys-surface));color:var(--mat-expansion-container-text-color, var(--mat-sys-on-surface));border-radius:var(--mat-expansion-container-shape, 12px)}.mat-expansion-panel.mat-expansion-panel-animations-enabled{transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:var(--mat-expansion-container-shape, 12px);border-top-left-radius:var(--mat-expansion-container-shape, 12px)}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:var(--mat-expansion-container-shape, 12px);border-bottom-left-radius:var(--mat-expansion-container-shape, 12px)}@media(forced-colors: active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel-content-wrapper{display:grid;grid-template-rows:0fr;grid-template-columns:100%}.mat-expansion-panel-animations-enabled .mat-expansion-panel-content-wrapper{transition:grid-template-rows 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel.mat-expanded>.mat-expansion-panel-content-wrapper{grid-template-rows:1fr}@supports not (grid-template-rows: 0fr){.mat-expansion-panel-content-wrapper{height:0}.mat-expansion-panel.mat-expanded>.mat-expansion-panel-content-wrapper{height:auto}}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible;min-height:0;visibility:hidden;font-family:var(--mat-expansion-container-text-font, var(--mat-sys-body-large-font));font-size:var(--mat-expansion-container-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-expansion-container-text-weight, var(--mat-sys-body-large-weight));line-height:var(--mat-expansion-container-text-line-height, var(--mat-sys-body-large-line-height));letter-spacing:var(--mat-expansion-container-text-tracking, var(--mat-sys-body-large-tracking))}.mat-expansion-panel-animations-enabled .mat-expansion-panel-content{transition:visibility 190ms linear}.mat-expansion-panel.mat-expanded>.mat-expansion-panel-content-wrapper>.mat-expansion-panel-content{visibility:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px;border-top-color:var(--mat-expansion-actions-divider-color, var(--mat-sys-outline))}.mat-action-row .mat-button-base,.mat-action-row .mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row .mat-button-base,[dir=rtl] .mat-action-row .mat-mdc-button-base{margin-left:0;margin-right:8px}"]
    }]
  }], () => [], {
    hideToggle: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    togglePosition: [{
      type: Input
    }],
    afterExpand: [{
      type: Output
    }],
    afterCollapse: [{
      type: Output
    }],
    _lazyContent: [{
      type: ContentChild,
      args: [MatExpansionPanelContent]
    }],
    _body: [{
      type: ViewChild,
      args: ["body"]
    }],
    _bodyWrapper: [{
      type: ViewChild,
      args: ["bodyWrapper"]
    }]
  });
})();
var MatExpansionPanelActionRow = class _MatExpansionPanelActionRow {
  static ɵfac = function MatExpansionPanelActionRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatExpansionPanelActionRow)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatExpansionPanelActionRow,
    selectors: [["mat-action-row"]],
    hostAttrs: [1, "mat-action-row"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelActionRow, [{
    type: Directive,
    args: [{
      selector: "mat-action-row",
      host: {
        class: "mat-action-row"
      }
    }]
  }], null, null);
})();
var MatExpansionPanelHeader = class _MatExpansionPanelHeader {
  panel = inject(MatExpansionPanel, {
    host: true
  });
  _element = inject(ElementRef);
  _focusMonitor = inject(FocusMonitor);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _parentChangeSubscription = Subscription.EMPTY;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
    const panel = this.panel;
    const defaultOptions = inject(MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, {
      optional: true
    });
    const tabIndex = inject(new HostAttributeToken("tabindex"), {
      optional: true
    });
    const accordionHideToggleChange = panel.accordion ? panel.accordion._stateChanges.pipe(filter(changes => !!(changes["hideToggle"] || changes["togglePosition"]))) : EMPTY;
    this.tabIndex = parseInt(tabIndex || "") || 0;
    this._parentChangeSubscription = merge(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(filter(changes => {
      return !!(changes["hideToggle"] || changes["disabled"] || changes["togglePosition"]);
    }))).subscribe(() => this._changeDetectorRef.markForCheck());
    panel.closed.pipe(filter(() => panel._containsFocus())).subscribe(() => this._focusMonitor.focusVia(this._element, "program"));
    if (defaultOptions) {
      this.expandedHeight = defaultOptions.expandedHeight;
      this.collapsedHeight = defaultOptions.collapsedHeight;
    }
  }
  /** Height of the header while the panel is expanded. */
  expandedHeight;
  /** Height of the header while the panel is collapsed. */
  collapsedHeight;
  /** Tab index of the header. */
  tabIndex = 0;
  /**
   * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
   * @docs-private
   */
  get disabled() {
    return this.panel.disabled;
  }
  /** Toggles the expanded state of the panel. */
  _toggle() {
    if (!this.disabled) {
      this.panel.toggle();
    }
  }
  /** Gets whether the panel is expanded. */
  _isExpanded() {
    return this.panel.expanded;
  }
  /** Gets the expanded state string of the panel. */
  _getExpandedState() {
    return this.panel._getExpandedState();
  }
  /** Gets the panel id. */
  _getPanelId() {
    return this.panel.id;
  }
  /** Gets the toggle position for the header. */
  _getTogglePosition() {
    return this.panel.togglePosition;
  }
  /** Gets whether the expand indicator should be shown. */
  _showToggle() {
    return !this.panel.hideToggle && !this.panel.disabled;
  }
  /**
   * Gets the current height of the header. Null if no custom height has been
   * specified, and if the default height from the stylesheet should be used.
   */
  _getHeaderHeight() {
    const isExpanded = this._isExpanded();
    if (isExpanded && this.expandedHeight) {
      return this.expandedHeight;
    } else if (!isExpanded && this.collapsedHeight) {
      return this.collapsedHeight;
    }
    return null;
  }
  /** Handle keydown event calling to toggle() if appropriate. */
  _keydown(event) {
    switch (event.keyCode) {
      // Toggle for space and enter keys.
      case SPACE:
      case ENTER:
        if (!hasModifierKey(event)) {
          event.preventDefault();
          this._toggle();
        }
        break;
      default:
        if (this.panel.accordion) {
          this.panel.accordion._handleHeaderKeydown(event);
        }
        return;
    }
  }
  /**
   * Focuses the panel header. Implemented as a part of `FocusableOption`.
   * @param origin Origin of the action that triggered the focus.
   * @docs-private
   */
  focus(origin, options) {
    if (origin) {
      this._focusMonitor.focusVia(this._element, origin, options);
    } else {
      this._element.nativeElement.focus(options);
    }
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this._element).subscribe(origin => {
      if (origin && this.panel.accordion) {
        this.panel.accordion._handleHeaderFocus(this);
      }
    });
  }
  ngOnDestroy() {
    this._parentChangeSubscription.unsubscribe();
    this._focusMonitor.stopMonitoring(this._element);
  }
  static ɵfac = function MatExpansionPanelHeader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatExpansionPanelHeader)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatExpansionPanelHeader,
    selectors: [["mat-expansion-panel-header"]],
    hostAttrs: ["role", "button", 1, "mat-expansion-panel-header", "mat-focus-indicator"],
    hostVars: 13,
    hostBindings: function MatExpansionPanelHeader_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function MatExpansionPanelHeader_click_HostBindingHandler() {
          return ctx._toggle();
        })("keydown", function MatExpansionPanelHeader_keydown_HostBindingHandler($event) {
          return ctx._keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("id", ctx.panel._headerId)("tabindex", ctx.disabled ? -1 : ctx.tabIndex)("aria-controls", ctx._getPanelId())("aria-expanded", ctx._isExpanded())("aria-disabled", ctx.panel.disabled);
        ɵɵstyleProp("height", ctx._getHeaderHeight());
        ɵɵclassProp("mat-expanded", ctx._isExpanded())("mat-expansion-toggle-indicator-after", ctx._getTogglePosition() === "after")("mat-expansion-toggle-indicator-before", ctx._getTogglePosition() === "before");
      }
    },
    inputs: {
      expandedHeight: "expandedHeight",
      collapsedHeight: "collapsedHeight",
      tabIndex: [2, "tabIndex", "tabIndex", value => value == null ? 0 : numberAttribute(value)]
    },
    ngContentSelectors: _c52,
    decls: 5,
    vars: 3,
    consts: [[1, "mat-content"], [1, "mat-expansion-indicator"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 -960 960 960", "aria-hidden", "true", "focusable", "false"], ["d", "M480-345 240-585l56-56 184 184 184-184 56 56-240 240Z"]],
    template: function MatExpansionPanelHeader_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c44);
        ɵɵelementStart(0, "span", 0);
        ɵɵprojection(1);
        ɵɵprojection(2, 1);
        ɵɵprojection(3, 2);
        ɵɵelementEnd();
        ɵɵtemplate(4, MatExpansionPanelHeader_Conditional_4_Template, 3, 0, "span", 1);
      }
      if (rf & 2) {
        ɵɵclassProp("mat-content-hide-toggle", !ctx._showToggle());
        ɵɵadvance(4);
        ɵɵconditional(ctx._showToggle() ? 4 : -1);
      }
    },
    styles: ['.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit;height:var(--mat-expansion-header-collapsed-state-height, 48px);font-family:var(--mat-expansion-header-text-font, var(--mat-sys-title-medium-font));font-size:var(--mat-expansion-header-text-size, var(--mat-sys-title-medium-size));font-weight:var(--mat-expansion-header-text-weight, var(--mat-sys-title-medium-weight));line-height:var(--mat-expansion-header-text-line-height, var(--mat-sys-title-medium-line-height));letter-spacing:var(--mat-expansion-header-text-tracking, var(--mat-sys-title-medium-tracking))}.mat-expansion-panel-animations-enabled .mat-expansion-panel-header{transition:height 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel-header::before{border-radius:inherit}.mat-expansion-panel-header.mat-expanded{height:var(--mat-expansion-header-expanded-state-height, 64px)}.mat-expansion-panel-header[aria-disabled=true]{color:var(--mat-expansion-header-disabled-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:var(--mat-expansion-header-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}@media(hover: none){.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:var(--mat-expansion-container-background-color, var(--mat-sys-surface))}}.mat-expansion-panel .mat-expansion-panel-header:not([aria-disabled=true]).cdk-keyboard-focused,.mat-expansion-panel .mat-expansion-panel-header:not([aria-disabled=true]).cdk-program-focused{background:var(--mat-expansion-header-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}.mat-expansion-panel-header._mat-animation-noopable{transition:none}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-content.mat-content-hide-toggle{margin-right:8px}[dir=rtl] .mat-content.mat-content-hide-toggle{margin-right:0;margin-left:8px}.mat-expansion-toggle-indicator-before .mat-content.mat-content-hide-toggle{margin-left:24px;margin-right:0}[dir=rtl] .mat-expansion-toggle-indicator-before .mat-content.mat-content-hide-toggle{margin-right:24px;margin-left:0}.mat-expansion-panel-header-title{color:var(--mat-expansion-header-text-color, var(--mat-sys-on-surface))}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;flex-basis:0;margin-right:16px;align-items:center}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description{color:inherit}.mat-expansion-panel-header-description{flex-grow:2;color:var(--mat-expansion-header-description-color, var(--mat-sys-on-surface-variant))}.mat-expansion-panel-animations-enabled .mat-expansion-indicator{transition:transform 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel-header.mat-expanded .mat-expansion-indicator{transform:rotate(180deg)}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle;color:var(--mat-expansion-header-indicator-color, var(--mat-sys-on-surface-variant));display:var(--mat-expansion-legacy-header-indicator-display, none)}.mat-expansion-indicator svg{width:24px;height:24px;margin:0 -8px;vertical-align:middle;fill:var(--mat-expansion-header-indicator-color, var(--mat-sys-on-surface-variant));display:var(--mat-expansion-header-indicator-display, inline-block)}@media(forced-colors: active){.mat-expansion-panel-content{border-top:1px solid;border-top-left-radius:0;border-top-right-radius:0}}'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelHeader, [{
    type: Component,
    args: [{
      selector: "mat-expansion-panel-header",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "class": "mat-expansion-panel-header mat-focus-indicator",
        "role": "button",
        "[attr.id]": "panel._headerId",
        "[attr.tabindex]": "disabled ? -1 : tabIndex",
        "[attr.aria-controls]": "_getPanelId()",
        "[attr.aria-expanded]": "_isExpanded()",
        "[attr.aria-disabled]": "panel.disabled",
        "[class.mat-expanded]": "_isExpanded()",
        "[class.mat-expansion-toggle-indicator-after]": `_getTogglePosition() === 'after'`,
        "[class.mat-expansion-toggle-indicator-before]": `_getTogglePosition() === 'before'`,
        "[style.height]": "_getHeaderHeight()",
        "(click)": "_toggle()",
        "(keydown)": "_keydown($event)"
      },
      template: '<span class="mat-content" [class.mat-content-hide-toggle]="!_showToggle()">\n  <ng-content select="mat-panel-title"></ng-content>\n  <ng-content select="mat-panel-description"></ng-content>\n  <ng-content></ng-content>\n</span>\n\n@if (_showToggle()) {\n  <span class="mat-expansion-indicator">\n    <svg\n      xmlns="http://www.w3.org/2000/svg"\n      viewBox="0 -960 960 960"\n      aria-hidden="true"\n      focusable="false">\n      <path d="M480-345 240-585l56-56 184 184 184-184 56 56-240 240Z"/>\n    </svg>\n  </span>\n}\n',
      styles: ['.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit;height:var(--mat-expansion-header-collapsed-state-height, 48px);font-family:var(--mat-expansion-header-text-font, var(--mat-sys-title-medium-font));font-size:var(--mat-expansion-header-text-size, var(--mat-sys-title-medium-size));font-weight:var(--mat-expansion-header-text-weight, var(--mat-sys-title-medium-weight));line-height:var(--mat-expansion-header-text-line-height, var(--mat-sys-title-medium-line-height));letter-spacing:var(--mat-expansion-header-text-tracking, var(--mat-sys-title-medium-tracking))}.mat-expansion-panel-animations-enabled .mat-expansion-panel-header{transition:height 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel-header::before{border-radius:inherit}.mat-expansion-panel-header.mat-expanded{height:var(--mat-expansion-header-expanded-state-height, 64px)}.mat-expansion-panel-header[aria-disabled=true]{color:var(--mat-expansion-header-disabled-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:var(--mat-expansion-header-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}@media(hover: none){.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:var(--mat-expansion-container-background-color, var(--mat-sys-surface))}}.mat-expansion-panel .mat-expansion-panel-header:not([aria-disabled=true]).cdk-keyboard-focused,.mat-expansion-panel .mat-expansion-panel-header:not([aria-disabled=true]).cdk-program-focused{background:var(--mat-expansion-header-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}.mat-expansion-panel-header._mat-animation-noopable{transition:none}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-content.mat-content-hide-toggle{margin-right:8px}[dir=rtl] .mat-content.mat-content-hide-toggle{margin-right:0;margin-left:8px}.mat-expansion-toggle-indicator-before .mat-content.mat-content-hide-toggle{margin-left:24px;margin-right:0}[dir=rtl] .mat-expansion-toggle-indicator-before .mat-content.mat-content-hide-toggle{margin-right:24px;margin-left:0}.mat-expansion-panel-header-title{color:var(--mat-expansion-header-text-color, var(--mat-sys-on-surface))}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;flex-basis:0;margin-right:16px;align-items:center}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description{color:inherit}.mat-expansion-panel-header-description{flex-grow:2;color:var(--mat-expansion-header-description-color, var(--mat-sys-on-surface-variant))}.mat-expansion-panel-animations-enabled .mat-expansion-indicator{transition:transform 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel-header.mat-expanded .mat-expansion-indicator{transform:rotate(180deg)}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle;color:var(--mat-expansion-header-indicator-color, var(--mat-sys-on-surface-variant));display:var(--mat-expansion-legacy-header-indicator-display, none)}.mat-expansion-indicator svg{width:24px;height:24px;margin:0 -8px;vertical-align:middle;fill:var(--mat-expansion-header-indicator-color, var(--mat-sys-on-surface-variant));display:var(--mat-expansion-header-indicator-display, inline-block)}@media(forced-colors: active){.mat-expansion-panel-content{border-top:1px solid;border-top-left-radius:0;border-top-right-radius:0}}']
    }]
  }], () => [], {
    expandedHeight: [{
      type: Input
    }],
    collapsedHeight: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: [{
        transform: value => value == null ? 0 : numberAttribute(value)
      }]
    }]
  });
})();
var MatExpansionPanelDescription = class _MatExpansionPanelDescription {
  static ɵfac = function MatExpansionPanelDescription_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatExpansionPanelDescription)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatExpansionPanelDescription,
    selectors: [["mat-panel-description"]],
    hostAttrs: [1, "mat-expansion-panel-header-description"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelDescription, [{
    type: Directive,
    args: [{
      selector: "mat-panel-description",
      host: {
        class: "mat-expansion-panel-header-description"
      }
    }]
  }], null, null);
})();
var MatExpansionPanelTitle = class _MatExpansionPanelTitle {
  static ɵfac = function MatExpansionPanelTitle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatExpansionPanelTitle)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatExpansionPanelTitle,
    selectors: [["mat-panel-title"]],
    hostAttrs: [1, "mat-expansion-panel-header-title"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelTitle, [{
    type: Directive,
    args: [{
      selector: "mat-panel-title",
      host: {
        class: "mat-expansion-panel-header-title"
      }
    }]
  }], null, null);
})();
var MatAccordion = class _MatAccordion extends CdkAccordion {
  _keyManager;
  /** Headers belonging to this accordion. */
  _ownHeaders = new QueryList();
  /** All headers inside the accordion. Includes headers inside nested accordions. */
  _headers;
  /** Whether the expansion indicator should be hidden. */
  hideToggle = false;
  /**
   * Display mode used for all expansion panels in the accordion. Currently two display
   * modes exist:
   *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded
   *     panel at a different elevation from the rest of the accordion.
   *  flat - no spacing is placed around expanded panels, showing all panels at the same
   *     elevation.
   */
  displayMode = "default";
  /** The position of the expansion indicator. */
  togglePosition = "after";
  ngAfterContentInit() {
    this._headers.changes.pipe(startWith(this._headers)).subscribe(headers => {
      this._ownHeaders.reset(headers.filter(header => header.panel.accordion === this));
      this._ownHeaders.notifyOnChanges();
    });
    this._keyManager = new FocusKeyManager(this._ownHeaders).withWrap().withHomeAndEnd();
  }
  /** Handles keyboard events coming in from the panel headers. */
  _handleHeaderKeydown(event) {
    this._keyManager.onKeydown(event);
  }
  _handleHeaderFocus(header) {
    this._keyManager.updateActiveItem(header);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._keyManager?.destroy();
    this._ownHeaders.destroy();
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatAccordion_BaseFactory;
    return function MatAccordion_Factory(__ngFactoryType__) {
      return (ɵMatAccordion_BaseFactory || (ɵMatAccordion_BaseFactory = ɵɵgetInheritedFactory(_MatAccordion)))(__ngFactoryType__ || _MatAccordion);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatAccordion,
    selectors: [["mat-accordion"]],
    contentQueries: function MatAccordion_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatExpansionPanelHeader, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._headers = _t2);
      }
    },
    hostAttrs: [1, "mat-accordion"],
    hostVars: 2,
    hostBindings: function MatAccordion_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("mat-accordion-multi", ctx.multi);
      }
    },
    inputs: {
      hideToggle: [2, "hideToggle", "hideToggle", booleanAttribute],
      displayMode: "displayMode",
      togglePosition: "togglePosition"
    },
    exportAs: ["matAccordion"],
    features: [ɵɵProvidersFeature([{
      provide: MAT_ACCORDION,
      useExisting: _MatAccordion
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatAccordion, [{
    type: Directive,
    args: [{
      selector: "mat-accordion",
      exportAs: "matAccordion",
      providers: [{
        provide: MAT_ACCORDION,
        useExisting: MatAccordion
      }],
      host: {
        class: "mat-accordion",
        // Class binding which is only used by the test harness as there is no other
        // way for the harness to detect if multiple panel support is enabled.
        "[class.mat-accordion-multi]": "this.multi"
      }
    }]
  }], null, {
    _headers: [{
      type: ContentChildren,
      args: [MatExpansionPanelHeader, {
        descendants: true
      }]
    }],
    hideToggle: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    displayMode: [{
      type: Input
    }],
    togglePosition: [{
      type: Input
    }]
  });
})();
var MatExpansionModule = class _MatExpansionModule {
  static ɵfac = function MatExpansionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatExpansionModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatExpansionModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [MatCommonModule, CdkAccordionModule, PortalModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, CdkAccordionModule, PortalModule, MatAccordion, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatExpansionPanelContent],
      exports: [MatAccordion, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatExpansionPanelContent]
    }]
  }], null, null);
})();

// libs/ui/src/lib/components/program-modal/program-modal.component.ts
function ProgramModalComponent_For_18_Conditional_31_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "span", 13);
    ɵɵi18n(2, 6);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const selectedExercise_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance(4);
    ɵɵtextInterpolate(selectedExercise_r2.pause);
  }
}
function ProgramModalComponent_For_18_Conditional_32_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "span", 13);
    ɵɵi18n(2, 7);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const selectedExercise_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance(4);
    ɵɵtextInterpolate(selectedExercise_r2.weight);
  }
}
function ProgramModalComponent_For_18_Conditional_33_For_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1, ", ");
    ɵɵelementEnd();
  }
}
function ProgramModalComponent_For_18_Conditional_33_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵtemplate(2, ProgramModalComponent_For_18_Conditional_33_For_4_Conditional_2_Template, 2, 0, "span");
  }
  if (rf & 2) {
    const equipment_r4 = ctx.$implicit;
    const ɵ$index_116_r5 = ctx.$index;
    const ɵ$count_116_r6 = ctx.$count;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(equipment_r4.translations[ctx_r2.data.selectedLang]);
    ɵɵadvance();
    ɵɵconditional(!(ɵ$index_116_r5 === ɵ$count_116_r6 - 1) ? 2 : -1);
  }
}
function ProgramModalComponent_For_18_Conditional_33_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "span", 13);
    ɵɵi18n(2, 8);
    ɵɵelementEnd();
    ɵɵrepeaterCreate(3, ProgramModalComponent_For_18_Conditional_33_For_4_Template, 3, 2, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const selectedExercise_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance(3);
    ɵɵrepeater(selectedExercise_r2.equipments);
  }
}
function ProgramModalComponent_For_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-expansion-panel", 15)(1, "mat-expansion-panel-header", 17)(2, "div", 18)(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()();
    ɵɵelementStart(5, "mat-panel-title", 19)(6, "div", 20);
    ɵɵelement(7, "img", 21);
    ɵɵelementEnd();
    ɵɵelementStart(8, "span", 22);
    ɵɵtext(9);
    ɵɵelementEnd()();
    ɵɵelementStart(10, "mat-panel-description", 23)(11, "button", 24);
    ɵɵlistener("click", function ProgramModalComponent_For_18_Template_button_click_11_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r2.showExerciseModal(selectedExercise_r2.id, selectedExercise_r2, true));
    });
    ɵɵelementStart(12, "mat-icon");
    ɵɵtext(13, "info_outline");
    ɵɵelementEnd()()()();
    ɵɵelementStart(14, "div", 25)(15, "div", 26)(16, "span", 13);
    ɵɵi18n(17, 3);
    ɵɵelementEnd();
    ɵɵelementStart(18, "span");
    ɵɵtext(19);
    ɵɵelementEnd()();
    ɵɵelementStart(20, "div", 27)(21, "div")(22, "span", 13);
    ɵɵi18n(23, 4);
    ɵɵelementEnd();
    ɵɵelementStart(24, "span");
    ɵɵtext(25);
    ɵɵelementEnd()();
    ɵɵelementStart(26, "div")(27, "span", 13);
    ɵɵi18n(28, 5);
    ɵɵelementEnd();
    ɵɵelementStart(29, "span");
    ɵɵtext(30);
    ɵɵelementEnd()();
    ɵɵtemplate(31, ProgramModalComponent_For_18_Conditional_31_Template, 5, 1, "div")(32, ProgramModalComponent_For_18_Conditional_32_Template, 5, 1, "div")(33, ProgramModalComponent_For_18_Conditional_33_Template, 5, 0, "div");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const selectedExercise_r2 = ctx.$implicit;
    const ɵ$index_32_r7 = ctx.$index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("expanded", ctx_r2.isExpanded);
    ɵɵadvance(4);
    ɵɵtextInterpolate(ɵ$index_32_r7 + 1);
    ɵɵadvance(3);
    ɵɵproperty("src", selectedExercise_r2.images == null ? null : selectedExercise_r2.images.mainImg, ɵɵsanitizeUrl)("alt", selectedExercise_r2.name[ctx_r2.data.selectedLang]);
    ɵɵadvance(2);
    ɵɵtextInterpolate(selectedExercise_r2.name[ctx_r2.data.selectedLang]);
    ɵɵadvance(10);
    ɵɵtextInterpolate(selectedExercise_r2.description[ctx_r2.data.selectedLang]);
    ɵɵadvance(6);
    ɵɵtextInterpolate(selectedExercise_r2.sets);
    ɵɵadvance(5);
    ɵɵtextInterpolate(selectedExercise_r2.reps);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r2.pause ? 31 : -1);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r2.weight ? 32 : -1);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r2.equipments.length !== 0 ? 33 : -1);
  }
}
function ProgramModalComponent_Conditional_19_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-dialog-actions", 16)(1, "button", 28)(2, "mat-icon");
    ɵɵtext(3, "add");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("mat-dialog-close", ctx_r2.data.program.id);
  }
}
var ProgramModalComponent = class _ProgramModalComponent {
  constructor() {
    this.dialogRef = inject(MatDialogRef);
    this.data = inject(MAT_DIALOG_DATA);
    this.dialog = inject(MatDialog);
    this.exercisesService = inject(ExercisesService);
    this.subscriptions = new Subscription();
    this.isExpanded = false;
    this.themeManager = inject(ThemeManagerService);
    this.themeSignal = this.themeManager.themeSignal;
  }
  _getExercise(exerciseId) {
    return this.exercisesService.getExercise(exerciseId);
  }
  showExerciseModal(exerciseId, exerciseCard, isProgramExercise) {
    const subscription = this._getExercise(exerciseId).subscribe(exercise => {
      this.dialog.open(ExerciseModalComponent, {
        data: {
          fullExercise: exercise,
          exerciseCard,
          isProgramExercise,
          selectedLang: this.data.selectedLang
        },
        width: "500px",
        // height: '736px',
        panelClass: ["custom-dialog", ...(isProgramExercise ? ["custom-shadow", "custom-exercise-dialog-content-wrapper"] : [])],
        // disableClose: isProgramExercise,
        // hasBackdrop: isProgramExercise ? false : true,
        backdropClass: isProgramExercise ? "custom-backdrop" : ""
        // enterAnimationDuration: 0,
      });
    });
    this.subscriptions.add(subscription);
  }
  onClose() {
    this.dialogRef.close();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static {
    this.ɵfac = function ProgramModalComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ProgramModalComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _ProgramModalComponent,
      selectors: [["ui-program-modal"]],
      decls: 20,
      vars: 5,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_programName$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_0 = goog.getMsg("Program name");
          i18n_0 = MSG_EXTERNAL_ProgramModal_programName$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_0;
        } else {
          i18n_0 = "Programmname";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_programDiagnosis$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_1 = goog.getMsg("Diagnosis");
          i18n_1 = MSG_EXTERNAL_ProgramModal_programDiagnosis$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_1;
        } else {
          i18n_1 = "Diagnose";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_programExercises$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_2 = goog.getMsg("Program exercises");
          i18n_2 = MSG_EXTERNAL_ProgramModal_programExercises$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_2;
        } else {
          i18n_2 = "\xDCbungen programmieren";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_exerciseDetailsTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_3 = goog.getMsg("Details");
          i18n_3 = MSG_EXTERNAL_ProgramModal_exerciseDetailsTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_3;
        } else {
          i18n_3 = "Einzelheiten";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_exerciseDetailsAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_4 = goog.getMsg("Info button with a info icon");
          i18n_4 = MSG_EXTERNAL_ProgramModal_exerciseDetailsAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_4;
        } else {
          i18n_4 = "Info-Button mit einem Info-Symbol";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_exerciseDescription$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_5 = goog.getMsg("Description");
          i18n_5 = MSG_EXTERNAL_ProgramModal_exerciseDescription$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_5;
        } else {
          i18n_5 = "Beschreibung";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_exerciseSets$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_6 = goog.getMsg("Sets:\xA0");
          i18n_6 = MSG_EXTERNAL_ProgramModal_exerciseSets$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_6;
        } else {
          i18n_6 = "S\xE4tze:\xA0";
        }
        let i18n_7;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_exerciseReps$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_7 = goog.getMsg("Reps:\xA0");
          i18n_7 = MSG_EXTERNAL_ProgramModal_exerciseReps$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_7;
        } else {
          i18n_7 = "Wiederholungen:\xA0";
        }
        let i18n_8;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_exercisePause$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_8 = goog.getMsg("Pause:\xA0");
          i18n_8 = MSG_EXTERNAL_ProgramModal_exercisePause$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_8;
        } else {
          i18n_8 = "Pause:";
        }
        let i18n_9;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_exerciseWeight$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_9 = goog.getMsg("Weight:\xA0");
          i18n_9 = MSG_EXTERNAL_ProgramModal_exerciseWeight$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_9;
        } else {
          i18n_9 = "Gewicht: ";
        }
        let i18n_10;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseEquipment$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_10 = goog.getMsg("Eq: ");
          i18n_10 = MSG_EXTERNAL_EditProgram_exerciseEquipment$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_10;
        } else {
          i18n_10 = "Ausr: ";
        }
        let i18n_11;
        if (false) {
          const MSG_EXTERNAL_ProgramModal_addProgramToClientAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_11 = goog.getMsg("Add to client");
          i18n_11 = MSG_EXTERNAL_ProgramModal_addProgramToClientAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAM_MODAL_PROGRAM_MODAL_COMPONENT_TS_11;
        } else {
          i18n_11 = "Zum Patienten hinzuf\xFCgen";
        }
        return [i18n_0, i18n_1, i18n_2, i18n_5, i18n_6, i18n_7, i18n_8, i18n_9, i18n_10, [1, "confirmation-dialog-wrapper"], [1, "header-container", "program-header"], ["mat-dialog-title", "", 1, "dialog-title", "mat-headline-small"], ["overlay-scrollbars", "", 1, "dialog-content", "dialog-content-wrapper", 3, "options", "defer"], [1, "label"], [1, "program-name", "mat-title-medium"], [1, "exer-expansion-panel", "program-panel", 2, "border-bottom", "none", 3, "expanded"], [1, "dialog-actions", "program-dialog-actions"], ["collapsedHeight", "80px", 1, "exer-expansion-panel-header"], [1, "expansion-panel-handle", "no-handle"], [1, "no-margin"], [1, "program-img-wrapper", "expanded-panels"], [1, "selected-exercise-img", 3, "src", "alt"], [1, "title-name", "mat-body-medium"], [1, "panel-description", "program-panel-description"], ["mat-icon-button", "", "matTooltip", i18n_3, "aria-label", i18n_4, 3, "click"], [1, "panel-content", "program-panel-content"], [1, "name-description-label", "program-description"], [1, "exercise-session", "program-exercise-session"], ["mat-fab", "", "matTooltip", i18n_11, "color", "primary", "aria-label", "Add icon button", 3, "mat-dialog-close"]];
      },
      template: function ProgramModalComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 9)(1, "div", 10)(2, "div")(3, "h2", 11);
          ɵɵtext(4);
          ɵɵelementEnd()()();
          ɵɵelementStart(5, "div", 12)(6, "span", 13);
          ɵɵi18n(7, 0);
          ɵɵelementEnd();
          ɵɵelementStart(8, "h2", 14);
          ɵɵtext(9);
          ɵɵelementEnd();
          ɵɵelementStart(10, "span", 13);
          ɵɵi18n(11, 1);
          ɵɵelementEnd();
          ɵɵelementStart(12, "h2", 14);
          ɵɵtext(13);
          ɵɵelementEnd();
          ɵɵelementStart(14, "span", 13);
          ɵɵi18n(15, 2);
          ɵɵelementEnd();
          ɵɵelementStart(16, "mat-accordion");
          ɵɵrepeaterCreate(17, ProgramModalComponent_For_18_Template, 34, 11, "mat-expansion-panel", 15, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵtemplate(19, ProgramModalComponent_Conditional_19_Template, 4, 1, "mat-dialog-actions", 16);
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance(4);
          ɵɵtextInterpolate1(" ", ctx.data.title, " ");
          ɵɵadvance();
          ɵɵproperty("options", ctx.themeSignal());
          ɵɵadvance(4);
          ɵɵtextInterpolate1(" ", ctx.data.program.name, " ");
          ɵɵadvance(4);
          ɵɵtextInterpolate(ctx.data.program.diagnosis);
          ɵɵadvance(4);
          ɵɵrepeater(ctx.data.program.selectedExercises);
          ɵɵadvance(2);
          ɵɵconditional(ctx.data.isClient ? 19 : -1);
        }
      },
      dependencies: [MatDialogTitle, OverlayscrollbarsModule, OverlayScrollbarsComponent, MatAccordion, MatExpansionPanel, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatIconButton, MatTooltip, MatIcon, MatDialogActions, MatFabButton, MatDialogClose],
      styles: [".confirmation-dialog-wrapper[_ngcontent-%COMP%]{height:736px;border-radius:28px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .header-container[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:24px;padding-left:24px;padding-right:24px;padding-top:24px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .header-container[_ngcontent-%COMP%]   .mdc-dialog__title[_ngcontent-%COMP%]:before{height:0}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .header-container[_ngcontent-%COMP%]   .dialog-title[_ngcontent-%COMP%]{padding:0;margin:0 0 0 -7px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{margin-bottom:8px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]{padding:0 24px 16px;flex-grow:1;height:552px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .no-handle[_ngcontent-%COMP%]{cursor:pointer}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .no-margin[_ngcontent-%COMP%]{margin-left:0;margin-right:0;flex-basis:274px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-panel[_ngcontent-%COMP%]{border-radius:0;border:none!important}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-panel[_ngcontent-%COMP%]:first-of-type{margin-top:8px;border-top-left-radius:16px;border-top-right-radius:16px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-panel[_ngcontent-%COMP%]:last-of-type{border-bottom:none!important;border-bottom-left-radius:16px;border-bottom-right-radius:16px}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-img-wrapper[_ngcontent-%COMP%]{padding:8px 16px 8px 0;width:80px;flex-grow:0}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-img-wrapper[_ngcontent-%COMP%]   .selected-exercise-img[_ngcontent-%COMP%]{width:100%}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-panel-description[_ngcontent-%COMP%]{justify-content:flex-end}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-panel-content[_ngcontent-%COMP%]{flex-direction:column}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-panel-content[_ngcontent-%COMP%]   .program-description[_ngcontent-%COMP%]{gap:0}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .dialog-content[_ngcontent-%COMP%]   .program-panel-content[_ngcontent-%COMP%]   .program-exercise-session[_ngcontent-%COMP%]{flex-direction:row}.confirmation-dialog-wrapper[_ngcontent-%COMP%]   .program-dialog-actions[_ngcontent-%COMP%]{margin-top:auto;justify-content:end}\n/*# sourceMappingURL=program-modal.component-KHIBZBPK.css.map */"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(ProgramModalComponent, {
    className: "ProgramModalComponent",
    filePath: "libs/ui/src/lib/components/program-modal/program-modal.component.ts",
    lineNumber: 59
  });
})();

// libs/ui/src/lib/components/client-full-edit-programs/client-full-edit-programs.component.ts
var ClientFullEditProgramsComponent_Defer_28_DepsFn = () => [import("./chunk-TIFX2JJM.js").then(m2 => m2.BasicProgramsTableComponent)];
var _c015 = () => ["expandedDetail"];
function ClientFullEditProgramsComponent_For_15_th_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵi18n(0, 1, 1);
  }
}
function ClientFullEditProgramsComponent_For_15_th_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵi18n(0, 1, 2);
  }
}
function ClientFullEditProgramsComponent_For_15_th_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵi18n(0, 1, 3);
  }
}
function ClientFullEditProgramsComponent_For_15_th_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵi18n(0, 1, 4);
  }
}
function ClientFullEditProgramsComponent_For_15_th_1_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵi18n(0, 1, 5);
  }
}
function ClientFullEditProgramsComponent_For_15_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 30);
    ɵɵi18nStart(1, 1);
    ɵɵtemplate(2, ClientFullEditProgramsComponent_For_15_th_1_Conditional_2_Template, 1, 0)(3, ClientFullEditProgramsComponent_For_15_th_1_Conditional_3_Template, 1, 0)(4, ClientFullEditProgramsComponent_For_15_th_1_Conditional_4_Template, 1, 0)(5, ClientFullEditProgramsComponent_For_15_th_1_Conditional_5_Template, 1, 0)(6, ClientFullEditProgramsComponent_For_15_th_1_Conditional_6_Template, 1, 0);
    ɵɵi18nEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r1 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵconditional(column_r1 === "position" ? 2 : column_r1 === "name" ? 3 : column_r1 === "dateRange" ? 4 : column_r1 === "noExercises" ? 5 : 6);
  }
}
function ClientFullEditProgramsComponent_For_15_td_2_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 33)(1, "span");
    ɵɵi18n(2, 2);
    ɵɵelementEnd()();
  }
}
function ClientFullEditProgramsComponent_For_15_td_2_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34)(1, "span");
    ɵɵi18n(2, 3);
    ɵɵelementEnd()();
  }
}
function ClientFullEditProgramsComponent_For_15_td_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 32);
    ɵɵtemplate(1, ClientFullEditProgramsComponent_For_15_td_2_Conditional_1_Conditional_1_Template, 3, 0, "div", 33)(2, ClientFullEditProgramsComponent_For_15_td_2_Conditional_1_Conditional_2_Template, 3, 0, "div", 34);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵconditional(element_r2.isProgramCompleted ? 1 : 2);
  }
}
function ClientFullEditProgramsComponent_For_15_td_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const element_r2 = ɵɵnextContext().$implicit;
    ɵɵtextInterpolate1(" ", element_r2.selectedExercises.length, " ");
  }
}
function ClientFullEditProgramsComponent_For_15_td_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
    ɵɵpipe(1, "date");
    ɵɵpipe(2, "date");
  }
  if (rf & 2) {
    const element_r2 = ɵɵnextContext().$implicit;
    ɵɵtextInterpolate2(" ", ɵɵpipeBind2(1, 2, element_r2.dateRange.start, "dd/MM/yyyy"), " - ", ɵɵpipeBind2(2, 5, element_r2.dateRange.end, "dd/MM/yyyy"), " ");
  }
}
function ClientFullEditProgramsComponent_For_15_td_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const element_r2 = ɵɵnextContext().$implicit;
    const column_r1 = ɵɵnextContext().$implicit;
    ɵɵtextInterpolate1(" ", element_r2[column_r1], " ");
  }
}
function ClientFullEditProgramsComponent_For_15_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 31);
    ɵɵtemplate(1, ClientFullEditProgramsComponent_For_15_td_2_Conditional_1_Template, 3, 1, "div", 32)(2, ClientFullEditProgramsComponent_For_15_td_2_Conditional_2_Template, 1, 1)(3, ClientFullEditProgramsComponent_For_15_td_2_Conditional_3_Template, 3, 8)(4, ClientFullEditProgramsComponent_For_15_td_2_Conditional_4_Template, 1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r1 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵconditional(column_r1 === "status" ? 1 : column_r1 === "noExercises" ? 2 : column_r1 === "dateRange" ? 3 : 4);
  }
}
function ClientFullEditProgramsComponent_For_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 20);
    ɵɵtemplate(1, ClientFullEditProgramsComponent_For_15_th_1_Template, 7, 1, "th", 29)(2, ClientFullEditProgramsComponent_For_15_td_2_Template, 5, 1, "td", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    ɵɵpropertyInterpolate("matColumnDef", column_r1);
  }
}
function ClientFullEditProgramsComponent_th_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 35);
    ɵɵtext(1, " \xA0 ");
    ɵɵelementEnd();
  }
}
function ClientFullEditProgramsComponent_td_18_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 41);
    ɵɵlistener("click", function ClientFullEditProgramsComponent_td_18_Conditional_2_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const element_r5 = ɵɵnextContext().$implicit;
      const ctx_r5 = ɵɵnextContext();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r5.openEditClientProgramDialog(element_r5.position));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "edit");
    ɵɵelementEnd()();
  }
}
function ClientFullEditProgramsComponent_td_18_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1, "keyboard_arrow_up");
    ɵɵelementEnd();
  }
}
function ClientFullEditProgramsComponent_td_18_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1, "keyboard_arrow_down");
    ɵɵelementEnd();
  }
}
function ClientFullEditProgramsComponent_td_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 31)(1, "div", 36);
    ɵɵtemplate(2, ClientFullEditProgramsComponent_td_18_Conditional_2_Template, 3, 0, "button", 37);
    ɵɵelementStart(3, "button", 38);
    ɵɵlistener("click", function ClientFullEditProgramsComponent_td_18_Template_button_click_3_listener($event) {
      const element_r5 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r5 = ɵɵnextContext();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r5.reuseEditProgram(element_r5.position));
    });
    ɵɵelementStart(4, "mat-icon");
    ɵɵtext(5, "person_add");
    ɵɵelementEnd()();
    ɵɵelementStart(6, "button", 39);
    ɵɵlistener("click", function ClientFullEditProgramsComponent_td_18_Template_button_click_6_listener($event) {
      const element_r5 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r5 = ɵɵnextContext();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r5.openDeleteConfirmationDialog(element_r5.position));
    });
    ɵɵelementStart(7, "mat-icon");
    ɵɵtext(8, "delete_outline");
    ɵɵelementEnd()();
    ɵɵelementStart(9, "button", 40);
    ɵɵlistener("click", function ClientFullEditProgramsComponent_td_18_Template_button_click_9_listener($event) {
      const element_r5 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r5 = ɵɵnextContext();
      ctx_r5.expandedElement = ctx_r5.expandedElement === element_r5 ? null : element_r5;
      return ɵɵresetView($event.stopPropagation());
    });
    ɵɵtemplate(10, ClientFullEditProgramsComponent_td_18_Conditional_10_Template, 2, 0, "mat-icon")(11, ClientFullEditProgramsComponent_td_18_Conditional_11_Template, 2, 0, "mat-icon");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const element_r5 = ctx.$implicit;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(!element_r5.isProgramCompleted ? 2 : -1);
    ɵɵadvance(8);
    ɵɵconditional(ctx_r5.expandedElement === element_r5 ? 10 : 11);
  }
}
function ClientFullEditProgramsComponent_td_20_For_4_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵi18n(1, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const selectedExercise_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵi18nExp(selectedExercise_r7.pause);
    ɵɵi18nApply(1);
  }
}
function ClientFullEditProgramsComponent_td_20_For_4_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵi18n(1, 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const selectedExercise_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵi18nExp(selectedExercise_r7.weight);
    ɵɵi18nApply(1);
  }
}
function ClientFullEditProgramsComponent_td_20_For_4_Conditional_13_For_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵi18nStart(0, 8, 2);
    ɵɵelement(1, "span");
    ɵɵi18nEnd();
  }
}
function ClientFullEditProgramsComponent_td_20_For_4_Conditional_13_For_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵi18nStart(0, 8, 1);
    ɵɵelement(1, "span");
    ɵɵtemplate(2, ClientFullEditProgramsComponent_td_20_For_4_Conditional_13_For_3_Conditional_2_Template, 2, 0, "span");
    ɵɵi18nEnd();
  }
  if (rf & 2) {
    const equipment_r8 = ctx.$implicit;
    const ɵ$index_160_r9 = ctx.$index;
    const ɵ$count_160_r10 = ctx.$count;
    const ctx_r5 = ɵɵnextContext(4);
    ɵɵadvance(2);
    ɵɵconditional(!(ɵ$index_160_r9 === ɵ$count_160_r10 - 1) ? 2 : -1);
    ɵɵi18nExp(equipment_r8.translations[ctx_r5.selectedLanguage]);
    ɵɵi18nApply(0);
  }
}
function ClientFullEditProgramsComponent_td_20_For_4_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵi18nStart(1, 8);
    ɵɵrepeaterCreate(2, ClientFullEditProgramsComponent_td_20_For_4_Conditional_13_For_3_Template, 3, 2, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵi18nEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const selectedExercise_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵrepeater(selectedExercise_r7.equipments);
  }
}
function ClientFullEditProgramsComponent_td_20_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 44)(1, "div", 45);
    ɵɵelement(2, "img", 46);
    ɵɵelementStart(3, "div", 47)(4, "span", 48);
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "span", 49)(7, "span");
    ɵɵi18n(8, 4);
    ɵɵelementEnd();
    ɵɵelementStart(9, "span");
    ɵɵi18n(10, 5);
    ɵɵelementEnd();
    ɵɵtemplate(11, ClientFullEditProgramsComponent_td_20_For_4_Conditional_11_Template, 2, 1, "span")(12, ClientFullEditProgramsComponent_td_20_For_4_Conditional_12_Template, 2, 1, "span")(13, ClientFullEditProgramsComponent_td_20_For_4_Conditional_13_Template, 4, 0, "span");
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const selectedExercise_r7 = ctx.$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("src", selectedExercise_r7.images == null ? null : selectedExercise_r7.images.mainImg, ɵɵsanitizeUrl)("alt", selectedExercise_r7.name[ctx_r5.selectedLanguage]);
    ɵɵadvance(3);
    ɵɵtextInterpolate(selectedExercise_r7.name[ctx_r5.selectedLanguage]);
    ɵɵadvance(3);
    ɵɵi18nExp(selectedExercise_r7.sets);
    ɵɵi18nApply(8);
    ɵɵadvance(2);
    ɵɵi18nExp(selectedExercise_r7.reps);
    ɵɵi18nApply(10);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r7.pause ? 11 : -1);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r7.weight ? 12 : -1);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r7.equipments.length !== 0 ? 13 : -1);
  }
}
function ClientFullEditProgramsComponent_td_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 31)(1, "div", 42)(2, "div", 43);
    ɵɵrepeaterCreate(3, ClientFullEditProgramsComponent_td_20_For_4_Template, 14, 8, "div", 44, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const element_r11 = ctx.$implicit;
    const ctx_r5 = ɵɵnextContext();
    ɵɵattribute("colspan", ctx_r5.columnsToDisplayWithExpand.length);
    ɵɵadvance();
    ɵɵproperty("@detailExpand", element_r11 === ctx_r5.expandedElement ? "expanded" : "collapsed");
    ɵɵadvance(2);
    ɵɵrepeater(element_r11.selectedExercises);
  }
}
function ClientFullEditProgramsComponent_tr_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 50);
  }
}
function ClientFullEditProgramsComponent_tr_22_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr", 51);
    ɵɵlistener("click", function ClientFullEditProgramsComponent_tr_22_Template_tr_click_0_listener() {
      const element_r13 = ɵɵrestoreView(_r12).$implicit;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.expandedElement = ctx_r5.expandedElement === element_r13 ? null : element_r13);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r13 = ctx.$implicit;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("client-program-expanded-row", ctx_r5.expandedElement === element_r13);
  }
}
function ClientFullEditProgramsComponent_tr_23_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 52);
  }
}
function ClientFullEditProgramsComponent_tr_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 53)(1, "td", 54);
    ɵɵi18n(2, 9);
    ɵɵelementEnd()();
  }
}
function ClientFullEditProgramsComponent_Defer_26_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "ui-basic-programs-table", 55);
    ɵɵlistener("getProgramsEvent", function ClientFullEditProgramsComponent_Defer_26_Template_ui_basic_programs_table_getProgramsEvent_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.getPrograms($event));
    })("viewProgramEvent", function ClientFullEditProgramsComponent_Defer_26_Template_ui_basic_programs_table_viewProgramEvent_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.viewProgramModal($event));
    })("addProgramToClientEvent", function ClientFullEditProgramsComponent_Defer_26_Template_ui_basic_programs_table_addProgramToClientEvent_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.addProgramToClient($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("dataSource", ctx_r5.dataSourceAllPrograms)("isClient", true);
  }
}
function ClientFullEditProgramsComponent_DeferPlaceholder_27_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 56)(1, "div", 57)(2, "h3", 58);
    ɵɵi18n(3, 10);
    ɵɵelementEnd();
    ɵɵelement(4, "div", 59);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 60);
    ɵɵelement(6, "div", 61)(7, "div", 61)(8, "div", 61)(9, "div", 61)(10, "div", 61)(11, "div", 61)(12, "div", 61)(13, "div", 61)(14, "div", 61);
    ɵɵelementEnd();
    ɵɵelement(15, "div", 61);
    ɵɵelementEnd();
  }
}
var ClientFullEditProgramsComponent = class _ClientFullEditProgramsComponent {
  constructor() {
    this.programsService = inject(ProgramsService);
    this.controlContainer = inject(ControlContainer);
    this.datePipe = inject(DatePipe);
    this.dialog = inject(MatDialog);
    this._snackBar = inject(MatSnackBar);
    this.router = inject(Router);
    this.formGroupDirective = inject(FormGroupDirective);
    this.shareClientsDataService = inject(ShareClientsDataService);
    this.clientsService = inject(ClientsService);
    this.localstorageService = inject(LocalstorageService);
    this.shareStateService = inject(ShareStateService);
    this.isFetchingData = this.shareStateService.isFetchingData;
    this.newButtonString = "Neu";
    this.columnsToDisplay = [
    // 'select',
    "position", "name", "noExercises", "dateRange", "status"];
    this.dataSourceClientsPrograms = new MatTableDataSource();
    this.dataSourceAllPrograms = new MatTableDataSource();
    this.columnsToDisplayWithExpand = [...this.columnsToDisplay, "expand"];
    this.selection = new SelectionModel(true, []);
    this.clientsPrograms = [];
    this.allPrograms = [];
    this.subscriptions = new Subscription();
    this.isProgramCompleted = [];
    this.clientInfo = this.shareClientsDataService.clientInfo;
    this.reuseProgram = this.shareClientsDataService.reuseProgram;
    this.isBrandNewClientsProgram = this.shareClientsDataService.isBrandNewClientsProgram;
    this.themeManager = inject(ThemeManagerService);
    this.themeSignal = this.themeManager.themeSignal;
    this.getPrograms("template");
  }
  ngOnInit() {
    this.selectedLanguage = this._getUserLanguageToken();
    console.log(this.selectedLanguage);
    this.form = this.controlContainer.control?.get("programs");
    console.log(this.form);
    this.clientId = this.formGroupDirective.form.get("clientInfo.id")?.value;
    console.log(this.formGroupDirective.form);
    this.clientName = this.formGroupDirective.form.get("clientInfo.name")?.value;
    this.client = this.formGroupDirective.form.get("clientInfo")?.value;
    this.parentForm = this.formGroupDirective.form;
    console.log(this.parentForm.value);
    this.getClientsPrograms();
    console.log(this.clientInfo());
  }
  getClientsPrograms() {
    this.clientsPrograms = [];
    let adaptedProgram;
    this.form.value.forEach((programData, i2) => {
      console.log(programData);
      const currentDate = /* @__PURE__ */new Date();
      const programEndDate = new Date(programData.dateRange.end);
      let isProgramCompleted;
      if (programEndDate < currentDate) {
        isProgramCompleted = true;
        console.log("This program is completed");
      } else {
        isProgramCompleted = false;
        console.log("This program is in progress");
      }
      adaptedProgram = {
        id: programData.program.id,
        name: programData.program.name,
        selectedExercises: programData.program.selectedExercises,
        // program: programData.program,
        // date: `${startDate} - ${endDate}`,
        dateRange: programData.dateRange,
        position: i2 + 1,
        isProgramCompleted
      };
      this.clientsPrograms.push(adaptedProgram);
      console.log(adaptedProgram);
    });
    console.log(this.clientsPrograms);
    this.dataSourceClientsPrograms.data = this.clientsPrograms;
  }
  openEditClientProgramDialog(programPosition) {
    this.reuseProgram.set(false);
    const programId = this.clientsPrograms[programPosition - 1].id;
    const programName = this.clientsPrograms[programPosition - 1].name;
    const dateRange = this.clientsPrograms[programPosition - 1].dateRange;
    console.log(dateRange);
    console.log(this.clientName);
    this.clientInfo.set({
      clientId: this.clientId,
      clientName: this.clientName,
      programPosition: programPosition - 1,
      programId,
      programName,
      dateRange
    });
    console.log(this.clientInfo());
    this.router.navigate([`programs/form/${programId}`], {
      queryParams: {
        programName: `${programName}`,
        isClientProgram: "true"
      }
    });
  }
  reuseEditProgram(programPosition) {
    this.reuseProgram.set(true);
    const programId = this.clientsPrograms[programPosition - 1].id;
    const programName = this.clientsPrograms[programPosition - 1].name;
    this.clientInfo.set({
      clientId: this.clientId,
      clientName: this.clientName,
      programPosition: programPosition - 1,
      programId,
      programName,
      dateRange: {
        start: "",
        end: ""
      }
    });
    this.router.navigate([`programs/form/${programId}`], {
      queryParams: {
        programName: `${programName}`,
        isClientProgram: "true"
      }
    });
  }
  openDeleteConfirmationDialog(programPosition) {
    const dialogRef = this.dialog.open(DeleteConfirmationDialogComponent, {
      width: "312px",
      data: {
        title: "Ausgew\xE4hltes Programm l\xF6schen?",
        message: "Durch das L\xF6schen des ausgew\xE4hlten Programms wird es aus dem Patientenprofil entfernt."
      },
      panelClass: "custom-dialog"
    });
    const subscription = dialogRef.afterClosed().subscribe(result => {
      if (result) {
        console.log("User confirmed deletion");
        const subscription2 = this.clientsService.deleteClientProgram(this.clientId, programPosition - 1).subscribe(res => {
          this.form.removeAt(programPosition - 1);
          this.getClientsPrograms();
          console.log(res);
        });
        this.subscriptions.add(subscription2);
        dialogRef.close();
      } else {
        console.log("User canceled deletion");
        dialogRef.close();
      }
    });
    this.subscriptions.add(subscription);
  }
  /* private deleteProgram(programPosition: number) {
      // console.log(programPosition - 1);
      // console.log(this.form.value[programPosition - 1]);
      this.form.removeAt(programPosition - 1);
      this.getPrograms();
  
      this._snackBar.open('Program deleted', '', {
        duration: 2000,
        panelClass: ['custom-snackbar-style'],
      });
      // this.programs.splice(programPosition - 1, 1);
  
      // this.dataSourceClientsPrograms.data = this.programs;
  
      // console.log(this.form.value);
    } */
  /** Whether the number of selected elements matches the total number of rows. */
  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSourceClientsPrograms.data.length;
    return numSelected === numRows;
  }
  /** Selects all rows if they are not all selected; otherwise clear selection. */
  toggleAllRows() {
    if (this.isAllSelected()) {
      this.selection.clear();
      return;
    }
    this.selection.select(...this.dataSourceClientsPrograms.data);
  }
  // getProgram(programId: string) {
  //   this.programsService.getProgram(programId).subscribe(program => {
  //     console.log(program);
  //   });
  // }
  /** The label for the checkbox on the passed row */
  // checkboxLabel(row?: Program): string {
  //   console.log('checkbox label dont work');
  //   if (!row) {
  //     return `${this.isAllSelected() ? 'deselect' : 'select'} all`;
  //   }
  //   return `${this.selection.isSelected(row) ? 'deselect' : 'select'} row ${
  //     row.position + 1
  //   }`;
  // }
  createProgram() {
    this.isBrandNewClientsProgram.set(true);
    this.router.navigateByUrl(`programs/form`);
  }
  getPrograms(listOption) {
    this.isFetchingData.set(true);
    if (listOption === "template") {
      const subscription = this.programsService.getPrograms().subscribe(programsList => {
        this.allPrograms = [];
        this.allPrograms = programsList;
        this.allPrograms.sort((a2, b2) => {
          return a2.name.localeCompare(b2.name);
        });
        console.log(this.allPrograms);
        this.dataSourceAllPrograms.data = this.allPrograms;
        this.isFetchingData.set(false);
      });
      this.subscriptions.add(subscription);
    }
  }
  viewProgramModal(programId) {
    const subscription = this.programsService.getProgram(programId).subscribe(program => {
      const dialogRef = this.dialog.open(ProgramModalComponent, {
        width: "500px",
        // height: '736px',
        data: {
          title: "Programminfo",
          program,
          selectedLang: this.selectedLanguage,
          isClient: true
        },
        // disableClose: true, // Disable closing when clicked outside
        panelClass: "custom-dialog"
        // enterAnimationDuration: 0,
      });
      const subscription2 = dialogRef.afterClosed().subscribe(result => {
        if (result) {
          this.addProgramToClient(result);
        } else {
          console.log("Program modal exited");
        }
      });
      this.subscriptions.add(subscription2);
    });
    this.subscriptions.add(subscription);
  }
  addProgramToClient(programId) {
    console.log(programId);
    const subscription = this.programsService.getProgram(programId).subscribe(program => {
      program.isTemplate = false;
      console.log(program);
      let startDate = this.form.get("clientInfo.dateRange.start")?.value;
      console.log(startDate === null);
      let endDate = this.form.get("clientInfo.dateRange.end")?.value;
      startDate === void 0 ? startDate = /* @__PURE__ */new Date() : startDate;
      endDate === void 0 ? endDate = startDate.getTime() + 7 * 24 * 60 * 60 * 1e3 : endDate;
      const newProgram = {
        // programId: createdProgram.id,
        // programName: createdProgram.name,
        program: {
          name: program.name,
          diagnosis: program.diagnosis,
          notes: program.notes,
          selectedExercises: program.selectedExercises,
          templateProgramId: program.id,
          isTemplate: false
        },
        dateRange: {
          // start: dateRange.start,
          // end: dateRange.end,
          start: startDate,
          end: endDate
        }
      };
      console.log(newProgram);
      const programs = this.form.value;
      const updatedPrograms = [...programs, newProgram];
      console.log(updatedPrograms);
      const updatedClient = {
        firstName: this.client.firstName,
        lastName: this.client.lastName,
        name: this.client.name,
        email: this.client.email,
        phone: this.client.phone,
        address: {
          street: this.client.address?.street,
          streetNumber: this.client.address?.streetNumber,
          city: this.client.address?.city,
          zipCode: this.client.address?.zipCode,
          country: this.client.address?.country
        },
        programs: updatedPrograms
      };
      const subscription2 = this.clientsService.updateClient(updatedClient, this.clientId).subscribe(updatedClient2 => {
        const newAddedProgram = updatedClient2.programs?.pop();
        const programsArray = this.form;
        programsArray.push(new FormControl(newAddedProgram));
        this.getClientsPrograms();
        const message = "Programm dem Patienten hinzugef\xFCgt";
        this._snackBar.open(message, "", {
          duration: 2e3,
          panelClass: ["custom-snackbar-style"]
        });
      });
      this.subscriptions.add(subscription2);
    });
    this.subscriptions.add(subscription);
  }
  _getUserLanguageToken() {
    return this.localstorageService.getToken("userLanguage")?.split("-")[0];
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static {
    this.ɵfac = function ClientFullEditProgramsComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ClientFullEditProgramsComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _ClientFullEditProgramsComponent,
      selectors: [["ui-client-full-edit-programs"]],
      features: [ɵɵProvidersFeature([DatePipe])],
      decls: 30,
      vars: 7,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_ClientForm_createProgramBtnTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_0 = goog.getMsg("Create program");
          i18n_0 = MSG_EXTERNAL_ClientForm_createProgramBtnTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_0;
        } else {
          i18n_0 = "Programm erstellen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_ClientForm_listOfClientProgramsTitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_1 = goog.getMsg(" List of client's programs ");
          i18n_1 = MSG_EXTERNAL_ClientForm_listOfClientProgramsTitle$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_1;
        } else {
          i18n_1 = "Liste der Programme des Patienten";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_column$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_2 = goog.getMsg("{$startBlockIf} No. {$closeBlockIf}{$startBlockElseIf} Name {$closeBlockElseIf}{$startBlockElseIf_1} Date {$closeBlockElseIf}{$startBlockElseIf_2} No. of exercises {$closeBlockElseIf}{$startBlockElse} Status {$closeBlockElse}", {
            "closeBlockElse": "\uFFFD/*6:5\uFFFD",
            "closeBlockElseIf": "[\uFFFD/*3:2\uFFFD|\uFFFD/*4:3\uFFFD|\uFFFD/*5:4\uFFFD]",
            "closeBlockIf": "\uFFFD/*2:1\uFFFD",
            "startBlockElse": "\uFFFD*6:5\uFFFD",
            "startBlockElseIf": "\uFFFD*3:2\uFFFD",
            "startBlockElseIf_1": "\uFFFD*4:3\uFFFD",
            "startBlockElseIf_2": "\uFFFD*5:4\uFFFD",
            "startBlockIf": "\uFFFD*2:1\uFFFD"
          }, {
            original_code: {
              "closeBlockElse": "}",
              "closeBlockElseIf": "}",
              "closeBlockIf": "}",
              "startBlockElse": "@else {",
              "startBlockElseIf": "@else if (column === 'name') {",
              "startBlockElseIf_1": "@else if (column === 'dateRange') {",
              "startBlockElseIf_2": "@else if (column === 'noExercises') {",
              "startBlockIf": "@if (column === 'position') {"
            }
          });
          i18n_2 = MSG_EXTERNAL_ClientFormProgramsTable_column$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_2;
        } else {
          i18n_2 = "" + "\uFFFD*2:1\uFFFD" + " Nr. " + "\uFFFD/*2:1\uFFFD" + "" + "\uFFFD*3:2\uFFFD" + " Name " + "[\uFFFD/*3:2\uFFFD|\uFFFD/*4:3\uFFFD|\uFFFD/*5:4\uFFFD]" + "" + "\uFFFD*4:3\uFFFD" + " Datum " + "[\uFFFD/*3:2\uFFFD|\uFFFD/*4:3\uFFFD|\uFFFD/*5:4\uFFFD]" + "" + "\uFFFD*5:4\uFFFD" + " Nr. \xDCbungen " + "[\uFFFD/*3:2\uFFFD|\uFFFD/*4:3\uFFFD|\uFFFD/*5:4\uFFFD]" + "" + "\uFFFD*6:5\uFFFD" + " Status " + "\uFFFD/*6:5\uFFFD" + "";
        }
        i18n_2 = ɵɵi18nPostprocess(i18n_2);
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_rowCompleted$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_3 = goog.getMsg("Completed");
          i18n_3 = MSG_EXTERNAL_ClientFormProgramsTable_rowCompleted$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_3;
        } else {
          i18n_3 = "Vollendet";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_rowInProgress$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_4 = goog.getMsg("In progress");
          i18n_4 = MSG_EXTERNAL_ClientFormProgramsTable_rowInProgress$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_4;
        } else {
          i18n_4 = "Im Gange";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_editProgramButton$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_5 = goog.getMsg("Edit");
          i18n_5 = MSG_EXTERNAL_ClientFormProgramsTable_editProgramButton$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_5;
        } else {
          i18n_5 = "Bearbeiten";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_addToClientButton$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_6 = goog.getMsg("Add to client");
          i18n_6 = MSG_EXTERNAL_ClientFormProgramsTable_addToClientButton$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_6;
        } else {
          i18n_6 = "Zum Patienten hinzuf\xFCgen";
        }
        let i18n_7;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_deleteClientProgramButton$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_7 = goog.getMsg("Delete");
          i18n_7 = MSG_EXTERNAL_ClientFormProgramsTable_deleteClientProgramButton$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_7;
        } else {
          i18n_7 = "L\xF6schen";
        }
        let i18n_8;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_sets$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_8 = goog.getMsg("Sets: {$interpolation} | ", {
            "interpolation": "\uFFFD0\uFFFD"
          }, {
            original_code: {
              "interpolation": "{{ selectedExercise.sets }}"
            }
          });
          i18n_8 = MSG_EXTERNAL_ClientFormProgramsTable_sets$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_8;
        } else {
          i18n_8 = "S\xE4tze: " + "\uFFFD0\uFFFD" + " | ";
        }
        let i18n_9;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_reps$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_9 = goog.getMsg("Reps: {$interpolation} | ", {
            "interpolation": "\uFFFD0\uFFFD"
          }, {
            original_code: {
              "interpolation": "{{ selectedExercise.reps }}"
            }
          });
          i18n_9 = MSG_EXTERNAL_ClientFormProgramsTable_reps$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_9;
        } else {
          i18n_9 = "Wiederholungen: " + "\uFFFD0\uFFFD" + " ";
        }
        let i18n_10;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_pause$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_10 = goog.getMsg("Pause: {$interpolation} | ", {
            "interpolation": "\uFFFD0\uFFFD"
          }, {
            original_code: {
              "interpolation": "{{ selectedExercise.pause }}"
            }
          });
          i18n_10 = MSG_EXTERNAL_ClientFormProgramsTable_pause$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_10;
        } else {
          i18n_10 = "Pause: " + "\uFFFD0\uFFFD" + " |";
        }
        let i18n_11;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_weight$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_11 = goog.getMsg("Weight: {$interpolation} | ", {
            "interpolation": "\uFFFD0\uFFFD"
          }, {
            original_code: {
              "interpolation": "{{ selectedExercise.weight }}"
            }
          });
          i18n_11 = MSG_EXTERNAL_ClientFormProgramsTable_weight$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_11;
        } else {
          i18n_11 = "Gewicht: " + "\uFFFD0\uFFFD" + " |";
        }
        let i18n_12;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseEquipment$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_12 = goog.getMsg("Eq: {$startBlockFor}{$startTagSpan}{$interpolation}{$closeTagSpan}{$startBlockIf}{$startTagSpan}, {$closeTagSpan}{$closeBlockIf}{$closeBlockFor}", {
            "closeBlockFor": "\uFFFD/*3:1\uFFFD",
            "closeBlockIf": "\uFFFD/*2:2\uFFFD",
            "closeTagSpan": "[\uFFFD/#1:1\uFFFD|\uFFFD/#1:2\uFFFD]",
            "interpolation": "\uFFFD0:1\uFFFD",
            "startBlockFor": "\uFFFD*3:1\uFFFD",
            "startBlockIf": "\uFFFD*2:2\uFFFD",
            "startTagSpan": "[\uFFFD#1:1\uFFFD|\uFFFD#1:2\uFFFD]"
          }, {
            original_code: {
              "closeBlockFor": "}",
              "closeBlockIf": "}",
              "closeTagSpan": "</span>",
              "interpolation": "{{\n                                      equipment.translations[selectedLanguage]\n                                    }}",
              "startBlockFor": "@for (\n                                    equipment of selectedExercise.equipments;\n                                    track equipment;\n                                    let last = $last\n                                  ) {",
              "startBlockIf": "@if (!last) {",
              "startTagSpan": "<span>"
            }
          });
          i18n_12 = MSG_EXTERNAL_EditProgram_exerciseEquipment$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_12;
        } else {
          i18n_12 = "Ausr: ";
        }
        i18n_12 = ɵɵi18nPostprocess(i18n_12);
        let i18n_13;
        if (false) {
          const MSG_EXTERNAL_ClientFormProgramsTable_noProgramsAssigned$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_13 = goog.getMsg(" No programs assigned to clients ");
          i18n_13 = MSG_EXTERNAL_ClientFormProgramsTable_noProgramsAssigned$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_13;
        } else {
          i18n_13 = "Den Patienten wurden keine Programme zugewiesen";
        }
        let i18n_14;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_titlePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_14 = goog.getMsg(" List of program templates ");
          i18n_14 = MSG_EXTERNAL_ClientFormBasicProgramsTable_titlePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_CLIENT_FULL_EDIT_PROGRAMS_CLIENT_FULL_EDIT_PROGRAMS_COMPONENT_TS_14;
        } else {
          i18n_14 = "Liste der Programmvorlagen";
        }
        return [i18n_1, i18n_2, i18n_3, i18n_4, i18n_8, i18n_9, i18n_10, i18n_11, i18n_12, i18n_13, i18n_14, [1, "table-wrapper", "clients-program-list-table"], [1, "tables-wrapper"], [1, "clients-program-list-title"], [1, "mat-title-large"], ["vertical", "", 2, "display", "inline-block", "height", "24px"], ["mat-flat-button", "", "matTooltip", i18n_0, 3, "click"], ["formArray", "form"], ["overlay-scrollbars", "", 1, "clients-table", 3, "options", "defer"], ["mat-table", "", "multiTemplateDataRows", "", 1, "mat-table-background", 3, "dataSource"], [3, "matColumnDef"], ["matColumnDef", "expand"], ["mat-header-cell", "", "aria-label", "row actions", 4, "matHeaderCellDef"], ["mat-cell", "", 4, "matCellDef"], ["matColumnDef", "expandedDetail"], ["mat-header-row", "", 4, "matHeaderRowDef"], ["mat-row", "", "class", "client-program-element-row table-rows", 3, "client-program-expanded-row", "click", 4, "matRowDef", "matRowDefColumns"], ["mat-row", "", "class", "client-program-detail-row", 4, "matRowDef", "matRowDefColumns"], ["class", "mat-row", 4, "matNoDataRow"], ["mat-header-cell", "", 4, "matHeaderCellDef"], ["mat-header-cell", ""], ["mat-cell", ""], [1, "status-chip-wrapper"], [1, "status-chip", "status-completed"], [1, "status-chip", "status-inprogress"], ["mat-header-cell", "", "aria-label", "row actions"], [1, "client-options"], ["mat-icon-button", "", "matTooltip", i18n_5, "aria-label", "Edit icon button", "i18m-aria-label", "@@ClientFormProgramsTable.editProgramBtnAriaLabel"], ["mat-icon-button", "", "matTooltip", i18n_6, "aria-label", "Add to client icon button", "i18m-aria-label", "@@ClientFormProgramsTable.addToClientAriaLabel", 3, "click"], ["mat-icon-button", "", "matTooltip", i18n_7, "aria-label", "Delete icon button", "i18m-aria-label", "@@ClientFormProgramsTable.deleteClientProgramAriaLabel", 3, "click"], ["mat-icon-button", "", "aria-label", "expand row", 3, "click"], ["mat-icon-button", "", "matTooltip", i18n_5, "aria-label", "Edit icon button", "i18m-aria-label", "@@ClientFormProgramsTable.editProgramBtnAriaLabel", 3, "click"], [1, "client-program-element-detail"], [1, "table-client-program-wrapper"], [1, "list-item"], [1, "list-item-flex"], [2, "width", "50px", 3, "src", "alt"], [1, "list-info"], [1, "list-info-title"], [1, "list-info-details"], ["mat-header-row", ""], ["mat-row", "", 1, "client-program-element-row", "table-rows", 3, "click"], ["mat-row", "", 1, "client-program-detail-row"], [1, "mat-row"], ["colspan", "4", 1, "mat-cell", "no-data-cell"], [1, "ui-programs-table", 3, "getProgramsEvent", "viewProgramEvent", "addProgramToClientEvent", "dataSource", "isClient"], [1, "basic-programs-table-placeholder"], [1, "basic-programs-title-placeholder"], [1, "basic-programs-title-skeleton", "mat-title-large"], [1, "input-placeholder", "animate-skeleton"], [1, "basic-program-skeleton-container"], [1, "basic-programs-table-skeleton", "animate-skeleton"]];
      },
      template: function ClientFullEditProgramsComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 11)(1, "div", 12)(2, "div")(3, "div", 13)(4, "h3", 14);
          ɵɵi18n(5, 0);
          ɵɵelementEnd();
          ɵɵelement(6, "mat-divider", 15);
          ɵɵelementStart(7, "button", 16);
          ɵɵlistener("click", function ClientFullEditProgramsComponent_Template_button_click_7_listener() {
            return ctx.createProgram();
          });
          ɵɵelementStart(8, "mat-icon");
          ɵɵtext(9, "add");
          ɵɵelementEnd();
          ɵɵtext(10);
          ɵɵelementEnd()();
          ɵɵelementStart(11, "form", 17)(12, "div", 18)(13, "table", 19);
          ɵɵrepeaterCreate(14, ClientFullEditProgramsComponent_For_15_Template, 3, 1, "ng-container", 20, ɵɵrepeaterTrackByIdentity);
          ɵɵelementContainerStart(16, 21);
          ɵɵtemplate(17, ClientFullEditProgramsComponent_th_17_Template, 2, 0, "th", 22)(18, ClientFullEditProgramsComponent_td_18_Template, 12, 2, "td", 23);
          ɵɵelementContainerEnd();
          ɵɵelementContainerStart(19, 24);
          ɵɵtemplate(20, ClientFullEditProgramsComponent_td_20_Template, 5, 2, "td", 23);
          ɵɵelementContainerEnd();
          ɵɵtemplate(21, ClientFullEditProgramsComponent_tr_21_Template, 1, 0, "tr", 25)(22, ClientFullEditProgramsComponent_tr_22_Template, 1, 2, "tr", 26)(23, ClientFullEditProgramsComponent_tr_23_Template, 1, 0, "tr", 27)(24, ClientFullEditProgramsComponent_tr_24_Template, 3, 0, "tr", 28);
          ɵɵelementEnd()()()();
          ɵɵelementStart(25, "div");
          ɵɵtemplate(26, ClientFullEditProgramsComponent_Defer_26_Template, 1, 2)(27, ClientFullEditProgramsComponent_DeferPlaceholder_27_Template, 16, 0);
          ɵɵdefer(28, 26, ClientFullEditProgramsComponent_Defer_28_DepsFn, null, 27);
          ɵɵdeferOnIdle();
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵadvance(10);
          ɵɵtextInterpolate1(" ", ctx.newButtonString, " ");
          ɵɵadvance(2);
          ɵɵproperty("options", ctx.themeSignal());
          ɵɵadvance();
          ɵɵproperty("dataSource", ctx.dataSourceClientsPrograms);
          ɵɵadvance();
          ɵɵrepeater(ctx.columnsToDisplay);
          ɵɵadvance(7);
          ɵɵproperty("matHeaderRowDef", ctx.columnsToDisplayWithExpand);
          ɵɵadvance();
          ɵɵproperty("matRowDefColumns", ctx.columnsToDisplayWithExpand);
          ɵɵadvance();
          ɵɵproperty("matRowDefColumns", ɵɵpureFunction0(6, _c015));
        }
      },
      dependencies: [MatDividerModule, MatDivider, MatButtonModule, MatButton, MatIconButton, MatTooltipModule, MatTooltip, MatIconModule, MatIcon, FormsModule, ɵNgNoValidate, NgControlStatusGroup, NgForm, OverlayscrollbarsModule, OverlayScrollbarsComponent, MatTableModule, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatNoDataRow, DatePipe],
      styles: ['.clients-program-list-table[_ngcontent-%COMP%]   .clients-program-list-title[_ngcontent-%COMP%]{display:flex;gap:16px;align-items:center;margin-bottom:18px;margin-top:26px}.clients-program-list-table[_ngcontent-%COMP%]   .clients-program-list-title[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{margin:0}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]{width:1000px;height:calc(100vh - 307px);overflow-y:scroll}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   tr.client-program-detail-row[_ngcontent-%COMP%]{height:0}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   .client-program-element-row[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{border-bottom-width:0}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   .client-program-element-detail[_ngcontent-%COMP%]{overflow:hidden;display:flex}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   .client-program-element-detail[_ngcontent-%COMP%]   .table-client-program-wrapper[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   .client-program-element-detail[_ngcontent-%COMP%]   .table-client-program-wrapper[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]{padding:8px;width:100%}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   .client-program-element-detail[_ngcontent-%COMP%]   .table-client-program-wrapper[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]:last-of-type{border:none}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   .client-program-element-detail[_ngcontent-%COMP%]   .table-client-program-wrapper[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-item-flex[_ngcontent-%COMP%]{display:flex;flex-direction:row;gap:16px}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   .client-program-element-detail[_ngcontent-%COMP%]   .table-client-program-wrapper[_ngcontent-%COMP%]   .list-item[_ngcontent-%COMP%]   .list-item-flex[_ngcontent-%COMP%]   .list-info[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:4px}.clients-program-list-table[_ngcontent-%COMP%]   .clients-table[_ngcontent-%COMP%]   .mat-cell.no-data-cell[_ngcontent-%COMP%]{padding:8px 0 0 8px}.status-chip-wrapper[_ngcontent-%COMP%]   .status-chip[_ngcontent-%COMP%]{text-align:center;padding:4px;border-radius:4px;width:76px;font-weight:700;font-size:12px}.basic-programs-table-placeholder[_ngcontent-%COMP%]{border-radius:16px;padding:16px;min-width:528px;height:calc(100vh - 222px);overflow:hidden;display:flex;flex-direction:column}.basic-programs-table-placeholder[_ngcontent-%COMP%]   .basic-programs-title-placeholder[_ngcontent-%COMP%]{display:flex;margin:14px 0}.basic-programs-table-placeholder[_ngcontent-%COMP%]   .basic-programs-title-placeholder[_ngcontent-%COMP%]   .basic-programs-title-skeleton[_ngcontent-%COMP%]{white-space:nowrap}.basic-programs-table-placeholder[_ngcontent-%COMP%]   .basic-programs-title-placeholder[_ngcontent-%COMP%]   .input-placeholder[_ngcontent-%COMP%]{width:100%;height:48px;margin-left:16px;margin-top:-8px}.basic-programs-table-placeholder[_ngcontent-%COMP%]   .basic-program-skeleton-container[_ngcontent-%COMP%]{margin-top:8px;flex-grow:1}.basic-programs-table-placeholder[_ngcontent-%COMP%]   .basic-programs-table-skeleton[_ngcontent-%COMP%]{height:48px;margin-bottom:2px}.animate-skeleton[_ngcontent-%COMP%]{overflow:hidden;position:relative;border-radius:8px}.animate-skeleton[_ngcontent-%COMP%]:after{position:absolute;inset:0;transform:translate(-100%);animation:_ngcontent-%COMP%_shimmer 2s infinite;content:""}@keyframes _ngcontent-%COMP%_shimmer{to{transform:translate(100%)}}\n/*# sourceMappingURL=client-full-edit-programs.component-T5M2Q3J2.css.map */'],
      data: {
        animation: [trigger("detailExpand", [state("collapsed,void", style({
          height: "0px",
          minHeight: "0"
        })), state("expanded", style({
          height: "*"
        })), transition("expanded <=> collapsed", animate("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))])]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(ClientFullEditProgramsComponent, {
    className: "ClientFullEditProgramsComponent",
    filePath: "libs/ui/src/lib/components/client-full-edit-programs/client-full-edit-programs.component.ts",
    lineNumber: 81
  });
})();

// node_modules/@angular/material/fesm2022/button-toggle.mjs
var _c016 = ["button"];
var _c113 = ["*"];
function MatButtonToggle_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelement(1, "mat-pseudo-checkbox", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.disabled);
  }
}
var MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS = new InjectionToken("MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS", {
  providedIn: "root",
  factory: MAT_BUTTON_TOGGLE_GROUP_DEFAULT_OPTIONS_FACTORY
});
function MAT_BUTTON_TOGGLE_GROUP_DEFAULT_OPTIONS_FACTORY() {
  return {
    hideSingleSelectionIndicator: false,
    hideMultipleSelectionIndicator: false,
    disabledInteractive: false
  };
}
var MAT_BUTTON_TOGGLE_GROUP = new InjectionToken("MatButtonToggleGroup");
var MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatButtonToggleGroup),
  multi: true
};
var MatButtonToggleChange = class {
  source;
  value;
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
};
var MatButtonToggleGroup = class _MatButtonToggleGroup {
  _changeDetector = inject(ChangeDetectorRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _multiple = false;
  _disabled = false;
  _disabledInteractive = false;
  _selectionModel;
  /**
   * Reference to the raw value that the consumer tried to assign. The real
   * value will exclude any values from this one that don't correspond to a
   * toggle. Useful for the cases where the value is assigned before the toggles
   * have been initialized or at the same that they're being swapped out.
   */
  _rawValue;
  /**
   * The method to be called in order to update ngModel.
   * Now `ngModel` binding is not supported in multiple selection mode.
   */
  _controlValueAccessorChangeFn = () => {};
  /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
  _onTouched = () => {};
  /** Child button toggle buttons. */
  _buttonToggles;
  /** The appearance for all the buttons in the group. */
  appearance;
  /** `name` attribute for the underlying `input` element. */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this._markButtonsForCheck();
  }
  _name = inject(_IdGenerator).getId("mat-button-toggle-group-");
  /** Whether the toggle group is vertical. */
  vertical;
  /** Value of the toggle group. */
  get value() {
    const selected = this._selectionModel ? this._selectionModel.selected : [];
    if (this.multiple) {
      return selected.map(toggle => toggle.value);
    }
    return selected[0] ? selected[0].value : void 0;
  }
  set value(newValue) {
    this._setSelectionByValue(newValue);
    this.valueChange.emit(this.value);
  }
  /**
   * Event that emits whenever the value of the group changes.
   * Used to facilitate two-way data binding.
   * @docs-private
   */
  valueChange = new EventEmitter();
  /** Selected button toggles in the group. */
  get selected() {
    const selected = this._selectionModel ? this._selectionModel.selected : [];
    return this.multiple ? selected : selected[0] || null;
  }
  /** Whether multiple button toggles can be selected. */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = value;
    this._markButtonsForCheck();
  }
  /** Whether multiple button toggle group is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._markButtonsForCheck();
  }
  /** Whether buttons in the group should be interactive while they're disabled. */
  get disabledInteractive() {
    return this._disabledInteractive;
  }
  set disabledInteractive(value) {
    this._disabledInteractive = value;
    this._markButtonsForCheck();
  }
  /** The layout direction of the toggle button group. */
  get dir() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /** Event emitted when the group's value changes. */
  change = new EventEmitter();
  /** Whether checkmark indicator for single-selection button toggle groups is hidden. */
  get hideSingleSelectionIndicator() {
    return this._hideSingleSelectionIndicator;
  }
  set hideSingleSelectionIndicator(value) {
    this._hideSingleSelectionIndicator = value;
    this._markButtonsForCheck();
  }
  _hideSingleSelectionIndicator;
  /** Whether checkmark indicator for multiple-selection button toggle groups is hidden. */
  get hideMultipleSelectionIndicator() {
    return this._hideMultipleSelectionIndicator;
  }
  set hideMultipleSelectionIndicator(value) {
    this._hideMultipleSelectionIndicator = value;
    this._markButtonsForCheck();
  }
  _hideMultipleSelectionIndicator;
  constructor() {
    const defaultOptions = inject(MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS, {
      optional: true
    });
    this.appearance = defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : "standard";
    this.hideSingleSelectionIndicator = defaultOptions?.hideSingleSelectionIndicator ?? false;
    this.hideMultipleSelectionIndicator = defaultOptions?.hideMultipleSelectionIndicator ?? false;
  }
  ngOnInit() {
    this._selectionModel = new SelectionModel(this.multiple, void 0, false);
  }
  ngAfterContentInit() {
    this._selectionModel.select(...this._buttonToggles.filter(toggle => toggle.checked));
    if (!this.multiple) {
      this._initializeTabIndex();
    }
  }
  /**
   * Sets the model value. Implemented as part of ControlValueAccessor.
   * @param value Value to be set to the model.
   */
  writeValue(value) {
    this.value = value;
    this._changeDetector.markForCheck();
  }
  // Implemented as part of ControlValueAccessor.
  registerOnChange(fn) {
    this._controlValueAccessorChangeFn = fn;
  }
  // Implemented as part of ControlValueAccessor.
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  // Implemented as part of ControlValueAccessor.
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /** Handle keydown event calling to single-select button toggle. */
  _keydown(event) {
    if (this.multiple || this.disabled) {
      return;
    }
    const target = event.target;
    const buttonId = target.id;
    const index = this._buttonToggles.toArray().findIndex(toggle => {
      return toggle.buttonId === buttonId;
    });
    let nextButton = null;
    switch (event.keyCode) {
      case SPACE:
      case ENTER:
        nextButton = this._buttonToggles.get(index) || null;
        break;
      case UP_ARROW:
        nextButton = this._getNextButton(index, -1);
        break;
      case LEFT_ARROW:
        nextButton = this._getNextButton(index, this.dir === "ltr" ? -1 : 1);
        break;
      case DOWN_ARROW:
        nextButton = this._getNextButton(index, 1);
        break;
      case RIGHT_ARROW:
        nextButton = this._getNextButton(index, this.dir === "ltr" ? 1 : -1);
        break;
      default:
        return;
    }
    if (nextButton) {
      event.preventDefault();
      nextButton._onButtonClick();
      nextButton.focus();
    }
  }
  /** Dispatch change event with current selection and group value. */
  _emitChangeEvent(toggle) {
    const event = new MatButtonToggleChange(toggle, this.value);
    this._rawValue = event.value;
    this._controlValueAccessorChangeFn(event.value);
    this.change.emit(event);
  }
  /**
   * Syncs a button toggle's selected state with the model value.
   * @param toggle Toggle to be synced.
   * @param select Whether the toggle should be selected.
   * @param isUserInput Whether the change was a result of a user interaction.
   * @param deferEvents Whether to defer emitting the change events.
   */
  _syncButtonToggle(toggle, select, isUserInput = false, deferEvents = false) {
    if (!this.multiple && this.selected && !toggle.checked) {
      this.selected.checked = false;
    }
    if (this._selectionModel) {
      if (select) {
        this._selectionModel.select(toggle);
      } else {
        this._selectionModel.deselect(toggle);
      }
    } else {
      deferEvents = true;
    }
    if (deferEvents) {
      Promise.resolve().then(() => this._updateModelValue(toggle, isUserInput));
    } else {
      this._updateModelValue(toggle, isUserInput);
    }
  }
  /** Checks whether a button toggle is selected. */
  _isSelected(toggle) {
    return this._selectionModel && this._selectionModel.isSelected(toggle);
  }
  /** Determines whether a button toggle should be checked on init. */
  _isPrechecked(toggle) {
    if (typeof this._rawValue === "undefined") {
      return false;
    }
    if (this.multiple && Array.isArray(this._rawValue)) {
      return this._rawValue.some(value => toggle.value != null && value === toggle.value);
    }
    return toggle.value === this._rawValue;
  }
  /** Initializes the tabindex attribute using the radio pattern. */
  _initializeTabIndex() {
    this._buttonToggles.forEach(toggle => {
      toggle.tabIndex = -1;
    });
    if (this.selected) {
      this.selected.tabIndex = 0;
    } else {
      for (let i2 = 0; i2 < this._buttonToggles.length; i2++) {
        const toggle = this._buttonToggles.get(i2);
        if (!toggle.disabled) {
          toggle.tabIndex = 0;
          break;
        }
      }
    }
    this._markButtonsForCheck();
  }
  /** Obtain the subsequent toggle to which the focus shifts. */
  _getNextButton(startIndex, offset) {
    const items = this._buttonToggles;
    for (let i2 = 1; i2 <= items.length; i2++) {
      const index = (startIndex + offset * i2 + items.length) % items.length;
      const item = items.get(index);
      if (item && !item.disabled) {
        return item;
      }
    }
    return null;
  }
  /** Updates the selection state of the toggles in the group based on a value. */
  _setSelectionByValue(value) {
    this._rawValue = value;
    if (!this._buttonToggles) {
      return;
    }
    const toggles = this._buttonToggles.toArray();
    if (this.multiple && value) {
      if (!Array.isArray(value) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("Value must be an array in multiple-selection mode.");
      }
      this._clearSelection();
      value.forEach(currentValue => this._selectValue(currentValue, toggles));
    } else {
      this._clearSelection();
      this._selectValue(value, toggles);
    }
    if (!this.multiple && toggles.every(toggle => toggle.tabIndex === -1)) {
      for (const toggle of toggles) {
        if (!toggle.disabled) {
          toggle.tabIndex = 0;
          break;
        }
      }
    }
  }
  /** Clears the selected toggles. */
  _clearSelection() {
    this._selectionModel.clear();
    this._buttonToggles.forEach(toggle => {
      toggle.checked = false;
      if (!this.multiple) {
        toggle.tabIndex = -1;
      }
    });
  }
  /** Selects a value if there's a toggle that corresponds to it. */
  _selectValue(value, toggles) {
    for (const toggle of toggles) {
      if (toggle.value === value) {
        toggle.checked = true;
        this._selectionModel.select(toggle);
        if (!this.multiple) {
          toggle.tabIndex = 0;
        }
        break;
      }
    }
  }
  /** Syncs up the group's value with the model and emits the change event. */
  _updateModelValue(toggle, isUserInput) {
    if (isUserInput) {
      this._emitChangeEvent(toggle);
    }
    this.valueChange.emit(this.value);
  }
  /** Marks all of the child button toggles to be checked. */
  _markButtonsForCheck() {
    this._buttonToggles?.forEach(toggle => toggle._markForCheck());
  }
  static ɵfac = function MatButtonToggleGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatButtonToggleGroup)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatButtonToggleGroup,
    selectors: [["mat-button-toggle-group"]],
    contentQueries: function MatButtonToggleGroup_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatButtonToggle, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._buttonToggles = _t2);
      }
    },
    hostAttrs: [1, "mat-button-toggle-group"],
    hostVars: 6,
    hostBindings: function MatButtonToggleGroup_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function MatButtonToggleGroup_keydown_HostBindingHandler($event) {
          return ctx._keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.multiple ? "group" : "radiogroup")("aria-disabled", ctx.disabled);
        ɵɵclassProp("mat-button-toggle-vertical", ctx.vertical)("mat-button-toggle-group-appearance-standard", ctx.appearance === "standard");
      }
    },
    inputs: {
      appearance: "appearance",
      name: "name",
      vertical: [2, "vertical", "vertical", booleanAttribute],
      value: "value",
      multiple: [2, "multiple", "multiple", booleanAttribute],
      disabled: [2, "disabled", "disabled", booleanAttribute],
      disabledInteractive: [2, "disabledInteractive", "disabledInteractive", booleanAttribute],
      hideSingleSelectionIndicator: [2, "hideSingleSelectionIndicator", "hideSingleSelectionIndicator", booleanAttribute],
      hideMultipleSelectionIndicator: [2, "hideMultipleSelectionIndicator", "hideMultipleSelectionIndicator", booleanAttribute]
    },
    outputs: {
      valueChange: "valueChange",
      change: "change"
    },
    exportAs: ["matButtonToggleGroup"],
    features: [ɵɵProvidersFeature([MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, {
      provide: MAT_BUTTON_TOGGLE_GROUP,
      useExisting: _MatButtonToggleGroup
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatButtonToggleGroup, [{
    type: Directive,
    args: [{
      selector: "mat-button-toggle-group",
      providers: [MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, {
        provide: MAT_BUTTON_TOGGLE_GROUP,
        useExisting: MatButtonToggleGroup
      }],
      host: {
        "class": "mat-button-toggle-group",
        "(keydown)": "_keydown($event)",
        "[attr.role]": "multiple ? 'group' : 'radiogroup'",
        "[attr.aria-disabled]": "disabled",
        "[class.mat-button-toggle-vertical]": "vertical",
        "[class.mat-button-toggle-group-appearance-standard]": 'appearance === "standard"'
      },
      exportAs: "matButtonToggleGroup"
    }]
  }], () => [], {
    _buttonToggles: [{
      type: ContentChildren,
      args: [forwardRef(() => MatButtonToggle), {
        // Note that this would technically pick up toggles
        // from nested groups, but that's not a case that we support.
        descendants: true
      }]
    }],
    appearance: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    vertical: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    value: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    multiple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabledInteractive: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    change: [{
      type: Output
    }],
    hideSingleSelectionIndicator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    hideMultipleSelectionIndicator: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var MatButtonToggle = class _MatButtonToggle {
  _changeDetectorRef = inject(ChangeDetectorRef);
  _elementRef = inject(ElementRef);
  _focusMonitor = inject(FocusMonitor);
  _idGenerator = inject(_IdGenerator);
  _animationMode = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _checked = false;
  /**
   * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will
   * take precedence so this may be omitted.
   */
  ariaLabel;
  /**
   * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
   */
  ariaLabelledby = null;
  /** Underlying native `button` element. */
  _buttonElement;
  /** The parent button toggle group (exclusive selection). Optional. */
  buttonToggleGroup;
  /** Unique ID for the underlying `button` element. */
  get buttonId() {
    return `${this.id}-button`;
  }
  /** The unique ID for this button toggle. */
  id;
  /** HTML's 'name' attribute used to group radios for unique selection. */
  name;
  /** MatButtonToggleGroup reads this to assign its own value. */
  value;
  /** Tabindex of the toggle. */
  get tabIndex() {
    return this._tabIndex;
  }
  set tabIndex(value) {
    if (value !== this._tabIndex) {
      this._tabIndex = value;
      this._markForCheck();
    }
  }
  _tabIndex;
  /** Whether ripples are disabled on the button toggle. */
  disableRipple;
  /** The appearance style of the button. */
  get appearance() {
    return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance;
  }
  set appearance(value) {
    this._appearance = value;
  }
  _appearance;
  /** Whether the button is checked. */
  get checked() {
    return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked;
  }
  set checked(value) {
    if (value !== this._checked) {
      this._checked = value;
      if (this.buttonToggleGroup) {
        this.buttonToggleGroup._syncButtonToggle(this, this._checked);
      }
      this._changeDetectorRef.markForCheck();
    }
  }
  /** Whether the button is disabled. */
  get disabled() {
    return this._disabled || this.buttonToggleGroup && this.buttonToggleGroup.disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  _disabled = false;
  /** Whether the button should remain interactive when it is disabled. */
  get disabledInteractive() {
    return this._disabledInteractive || this.buttonToggleGroup !== null && this.buttonToggleGroup.disabledInteractive;
  }
  set disabledInteractive(value) {
    this._disabledInteractive = value;
  }
  _disabledInteractive;
  /** Event emitted when the group value changes. */
  change = new EventEmitter();
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
    const toggleGroup = inject(MAT_BUTTON_TOGGLE_GROUP, {
      optional: true
    });
    const defaultTabIndex = inject(new HostAttributeToken("tabindex"), {
      optional: true
    }) || "";
    const defaultOptions = inject(MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS, {
      optional: true
    });
    this._tabIndex = parseInt(defaultTabIndex) || 0;
    this.buttonToggleGroup = toggleGroup;
    this.appearance = defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : "standard";
    this.disabledInteractive = defaultOptions?.disabledInteractive ?? false;
  }
  ngOnInit() {
    const group = this.buttonToggleGroup;
    this.id = this.id || this._idGenerator.getId("mat-button-toggle-");
    if (group) {
      if (group._isPrechecked(this)) {
        this.checked = true;
      } else if (group._isSelected(this) !== this._checked) {
        group._syncButtonToggle(this, this._checked);
      }
    }
  }
  ngAfterViewInit() {
    if (this._animationMode !== "NoopAnimations") {
      this._elementRef.nativeElement.classList.add("mat-button-toggle-animations-enabled");
    }
    this._focusMonitor.monitor(this._elementRef, true);
  }
  ngOnDestroy() {
    const group = this.buttonToggleGroup;
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (group && group._isSelected(this)) {
      group._syncButtonToggle(this, false, false, true);
    }
  }
  /** Focuses the button. */
  focus(options) {
    this._buttonElement.nativeElement.focus(options);
  }
  /** Checks the button toggle due to an interaction with the underlying native button. */
  _onButtonClick() {
    if (this.disabled) {
      return;
    }
    const newChecked = this.isSingleSelector() ? true : !this._checked;
    if (newChecked !== this._checked) {
      this._checked = newChecked;
      if (this.buttonToggleGroup) {
        this.buttonToggleGroup._syncButtonToggle(this, this._checked, true);
        this.buttonToggleGroup._onTouched();
      }
    }
    if (this.isSingleSelector()) {
      const focusable = this.buttonToggleGroup._buttonToggles.find(toggle => {
        return toggle.tabIndex === 0;
      });
      if (focusable) {
        focusable.tabIndex = -1;
      }
      this.tabIndex = 0;
    }
    this.change.emit(new MatButtonToggleChange(this, this.value));
  }
  /**
   * Marks the button toggle as needing checking for change detection.
   * This method is exposed because the parent button toggle group will directly
   * update bound properties of the radio button.
   */
  _markForCheck() {
    this._changeDetectorRef.markForCheck();
  }
  /** Gets the name that should be assigned to the inner DOM node. */
  _getButtonName() {
    if (this.isSingleSelector()) {
      return this.buttonToggleGroup.name;
    }
    return this.name || null;
  }
  /** Whether the toggle is in single selection mode. */
  isSingleSelector() {
    return this.buttonToggleGroup && !this.buttonToggleGroup.multiple;
  }
  static ɵfac = function MatButtonToggle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatButtonToggle)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatButtonToggle,
    selectors: [["mat-button-toggle"]],
    viewQuery: function MatButtonToggle_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c016, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._buttonElement = _t2.first);
      }
    },
    hostAttrs: ["role", "presentation", 1, "mat-button-toggle"],
    hostVars: 14,
    hostBindings: function MatButtonToggle_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function MatButtonToggle_focus_HostBindingHandler() {
          return ctx.focus();
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-label", null)("aria-labelledby", null)("id", ctx.id)("name", null);
        ɵɵclassProp("mat-button-toggle-standalone", !ctx.buttonToggleGroup)("mat-button-toggle-checked", ctx.checked)("mat-button-toggle-disabled", ctx.disabled)("mat-button-toggle-disabled-interactive", ctx.disabledInteractive)("mat-button-toggle-appearance-standard", ctx.appearance === "standard");
      }
    },
    inputs: {
      ariaLabel: [0, "aria-label", "ariaLabel"],
      ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
      id: "id",
      name: "name",
      value: "value",
      tabIndex: "tabIndex",
      disableRipple: [2, "disableRipple", "disableRipple", booleanAttribute],
      appearance: "appearance",
      checked: [2, "checked", "checked", booleanAttribute],
      disabled: [2, "disabled", "disabled", booleanAttribute],
      disabledInteractive: [2, "disabledInteractive", "disabledInteractive", booleanAttribute]
    },
    outputs: {
      change: "change"
    },
    exportAs: ["matButtonToggle"],
    ngContentSelectors: _c113,
    decls: 7,
    vars: 13,
    consts: [["button", ""], ["type", "button", 1, "mat-button-toggle-button", "mat-focus-indicator", 3, "click", "id", "disabled"], [1, "mat-button-toggle-checkbox-wrapper"], [1, "mat-button-toggle-label-content"], [1, "mat-button-toggle-focus-overlay"], ["matRipple", "", 1, "mat-button-toggle-ripple", 3, "matRippleTrigger", "matRippleDisabled"], ["state", "checked", "aria-hidden", "true", "appearance", "minimal", 3, "disabled"]],
    template: function MatButtonToggle_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵelementStart(0, "button", 1, 0);
        ɵɵlistener("click", function MatButtonToggle_Template_button_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx._onButtonClick());
        });
        ɵɵtemplate(2, MatButtonToggle_Conditional_2_Template, 2, 1, "div", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd()();
        ɵɵelement(5, "span", 4)(6, "span", 5);
      }
      if (rf & 2) {
        const button_r3 = ɵɵreference(1);
        ɵɵproperty("id", ctx.buttonId)("disabled", ctx.disabled && !ctx.disabledInteractive || null);
        ɵɵattribute("role", ctx.isSingleSelector() ? "radio" : "button")("tabindex", ctx.disabled && !ctx.disabledInteractive ? -1 : ctx.tabIndex)("aria-pressed", !ctx.isSingleSelector() ? ctx.checked : null)("aria-checked", ctx.isSingleSelector() ? ctx.checked : null)("name", ctx._getButtonName())("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-disabled", ctx.disabled && ctx.disabledInteractive ? "true" : null);
        ɵɵadvance(2);
        ɵɵconditional(ctx.buttonToggleGroup && (!ctx.buttonToggleGroup.multiple && !ctx.buttonToggleGroup.hideSingleSelectionIndicator || ctx.buttonToggleGroup.multiple && !ctx.buttonToggleGroup.hideMultipleSelectionIndicator) ? 2 : -1);
        ɵɵadvance(4);
        ɵɵproperty("matRippleTrigger", button_r3)("matRippleDisabled", ctx.disableRipple || ctx.disabled);
      }
    },
    dependencies: [MatRipple, MatPseudoCheckbox],
    styles: [".mat-button-toggle-standalone,.mat-button-toggle-group{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);transform:translateZ(0);border-radius:var(--mat-legacy-button-toggle-shape)}.mat-button-toggle-standalone:not([class*=mat-elevation-z]),.mat-button-toggle-group:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}@media(forced-colors: active){.mat-button-toggle-standalone,.mat-button-toggle-group{outline:solid 1px}}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{border-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border:solid 1px var(--mat-standard-button-toggle-divider-color, var(--mat-sys-outline))}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard .mat-pseudo-checkbox,.mat-button-toggle-group-appearance-standard .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-selected-checkmark-color: var(--mat-standard-button-toggle-selected-state-text-color, var(--mat-sys-on-secondary-container))}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard:not([class*=mat-elevation-z]),.mat-button-toggle-group-appearance-standard:not([class*=mat-elevation-z]){box-shadow:none}@media(forced-colors: active){.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{outline:0}}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative;color:var(--mat-legacy-button-toggle-text-color);font-family:var(--mat-legacy-button-toggle-label-text-font);font-size:var(--mat-legacy-button-toggle-label-text-size);line-height:var(--mat-legacy-button-toggle-label-text-line-height);font-weight:var(--mat-legacy-button-toggle-label-text-weight);letter-spacing:var(--mat-legacy-button-toggle-label-text-tracking);--mat-minimal-pseudo-checkbox-selected-checkmark-color: var(--mat-legacy-button-toggle-selected-state-text-color)}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:var(--mat-legacy-button-toggle-focus-state-layer-opacity)}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle-checkbox-wrapper{display:inline-block;justify-content:flex-start;align-items:center;width:0;height:18px;line-height:18px;overflow:hidden;box-sizing:border-box;position:absolute;top:50%;left:16px;transform:translate3d(0, -50%, 0)}[dir=rtl] .mat-button-toggle-checkbox-wrapper{left:auto;right:16px}.mat-button-toggle-appearance-standard .mat-button-toggle-checkbox-wrapper{left:12px}[dir=rtl] .mat-button-toggle-appearance-standard .mat-button-toggle-checkbox-wrapper{left:auto;right:12px}.mat-button-toggle-checked .mat-button-toggle-checkbox-wrapper{width:18px}.mat-button-toggle-animations-enabled .mat-button-toggle-checkbox-wrapper{transition:width 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-button-toggle-vertical .mat-button-toggle-checkbox-wrapper{transition:none}.mat-button-toggle-checked{color:var(--mat-legacy-button-toggle-selected-state-text-color);background-color:var(--mat-legacy-button-toggle-selected-state-background-color)}.mat-button-toggle-disabled{pointer-events:none;color:var(--mat-legacy-button-toggle-disabled-state-text-color);background-color:var(--mat-legacy-button-toggle-disabled-state-background-color);--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color: var(--mat-legacy-button-toggle-disabled-state-text-color)}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:var(--mat-legacy-button-toggle-disabled-selected-state-background-color)}.mat-button-toggle-disabled-interactive{pointer-events:auto}.mat-button-toggle-appearance-standard{color:var(--mat-standard-button-toggle-text-color, var(--mat-sys-on-surface));background-color:var(--mat-standard-button-toggle-background-color, transparent);font-family:var(--mat-standard-button-toggle-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-standard-button-toggle-label-text-size, var(--mat-sys-label-large-size));line-height:var(--mat-standard-button-toggle-label-text-line-height, var(--mat-sys-label-large-line-height));font-weight:var(--mat-standard-button-toggle-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mat-standard-button-toggle-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:solid 1px var(--mat-standard-button-toggle-divider-color, var(--mat-sys-outline))}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:solid 1px var(--mat-standard-button-toggle-divider-color, var(--mat-sys-outline))}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:none;border-top:solid 1px var(--mat-standard-button-toggle-divider-color, var(--mat-sys-outline))}.mat-button-toggle-appearance-standard.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-selected-state-text-color, var(--mat-sys-on-secondary-container));background-color:var(--mat-standard-button-toggle-selected-state-background-color, var(--mat-sys-secondary-container))}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled{color:var(--mat-standard-button-toggle-disabled-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-standard-button-toggle-disabled-state-background-color, transparent)}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color: var(--mat-standard-button-toggle-disabled-selected-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-disabled-selected-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-standard-button-toggle-disabled-selected-state-background-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:var(--mat-standard-button-toggle-state-layer-color, var(--mat-sys-on-surface))}.mat-button-toggle-appearance-standard:hover .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-button-toggle-appearance-standard.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}@media(hover: none){.mat-button-toggle-appearance-standard:hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;user-select:none;display:inline-block;padding:0 16px;line-height:var(--mat-legacy-button-toggle-height);position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{padding:0 12px;line-height:var(--mat-standard-button-toggle-height, 40px)}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;pointer-events:none;opacity:0;background-color:var(--mat-legacy-button-toggle-state-layer-color)}@media(forced-colors: active){.mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 500px;opacity:.5;height:0}.mat-button-toggle-checked:hover .mat-button-toggle-focus-overlay{opacity:.6}.mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 500px}}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:none;color:inherit;padding:0;margin:0;font:inherit;outline:none;width:100%;cursor:pointer}.mat-button-toggle-animations-enabled .mat-button-toggle-button{transition:padding 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-button-toggle-vertical .mat-button-toggle-button{transition:none}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}.mat-button-toggle-checked .mat-button-toggle-button:has(.mat-button-toggle-checkbox-wrapper){padding-left:30px}[dir=rtl] .mat-button-toggle-checked .mat-button-toggle-button:has(.mat-button-toggle-checkbox-wrapper){padding-left:0;padding-right:30px}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{--mat-focus-indicator-border-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}.mat-button-toggle-group-appearance-standard:not(.mat-button-toggle-vertical) .mat-button-toggle:last-of-type .mat-button-toggle-button::before{border-top-right-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border-bottom-right-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}.mat-button-toggle-group-appearance-standard:not(.mat-button-toggle-vertical) .mat-button-toggle:first-of-type .mat-button-toggle-button::before{border-top-left-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border-bottom-left-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle:last-of-type .mat-button-toggle-button::before{border-bottom-right-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border-bottom-left-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle:first-of-type .mat-button-toggle-button::before{border-top-right-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border-top-left-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatButtonToggle, [{
    type: Component,
    args: [{
      selector: "mat-button-toggle",
      encapsulation: ViewEncapsulation.None,
      exportAs: "matButtonToggle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "[class.mat-button-toggle-standalone]": "!buttonToggleGroup",
        "[class.mat-button-toggle-checked]": "checked",
        "[class.mat-button-toggle-disabled]": "disabled",
        "[class.mat-button-toggle-disabled-interactive]": "disabledInteractive",
        "[class.mat-button-toggle-appearance-standard]": 'appearance === "standard"',
        "class": "mat-button-toggle",
        "[attr.aria-label]": "null",
        "[attr.aria-labelledby]": "null",
        "[attr.id]": "id",
        "[attr.name]": "null",
        "(focus)": "focus()",
        "role": "presentation"
      },
      imports: [MatRipple, MatPseudoCheckbox],
      template: `<button #button class="mat-button-toggle-button mat-focus-indicator"
        type="button"
        [id]="buttonId"
        [attr.role]="isSingleSelector() ? 'radio' : 'button'"
        [attr.tabindex]="disabled && !disabledInteractive ? -1 : tabIndex"
        [attr.aria-pressed]="!isSingleSelector() ? checked : null"
        [attr.aria-checked]="isSingleSelector() ? checked : null"
        [disabled]="(disabled && !disabledInteractive) || null"
        [attr.name]="_getButtonName()"
        [attr.aria-label]="ariaLabel"
        [attr.aria-labelledby]="ariaLabelledby"
        [attr.aria-disabled]="disabled && disabledInteractive ? 'true' : null"
        (click)="_onButtonClick()">
  @if (buttonToggleGroup && (
    !buttonToggleGroup.multiple && !buttonToggleGroup.hideSingleSelectionIndicator ||
    buttonToggleGroup.multiple && !buttonToggleGroup.hideMultipleSelectionIndicator)
  ) {
    <div class="mat-button-toggle-checkbox-wrapper">
      <mat-pseudo-checkbox
        [disabled]="disabled"
        state="checked"
        aria-hidden="true"
        appearance="minimal"/>
    </div>
  }

  <span class="mat-button-toggle-label-content">
    <ng-content></ng-content>
  </span>
</button>

<span class="mat-button-toggle-focus-overlay"></span>
<span class="mat-button-toggle-ripple" matRipple
     [matRippleTrigger]="button"
     [matRippleDisabled]="this.disableRipple || this.disabled">
</span>
`,
      styles: [".mat-button-toggle-standalone,.mat-button-toggle-group{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);transform:translateZ(0);border-radius:var(--mat-legacy-button-toggle-shape)}.mat-button-toggle-standalone:not([class*=mat-elevation-z]),.mat-button-toggle-group:not([class*=mat-elevation-z]){box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}@media(forced-colors: active){.mat-button-toggle-standalone,.mat-button-toggle-group{outline:solid 1px}}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{border-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border:solid 1px var(--mat-standard-button-toggle-divider-color, var(--mat-sys-outline))}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard .mat-pseudo-checkbox,.mat-button-toggle-group-appearance-standard .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-selected-checkmark-color: var(--mat-standard-button-toggle-selected-state-text-color, var(--mat-sys-on-secondary-container))}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard:not([class*=mat-elevation-z]),.mat-button-toggle-group-appearance-standard:not([class*=mat-elevation-z]){box-shadow:none}@media(forced-colors: active){.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{outline:0}}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative;color:var(--mat-legacy-button-toggle-text-color);font-family:var(--mat-legacy-button-toggle-label-text-font);font-size:var(--mat-legacy-button-toggle-label-text-size);line-height:var(--mat-legacy-button-toggle-label-text-line-height);font-weight:var(--mat-legacy-button-toggle-label-text-weight);letter-spacing:var(--mat-legacy-button-toggle-label-text-tracking);--mat-minimal-pseudo-checkbox-selected-checkmark-color: var(--mat-legacy-button-toggle-selected-state-text-color)}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:var(--mat-legacy-button-toggle-focus-state-layer-opacity)}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle-checkbox-wrapper{display:inline-block;justify-content:flex-start;align-items:center;width:0;height:18px;line-height:18px;overflow:hidden;box-sizing:border-box;position:absolute;top:50%;left:16px;transform:translate3d(0, -50%, 0)}[dir=rtl] .mat-button-toggle-checkbox-wrapper{left:auto;right:16px}.mat-button-toggle-appearance-standard .mat-button-toggle-checkbox-wrapper{left:12px}[dir=rtl] .mat-button-toggle-appearance-standard .mat-button-toggle-checkbox-wrapper{left:auto;right:12px}.mat-button-toggle-checked .mat-button-toggle-checkbox-wrapper{width:18px}.mat-button-toggle-animations-enabled .mat-button-toggle-checkbox-wrapper{transition:width 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-button-toggle-vertical .mat-button-toggle-checkbox-wrapper{transition:none}.mat-button-toggle-checked{color:var(--mat-legacy-button-toggle-selected-state-text-color);background-color:var(--mat-legacy-button-toggle-selected-state-background-color)}.mat-button-toggle-disabled{pointer-events:none;color:var(--mat-legacy-button-toggle-disabled-state-text-color);background-color:var(--mat-legacy-button-toggle-disabled-state-background-color);--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color: var(--mat-legacy-button-toggle-disabled-state-text-color)}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:var(--mat-legacy-button-toggle-disabled-selected-state-background-color)}.mat-button-toggle-disabled-interactive{pointer-events:auto}.mat-button-toggle-appearance-standard{color:var(--mat-standard-button-toggle-text-color, var(--mat-sys-on-surface));background-color:var(--mat-standard-button-toggle-background-color, transparent);font-family:var(--mat-standard-button-toggle-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-standard-button-toggle-label-text-size, var(--mat-sys-label-large-size));line-height:var(--mat-standard-button-toggle-label-text-line-height, var(--mat-sys-label-large-line-height));font-weight:var(--mat-standard-button-toggle-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mat-standard-button-toggle-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:solid 1px var(--mat-standard-button-toggle-divider-color, var(--mat-sys-outline))}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:solid 1px var(--mat-standard-button-toggle-divider-color, var(--mat-sys-outline))}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle-appearance-standard+.mat-button-toggle-appearance-standard{border-left:none;border-right:none;border-top:solid 1px var(--mat-standard-button-toggle-divider-color, var(--mat-sys-outline))}.mat-button-toggle-appearance-standard.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-selected-state-text-color, var(--mat-sys-on-secondary-container));background-color:var(--mat-standard-button-toggle-selected-state-background-color, var(--mat-sys-secondary-container))}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled{color:var(--mat-standard-button-toggle-disabled-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-standard-button-toggle-disabled-state-background-color, transparent)}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color: var(--mat-standard-button-toggle-disabled-selected-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-button-toggle-appearance-standard.mat-button-toggle-disabled.mat-button-toggle-checked{color:var(--mat-standard-button-toggle-disabled-selected-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-standard-button-toggle-disabled-selected-state-background-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:var(--mat-standard-button-toggle-state-layer-color, var(--mat-sys-on-surface))}.mat-button-toggle-appearance-standard:hover .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-button-toggle-appearance-standard.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:var(--mat-standard-button-toggle-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}@media(hover: none){.mat-button-toggle-appearance-standard:hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;user-select:none;display:inline-block;padding:0 16px;line-height:var(--mat-legacy-button-toggle-height);position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{padding:0 12px;line-height:var(--mat-standard-button-toggle-height, 40px)}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;pointer-events:none;opacity:0;background-color:var(--mat-legacy-button-toggle-state-layer-color)}@media(forced-colors: active){.mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 500px;opacity:.5;height:0}.mat-button-toggle-checked:hover .mat-button-toggle-focus-overlay{opacity:.6}.mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 500px}}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:none;color:inherit;padding:0;margin:0;font:inherit;outline:none;width:100%;cursor:pointer}.mat-button-toggle-animations-enabled .mat-button-toggle-button{transition:padding 150ms 45ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-button-toggle-vertical .mat-button-toggle-button{transition:none}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}.mat-button-toggle-checked .mat-button-toggle-button:has(.mat-button-toggle-checkbox-wrapper){padding-left:30px}[dir=rtl] .mat-button-toggle-checked .mat-button-toggle-button:has(.mat-button-toggle-checkbox-wrapper){padding-left:0;padding-right:30px}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{--mat-focus-indicator-border-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}.mat-button-toggle-group-appearance-standard:not(.mat-button-toggle-vertical) .mat-button-toggle:last-of-type .mat-button-toggle-button::before{border-top-right-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border-bottom-right-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}.mat-button-toggle-group-appearance-standard:not(.mat-button-toggle-vertical) .mat-button-toggle:first-of-type .mat-button-toggle-button::before{border-top-left-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border-bottom-left-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle:last-of-type .mat-button-toggle-button::before{border-bottom-right-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border-bottom-left-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle:first-of-type .mat-button-toggle-button::before{border-top-right-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full));border-top-left-radius:var(--mat-standard-button-toggle-shape, var(--mat-sys-corner-full))}"]
    }]
  }], () => [], {
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    _buttonElement: [{
      type: ViewChild,
      args: ["button"]
    }],
    id: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    appearance: [{
      type: Input
    }],
    checked: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabledInteractive: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    change: [{
      type: Output
    }]
  });
})();
var MatButtonToggleModule = class _MatButtonToggleModule {
  static ɵfac = function MatButtonToggleModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatButtonToggleModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatButtonToggleModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [MatCommonModule, MatRippleModule, MatButtonToggle, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatButtonToggleModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, MatRippleModule, MatButtonToggleGroup, MatButtonToggle],
      exports: [MatCommonModule, MatButtonToggleGroup, MatButtonToggle]
    }]
  }], null, null);
})();

// libs/ui/src/lib/components/programs-table/programs-table.component.ts
var _c017 = () => [5, 10, 25, 100];
function ProgramsTableComponent_th_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 33);
    ɵɵi18n(1, 6);
    ɵɵelementEnd();
  }
}
function ProgramsTableComponent_td_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 34);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(row_r2.name);
  }
}
function ProgramsTableComponent_th_23_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 35);
    ɵɵi18n(1, 7);
    ɵɵelementEnd();
  }
}
function ProgramsTableComponent_td_24_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 36);
    ɵɵelement(1, "img", 38);
    ɵɵelementEnd();
  }
}
function ProgramsTableComponent_td_24_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 37);
    ɵɵelement(1, "img", 39);
    ɵɵelementEnd();
  }
}
function ProgramsTableComponent_td_24_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵi18n(1, 8);
    ɵɵelementEnd();
    ɵɵtemplate(2, ProgramsTableComponent_td_24_Conditional_1_Conditional_2_Template, 2, 0, "span", 36)(3, ProgramsTableComponent_td_24_Conditional_1_Conditional_3_Template, 2, 0, "span", 37);
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵconditional(row_r3.isAdminProgram ? 2 : 3);
  }
}
function ProgramsTableComponent_td_24_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(row_r3.clientName);
  }
}
function ProgramsTableComponent_td_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 34);
    ɵɵtemplate(1, ProgramsTableComponent_td_24_Conditional_1_Template, 4, 1)(2, ProgramsTableComponent_td_24_Conditional_2_Template, 2, 1, "span");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵconditional(row_r3.isTemplate ? 1 : 2);
  }
}
function ProgramsTableComponent_th_26_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 35);
    ɵɵi18n(1, 9);
    ɵɵelementEnd();
  }
}
function ProgramsTableComponent_td_27_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 34);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r4 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", row_r4.selectedExercises.length, " ");
  }
}
function ProgramsTableComponent_th_29_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 35);
  }
}
function ProgramsTableComponent_td_30_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 44);
    ɵɵlistener("click", function ProgramsTableComponent_td_30_Conditional_2_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const row_r6 = ɵɵnextContext().$implicit;
      const ctx_r6 = ɵɵnextContext();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r6.reuseEditProgram(row_r6.position, row_r6.id));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "person_add");
    ɵɵelementEnd()();
  }
}
function ProgramsTableComponent_td_30_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 46);
    ɵɵlistener("click", function ProgramsTableComponent_td_30_Conditional_3_Conditional_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r8);
      const row_r6 = ɵɵnextContext(2).$implicit;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.openEditProgram(row_r6.id));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "edit");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const row_r6 = ɵɵnextContext(2).$implicit;
    const ctx_r6 = ɵɵnextContext();
    ɵɵproperty("disabled", row_r6.isAdminProgram && !ctx_r6.isAdmin);
  }
}
function ProgramsTableComponent_td_30_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ProgramsTableComponent_td_30_Conditional_3_Conditional_0_Template, 3, 1, "button", 45);
  }
  if (rf & 2) {
    const row_r6 = ɵɵnextContext().$implicit;
    const ctx_r6 = ɵɵnextContext();
    ɵɵconditional(!(row_r6.isAdminProgram && !ctx_r6.isAdmin) ? 0 : -1);
  }
}
function ProgramsTableComponent_td_30_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 47);
    ɵɵlistener("click", function ProgramsTableComponent_td_30_Conditional_4_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const row_r6 = ɵɵnextContext().$implicit;
      const ctx_r6 = ɵɵnextContext();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r6.reuseEditProgram(row_r6.position, row_r6.id));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "person_add");
    ɵɵelementEnd()();
  }
}
function ProgramsTableComponent_td_30_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 48);
    ɵɵlistener("click", function ProgramsTableComponent_td_30_Conditional_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r10);
      const row_r6 = ɵɵnextContext().$implicit;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.openDeleteConfirmationDialog(row_r6.id, ctx_r6.listOption));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "delete_outline");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const row_r6 = ɵɵnextContext().$implicit;
    const ctx_r6 = ɵɵnextContext();
    ɵɵproperty("disabled", row_r6.isAdminProgram && !ctx_r6.isAdmin);
  }
}
function ProgramsTableComponent_td_30_Conditional_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 51);
    ɵɵlistener("click", function ProgramsTableComponent_td_30_Conditional_6_Conditional_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r11);
      const row_r6 = ɵɵnextContext(2).$implicit;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.removeFromFavorites(row_r6));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "star");
    ɵɵelementEnd()();
  }
}
function ProgramsTableComponent_td_30_Conditional_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 52);
    ɵɵlistener("click", function ProgramsTableComponent_td_30_Conditional_6_Conditional_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r12);
      const row_r6 = ɵɵnextContext(2).$implicit;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.addToFavorites(row_r6));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "star_border");
    ɵɵelementEnd()();
  }
}
function ProgramsTableComponent_td_30_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ProgramsTableComponent_td_30_Conditional_6_Conditional_0_Template, 3, 0, "button", 49)(1, ProgramsTableComponent_td_30_Conditional_6_Conditional_1_Template, 3, 0, "button", 50);
  }
  if (rf & 2) {
    const row_r6 = ɵɵnextContext().$implicit;
    ɵɵconditional(row_r6.isFavorite ? 0 : 1);
  }
}
function ProgramsTableComponent_td_30_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 34)(1, "div", 40);
    ɵɵtemplate(2, ProgramsTableComponent_td_30_Conditional_2_Template, 3, 0, "button", 41)(3, ProgramsTableComponent_td_30_Conditional_3_Template, 1, 1)(4, ProgramsTableComponent_td_30_Conditional_4_Template, 3, 0, "button", 42)(5, ProgramsTableComponent_td_30_Conditional_5_Template, 3, 1, "button", 43)(6, ProgramsTableComponent_td_30_Conditional_6_Template, 2, 1);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const row_r6 = ctx.$implicit;
    const ctx_r6 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵconditional(row_r6.clientName ? 2 : 3);
    ɵɵadvance(2);
    ɵɵconditional(!row_r6.clientName ? 4 : -1);
    ɵɵadvance();
    ɵɵconditional(!(row_r6.isAdminProgram && !ctx_r6.isAdmin) ? 5 : -1);
    ɵɵadvance();
    ɵɵconditional(row_r6.isTemplate ? 6 : -1);
  }
}
function ProgramsTableComponent_tr_31_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 53);
  }
}
function ProgramsTableComponent_tr_32_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 54);
  }
}
function ProgramsTableComponent_tr_33_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 55)(1, "td", 56);
    ɵɵi18n(2, 10);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const input_r13 = ɵɵreference(5);
    ɵɵadvance(2);
    ɵɵi18nExp(input_r13.value);
    ɵɵi18nApply(2);
  }
}
var ProgramsTableComponent = class _ProgramsTableComponent {
  constructor() {
    this.displayedColumns = ["name", "numberOfExercises", "type", "options"];
    this.isAdmin = false;
    this.isAdminProgram = false;
    this.dataSource = new MatTableDataSource();
    this.listOption = "all";
    this.mainProgramsList = false;
    this.getProgramsEvent = output();
    this.reuseEditProgramEvent = output();
    this.openEditProgramEvent = output();
    this.openDeleteConfirmationDialogEvent = output();
    this.favoriteProgram = output();
    this.removeFavoriteProgram = output();
    this.themeManager = inject(ThemeManagerService);
    this.themeSignal = this.themeManager.themeSignal;
  }
  // @Output() viewProgramEvent: EventEmitter<any> = new EventEmitter();
  // @Output() addProgramToClientEvent: EventEmitter<any> = new EventEmitter();
  getPrograms(listOption) {
    console.log(this.dataSource.data);
    this.getProgramsEvent.emit(listOption);
    console.log(this.dataSource.data);
  }
  reuseEditProgram(programPosition, programId) {
    this.reuseEditProgramEvent.emit({
      programPosition,
      programId
    });
  }
  openEditProgram(programId) {
    this.openEditProgramEvent.emit(programId);
  }
  openDeleteConfirmationDialog(itemId, listOption) {
    this.openDeleteConfirmationDialogEvent.emit({
      itemId,
      listOption
    });
  }
  // viewProgram(programId: string) {
  //   this.viewProgramEvent.emit(programId);
  //   console.log('this is open view program', programId);
  // }
  // addProgramToClient(programId: string) {
  //   this.addProgramToClientEvent.emit(programId);
  // }
  addToFavorites(program) {
    program.isFavorite = true;
    this.favoriteProgram.emit(program);
    console.log(program);
  }
  removeFromFavorites(program) {
    program.isFavorite = false;
    this.removeFavoriteProgram.emit(program);
    console.log(program);
  }
  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }
  static {
    this.ɵfac = function ProgramsTableComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ProgramsTableComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _ProgramsTableComponent,
      selectors: [["ui-programs-table"]],
      viewQuery: function ProgramsTableComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(MatSort, 5);
          ɵɵviewQuery(MatPaginator, 5);
        }
        if (rf & 2) {
          let _t2;
          ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.sort = _t2.first);
          ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.paginator = _t2.first);
        }
      },
      inputs: {
        isAdmin: "isAdmin",
        isAdminProgram: "isAdminProgram",
        dataSource: "dataSource",
        listOption: "listOption",
        mainProgramsList: "mainProgramsList"
      },
      outputs: {
        getProgramsEvent: "getProgramsEvent",
        reuseEditProgramEvent: "reuseEditProgramEvent",
        openEditProgramEvent: "openEditProgramEvent",
        openDeleteConfirmationDialogEvent: "openDeleteConfirmationDialogEvent",
        favoriteProgram: "favoriteProgram",
        removeFavoriteProgram: "removeFavoriteProgram"
      },
      decls: 35,
      vars: 7,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_inputPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_0 = goog.getMsg("E.g. Seated back stretch");
          i18n_0 = MSG_EXTERNAL_ProgramsList_inputPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_0;
        } else {
          i18n_0 = "z.B. R\xFCckendehnung im Sitzen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_listOptionAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_1 = goog.getMsg("List Option");
          i18n_1 = MSG_EXTERNAL_ProgramsList_listOptionAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_1;
        } else {
          i18n_1 = "Listenoption";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_selectPageOfPrograms$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_2 = goog.getMsg("Select page of programs");
          i18n_2 = MSG_EXTERNAL_ProgramsList_selectPageOfPrograms$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_2;
        } else {
          i18n_2 = "Seite mit Programmen ausw\xE4hlen";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_inputFilterLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_3 = goog.getMsg("Filter");
          i18n_3 = MSG_EXTERNAL_ProgramsList_inputFilterLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_3;
        } else {
          i18n_3 = "Filter";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_listOptionAll$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_4 = goog.getMsg("All");
          i18n_4 = MSG_EXTERNAL_ProgramsList_listOptionAll$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_4;
        } else {
          i18n_4 = "Alle";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_listOptionTemplate$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_5 = goog.getMsg("Template");
          i18n_5 = MSG_EXTERNAL_ProgramsList_listOptionTemplate$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_5;
        } else {
          i18n_5 = "Vorlage";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_listOptionClient$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_6 = goog.getMsg("Client");
          i18n_6 = MSG_EXTERNAL_ProgramsList_listOptionClient$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_6;
        } else {
          i18n_6 = "Patient";
        }
        let i18n_7;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_listOptionFavorite$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_7 = goog.getMsg("Favorite");
          i18n_7 = MSG_EXTERNAL_ProgramsList_listOptionFavorite$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_7;
        } else {
          i18n_7 = "Favorit";
        }
        let i18n_8;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_tableColumnName$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_8 = goog.getMsg(" Name ");
          i18n_8 = MSG_EXTERNAL_ProgramsList_tableColumnName$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_8;
        } else {
          i18n_8 = " Name ";
        }
        let i18n_9;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_tableColumnType$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_9 = goog.getMsg(" Type ");
          i18n_9 = MSG_EXTERNAL_ProgramsList_tableColumnType$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_9;
        } else {
          i18n_9 = "Eingeben ";
        }
        let i18n_10;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_defaultProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_10 = goog.getMsg("Default program");
          i18n_10 = MSG_EXTERNAL_ProgramsList_defaultProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_10;
        } else {
          i18n_10 = "Standardprogramm";
        }
        let i18n_11;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_UsersProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_11 = goog.getMsg("User's program");
          i18n_11 = MSG_EXTERNAL_ProgramsList_UsersProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_11;
        } else {
          i18n_11 = "Benutzerprogramm";
        }
        let i18n_12;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_tableColumnTemplate$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_12 = goog.getMsg("Template");
          i18n_12 = MSG_EXTERNAL_ProgramsList_tableColumnTemplate$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_12;
        } else {
          i18n_12 = "Vorlage";
        }
        let i18n_13;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_tableColumnNumberOfExercises$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_13 = goog.getMsg(" No. exercises ");
          i18n_13 = MSG_EXTERNAL_ProgramsList_tableColumnNumberOfExercises$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_13;
        } else {
          i18n_13 = "Anzahl \xDCbungen";
        }
        let i18n_14;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_addToClientTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_14 = goog.getMsg("Add to client");
          i18n_14 = MSG_EXTERNAL_ProgramsList_addToClientTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_14;
        } else {
          i18n_14 = "Zum Patienten hinzuf\xFCgen";
        }
        let i18n_15;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_addToClientAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_15 = goog.getMsg("Add to client icon button");
          i18n_15 = MSG_EXTERNAL_ProgramsList_addToClientAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_15;
        } else {
          i18n_15 = "Schaltfl\xE4che \u201EZum Client hinzuf\xFCgen\u201C";
        }
        let i18n_16;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_addToClientTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_16 = goog.getMsg("Add to client");
          i18n_16 = MSG_EXTERNAL_ProgramsList_addToClientTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_16;
        } else {
          i18n_16 = "Zum Patienten hinzuf\xFCgen";
        }
        let i18n_17;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_addToClientAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_17 = goog.getMsg("Add to client icon button");
          i18n_17 = MSG_EXTERNAL_ProgramsList_addToClientAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_17;
        } else {
          i18n_17 = "Schaltfl\xE4che \u201EZum Client hinzuf\xFCgen\u201C";
        }
        let i18n_18;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_deleteProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_18 = goog.getMsg("Delete");
          i18n_18 = MSG_EXTERNAL_ProgramsList_deleteProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_18;
        } else {
          i18n_18 = "L\xF6schen";
        }
        let i18n_19;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_deleteProgramAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_19 = goog.getMsg("Delete icon button");
          i18n_19 = MSG_EXTERNAL_ProgramsList_deleteProgramAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_19;
        } else {
          i18n_19 = "Symbolschaltfl\xE4che \u201EL\xF6schen\u201C";
        }
        let i18n_20;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_editProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_20 = goog.getMsg("Edit");
          i18n_20 = MSG_EXTERNAL_ProgramsList_editProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_20;
        } else {
          i18n_20 = "Bearbeiten";
        }
        let i18n_21;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_editProgramAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_21 = goog.getMsg("Edit icon button");
          i18n_21 = MSG_EXTERNAL_ProgramsList_editProgramAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_21;
        } else {
          i18n_21 = "Symbolschaltfl\xE4che \u201EBearbeiten\u201C";
        }
        let i18n_22;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_removeProgramFromFavoritesTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_22 = goog.getMsg("Remove from favorites");
          i18n_22 = MSG_EXTERNAL_ProgramsList_removeProgramFromFavoritesTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_22;
        } else {
          i18n_22 = "Aus Favoriten entfernen";
        }
        let i18n_23;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_removeProgramFromFavoritesAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_23 = goog.getMsg("Favorite icon-button with a star icon");
          i18n_23 = MSG_EXTERNAL_ProgramsList_removeProgramFromFavoritesAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_23;
        } else {
          i18n_23 = "Favoriten-Symbol-Schaltfl\xE4che mit einem Sternsymbol";
        }
        let i18n_24;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_addProgramToFavoritesTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_24 = goog.getMsg("Add to favorites");
          i18n_24 = MSG_EXTERNAL_ProgramsList_addProgramToFavoritesTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_24;
        } else {
          i18n_24 = "Zu meinen Favoriten hinzuf\xFCgen";
        }
        let i18n_25;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_addProgramToFavoritesAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_25 = goog.getMsg("Favorite icon-button with a star icon");
          i18n_25 = MSG_EXTERNAL_ProgramsList_addProgramToFavoritesAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_25;
        } else {
          i18n_25 = "Favoriten-Symbol-Schaltfl\xE4che mit einem Sternsymbol";
        }
        let i18n_26;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_noMatchingFilter$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_26 = goog.getMsg(' No data matching the filter "{$interpolation}" ', {
            "interpolation": "\uFFFD0\uFFFD"
          }, {
            original_code: {
              "interpolation": "{{ input.value }}"
            }
          });
          i18n_26 = MSG_EXTERNAL_ProgramsList_noMatchingFilter$$LIBS_UI_SRC_LIB_COMPONENTS_PROGRAMS_TABLE_PROGRAMS_TABLE_COMPONENT_TS_26;
        } else {
          i18n_26 = "Keine Daten, die dem Filter \"" + "\uFFFD0\uFFFD" + "\" entsprechen";
        }
        return [["input", ""], i18n_3, i18n_4, i18n_5, i18n_6, i18n_7, i18n_8, i18n_9, i18n_12, i18n_13, i18n_26, [1, "table-wrapper"], ["matInput", "", "placeholder", i18n_0, 3, "keyup"], [1, "search-segmented-btns"], ["name", "listOption", "aria-label", i18n_1, "hideSingleSelectionIndicator", "true", 1, "segmented-btns", 3, "ngModelChange", "change", "ngModel"], ["value", "all"], ["value", "template"], ["value", "client"], ["value", "favorite"], [1, "programs-table-container"], ["overlay-scrollbars", "", 1, "programs-table", "table-scroll-container", 3, "options", "defer"], ["mat-table", "", "matSort", "", 1, "mat-table-background", 3, "dataSource"], ["matColumnDef", "name"], ["mat-header-cell", "", "mat-sort-header", "", 4, "matHeaderCellDef"], ["mat-cell", "", 4, "matCellDef"], ["matColumnDef", "type"], ["mat-header-cell", "", 4, "matHeaderCellDef"], ["matColumnDef", "numberOfExercises"], ["matColumnDef", "options"], ["mat-header-row", "", 4, "matHeaderRowDef"], ["mat-row", "", "class", "table-rows", 4, "matRowDef", "matRowDefColumns"], ["class", "mat-row", 4, "matNoDataRow"], ["pageSize", "10", "aria-label", i18n_2, 1, "mat-paginator-background", 3, "pageSizeOptions"], ["mat-header-cell", "", "mat-sort-header", ""], ["mat-cell", ""], ["mat-header-cell", ""], ["matTooltip", i18n_10, 1, "template-icon"], ["matTooltip", i18n_11, 1, "template-icon"], ["width", "16", "src", "assets/images/leaf-img.svg", "alt", ""], ["width", "14", "src", "assets/images/blue-user-icon.svg", "alt", ""], [1, "program-options"], ["mat-icon-button", "", "matTooltip", i18n_14, "aria-label", i18n_15], ["mat-icon-button", "", "matTooltip", i18n_16, "aria-label", i18n_17], ["mat-icon-button", "", "matTooltip", i18n_18, "aria-label", i18n_19, 3, "disabled"], ["mat-icon-button", "", "matTooltip", i18n_14, "aria-label", i18n_15, 3, "click"], ["mat-icon-button", "", "matTooltip", i18n_20, "aria-label", i18n_21, 3, "disabled"], ["mat-icon-button", "", "matTooltip", i18n_20, "aria-label", i18n_21, 3, "click", "disabled"], ["mat-icon-button", "", "matTooltip", i18n_16, "aria-label", i18n_17, 3, "click"], ["mat-icon-button", "", "matTooltip", i18n_18, "aria-label", i18n_19, 3, "click", "disabled"], ["mat-icon-button", "", "matTooltip", i18n_22, "aria-label", i18n_23, 1, "favorite-program-star"], ["mat-icon-button", "", "matTooltip", i18n_24, "aria-label", i18n_25], ["mat-icon-button", "", "matTooltip", i18n_22, "aria-label", i18n_23, 1, "favorite-program-star", 3, "click"], ["mat-icon-button", "", "matTooltip", i18n_24, "aria-label", i18n_25, 3, "click"], ["mat-header-row", ""], ["mat-row", "", 1, "table-rows"], [1, "mat-row"], ["colspan", "4", 1, "mat-cell"]];
      },
      template: function ProgramsTableComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "div", 11)(1, "mat-form-field")(2, "mat-label");
          ɵɵi18n(3, 1);
          ɵɵelementEnd();
          ɵɵelementStart(4, "input", 12, 0);
          ɵɵlistener("keyup", function ProgramsTableComponent_Template_input_keyup_4_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.applyFilter($event));
          });
          ɵɵelementEnd()();
          ɵɵelementStart(6, "div", 13)(7, "mat-button-toggle-group", 14);
          ɵɵtwoWayListener("ngModelChange", function ProgramsTableComponent_Template_mat_button_toggle_group_ngModelChange_7_listener($event) {
            ɵɵrestoreView(_r1);
            ɵɵtwoWayBindingSet(ctx.listOption, $event) || (ctx.listOption = $event);
            return ɵɵresetView($event);
          });
          ɵɵlistener("change", function ProgramsTableComponent_Template_mat_button_toggle_group_change_7_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.getPrograms(ctx.listOption));
          });
          ɵɵelementStart(8, "mat-button-toggle", 15);
          ɵɵi18n(9, 2);
          ɵɵelementEnd();
          ɵɵelementStart(10, "mat-button-toggle", 16);
          ɵɵi18n(11, 3);
          ɵɵelementEnd();
          ɵɵelementStart(12, "mat-button-toggle", 17);
          ɵɵi18n(13, 4);
          ɵɵelementEnd();
          ɵɵelementStart(14, "mat-button-toggle", 18);
          ɵɵi18n(15, 5);
          ɵɵelementEnd()()();
          ɵɵelementStart(16, "div", 19)(17, "div", 20)(18, "table", 21);
          ɵɵelementContainerStart(19, 22);
          ɵɵtemplate(20, ProgramsTableComponent_th_20_Template, 2, 0, "th", 23)(21, ProgramsTableComponent_td_21_Template, 2, 1, "td", 24);
          ɵɵelementContainerEnd();
          ɵɵelementContainerStart(22, 25);
          ɵɵtemplate(23, ProgramsTableComponent_th_23_Template, 2, 0, "th", 26)(24, ProgramsTableComponent_td_24_Template, 3, 1, "td", 24);
          ɵɵelementContainerEnd();
          ɵɵelementContainerStart(25, 27);
          ɵɵtemplate(26, ProgramsTableComponent_th_26_Template, 2, 0, "th", 26)(27, ProgramsTableComponent_td_27_Template, 2, 1, "td", 24);
          ɵɵelementContainerEnd();
          ɵɵelementContainerStart(28, 28);
          ɵɵtemplate(29, ProgramsTableComponent_th_29_Template, 1, 0, "th", 26)(30, ProgramsTableComponent_td_30_Template, 7, 4, "td", 24);
          ɵɵelementContainerEnd();
          ɵɵtemplate(31, ProgramsTableComponent_tr_31_Template, 1, 0, "tr", 29)(32, ProgramsTableComponent_tr_32_Template, 1, 0, "tr", 30)(33, ProgramsTableComponent_tr_33_Template, 3, 1, "tr", 31);
          ɵɵelementEnd()();
          ɵɵelement(34, "mat-paginator", 32);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance(7);
          ɵɵtwoWayProperty("ngModel", ctx.listOption);
          ɵɵadvance(10);
          ɵɵproperty("options", ctx.themeSignal());
          ɵɵadvance();
          ɵɵproperty("dataSource", ctx.dataSource);
          ɵɵadvance(13);
          ɵɵproperty("matHeaderRowDef", ctx.displayedColumns);
          ɵɵadvance();
          ɵɵproperty("matRowDefColumns", ctx.displayedColumns);
          ɵɵadvance(2);
          ɵɵproperty("pageSizeOptions", ɵɵpureFunction0(6, _c017));
        }
      },
      dependencies: [MatFormField, MatLabel, MatInput, MatButtonToggleGroup, FormsModule, NgControlStatus, NgModel, MatButtonToggle, OverlayscrollbarsModule, OverlayScrollbarsComponent, MatTableModule, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatNoDataRow, MatSort, MatSortModule, MatSortHeader, MatIconButton, MatTooltip, MatIcon, MatPaginatorModule, MatPaginator],
      styles: ['.programs-table-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:space-between;height:calc(100vh - 272px);overflow:hidden}.programs-table-container[_ngcontent-%COMP%]   .table-scroll-container[_ngcontent-%COMP%]{height:calc(100vh - 290px);overflow-y:scroll}.programs-table-skeleton[_ngcontent-%COMP%]{width:100%;height:440px;overflow:hidden}.programs-table-skeleton[_ngcontent-%COMP%]   .row-skeleton[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:center;gap:14px;height:48px;border-bottom-width:1px;border-bottom-style:solid}.programs-table-skeleton[_ngcontent-%COMP%]   .row-skeleton[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{border-radius:16px;min-width:193px;height:30px;overflow:hidden;position:relative;width:100%}.programs-table-skeleton[_ngcontent-%COMP%]   .row-skeleton[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:after{position:absolute;inset:0;transform:translate(-100%);animation:_ngcontent-%COMP%_shimmer 1s infinite;content:""}@keyframes _ngcontent-%COMP%_shimmer{to{transform:translate(100%)}}.programs-table-skeleton[_ngcontent-%COMP%]   .row-skeleton[_ngcontent-%COMP%]:last-of-type{border-bottom:0}\n/*# sourceMappingURL=programs-table.component-R7TBPWXS.css.map */']
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(ProgramsTableComponent, {
    className: "ProgramsTableComponent",
    filePath: "libs/ui/src/lib/components/programs-table/programs-table.component.ts",
    lineNumber: 48
  });
})();

// libs/ui/src/lib/pages/filter-select-clients/filter-select-clients.component.ts
var _c018 = ["singleSelect"];
function FilterSelectClientsComponent_For_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-option", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const client_r2 = ctx.$implicit;
    ɵɵproperty("value", client_r2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", client_r2.name, " ");
  }
}
var FilterSelectClientsComponent = class _FilterSelectClientsComponent {
  constructor() {
    this.shareClientsDataService = inject(ShareClientsDataService);
    this.clientsService = inject(ClientsService);
    this.controlContainer = inject(ControlContainer);
    this.clients = [];
    this.subscriptions = new Subscription();
    this.clientFilterCtrl = new FormControl();
    this.filteredClients = new ReplaySubject(1);
    this.reuseProgram = this.shareClientsDataService.reuseProgram;
    this._onDestroy = new Subject();
    this.isIndeterminate = false;
    this.isChecked = false;
    this.isClientProgramSignal = this.shareClientsDataService.isClientProgram;
    this.clientInfo = this.shareClientsDataService.clientInfo;
  }
  ngOnInit() {
    this.clientCtrl = this.controlContainer.control?.get("selectedClients");
    console.log(this.clientCtrl);
    console.log(this.clientInfo());
    if (this.isClientProgramSignal() && !this.reuseProgram()) {
      const subscription2 = this.clientsService.getClient(this.clientInfo().clientId).subscribe(client => {
        console.log("this is client", client);
        this.clientCtrl.setValue([client
        // { name: this.clientInfo().clientName, id: this.clientInfo().clientId },
        ]);
      });
      this.subscriptions.add(subscription2);
    }
    const subscription = this.clientsService.getClients().subscribe(clientsList => {
      this.clients = clientsList;
      console.log(this.clients);
      this.filteredClients.next(this.clients.slice());
    });
    this.subscriptions.add(subscription);
    this.clientFilterCtrl.valueChanges.pipe(takeUntil(this._onDestroy)).subscribe(() => {
      this.filterClients();
    });
  }
  ngAfterViewInit() {
    this.setInitialValue();
  }
  /**
   * Sets the initial value after the filteredClients are loaded initially
   */
  setInitialValue() {
    this.filteredClients.pipe(take(1), takeUntil(this._onDestroy)).subscribe(() => {
      this.singleSelect.compareWith = (a2, b2) => a2 && b2 && a2.id === b2.id;
    });
  }
  filterClients() {
    if (!this.clients) {
      return;
    }
    let search = this.clientFilterCtrl.value;
    if (!search) {
      this.filteredClients.next(this.clients.slice());
      return;
    } else {
      search = search.toLowerCase();
    }
    this.filteredClients.next(this.clients.filter(client => client.name.toLowerCase().indexOf(search) > -1));
  }
  toggleSelectAll(selectAllValue) {
    this.filteredClients.pipe(take(1), takeUntil(this._onDestroy)).subscribe(val => {
      if (selectAllValue) {
        this.clientCtrl.patchValue(val);
      } else {
        this.clientCtrl.patchValue([]);
      }
    });
  }
  ngOnDestroy() {
    this._onDestroy.next();
    this._onDestroy.complete();
    this.subscriptions.unsubscribe();
  }
  static {
    this.ɵfac = function FilterSelectClientsComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _FilterSelectClientsComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _FilterSelectClientsComponent,
      selectors: [["ui-filter-select-clients"]],
      viewQuery: function FilterSelectClientsComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(_c018, 7);
        }
        if (rf & 2) {
          let _t2;
          ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.singleSelect = _t2.first);
        }
      },
      decls: 14,
      vars: 8,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_FilterSelectClients_addClientsInputPlaceholder$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_0 = goog.getMsg("Add client(s)");
          i18n_0 = MSG_EXTERNAL_FilterSelectClients_addClientsInputPlaceholder$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_0;
        } else {
          i18n_0 = "Patienten hinzuf\xFCgen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_FilterSelectClients_addClientsPlaceholderLabel$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_1 = goog.getMsg("Find clients...");
          i18n_1 = MSG_EXTERNAL_FilterSelectClients_addClientsPlaceholderLabel$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_1;
        } else {
          i18n_1 = "Patienten finden...";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_FilterSelectClients_noEntriesFoundLabel$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_2 = goog.getMsg("No entries found");
          i18n_2 = MSG_EXTERNAL_FilterSelectClients_noEntriesFoundLabel$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_2;
        } else {
          i18n_2 = "Keine Eintr\xE4ge gefunden";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_FilterSelectClients_toggleAllCheckboxTooltipMessage$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_3 = goog.getMsg("Select / Unselect All");
          i18n_3 = MSG_EXTERNAL_FilterSelectClients_toggleAllCheckboxTooltipMessage$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_3;
        } else {
          i18n_3 = "Alles ausw\xE4hlen / Auswahl aufheben";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_FilterSelectClients_addClientsLabel$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_4 = goog.getMsg("Add client(s)");
          i18n_4 = MSG_EXTERNAL_FilterSelectClients_addClientsLabel$$LIBS_UI_SRC_LIB_PAGES_FILTER_SELECT_CLIENTS_FILTER_SELECT_CLIENTS_COMPONENT_TS_4;
        } else {
          i18n_4 = "Patienten hinzuf\xFCgen";
        }
        return [["singleSelect", ""], i18n_4, ["appearance", "outline", 1, "add-clients"], ["matPrefix", ""], ["placeholder", i18n_0, 3, "formControl", "multiple"], ["placeholderLabel", i18n_1, "noEntriesFoundLabel", i18n_2, "toggleAllCheckboxTooltipMessage", i18n_3, 3, "toggleAll", "formControl", "showToggleAllCheckbox", "toggleAllCheckboxIndeterminate", "toggleAllCheckboxChecked"], ["ngxMatSelectSearchClear", ""], [3, "value"]];
      },
      template: function FilterSelectClientsComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "mat-form-field", 2)(1, "mat-label");
          ɵɵi18n(2, 1);
          ɵɵelementEnd();
          ɵɵelementStart(3, "mat-icon", 3);
          ɵɵtext(4, "people_outline");
          ɵɵelementEnd();
          ɵɵelementStart(5, "mat-select", 4, 0)(7, "mat-option")(8, "ngx-mat-select-search", 5);
          ɵɵlistener("toggleAll", function FilterSelectClientsComponent_Template_ngx_mat_select_search_toggleAll_8_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.toggleSelectAll($event));
          });
          ɵɵelementStart(9, "mat-icon", 6);
          ɵɵtext(10, "close");
          ɵɵelementEnd()()();
          ɵɵrepeaterCreate(11, FilterSelectClientsComponent_For_12_Template, 2, 2, "mat-option", 7, ɵɵrepeaterTrackByIdentity);
          ɵɵpipe(13, "async");
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance(5);
          ɵɵproperty("formControl", ctx.clientCtrl)("multiple", true);
          ɵɵadvance(3);
          ɵɵproperty("formControl", ctx.clientFilterCtrl)("showToggleAllCheckbox", true)("toggleAllCheckboxIndeterminate", ctx.isIndeterminate)("toggleAllCheckboxChecked", ctx.isChecked);
          ɵɵadvance(3);
          ɵɵrepeater(ɵɵpipeBind1(13, 6, ctx.filteredClients));
        }
      },
      dependencies: [MatFormField, MatLabel, MatIcon, MatPrefix, MatSelect, FormsModule, NgControlStatus, ReactiveFormsModule, FormControlDirective, MatOption, NgxMatSelectSearchModule, MatSelectSearchComponent, MatSelectSearchClearDirective, AsyncPipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(FilterSelectClientsComponent, {
    className: "FilterSelectClientsComponent",
    filePath: "libs/ui/src/lib/pages/filter-select-clients/filter-select-clients.component.ts",
    lineNumber: 66
  });
})();

// libs/ui/src/lib/pages/search/search.component.ts
function SearchComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function SearchComponent_Conditional_4_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearSearch());
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "close");
    ɵɵelementEnd()();
  }
}
var SearchComponent = class _SearchComponent {
  constructor() {
    this.searchService = inject(SearchService);
    this.shareDataService = inject(ShareDataService);
    this.shareStateService = inject(ShareStateService);
    this.localstorageService = inject(LocalstorageService);
    this.searchTerm = new FormControl();
    this.drawerOpen = false;
    this.subscriptions = new Subscription();
    this.isFetchingData = this.shareStateService.isFetchingData;
  }
  // constructor(
  //   private searchService: SearchService,
  //   private shareDataService: ShareDataService,
  //   private shareStateService: ShareStateService,
  // ) {
  //   // this.searchTerm.valueChanges.pipe(
  //   //   debounceTime(400),
  //   //   distinctUntilChanged(),
  //   //   switchMap(async (searchTerm) => this.searchService
  //   //       .searchExercises(searchTerm)
  //   //       .subscribe(exercises => console.log(exercises)),
  //   //   ),
  //   // );
  //   // let filterData = this.shareDataService.filterData$.subscribe(filterData => console.log(filterData))
  //   // this.searchTerm.valueChanges
  //   //   .pipe(
  //   //     debounceTime(400),
  //   //     distinctUntilChanged(),
  //   //     switchMap(() => searchService.searchExercises(this.searchTerm.value)),
  //   //   )
  //   //   .subscribe(searchResult =>
  //   //     shareDataService.updateSearchResults(searchResult),
  //   //   );
  //   // combineLatest([
  //   //   this.searchTerm.valueChanges,
  //   //   this.shareDataService.filterData$,
  //   // ])
  //   //   .pipe(
  //   //     debounceTime(400),
  //   //     distinctUntilChanged(),
  //   //     switchMap(([searchTerm, filterData]) =>
  //   //       searchService.searchExercises(searchTerm, filterData),
  //   //     ),
  //   //   )
  //   //   .subscribe(searchResult =>
  //   //     shareDataService.updateSearchResults(searchResult),
  //   //   );
  // }
  ngOnInit() {
    this.selectedLanguage = this._getUserLanguageToken();
    console.log("running from search");
    const subscription = combineLatest([
    // concat(of(''), this.searchTerm.valueChanges),
    this.searchTerm.valueChanges.pipe(startWith(""), tap(() => this.isFetchingData.set(true))), this.shareDataService.filterData$]).pipe(debounceTime(400), distinctUntilChanged(), switchMap(([searchTerm, filterData]) => this.searchService.searchExercises(searchTerm, filterData, this.selectedLanguage))).subscribe(searchResult => this.shareDataService.updateSearchResults(searchResult));
    this.subscriptions.add(subscription);
  }
  clearSearch() {
    this.searchTerm.setValue("");
  }
  // hideRequiredControl = new FormControl(false);
  // floatLabelControl = new FormControl('auto' as FloatLabelType);
  // options = this._formBuilder.group({
  //   hideRequired: this.hideRequiredControl,
  //   floatLabel: this.floatLabelControl,
  // });
  // hide = true;
  // constructor(private _formBuilder: FormBuilder) {}
  // getFloatLabelValue(): FloatLabelType {
  //   return this.floatLabelControl.value || 'auto';
  // }
  // get formValue(): FormControl {
  //   return this.searchTerm.get('images') as FormArray;
  // }
  toggleDrawer() {
    this.shareStateService.drawerSignal.update(value => !value);
  }
  _getUserLanguageToken() {
    return this.localstorageService.getToken("userLanguage")?.split("-")[0];
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static {
    this.ɵfac = function SearchComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SearchComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _SearchComponent,
      selectors: [["ui-search"]],
      decls: 10,
      vars: 2,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_searchExercisesPlaceholder$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_0 = goog.getMsg("Search exercises");
          i18n_0 = MSG_EXTERNAL_SearchSegmentedBtns_searchExercisesPlaceholder$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_0;
        } else {
          i18n_0 = "\xDCbungen suchen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_clearSearch$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_1 = goog.getMsg("Clear");
          i18n_1 = MSG_EXTERNAL_SearchSegmentedBtns_clearSearch$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_1;
        } else {
          i18n_1 = "L\xF6schen";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_clearSearchAriaLabel$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_2 = goog.getMsg("Clear");
          i18n_2 = MSG_EXTERNAL_SearchSegmentedBtns_clearSearchAriaLabel$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_2;
        } else {
          i18n_2 = "L\xF6schen";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_filterSearch$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_3 = goog.getMsg("Filter");
          i18n_3 = MSG_EXTERNAL_SearchSegmentedBtns_filterSearch$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_3;
        } else {
          i18n_3 = "Filter";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_filterSearchAriaLabel$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_4 = goog.getMsg("Filter button");
          i18n_4 = MSG_EXTERNAL_SearchSegmentedBtns_filterSearchAriaLabel$$LIBS_UI_SRC_LIB_PAGES_SEARCH_SEARCH_COMPONENT_TS_4;
        } else {
          i18n_4 = "Schaltfl\xE4che \"Filter\"";
        }
        return [[1, "search-container"], [1, "search-form-fields"], [1, "search-input"], ["matInput", "", "placeholder", i18n_0, 3, "formControl"], ["matSuffix", "", "mat-icon-button", "", "matTooltip", i18n_1, "aria-label", i18n_2], ["matTooltip", i18n_3, "aria-label", i18n_4, "mat-icon-button", "", "matSuffix", "", 3, "click"], ["matPrefix", ""], ["matSuffix", "", "mat-icon-button", "", "matTooltip", i18n_1, "aria-label", i18n_2, 3, "click"]];
      },
      template: function SearchComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "mat-form-field", 2);
          ɵɵelement(3, "input", 3);
          ɵɵtemplate(4, SearchComponent_Conditional_4_Template, 3, 0, "button", 4);
          ɵɵelementStart(5, "button", 5);
          ɵɵlistener("click", function SearchComponent_Template_button_click_5_listener() {
            return ctx.toggleDrawer();
          });
          ɵɵelementStart(6, "mat-icon");
          ɵɵtext(7, "tune");
          ɵɵelementEnd()();
          ɵɵelementStart(8, "mat-icon", 6);
          ɵɵtext(9, "search");
          ɵɵelementEnd()()()();
        }
        if (rf & 2) {
          ɵɵadvance(3);
          ɵɵproperty("formControl", ctx.searchTerm);
          ɵɵadvance();
          ɵɵconditional(ctx.searchTerm.value ? 4 : -1);
        }
      },
      dependencies: [MatFormField, MatInput, FormsModule, DefaultValueAccessor, NgControlStatus, ReactiveFormsModule, FormControlDirective, MatIconButton, MatSuffix, MatTooltip, MatIcon, MatPrefix],
      styles: [".search-container[_ngcontent-%COMP%]{padding-right:16px}.search-container[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%]{width:100%}.search-container[_ngcontent-%COMP%]   .search-form-fields[_ngcontent-%COMP%]{display:flex;align-items:flex-start}  .search-input .mat-mdc-text-field-wrapper{border-radius:28px!important}  .mat-mdc-form-field-icon-suffix,   [dir=rtl] .mat-mdc-form-field-icon-prefix{margin-right:6px}  .mat-mdc-form-field-icon-prefix,   [dir=rtl] .mat-mdc-form-field-icon-suffix{margin-left:6px}  .mat-mdc-form-field-subscript-wrapper{height:0}\n/*# sourceMappingURL=search.component-SVWJ5QNZ.css.map */"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(SearchComponent, {
    className: "SearchComponent",
    filePath: "libs/ui/src/lib/pages/search/search.component.ts",
    lineNumber: 49
  });
})();

// node_modules/@angular/cdk/fesm2022/tree.mjs
var BaseTreeControl = class {
  /** Saved data node for `expandAll` action. */
  dataNodes;
  /** A selection model with multi-selection to track expansion status. */
  expansionModel = new SelectionModel(true);
  /**
   * Returns the identifier by which a dataNode should be tracked, should its
   * reference change.
   *
   * Similar to trackBy for *ngFor
   */
  trackBy;
  /** Get depth of a given data node, return the level number. This is for flat tree node. */
  getLevel;
  /**
   * Whether the data node is expandable. Returns true if expandable.
   * This is for flat tree node.
   */
  isExpandable;
  /** Gets a stream that emits whenever the given data node's children change. */
  getChildren;
  /** Toggles one single data node's expanded/collapsed state. */
  toggle(dataNode) {
    this.expansionModel.toggle(this._trackByValue(dataNode));
  }
  /** Expands one single data node. */
  expand(dataNode) {
    this.expansionModel.select(this._trackByValue(dataNode));
  }
  /** Collapses one single data node. */
  collapse(dataNode) {
    this.expansionModel.deselect(this._trackByValue(dataNode));
  }
  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */
  isExpanded(dataNode) {
    return this.expansionModel.isSelected(this._trackByValue(dataNode));
  }
  /** Toggles a subtree rooted at `node` recursively. */
  toggleDescendants(dataNode) {
    this.expansionModel.isSelected(this._trackByValue(dataNode)) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);
  }
  /** Collapse all dataNodes in the tree. */
  collapseAll() {
    this.expansionModel.clear();
  }
  /** Expands a subtree rooted at given data node recursively. */
  expandDescendants(dataNode) {
    let toBeProcessed = [dataNode];
    toBeProcessed.push(...this.getDescendants(dataNode));
    this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));
  }
  /** Collapses a subtree rooted at given data node recursively. */
  collapseDescendants(dataNode) {
    let toBeProcessed = [dataNode];
    toBeProcessed.push(...this.getDescendants(dataNode));
    this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));
  }
  _trackByValue(value) {
    return this.trackBy ? this.trackBy(value) : value;
  }
};
var FlatTreeControl = class extends BaseTreeControl {
  getLevel;
  isExpandable;
  options;
  /** Construct with flat tree data node functions getLevel and isExpandable. */
  constructor(getLevel, isExpandable, options) {
    super();
    this.getLevel = getLevel;
    this.isExpandable = isExpandable;
    this.options = options;
    if (this.options) {
      this.trackBy = this.options.trackBy;
    }
  }
  /**
   * Gets a list of the data node's subtree of descendent data nodes.
   *
   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes
   * with correct levels.
   */
  getDescendants(dataNode) {
    const startIndex = this.dataNodes.indexOf(dataNode);
    const results = [];
    for (let i2 = startIndex + 1; i2 < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i2]); i2++) {
      results.push(this.dataNodes[i2]);
    }
    return results;
  }
  /**
   * Expands all data nodes in the tree.
   *
   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened
   * data nodes of the tree.
   */
  expandAll() {
    this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));
  }
};
var CDK_TREE_NODE_OUTLET_NODE = new InjectionToken("CDK_TREE_NODE_OUTLET_NODE");
var CdkTreeNodeOutlet = class _CdkTreeNodeOutlet {
  viewContainer = inject(ViewContainerRef);
  _node = inject(CDK_TREE_NODE_OUTLET_NODE, {
    optional: true
  });
  constructor() {}
  static ɵfac = function CdkTreeNodeOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTreeNodeOutlet)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkTreeNodeOutlet,
    selectors: [["", "cdkTreeNodeOutlet", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeOutlet]"
    }]
  }], () => [], null);
})();
var CdkTreeNodeOutletContext = class {
  /** Data for the node. */
  $implicit;
  /** Depth of the node. */
  level;
  /** Index location of the node. */
  index;
  /** Length of the number of total dataNodes. */
  count;
  constructor(data) {
    this.$implicit = data;
  }
};
var CdkTreeNodeDef = class _CdkTreeNodeDef {
  /** @docs-private */
  template = inject(TemplateRef);
  /**
   * Function that should return true if this node template should be used for the provided node
   * data and index. If left undefined, this node will be considered the default node template to
   * use when no other when functions return true for the data.
   * For every node, there must be at least one when function that passes or an undefined to
   * default.
   */
  when;
  constructor() {}
  static ɵfac = function CdkTreeNodeDef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTreeNodeDef)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkTreeNodeDef,
    selectors: [["", "cdkTreeNodeDef", ""]],
    inputs: {
      when: [0, "cdkTreeNodeDefWhen", "when"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeDef, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeDef]",
      inputs: [{
        name: "when",
        alias: "cdkTreeNodeDefWhen"
      }]
    }]
  }], () => [], null);
})();
function getTreeNoValidDataSourceError() {
  return Error(`A valid data source must be provided.`);
}
function getTreeMultipleDefaultNodeDefsError() {
  return Error(`There can only be one default row without a when predicate function.`);
}
function getTreeMissingMatchingNodeDefError() {
  return Error(`Could not find a matching node definition for the provided node data.`);
}
function getTreeControlMissingError() {
  return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);
}
function getMultipleTreeControlsError() {
  return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);
}
var CdkTree = class _CdkTree {
  _differs = inject(IterableDiffers);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _elementRef = inject(ElementRef);
  _dir = inject(Directionality);
  /** Subject that emits when the component has been destroyed. */
  _onDestroy = new Subject();
  /** Differ used to find the changes in the data provided by the data source. */
  _dataDiffer;
  /** Stores the node definition that does not have a when predicate. */
  _defaultNodeDef;
  /** Data subscription */
  _dataSubscription;
  /** Level of nodes */
  _levels = /* @__PURE__ */new Map();
  /** The immediate parents for a node. This is `null` if there is no parent. */
  _parents = /* @__PURE__ */new Map();
  /**
   * Nodes grouped into each set, which is a list of nodes displayed together in the DOM.
   *
   * Lookup key is the parent of a set. Root nodes have key of null.
   *
   * Values is a 'set' of tree nodes. Each tree node maps to a treeitem element. Sets are in the
   * order that it is rendered. Each set maps directly to aria-posinset and aria-setsize attributes.
   */
  _ariaSets = /* @__PURE__ */new Map();
  /**
   * Provides a stream containing the latest data array to render. Influenced by the tree's
   * stream of view window (what dataNodes are currently on screen).
   * Data source can be an observable of data array, or a data array to render.
   */
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(dataSource) {
    if (this._dataSource !== dataSource) {
      this._switchDataSource(dataSource);
    }
  }
  _dataSource;
  /**
   * The tree controller
   *
   * @deprecated Use one of `levelAccessor` or `childrenAccessor` instead. To be removed in a
   * future version.
   * @breaking-change 21.0.0
   */
  treeControl;
  /**
   * Given a data node, determines what tree level the node is at.
   *
   * One of levelAccessor or childrenAccessor must be specified, not both.
   * This is enforced at run-time.
   */
  levelAccessor;
  /**
   * Given a data node, determines what the children of that node are.
   *
   * One of levelAccessor or childrenAccessor must be specified, not both.
   * This is enforced at run-time.
   */
  childrenAccessor;
  /**
   * Tracking function that will be used to check the differences in data changes. Used similarly
   * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data
   * relative to the function to know if a node should be added/removed/moved.
   * Accepts a function that takes two parameters, `index` and `item`.
   */
  trackBy;
  /**
   * Given a data node, determines the key by which we determine whether or not this node is expanded.
   */
  expansionKey;
  // Outlets within the tree's template where the dataNodes will be inserted.
  _nodeOutlet;
  /** The tree node template for the tree */
  _nodeDefs;
  // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.
  //     Remove the MAX_VALUE in viewChange
  /**
   * Stream containing the latest information on what rows are being displayed on screen.
   * Can be used by the data source to as a heuristic of what data should be provided.
   */
  viewChange = new BehaviorSubject({
    start: 0,
    end: Number.MAX_VALUE
  });
  /** Keep track of which nodes are expanded. */
  _expansionModel;
  /**
   * Maintain a synchronous cache of flattened data nodes. This will only be
   * populated after initial render, and in certain cases, will be delayed due to
   * relying on Observable `getChildren` calls.
   */
  _flattenedNodes = new BehaviorSubject([]);
  /** The automatically determined node type for the tree. */
  _nodeType = new BehaviorSubject(null);
  /** The mapping between data and the node that is rendered. */
  _nodes = new BehaviorSubject(/* @__PURE__ */new Map());
  /**
   * Synchronous cache of nodes for the `TreeKeyManager`. This is separate
   * from `_flattenedNodes` so they can be independently updated at different
   * times.
   */
  _keyManagerNodes = new BehaviorSubject([]);
  _keyManagerFactory = inject(TREE_KEY_MANAGER);
  /** The key manager for this tree. Handles focus and activation based on user keyboard input. */
  _keyManager;
  _viewInit = false;
  constructor() {}
  ngAfterContentInit() {
    this._initializeKeyManager();
  }
  ngAfterContentChecked() {
    this._updateDefaultNodeDefinition();
    this._subscribeToDataChanges();
  }
  ngOnDestroy() {
    this._nodeOutlet.viewContainer.clear();
    this.viewChange.complete();
    this._onDestroy.next();
    this._onDestroy.complete();
    if (this._dataSource && typeof this._dataSource.disconnect === "function") {
      this.dataSource.disconnect(this);
    }
    if (this._dataSubscription) {
      this._dataSubscription.unsubscribe();
      this._dataSubscription = null;
    }
    this._keyManager?.destroy();
  }
  ngOnInit() {
    this._checkTreeControlUsage();
    this._initializeDataDiffer();
  }
  ngAfterViewInit() {
    this._viewInit = true;
  }
  _updateDefaultNodeDefinition() {
    const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);
    if (defaultNodeDefs.length > 1 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeMultipleDefaultNodeDefsError();
    }
    this._defaultNodeDef = defaultNodeDefs[0];
  }
  /**
   * Sets the node type for the tree, if it hasn't been set yet.
   *
   * This will be called by the first node that's rendered in order for the tree
   * to determine what data transformations are required.
   */
  _setNodeTypeIfUnset(newType) {
    const currentType = this._nodeType.value;
    if (currentType === null) {
      this._nodeType.next(newType);
    } else if ((typeof ngDevMode === "undefined" || ngDevMode) && currentType !== newType) {
      console.warn(`Tree is using conflicting node types which can cause unexpected behavior. Please use tree nodes of the same type (e.g. only flat or only nested). Current node type: "${currentType}", new node type "${newType}".`);
    }
  }
  /**
   * Switch to the provided data source by resetting the data and unsubscribing from the current
   * render change subscription if one exists. If the data source is null, interpret this by
   * clearing the node outlet. Otherwise start listening for new data.
   */
  _switchDataSource(dataSource) {
    if (this._dataSource && typeof this._dataSource.disconnect === "function") {
      this.dataSource.disconnect(this);
    }
    if (this._dataSubscription) {
      this._dataSubscription.unsubscribe();
      this._dataSubscription = null;
    }
    if (!dataSource) {
      this._nodeOutlet.viewContainer.clear();
    }
    this._dataSource = dataSource;
    if (this._nodeDefs) {
      this._subscribeToDataChanges();
    }
  }
  _getExpansionModel() {
    if (!this.treeControl) {
      this._expansionModel ??= new SelectionModel(true);
      return this._expansionModel;
    }
    return this.treeControl.expansionModel;
  }
  /** Set up a subscription for the data provided by the data source. */
  _subscribeToDataChanges() {
    if (this._dataSubscription) {
      return;
    }
    let dataStream;
    if (isDataSource(this._dataSource)) {
      dataStream = this._dataSource.connect(this);
    } else if (isObservable(this._dataSource)) {
      dataStream = this._dataSource;
    } else if (Array.isArray(this._dataSource)) {
      dataStream = of(this._dataSource);
    }
    if (!dataStream) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        throw getTreeNoValidDataSourceError();
      }
      return;
    }
    this._dataSubscription = this._getRenderData(dataStream).pipe(takeUntil(this._onDestroy)).subscribe(renderingData => {
      this._renderDataChanges(renderingData);
    });
  }
  /** Given an Observable containing a stream of the raw data, returns an Observable containing the RenderingData */
  _getRenderData(dataStream) {
    const expansionModel = this._getExpansionModel();
    return combineLatest([dataStream, this._nodeType,
    // We don't use the expansion data directly, however we add it here to essentially
    // trigger data rendering when expansion changes occur.
    expansionModel.changed.pipe(startWith(null), tap(expansionChanges => {
      this._emitExpansionChanges(expansionChanges);
    }))]).pipe(switchMap(([data, nodeType]) => {
      if (nodeType === null) {
        return of({
          renderNodes: data,
          flattenedNodes: null,
          nodeType
        });
      }
      return this._computeRenderingData(data, nodeType).pipe(map(convertedData => __spreadProps(__spreadValues({}, convertedData), {
        nodeType
      })));
    }));
  }
  _renderDataChanges(data) {
    if (data.nodeType === null) {
      this.renderNodeChanges(data.renderNodes);
      return;
    }
    this._updateCachedData(data.flattenedNodes);
    this.renderNodeChanges(data.renderNodes);
    this._updateKeyManagerItems(data.flattenedNodes);
  }
  _emitExpansionChanges(expansionChanges) {
    if (!expansionChanges) {
      return;
    }
    const nodes = this._nodes.value;
    for (const added of expansionChanges.added) {
      const node = nodes.get(added);
      node?._emitExpansionState(true);
    }
    for (const removed of expansionChanges.removed) {
      const node = nodes.get(removed);
      node?._emitExpansionState(false);
    }
  }
  _initializeKeyManager() {
    const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(map(([keyManagerNodes, renderNodes]) => keyManagerNodes.reduce((items2, data) => {
      const node = renderNodes.get(this._getExpansionKey(data));
      if (node) {
        items2.push(node);
      }
      return items2;
    }, [])));
    const keyManagerOptions = {
      trackBy: node => this._getExpansionKey(node.data),
      skipPredicate: node => !!node.isDisabled,
      typeAheadDebounceInterval: true,
      horizontalOrientation: this._dir.value
    };
    this._keyManager = this._keyManagerFactory(items, keyManagerOptions);
  }
  _initializeDataDiffer() {
    const trackBy = this.trackBy ?? ((_index, item) => this._getExpansionKey(item));
    this._dataDiffer = this._differs.find([]).create(trackBy);
  }
  _checkTreeControlUsage() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      let numTreeControls = 0;
      if (this.treeControl) {
        numTreeControls++;
      }
      if (this.levelAccessor) {
        numTreeControls++;
      }
      if (this.childrenAccessor) {
        numTreeControls++;
      }
      if (!numTreeControls) {
        throw getTreeControlMissingError();
      } else if (numTreeControls > 1) {
        throw getMultipleTreeControlsError();
      }
    }
  }
  /** Check for changes made in the data and render each change (node added/removed/moved). */
  renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {
    const changes = dataDiffer.diff(data);
    if (!changes && !this._viewInit) {
      return;
    }
    changes?.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
      if (item.previousIndex == null) {
        this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);
      } else if (currentIndex == null) {
        viewContainer.remove(adjustedPreviousIndex);
      } else {
        const view = viewContainer.get(adjustedPreviousIndex);
        viewContainer.move(view, currentIndex);
      }
    });
    changes?.forEachIdentityChange(record => {
      const newData = record.item;
      if (record.currentIndex != void 0) {
        const view = viewContainer.get(record.currentIndex);
        view.context.$implicit = newData;
      }
    });
    if (parentData) {
      this._changeDetectorRef.markForCheck();
    } else {
      this._changeDetectorRef.detectChanges();
    }
  }
  /**
   * Finds the matching node definition that should be used for this node data. If there is only
   * one node definition, it is returned. Otherwise, find the node definition that has a when
   * predicate that returns true with the data. If none return true, return the default node
   * definition.
   */
  _getNodeDef(data, i2) {
    if (this._nodeDefs.length === 1) {
      return this._nodeDefs.first;
    }
    const nodeDef = this._nodeDefs.find(def => def.when && def.when(i2, data)) || this._defaultNodeDef;
    if (!nodeDef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeMissingMatchingNodeDefError();
    }
    return nodeDef;
  }
  /**
   * Create the embedded view for the data node template and place it in the correct index location
   * within the data node view container.
   */
  insertNode(nodeData, index, viewContainer, parentData) {
    const levelAccessor = this._getLevelAccessor();
    const node = this._getNodeDef(nodeData, index);
    const key = this._getExpansionKey(nodeData);
    const context = new CdkTreeNodeOutletContext(nodeData);
    parentData ??= this._parents.get(key) ?? void 0;
    if (levelAccessor) {
      context.level = levelAccessor(nodeData);
    } else if (parentData !== void 0 && this._levels.has(this._getExpansionKey(parentData))) {
      context.level = this._levels.get(this._getExpansionKey(parentData)) + 1;
    } else {
      context.level = 0;
    }
    this._levels.set(key, context.level);
    const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;
    container.createEmbeddedView(node.template, context, index);
    if (CdkTreeNode.mostRecentTreeNode) {
      CdkTreeNode.mostRecentTreeNode.data = nodeData;
    }
  }
  /** Whether the data node is expanded or collapsed. Returns true if it's expanded. */
  isExpanded(dataNode) {
    return !!(this.treeControl?.isExpanded(dataNode) || this._expansionModel?.isSelected(this._getExpansionKey(dataNode)));
  }
  /** If the data node is currently expanded, collapse it. Otherwise, expand it. */
  toggle(dataNode) {
    if (this.treeControl) {
      this.treeControl.toggle(dataNode);
    } else if (this._expansionModel) {
      this._expansionModel.toggle(this._getExpansionKey(dataNode));
    }
  }
  /** Expand the data node. If it is already expanded, does nothing. */
  expand(dataNode) {
    if (this.treeControl) {
      this.treeControl.expand(dataNode);
    } else if (this._expansionModel) {
      this._expansionModel.select(this._getExpansionKey(dataNode));
    }
  }
  /** Collapse the data node. If it is already collapsed, does nothing. */
  collapse(dataNode) {
    if (this.treeControl) {
      this.treeControl.collapse(dataNode);
    } else if (this._expansionModel) {
      this._expansionModel.deselect(this._getExpansionKey(dataNode));
    }
  }
  /**
   * If the data node is currently expanded, collapse it and all its descendants.
   * Otherwise, expand it and all its descendants.
   */
  toggleDescendants(dataNode) {
    if (this.treeControl) {
      this.treeControl.toggleDescendants(dataNode);
    } else if (this._expansionModel) {
      if (this.isExpanded(dataNode)) {
        this.collapseDescendants(dataNode);
      } else {
        this.expandDescendants(dataNode);
      }
    }
  }
  /**
   * Expand the data node and all its descendants. If they are already expanded, does nothing.
   */
  expandDescendants(dataNode) {
    if (this.treeControl) {
      this.treeControl.expandDescendants(dataNode);
    } else if (this._expansionModel) {
      const expansionModel = this._expansionModel;
      expansionModel.select(this._getExpansionKey(dataNode));
      this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {
        expansionModel.select(...children.map(child => this._getExpansionKey(child)));
      });
    }
  }
  /** Collapse the data node and all its descendants. If it is already collapsed, does nothing. */
  collapseDescendants(dataNode) {
    if (this.treeControl) {
      this.treeControl.collapseDescendants(dataNode);
    } else if (this._expansionModel) {
      const expansionModel = this._expansionModel;
      expansionModel.deselect(this._getExpansionKey(dataNode));
      this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {
        expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));
      });
    }
  }
  /** Expands all data nodes in the tree. */
  expandAll() {
    if (this.treeControl) {
      this.treeControl.expandAll();
    } else if (this._expansionModel) {
      this._forEachExpansionKey(keys2 => this._expansionModel?.select(...keys2));
    }
  }
  /** Collapse all data nodes in the tree. */
  collapseAll() {
    if (this.treeControl) {
      this.treeControl.collapseAll();
    } else if (this._expansionModel) {
      this._forEachExpansionKey(keys2 => this._expansionModel?.deselect(...keys2));
    }
  }
  /** Level accessor, used for compatibility between the old Tree and new Tree */
  _getLevelAccessor() {
    return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;
  }
  /** Children accessor, used for compatibility between the old Tree and new Tree */
  _getChildrenAccessor() {
    return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;
  }
  /**
   * Gets the direct children of a node; used for compatibility between the old tree and the
   * new tree.
   */
  _getDirectChildren(dataNode) {
    const levelAccessor = this._getLevelAccessor();
    const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;
    if (!expansionModel) {
      return of([]);
    }
    const key = this._getExpansionKey(dataNode);
    const isExpanded = expansionModel.changed.pipe(switchMap(changes => {
      if (changes.added.includes(key)) {
        return of(true);
      } else if (changes.removed.includes(key)) {
        return of(false);
      }
      return EMPTY;
    }), startWith(this.isExpanded(dataNode)));
    if (levelAccessor) {
      return combineLatest([isExpanded, this._flattenedNodes]).pipe(map(([expanded, flattenedNodes]) => {
        if (!expanded) {
          return [];
        }
        return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);
      }));
    }
    const childrenAccessor = this._getChildrenAccessor();
    if (childrenAccessor) {
      return coerceObservable(childrenAccessor(dataNode) ?? []);
    }
    throw getTreeControlMissingError();
  }
  /**
   * Given the list of flattened nodes, the level accessor, and the level range within
   * which to consider children, finds the children for a given node.
   *
   * For example, for direct children, `levelDelta` would be 1. For all descendants,
   * `levelDelta` would be Infinity.
   */
  _findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, levelDelta) {
    const key = this._getExpansionKey(dataNode);
    const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);
    const dataNodeLevel = levelAccessor(dataNode);
    const expectedLevel = dataNodeLevel + levelDelta;
    const results = [];
    for (let i2 = startIndex + 1; i2 < flattenedNodes.length; i2++) {
      const currentLevel = levelAccessor(flattenedNodes[i2]);
      if (currentLevel <= dataNodeLevel) {
        break;
      }
      if (currentLevel <= expectedLevel) {
        results.push(flattenedNodes[i2]);
      }
    }
    return results;
  }
  /**
   * Adds the specified node component to the tree's internal registry.
   *
   * This primarily facilitates keyboard navigation.
   */
  _registerNode(node) {
    this._nodes.value.set(this._getExpansionKey(node.data), node);
    this._nodes.next(this._nodes.value);
  }
  /** Removes the specified node component from the tree's internal registry. */
  _unregisterNode(node) {
    this._nodes.value.delete(this._getExpansionKey(node.data));
    this._nodes.next(this._nodes.value);
  }
  /**
   * For the given node, determine the level where this node appears in the tree.
   *
   * This is intended to be used for `aria-level` but is 0-indexed.
   */
  _getLevel(node) {
    return this._levels.get(this._getExpansionKey(node));
  }
  /**
   * For the given node, determine the size of the parent's child set.
   *
   * This is intended to be used for `aria-setsize`.
   */
  _getSetSize(dataNode) {
    const set = this._getAriaSet(dataNode);
    return set.length;
  }
  /**
   * For the given node, determine the index (starting from 1) of the node in its parent's child set.
   *
   * This is intended to be used for `aria-posinset`.
   */
  _getPositionInSet(dataNode) {
    const set = this._getAriaSet(dataNode);
    const key = this._getExpansionKey(dataNode);
    return set.findIndex(node => this._getExpansionKey(node) === key) + 1;
  }
  /** Given a CdkTreeNode, gets the node that renders that node's parent's data. */
  _getNodeParent(node) {
    const parent2 = this._parents.get(this._getExpansionKey(node.data));
    return parent2 && this._nodes.value.get(this._getExpansionKey(parent2));
  }
  /** Given a CdkTreeNode, gets the nodes that renders that node's child data. */
  _getNodeChildren(node) {
    return this._getDirectChildren(node.data).pipe(map(children => children.reduce((nodes, child) => {
      const value = this._nodes.value.get(this._getExpansionKey(child));
      if (value) {
        nodes.push(value);
      }
      return nodes;
    }, [])));
  }
  /** `keydown` event handler; this just passes the event to the `TreeKeyManager`. */
  _sendKeydownToKeyManager(event) {
    if (event.target === this._elementRef.nativeElement) {
      this._keyManager.onKeydown(event);
    } else {
      const nodes = this._nodes.getValue();
      for (const [, node] of nodes) {
        if (event.target === node._elementRef.nativeElement) {
          this._keyManager.onKeydown(event);
          break;
        }
      }
    }
  }
  /** Gets all nested descendants of a given node. */
  _getDescendants(dataNode) {
    if (this.treeControl) {
      return of(this.treeControl.getDescendants(dataNode));
    }
    if (this.levelAccessor) {
      const results = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, dataNode, Infinity);
      return of(results);
    }
    if (this.childrenAccessor) {
      return this._getAllChildrenRecursively(dataNode).pipe(reduce((allChildren, nextChildren) => {
        allChildren.push(...nextChildren);
        return allChildren;
      }, []));
    }
    throw getTreeControlMissingError();
  }
  /**
   * Gets all children and sub-children of the provided node.
   *
   * This will emit multiple times, in the order that the children will appear
   * in the tree, and can be combined with a `reduce` operator.
   */
  _getAllChildrenRecursively(dataNode) {
    if (!this.childrenAccessor) {
      return of([]);
    }
    return coerceObservable(this.childrenAccessor(dataNode)).pipe(take(1), switchMap(children => {
      for (const child of children) {
        this._parents.set(this._getExpansionKey(child), dataNode);
      }
      return of(...children).pipe(concatMap(child => concat(of([child]), this._getAllChildrenRecursively(child))));
    }));
  }
  _getExpansionKey(dataNode) {
    return this.expansionKey?.(dataNode) ?? dataNode;
  }
  _getAriaSet(node) {
    const key = this._getExpansionKey(node);
    const parent2 = this._parents.get(key);
    const parentKey = parent2 ? this._getExpansionKey(parent2) : null;
    const set = this._ariaSets.get(parentKey);
    return set ?? [node];
  }
  /**
   * Finds the parent for the given node. If this is a root node, this
   * returns null. If we're unable to determine the parent, for example,
   * if we don't have cached node data, this returns undefined.
   */
  _findParentForNode(node, index, cachedNodes) {
    if (!cachedNodes.length) {
      return null;
    }
    const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;
    for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {
      const parentNode = cachedNodes[parentIndex];
      const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;
      if (parentLevel < currentLevel) {
        return parentNode;
      }
    }
    return null;
  }
  /**
   * Given a set of root nodes and the current node level, flattens any nested
   * nodes into a single array.
   *
   * If any nodes are not expanded, then their children will not be added into the array.
   * This will still traverse all nested children in order to build up our internal data
   * models, but will not include them in the returned array.
   */
  _flattenNestedNodesWithExpansion(nodes, level = 0) {
    const childrenAccessor = this._getChildrenAccessor();
    if (!childrenAccessor) {
      return of([...nodes]);
    }
    return of(...nodes).pipe(concatMap(node => {
      const parentKey = this._getExpansionKey(node);
      if (!this._parents.has(parentKey)) {
        this._parents.set(parentKey, null);
      }
      this._levels.set(parentKey, level);
      const children = coerceObservable(childrenAccessor(node));
      return concat(of([node]), children.pipe(take(1), tap(childNodes => {
        this._ariaSets.set(parentKey, [...(childNodes ?? [])]);
        for (const child of childNodes ?? []) {
          const childKey = this._getExpansionKey(child);
          this._parents.set(childKey, node);
          this._levels.set(childKey, level + 1);
        }
      }), switchMap(childNodes => {
        if (!childNodes) {
          return of([]);
        }
        return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(map(nestedNodes => this.isExpanded(node) ? nestedNodes : []));
      })));
    }), reduce((results, children) => {
      results.push(...children);
      return results;
    }, []));
  }
  /**
   * Converts children for certain tree configurations.
   *
   * This also computes parent, level, and group data.
   */
  _computeRenderingData(nodes, nodeType) {
    if (this.childrenAccessor && nodeType === "flat") {
      this._clearPreviousCache();
      this._ariaSets.set(null, [...nodes]);
      return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({
        renderNodes: flattenedNodes,
        flattenedNodes
      })));
    } else if (this.levelAccessor && nodeType === "nested") {
      const levelAccessor = this.levelAccessor;
      return of(nodes.filter(node => levelAccessor(node) === 0)).pipe(map(rootNodes => ({
        renderNodes: rootNodes,
        flattenedNodes: nodes
      })), tap(({
        flattenedNodes
      }) => {
        this._calculateParents(flattenedNodes);
      }));
    } else if (nodeType === "flat") {
      return of({
        renderNodes: nodes,
        flattenedNodes: nodes
      }).pipe(tap(({
        flattenedNodes
      }) => {
        this._calculateParents(flattenedNodes);
      }));
    } else {
      this._clearPreviousCache();
      this._ariaSets.set(null, [...nodes]);
      return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({
        renderNodes: nodes,
        flattenedNodes
      })));
    }
  }
  _updateCachedData(flattenedNodes) {
    this._flattenedNodes.next(flattenedNodes);
  }
  _updateKeyManagerItems(flattenedNodes) {
    this._keyManagerNodes.next(flattenedNodes);
  }
  /** Traverse the flattened node data and compute parents, levels, and group data. */
  _calculateParents(flattenedNodes) {
    const levelAccessor = this._getLevelAccessor();
    if (!levelAccessor) {
      return;
    }
    this._clearPreviousCache();
    for (let index = 0; index < flattenedNodes.length; index++) {
      const dataNode = flattenedNodes[index];
      const key = this._getExpansionKey(dataNode);
      this._levels.set(key, levelAccessor(dataNode));
      const parent2 = this._findParentForNode(dataNode, index, flattenedNodes);
      this._parents.set(key, parent2);
      const parentKey = parent2 ? this._getExpansionKey(parent2) : null;
      const group = this._ariaSets.get(parentKey) ?? [];
      group.splice(index, 0, dataNode);
      this._ariaSets.set(parentKey, group);
    }
  }
  /** Invokes a callback with all node expansion keys. */
  _forEachExpansionKey(callback) {
    const toToggle = [];
    const observables = [];
    this._nodes.value.forEach(node => {
      toToggle.push(this._getExpansionKey(node.data));
      observables.push(this._getDescendants(node.data));
    });
    if (observables.length > 0) {
      combineLatest(observables).pipe(take(1), takeUntil(this._onDestroy)).subscribe(results => {
        results.forEach(inner => inner.forEach(r2 => toToggle.push(this._getExpansionKey(r2))));
        callback(toToggle);
      });
    } else {
      callback(toToggle);
    }
  }
  /** Clears the maps we use to store parents, level & aria-sets in. */
  _clearPreviousCache() {
    this._parents.clear();
    this._levels.clear();
    this._ariaSets.clear();
  }
  static ɵfac = function CdkTree_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTree)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _CdkTree,
    selectors: [["cdk-tree"]],
    contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._nodeDefs = _t2);
      }
    },
    viewQuery: function CdkTree_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(CdkTreeNodeOutlet, 7);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._nodeOutlet = _t2.first);
      }
    },
    hostAttrs: ["role", "tree", 1, "cdk-tree"],
    hostBindings: function CdkTree_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function CdkTree_keydown_HostBindingHandler($event) {
          return ctx._sendKeydownToKeyManager($event);
        });
      }
    },
    inputs: {
      dataSource: "dataSource",
      treeControl: "treeControl",
      levelAccessor: "levelAccessor",
      childrenAccessor: "childrenAccessor",
      trackBy: "trackBy",
      expansionKey: "expansionKey"
    },
    exportAs: ["cdkTree"],
    decls: 1,
    vars: 0,
    consts: [["cdkTreeNodeOutlet", ""]],
    template: function CdkTree_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [CdkTreeNodeOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTree, [{
    type: Component,
    args: [{
      selector: "cdk-tree",
      exportAs: "cdkTree",
      template: `<ng-container cdkTreeNodeOutlet></ng-container>`,
      host: {
        "class": "cdk-tree",
        "role": "tree",
        "(keydown)": "_sendKeydownToKeyManager($event)"
      },
      encapsulation: ViewEncapsulation.None,
      // The "OnPush" status for the `CdkTree` component is effectively a noop, so we are removing it.
      // The view for `CdkTree` consists entirely of templates declared in other views. As they are
      // declared elsewhere, they are checked when their declaration points are checked.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      imports: [CdkTreeNodeOutlet]
    }]
  }], () => [], {
    dataSource: [{
      type: Input
    }],
    treeControl: [{
      type: Input
    }],
    levelAccessor: [{
      type: Input
    }],
    childrenAccessor: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    expansionKey: [{
      type: Input
    }],
    _nodeOutlet: [{
      type: ViewChild,
      args: [CdkTreeNodeOutlet, {
        static: true
      }]
    }],
    _nodeDefs: [{
      type: ContentChildren,
      args: [CdkTreeNodeDef, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var CdkTreeNode = class _CdkTreeNode {
  _elementRef = inject(ElementRef);
  _tree = inject(CdkTree);
  _tabindex = -1;
  _type = "flat";
  /**
   * The role of the tree node.
   *
   * @deprecated This will be ignored; the tree will automatically determine the appropriate role
   * for tree node. This input will be removed in a future version.
   * @breaking-change 21.0.0
   */
  get role() {
    return "treeitem";
  }
  set role(_role) {}
  /**
   * Whether or not this node is expandable.
   *
   * If not using `FlatTreeControl`, or if `isExpandable` is not provided to
   * `NestedTreeControl`, this should be provided for correct node a11y.
   */
  get isExpandable() {
    return this._isExpandable();
  }
  set isExpandable(isExpandable) {
    this._inputIsExpandable = isExpandable;
    if (this.data && !this._isExpandable || !this._inputIsExpandable) {
      return;
    }
    if (this._inputIsExpanded) {
      this.expand();
    } else if (this._inputIsExpanded === false) {
      this.collapse();
    }
  }
  get isExpanded() {
    return this._tree.isExpanded(this._data);
  }
  set isExpanded(isExpanded) {
    this._inputIsExpanded = isExpanded;
    if (isExpanded) {
      this.expand();
    } else {
      this.collapse();
    }
  }
  /**
   * Whether or not this node is disabled. If it's disabled, then the user won't be able to focus
   * or activate this node.
   */
  isDisabled;
  /**
   * The text used to locate this item during typeahead. If not specified, the `textContent` will
   * will be used.
   */
  typeaheadLabel;
  getLabel() {
    return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || "";
  }
  /** This emits when the node has been programatically activated or activated by keyboard. */
  activation = new EventEmitter();
  /** This emits when the node's expansion status has been changed. */
  expandedChange = new EventEmitter();
  /**
   * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it
   * in `CdkTree` and set the data to it.
   */
  static mostRecentTreeNode = null;
  /** Subject that emits when the component has been destroyed. */
  _destroyed = new Subject();
  /** Emits when the node's data has changed. */
  _dataChanges = new Subject();
  _inputIsExpandable = false;
  _inputIsExpanded = void 0;
  /**
   * Flag used to determine whether or not we should be focusing the actual element based on
   * some user interaction (click or focus). On click, we don't forcibly focus the element
   * since the click could trigger some other component that wants to grab its own focus
   * (e.g. menu, dialog).
   */
  _shouldFocus = true;
  _parentNodeAriaLevel;
  /** The tree node's data. */
  get data() {
    return this._data;
  }
  set data(value) {
    if (value !== this._data) {
      this._data = value;
      this._dataChanges.next();
    }
  }
  _data;
  /* If leaf node, return true to not assign aria-expanded attribute */
  get isLeafNode() {
    if (this._tree.treeControl?.isExpandable !== void 0 && !this._tree.treeControl.isExpandable(this._data)) {
      return true;
    } else if (this._tree.treeControl?.isExpandable === void 0 && this._tree.treeControl?.getDescendants(this._data).length === 0) {
      return true;
    }
    return false;
  }
  get level() {
    return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;
  }
  /** Determines if the tree node is expandable. */
  _isExpandable() {
    if (this._tree.treeControl) {
      if (this.isLeafNode) {
        return false;
      }
      return true;
    }
    return this._inputIsExpandable;
  }
  /**
   * Determines the value for `aria-expanded`.
   *
   * For non-expandable nodes, this is `null`.
   */
  _getAriaExpanded() {
    if (!this._isExpandable()) {
      return null;
    }
    return String(this.isExpanded);
  }
  /**
   * Determines the size of this node's parent's child set.
   *
   * This is intended to be used for `aria-setsize`.
   */
  _getSetSize() {
    return this._tree._getSetSize(this._data);
  }
  /**
   * Determines the index (starting from 1) of this node in its parent's child set.
   *
   * This is intended to be used for `aria-posinset`.
   */
  _getPositionInSet() {
    return this._tree._getPositionInSet(this._data);
  }
  _changeDetectorRef = inject(ChangeDetectorRef);
  constructor() {
    _CdkTreeNode.mostRecentTreeNode = this;
  }
  ngOnInit() {
    this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);
    this._tree._getExpansionModel().changed.pipe(map(() => this.isExpanded), distinctUntilChanged()).subscribe(() => this._changeDetectorRef.markForCheck());
    this._tree._setNodeTypeIfUnset(this._type);
    this._tree._registerNode(this);
  }
  ngOnDestroy() {
    if (_CdkTreeNode.mostRecentTreeNode === this) {
      _CdkTreeNode.mostRecentTreeNode = null;
    }
    this._dataChanges.complete();
    this._destroyed.next();
    this._destroyed.complete();
  }
  getParent() {
    return this._tree._getNodeParent(this) ?? null;
  }
  getChildren() {
    return this._tree._getNodeChildren(this);
  }
  /** Focuses this data node. Implemented for TreeKeyManagerItem. */
  focus() {
    this._tabindex = 0;
    if (this._shouldFocus) {
      this._elementRef.nativeElement.focus();
    }
    this._changeDetectorRef.markForCheck();
  }
  /** Defocus this data node. */
  unfocus() {
    this._tabindex = -1;
    this._changeDetectorRef.markForCheck();
  }
  /** Emits an activation event. Implemented for TreeKeyManagerItem. */
  activate() {
    if (this.isDisabled) {
      return;
    }
    this.activation.next(this._data);
  }
  /** Collapses this data node. Implemented for TreeKeyManagerItem. */
  collapse() {
    if (this.isExpandable) {
      this._tree.collapse(this._data);
    }
  }
  /** Expands this data node. Implemented for TreeKeyManagerItem. */
  expand() {
    if (this.isExpandable) {
      this._tree.expand(this._data);
    }
  }
  /** Makes the node focusable. Implemented for TreeKeyManagerItem. */
  makeFocusable() {
    this._tabindex = 0;
    this._changeDetectorRef.markForCheck();
  }
  _focusItem() {
    if (this.isDisabled) {
      return;
    }
    this._tree._keyManager.focusItem(this);
  }
  _setActiveItem() {
    if (this.isDisabled) {
      return;
    }
    this._shouldFocus = false;
    this._tree._keyManager.focusItem(this);
    this._shouldFocus = true;
  }
  _emitExpansionState(expanded) {
    this.expandedChange.emit(expanded);
  }
  static ɵfac = function CdkTreeNode_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTreeNode)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkTreeNode,
    selectors: [["cdk-tree-node"]],
    hostAttrs: ["role", "treeitem", 1, "cdk-tree-node"],
    hostVars: 5,
    hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function CdkTreeNode_click_HostBindingHandler() {
          return ctx._setActiveItem();
        })("focus", function CdkTreeNode_focus_HostBindingHandler() {
          return ctx._focusItem();
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("tabindex", ctx._tabindex);
        ɵɵattribute("aria-expanded", ctx._getAriaExpanded())("aria-level", ctx.level + 1)("aria-posinset", ctx._getPositionInSet())("aria-setsize", ctx._getSetSize());
      }
    },
    inputs: {
      role: "role",
      isExpandable: [2, "isExpandable", "isExpandable", booleanAttribute],
      isExpanded: "isExpanded",
      isDisabled: [2, "isDisabled", "isDisabled", booleanAttribute],
      typeaheadLabel: [0, "cdkTreeNodeTypeaheadLabel", "typeaheadLabel"]
    },
    outputs: {
      activation: "activation",
      expandedChange: "expandedChange"
    },
    exportAs: ["cdkTreeNode"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNode, [{
    type: Directive,
    args: [{
      selector: "cdk-tree-node",
      exportAs: "cdkTreeNode",
      host: {
        "class": "cdk-tree-node",
        "[attr.aria-expanded]": "_getAriaExpanded()",
        "[attr.aria-level]": "level + 1",
        "[attr.aria-posinset]": "_getPositionInSet()",
        "[attr.aria-setsize]": "_getSetSize()",
        "[tabindex]": "_tabindex",
        "role": "treeitem",
        "(click)": "_setActiveItem()",
        "(focus)": "_focusItem()"
      }
    }]
  }], () => [], {
    role: [{
      type: Input
    }],
    isExpandable: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    isExpanded: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    typeaheadLabel: [{
      type: Input,
      args: ["cdkTreeNodeTypeaheadLabel"]
    }],
    activation: [{
      type: Output
    }],
    expandedChange: [{
      type: Output
    }]
  });
})();
function getParentNodeAriaLevel(nodeElement) {
  let parent2 = nodeElement.parentElement;
  while (parent2 && !isNodeElement(parent2)) {
    parent2 = parent2.parentElement;
  }
  if (!parent2) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw Error("Incorrect tree structure containing detached node.");
    } else {
      return -1;
    }
  } else if (parent2.classList.contains("cdk-nested-tree-node")) {
    return numberAttribute(parent2.getAttribute("aria-level"));
  } else {
    return 0;
  }
}
function isNodeElement(element) {
  const classList = element.classList;
  return !!(classList?.contains("cdk-nested-tree-node") || classList?.contains("cdk-tree"));
}
var CdkNestedTreeNode = class _CdkNestedTreeNode extends CdkTreeNode {
  _type = "nested";
  _differs = inject(IterableDiffers);
  /** Differ used to find the changes in the data provided by the data source. */
  _dataDiffer;
  /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */
  _children;
  /** The children node placeholder. */
  nodeOutlet;
  constructor() {
    super();
  }
  ngAfterContentInit() {
    this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);
    this._tree._getDirectChildren(this.data).pipe(takeUntil(this._destroyed)).subscribe(result => this.updateChildrenNodes(result));
    this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(() => this.updateChildrenNodes());
  }
  ngOnDestroy() {
    this._clear();
    super.ngOnDestroy();
  }
  /** Add children dataNodes to the NodeOutlet */
  updateChildrenNodes(children) {
    const outlet = this._getNodeOutlet();
    if (children) {
      this._children = children;
    }
    if (outlet && this._children) {
      const viewContainer = outlet.viewContainer;
      this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);
    } else {
      this._dataDiffer.diff([]);
    }
  }
  /** Clear the children dataNodes. */
  _clear() {
    const outlet = this._getNodeOutlet();
    if (outlet) {
      outlet.viewContainer.clear();
      this._dataDiffer.diff([]);
    }
  }
  /** Gets the outlet for the current node. */
  _getNodeOutlet() {
    const outlets = this.nodeOutlet;
    return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);
  }
  static ɵfac = function CdkNestedTreeNode_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkNestedTreeNode)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkNestedTreeNode,
    selectors: [["cdk-nested-tree-node"]],
    contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.nodeOutlet = _t2);
      }
    },
    hostAttrs: [1, "cdk-nested-tree-node"],
    exportAs: ["cdkNestedTreeNode"],
    features: [ɵɵProvidersFeature([{
      provide: CdkTreeNode,
      useExisting: _CdkNestedTreeNode
    }, {
      provide: CDK_TREE_NODE_OUTLET_NODE,
      useExisting: _CdkNestedTreeNode
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkNestedTreeNode, [{
    type: Directive,
    args: [{
      selector: "cdk-nested-tree-node",
      exportAs: "cdkNestedTreeNode",
      providers: [{
        provide: CdkTreeNode,
        useExisting: CdkNestedTreeNode
      }, {
        provide: CDK_TREE_NODE_OUTLET_NODE,
        useExisting: CdkNestedTreeNode
      }],
      host: {
        "class": "cdk-nested-tree-node"
      }
    }]
  }], () => [], {
    nodeOutlet: [{
      type: ContentChildren,
      args: [CdkTreeNodeOutlet, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var cssUnitPattern = /([A-Za-z%]+)$/;
var CdkTreeNodePadding = class _CdkTreeNodePadding {
  _treeNode = inject(CdkTreeNode);
  _tree = inject(CdkTree);
  _element = inject(ElementRef);
  _dir = inject(Directionality, {
    optional: true
  });
  /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */
  _currentPadding;
  /** Subject that emits when the component has been destroyed. */
  _destroyed = new Subject();
  /** CSS units used for the indentation value. */
  indentUnits = "px";
  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
  get level() {
    return this._level;
  }
  set level(value) {
    this._setLevelInput(value);
  }
  _level;
  /**
   * The indent for each level. Can be a number or a CSS string.
   * Default number 40px from material design menu sub-menu spec.
   */
  get indent() {
    return this._indent;
  }
  set indent(indent) {
    this._setIndentInput(indent);
  }
  _indent = 40;
  constructor() {
    this._setPadding();
    this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));
    this._treeNode._dataChanges.subscribe(() => this._setPadding());
  }
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** The padding indent value for the tree node. Returns a string with px numbers if not null. */
  _paddingIndent() {
    const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;
    const level = this._level == null ? nodeLevel : this._level;
    return typeof level === "number" ? `${level * this._indent}${this.indentUnits}` : null;
  }
  _setPadding(forceChange = false) {
    const padding = this._paddingIndent();
    if (padding !== this._currentPadding || forceChange) {
      const element = this._element.nativeElement;
      const paddingProp = this._dir && this._dir.value === "rtl" ? "paddingRight" : "paddingLeft";
      const resetProp = paddingProp === "paddingLeft" ? "paddingRight" : "paddingLeft";
      element.style[paddingProp] = padding || "";
      element.style[resetProp] = "";
      this._currentPadding = padding;
    }
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setLevelInput(value) {
    this._level = isNaN(value) ? null : value;
    this._setPadding();
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setIndentInput(indent) {
    let value = indent;
    let units = "px";
    if (typeof indent === "string") {
      const parts = indent.split(cssUnitPattern);
      value = parts[0];
      units = parts[1] || units;
    }
    this.indentUnits = units;
    this._indent = numberAttribute(value);
    this._setPadding();
  }
  static ɵfac = function CdkTreeNodePadding_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTreeNodePadding)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkTreeNodePadding,
    selectors: [["", "cdkTreeNodePadding", ""]],
    inputs: {
      level: [2, "cdkTreeNodePadding", "level", numberAttribute],
      indent: [0, "cdkTreeNodePaddingIndent", "indent"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodePadding, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodePadding]"
    }]
  }], () => [], {
    level: [{
      type: Input,
      args: [{
        alias: "cdkTreeNodePadding",
        transform: numberAttribute
      }]
    }],
    indent: [{
      type: Input,
      args: ["cdkTreeNodePaddingIndent"]
    }]
  });
})();
var CdkTreeNodeToggle = class _CdkTreeNodeToggle {
  _tree = inject(CdkTree);
  _treeNode = inject(CdkTreeNode);
  /** Whether expand/collapse the node recursively. */
  recursive = false;
  constructor() {}
  // Toggle the expanded or collapsed state of this node.
  //
  // Focus this node with expanding or collapsing it. This ensures that the active node will always
  // be visible when expanding and collapsing.
  _toggle() {
    this.recursive ? this._tree.toggleDescendants(this._treeNode.data) : this._tree.toggle(this._treeNode.data);
    this._tree._keyManager.focusItem(this._treeNode);
  }
  static ɵfac = function CdkTreeNodeToggle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTreeNodeToggle)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkTreeNodeToggle,
    selectors: [["", "cdkTreeNodeToggle", ""]],
    hostAttrs: ["tabindex", "-1"],
    hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function CdkTreeNodeToggle_click_HostBindingHandler($event) {
          ctx._toggle();
          return $event.stopPropagation();
        })("keydown.Enter", function CdkTreeNodeToggle_keydown_Enter_HostBindingHandler($event) {
          ctx._toggle();
          return $event.preventDefault();
        })("keydown.Space", function CdkTreeNodeToggle_keydown_Space_HostBindingHandler($event) {
          ctx._toggle();
          return $event.preventDefault();
        });
      }
    },
    inputs: {
      recursive: [2, "cdkTreeNodeToggleRecursive", "recursive", booleanAttribute]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeToggle, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeToggle]",
      host: {
        "(click)": "_toggle(); $event.stopPropagation();",
        "(keydown.Enter)": "_toggle(); $event.preventDefault();",
        "(keydown.Space)": "_toggle(); $event.preventDefault();",
        "tabindex": "-1"
      }
    }]
  }], () => [], {
    recursive: [{
      type: Input,
      args: [{
        alias: "cdkTreeNodeToggleRecursive",
        transform: booleanAttribute
      }]
    }]
  });
})();
var EXPORTED_DECLARATIONS3 = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];
var CdkTreeModule = class _CdkTreeModule {
  static ɵfac = function CdkTreeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTreeModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _CdkTreeModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeModule, [{
    type: NgModule,
    args: [{
      imports: EXPORTED_DECLARATIONS3,
      exports: EXPORTED_DECLARATIONS3
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2022/tree.mjs
function isNoopTreeKeyManager(keyManager) {
  return !!keyManager._isNoopTreeKeyManager;
}
var MatTreeNode = class _MatTreeNode extends CdkTreeNode {
  /**
   * The tabindex of the tree node.
   *
   * @deprecated By default MatTreeNode manages focus using TreeKeyManager instead of tabIndex.
   *   Recommend to avoid setting tabIndex directly to prevent TreeKeyManager form getting into
   *   an unexpected state. Tabindex to be removed in a future version.
   * @breaking-change 21.0.0 Remove this attribute.
   */
  get tabIndexInputBinding() {
    return this._tabIndexInputBinding;
  }
  set tabIndexInputBinding(value) {
    this._tabIndexInputBinding = value;
  }
  _tabIndexInputBinding;
  /**
   * The default tabindex of the tree node.
   *
   * @deprecated By default MatTreeNode manages focus using TreeKeyManager instead of tabIndex.
   *   Recommend to avoid setting tabIndex directly to prevent TreeKeyManager form getting into
   *   an unexpected state. Tabindex to be removed in a future version.
   * @breaking-change 21.0.0 Remove this attribute.
   */
  defaultTabIndex = 0;
  _getTabindexAttribute() {
    if (isNoopTreeKeyManager(this._tree._keyManager)) {
      return this.tabIndexInputBinding;
    }
    return this._tabindex;
  }
  /**
   * Whether the component is disabled.
   *
   * @deprecated This is an alias for `isDisabled`.
   * @breaking-change 21.0.0 Remove this input
   */
  get disabled() {
    return this.isDisabled;
  }
  set disabled(value) {
    this.isDisabled = value;
  }
  constructor() {
    super();
    const tabIndex = inject(new HostAttributeToken("tabindex"), {
      optional: true
    });
    this.tabIndexInputBinding = Number(tabIndex) || this.defaultTabIndex;
  }
  // This is a workaround for https://github.com/angular/angular/issues/23091
  // In aot mode, the lifecycle hooks from parent class are not called.
  ngOnInit() {
    super.ngOnInit();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
  }
  static ɵfac = function MatTreeNode_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatTreeNode)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatTreeNode,
    selectors: [["mat-tree-node"]],
    hostAttrs: [1, "mat-tree-node"],
    hostVars: 5,
    hostBindings: function MatTreeNode_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function MatTreeNode_click_HostBindingHandler() {
          return ctx._focusItem();
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("tabindex", ctx._getTabindexAttribute());
        ɵɵattribute("aria-expanded", ctx._getAriaExpanded())("aria-level", ctx.level + 1)("aria-posinset", ctx._getPositionInSet())("aria-setsize", ctx._getSetSize());
      }
    },
    inputs: {
      tabIndexInputBinding: [2, "tabIndex", "tabIndexInputBinding", value => value == null ? 0 : numberAttribute(value)],
      disabled: [2, "disabled", "disabled", booleanAttribute]
    },
    outputs: {
      activation: "activation",
      expandedChange: "expandedChange"
    },
    exportAs: ["matTreeNode"],
    features: [ɵɵProvidersFeature([{
      provide: CdkTreeNode,
      useExisting: _MatTreeNode
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNode, [{
    type: Directive,
    args: [{
      selector: "mat-tree-node",
      exportAs: "matTreeNode",
      outputs: ["activation", "expandedChange"],
      providers: [{
        provide: CdkTreeNode,
        useExisting: MatTreeNode
      }],
      host: {
        "class": "mat-tree-node",
        "[attr.aria-expanded]": "_getAriaExpanded()",
        "[attr.aria-level]": "level + 1",
        "[attr.aria-posinset]": "_getPositionInSet()",
        "[attr.aria-setsize]": "_getSetSize()",
        "(click)": "_focusItem()",
        "[tabindex]": "_getTabindexAttribute()"
      }
    }]
  }], () => [], {
    tabIndexInputBinding: [{
      type: Input,
      args: [{
        transform: value => value == null ? 0 : numberAttribute(value),
        alias: "tabIndex"
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var MatTreeNodeDef = class _MatTreeNodeDef extends CdkTreeNodeDef {
  data;
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatTreeNodeDef_BaseFactory;
    return function MatTreeNodeDef_Factory(__ngFactoryType__) {
      return (ɵMatTreeNodeDef_BaseFactory || (ɵMatTreeNodeDef_BaseFactory = ɵɵgetInheritedFactory(_MatTreeNodeDef)))(__ngFactoryType__ || _MatTreeNodeDef);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatTreeNodeDef,
    selectors: [["", "matTreeNodeDef", ""]],
    inputs: {
      when: [0, "matTreeNodeDefWhen", "when"],
      data: [0, "matTreeNode", "data"]
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkTreeNodeDef,
      useExisting: _MatTreeNodeDef
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeDef, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeDef]",
      inputs: [{
        name: "when",
        alias: "matTreeNodeDefWhen"
      }],
      providers: [{
        provide: CdkTreeNodeDef,
        useExisting: MatTreeNodeDef
      }]
    }]
  }], null, {
    data: [{
      type: Input,
      args: ["matTreeNode"]
    }]
  });
})();
var MatNestedTreeNode = class _MatNestedTreeNode extends CdkNestedTreeNode {
  node;
  /**
   * Whether the node is disabled.
   *
   * @deprecated This is an alias for `isDisabled`.
   * @breaking-change 21.0.0 Remove this input
   */
  get disabled() {
    return this.isDisabled;
  }
  set disabled(value) {
    this.isDisabled = value;
  }
  /** Tabindex of the node. */
  get tabIndex() {
    return this.isDisabled ? -1 : this._tabIndex;
  }
  set tabIndex(value) {
    this._tabIndex = value;
  }
  _tabIndex;
  // This is a workaround for https://github.com/angular/angular/issues/19145
  // In aot mode, the lifecycle hooks from parent class are not called.
  // TODO(tinayuangao): Remove when the angular issue #19145 is fixed
  ngOnInit() {
    super.ngOnInit();
  }
  ngAfterContentInit() {
    super.ngAfterContentInit();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatNestedTreeNode_BaseFactory;
    return function MatNestedTreeNode_Factory(__ngFactoryType__) {
      return (ɵMatNestedTreeNode_BaseFactory || (ɵMatNestedTreeNode_BaseFactory = ɵɵgetInheritedFactory(_MatNestedTreeNode)))(__ngFactoryType__ || _MatNestedTreeNode);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatNestedTreeNode,
    selectors: [["mat-nested-tree-node"]],
    hostAttrs: [1, "mat-nested-tree-node"],
    inputs: {
      node: [0, "matNestedTreeNode", "node"],
      disabled: [2, "disabled", "disabled", booleanAttribute],
      tabIndex: [2, "tabIndex", "tabIndex", value => value == null ? 0 : numberAttribute(value)]
    },
    outputs: {
      activation: "activation",
      expandedChange: "expandedChange"
    },
    exportAs: ["matNestedTreeNode"],
    features: [ɵɵProvidersFeature([{
      provide: CdkNestedTreeNode,
      useExisting: _MatNestedTreeNode
    }, {
      provide: CdkTreeNode,
      useExisting: _MatNestedTreeNode
    }, {
      provide: CDK_TREE_NODE_OUTLET_NODE,
      useExisting: _MatNestedTreeNode
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatNestedTreeNode, [{
    type: Directive,
    args: [{
      selector: "mat-nested-tree-node",
      exportAs: "matNestedTreeNode",
      outputs: ["activation", "expandedChange"],
      providers: [{
        provide: CdkNestedTreeNode,
        useExisting: MatNestedTreeNode
      }, {
        provide: CdkTreeNode,
        useExisting: MatNestedTreeNode
      }, {
        provide: CDK_TREE_NODE_OUTLET_NODE,
        useExisting: MatNestedTreeNode
      }],
      host: {
        "class": "mat-nested-tree-node"
      }
    }]
  }], null, {
    node: [{
      type: Input,
      args: ["matNestedTreeNode"]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    tabIndex: [{
      type: Input,
      args: [{
        transform: value => value == null ? 0 : numberAttribute(value)
      }]
    }]
  });
})();
var MatTreeNodePadding = class _MatTreeNodePadding extends CdkTreeNodePadding {
  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
  get level() {
    return this._level;
  }
  set level(value) {
    this._setLevelInput(value);
  }
  /** The indent for each level. Default number 40px from material design menu sub-menu spec. */
  get indent() {
    return this._indent;
  }
  set indent(indent) {
    this._setIndentInput(indent);
  }
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatTreeNodePadding_BaseFactory;
    return function MatTreeNodePadding_Factory(__ngFactoryType__) {
      return (ɵMatTreeNodePadding_BaseFactory || (ɵMatTreeNodePadding_BaseFactory = ɵɵgetInheritedFactory(_MatTreeNodePadding)))(__ngFactoryType__ || _MatTreeNodePadding);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatTreeNodePadding,
    selectors: [["", "matTreeNodePadding", ""]],
    inputs: {
      level: [2, "matTreeNodePadding", "level", numberAttribute],
      indent: [0, "matTreeNodePaddingIndent", "indent"]
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkTreeNodePadding,
      useExisting: _MatTreeNodePadding
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodePadding, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodePadding]",
      providers: [{
        provide: CdkTreeNodePadding,
        useExisting: MatTreeNodePadding
      }]
    }]
  }], null, {
    level: [{
      type: Input,
      args: [{
        alias: "matTreeNodePadding",
        transform: numberAttribute
      }]
    }],
    indent: [{
      type: Input,
      args: ["matTreeNodePaddingIndent"]
    }]
  });
})();
var MatTreeNodeOutlet = class _MatTreeNodeOutlet {
  viewContainer = inject(ViewContainerRef);
  _node = inject(CDK_TREE_NODE_OUTLET_NODE, {
    optional: true
  });
  static ɵfac = function MatTreeNodeOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatTreeNodeOutlet)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatTreeNodeOutlet,
    selectors: [["", "matTreeNodeOutlet", ""]],
    features: [ɵɵProvidersFeature([{
      provide: CdkTreeNodeOutlet,
      useExisting: _MatTreeNodeOutlet
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeOutlet, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeOutlet]",
      providers: [{
        provide: CdkTreeNodeOutlet,
        useExisting: MatTreeNodeOutlet
      }]
    }]
  }], null, null);
})();
var MatTree = class _MatTree extends CdkTree {
  // Outlets within the tree's template where the dataNodes will be inserted.
  // We need an initializer here to avoid a TS error. The value will be set in `ngAfterViewInit`.
  _nodeOutlet = void 0;
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatTree_BaseFactory;
    return function MatTree_Factory(__ngFactoryType__) {
      return (ɵMatTree_BaseFactory || (ɵMatTree_BaseFactory = ɵɵgetInheritedFactory(_MatTree)))(__ngFactoryType__ || _MatTree);
    };
  })();
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatTree,
    selectors: [["mat-tree"]],
    viewQuery: function MatTree_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(MatTreeNodeOutlet, 7);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._nodeOutlet = _t2.first);
      }
    },
    hostAttrs: [1, "mat-tree"],
    exportAs: ["matTree"],
    features: [ɵɵProvidersFeature([{
      provide: CdkTree,
      useExisting: _MatTree
    }]), ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 0,
    consts: [["matTreeNodeOutlet", ""]],
    template: function MatTree_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
    },
    dependencies: [MatTreeNodeOutlet],
    styles: [".mat-tree{display:block;background-color:var(--mat-tree-container-background-color, var(--mat-sys-surface))}.mat-tree-node,.mat-nested-tree-node{color:var(--mat-tree-node-text-color, var(--mat-sys-on-surface));font-family:var(--mat-tree-node-text-font, var(--mat-sys-body-large-font));font-size:var(--mat-tree-node-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-tree-node-text-weight, var(--mat-sys-body-large-weight))}.mat-tree-node{display:flex;align-items:center;flex:1;word-wrap:break-word;min-height:var(--mat-tree-node-min-height, 48px)}.mat-nested-tree-node{border-bottom-width:0}"],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTree, [{
    type: Component,
    args: [{
      selector: "mat-tree",
      exportAs: "matTree",
      template: `<ng-container matTreeNodeOutlet></ng-container>`,
      host: {
        "class": "mat-tree"
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.Default,
      providers: [{
        provide: CdkTree,
        useExisting: MatTree
      }],
      imports: [MatTreeNodeOutlet],
      styles: [".mat-tree{display:block;background-color:var(--mat-tree-container-background-color, var(--mat-sys-surface))}.mat-tree-node,.mat-nested-tree-node{color:var(--mat-tree-node-text-color, var(--mat-sys-on-surface));font-family:var(--mat-tree-node-text-font, var(--mat-sys-body-large-font));font-size:var(--mat-tree-node-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-tree-node-text-weight, var(--mat-sys-body-large-weight))}.mat-tree-node{display:flex;align-items:center;flex:1;word-wrap:break-word;min-height:var(--mat-tree-node-min-height, 48px)}.mat-nested-tree-node{border-bottom-width:0}"]
    }]
  }], null, {
    _nodeOutlet: [{
      type: ViewChild,
      args: [MatTreeNodeOutlet, {
        static: true
      }]
    }]
  });
})();
var MatTreeNodeToggle = class _MatTreeNodeToggle extends CdkTreeNodeToggle {
  static ɵfac = /* @__PURE__ */(() => {
    let ɵMatTreeNodeToggle_BaseFactory;
    return function MatTreeNodeToggle_Factory(__ngFactoryType__) {
      return (ɵMatTreeNodeToggle_BaseFactory || (ɵMatTreeNodeToggle_BaseFactory = ɵɵgetInheritedFactory(_MatTreeNodeToggle)))(__ngFactoryType__ || _MatTreeNodeToggle);
    };
  })();
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatTreeNodeToggle,
    selectors: [["", "matTreeNodeToggle", ""]],
    inputs: {
      recursive: [0, "matTreeNodeToggleRecursive", "recursive"]
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkTreeNodeToggle,
      useExisting: _MatTreeNodeToggle
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeToggle, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeToggle]",
      providers: [{
        provide: CdkTreeNodeToggle,
        useExisting: MatTreeNodeToggle
      }],
      inputs: [{
        name: "recursive",
        alias: "matTreeNodeToggleRecursive"
      }]
    }]
  }], null, null);
})();
var MAT_TREE_DIRECTIVES = [MatNestedTreeNode, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatTreeNodeOutlet];
var MatTreeModule = class _MatTreeModule {
  static ɵfac = function MatTreeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatTreeModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatTreeModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [CdkTreeModule, MatCommonModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeModule, [{
    type: NgModule,
    args: [{
      imports: [CdkTreeModule, MatCommonModule, ...MAT_TREE_DIRECTIVES],
      exports: [MatCommonModule, MAT_TREE_DIRECTIVES]
    }]
  }], null, null);
})();
var MatTreeFlattener = class {
  transformFunction;
  getLevel;
  isExpandable;
  getChildren;
  constructor(transformFunction, getLevel, isExpandable, getChildren) {
    this.transformFunction = transformFunction;
    this.getLevel = getLevel;
    this.isExpandable = isExpandable;
    this.getChildren = getChildren;
  }
  _flattenNode(node, level, resultNodes, parentMap) {
    const flatNode = this.transformFunction(node, level);
    resultNodes.push(flatNode);
    if (this.isExpandable(flatNode)) {
      const childrenNodes = this.getChildren(node);
      if (childrenNodes) {
        if (Array.isArray(childrenNodes)) {
          this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
        } else {
          childrenNodes.pipe(take(1)).subscribe(children => {
            this._flattenChildren(children, level, resultNodes, parentMap);
          });
        }
      }
    }
    return resultNodes;
  }
  _flattenChildren(children, level, resultNodes, parentMap) {
    children.forEach((child, index) => {
      let childParentMap = parentMap.slice();
      childParentMap.push(index != children.length - 1);
      this._flattenNode(child, level + 1, resultNodes, childParentMap);
    });
  }
  /**
   * Flatten a list of node type T to flattened version of node F.
   * Please note that type T may be nested, and the length of `structuredData` may be different
   * from that of returned list `F[]`.
   */
  flattenNodes(structuredData) {
    let resultNodes = [];
    structuredData.forEach(node => this._flattenNode(node, 0, resultNodes, []));
    return resultNodes;
  }
  /**
   * Expand flattened node with current expansion status.
   * The returned list may have different length.
   */
  expandFlattenedNodes(nodes, treeControl) {
    let results = [];
    let currentExpand = [];
    currentExpand[0] = true;
    nodes.forEach(node => {
      let expand = true;
      for (let i2 = 0; i2 <= this.getLevel(node); i2++) {
        expand = expand && currentExpand[i2];
      }
      if (expand) {
        results.push(node);
      }
      if (this.isExpandable(node)) {
        currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);
      }
    });
    return results;
  }
};
var MatTreeFlatDataSource = class extends DataSource {
  _treeControl;
  _treeFlattener;
  _flattenedData = new BehaviorSubject([]);
  _expandedData = new BehaviorSubject([]);
  get data() {
    return this._data.value;
  }
  set data(value) {
    this._data.next(value);
    this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
    this._treeControl.dataNodes = this._flattenedData.value;
  }
  _data = new BehaviorSubject([]);
  constructor(_treeControl, _treeFlattener, initialData) {
    super();
    this._treeControl = _treeControl;
    this._treeFlattener = _treeFlattener;
    if (initialData) {
      this.data = initialData;
    }
  }
  connect(collectionViewer) {
    return merge(collectionViewer.viewChange, this._treeControl.expansionModel.changed, this._flattenedData).pipe(map(() => {
      this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this._treeControl));
      return this._expandedData.value;
    }));
  }
  disconnect() {}
};

// libs/ui/src/lib/pages/search-filter/search-filter.component.ts
var _forTrack0 = ($index, $item) => $item.name;
function SearchFilterComponent_For_9_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-chip");
    ɵɵtext(1);
    ɵɵelementStart(2, "button", 12);
    ɵɵlistener("click", function SearchFilterComponent_For_9_For_1_Template_button_click_2_listener() {
      const localeName_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.chipRemoveNode(localeName_r2));
    });
    ɵɵelementStart(3, "mat-icon");
    ɵɵtext(4, "cancel");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const localeName_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1("", localeName_r2, " ");
  }
}
function SearchFilterComponent_For_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, SearchFilterComponent_For_9_For_1_Template, 5, 1, "mat-chip", null, ɵɵrepeaterTrackByIdentity);
  }
  if (rf & 2) {
    const category_r4 = ctx.$implicit;
    ɵɵrepeater(category_r4.localeNames);
  }
}
function SearchFilterComponent_mat_tree_node_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-tree-node", 13)(1, "mat-checkbox", 14);
    ɵɵtwoWayListener("ngModelChange", function SearchFilterComponent_mat_tree_node_14_Template_mat_checkbox_ngModelChange_1_listener($event) {
      const node_r6 = ɵɵrestoreView(_r5).$implicit;
      ɵɵtwoWayBindingSet(node_r6.isChecked, $event) || (node_r6.isChecked = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("change", function SearchFilterComponent_mat_tree_node_14_Template_mat_checkbox_change_1_listener() {
      const node_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onCheckboxChange(node_r6));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const node_r6 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtwoWayProperty("ngModel", node_r6.isChecked);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", node_r6.localeName, " ");
  }
}
function SearchFilterComponent_mat_tree_node_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-tree-node", 13)(1, "button", 15)(2, "mat-icon", 16);
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵtext(4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const node_r7 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("aria-label", "Toggle " + node_r7.name);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.treeControl.isExpanded(node_r7) ? "expand_more" : "chevron_right", " ");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", node_r7.name, " ");
  }
}
var CATEGORIES = [{
  categoryName: "bodyAreas",
  categoryNameLocale: "K\xF6rperbereiche"
}, {
  categoryName: "movements",
  categoryNameLocale: "Bewegungen"
}, {
  categoryName: "startingPositions",
  categoryNameLocale: "Startpositionen"
}, {
  categoryName: "equipment",
  categoryNameLocale: "Ausr\xFCstung"
}];
var SearchFilterComponent = class _SearchFilterComponent {
  constructor() {
    this.bodyAreasService = inject(BodyAreasService);
    this.movementsService = inject(MovementsService);
    this.startingPositionsService = inject(StartingPositionsService);
    this.equipmentService = inject(EquipmentService);
    this.addRemoveDataService = inject(AddRemoveDataService);
    this.localstorageService = inject(LocalstorageService);
    this.shareDataService = inject(ShareDataService);
    this.shareStateService = inject(ShareStateService);
    this.isFetchingData = this.shareStateService.isFetchingData;
    this.subscriptions = new Subscription();
    this.toggleDrawerSignal = output();
    this.categoriesData = [];
    this.filterData = [];
    this._transformer = (node, level) => {
      return {
        expandable: !!node.children && node.children.length > 0,
        name: node.name,
        localeName: node.localeName,
        level,
        categoryName: node.categoryName,
        isChecked: node.isChecked
      };
    };
    this.treeControl = new FlatTreeControl(node => node.level, node => node.expandable);
    this.treeFlattener = new MatTreeFlattener(this._transformer, node => node.level, node => node.expandable, node => node.children);
    this.dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
    this.hasChild = (_2, node) => node.expandable;
  }
  ngOnInit() {
    this.selectedLanguage = this._getUserLanguageToken();
    console.log(this.selectedLanguage);
    const observables = [this._getBodyAreas(), this._getMovements(), this._getStartingPositions(), this._getEquipment()];
    const subscription = forkJoin(observables).subscribe({
      next: data => {
        data.forEach((category, i2) => {
          const categoryNameLocale = CATEGORIES[i2].categoryNameLocale;
          const categoryChildren = [];
          category.forEach(nameValue => {
            categoryChildren.push({
              name: nameValue.name,
              localeName: nameValue.translations[this.selectedLanguage],
              isChecked: false,
              categoryName: CATEGORIES[i2].categoryName
            });
          });
          this.categoriesData.push({
            name: categoryNameLocale,
            children: categoryChildren
          });
        });
        this.dataSource.data = this.categoriesData;
      },
      error: error => {
        console.error(error);
      }
    });
    this.subscriptions.add(subscription);
  }
  // addDataItem(name: string | undefined, value: string): void {
  //   const itemIndex = this.data.findIndex(item => item.name === name);
  //   if (itemIndex !== -1) {
  //     // If the item already exists, add the value to its array
  //     this.data[itemIndex].values.push(value);
  //   } else {
  //     // If the item does not exist, create a new one
  //     this.data.push({ name, values: [value] });
  //   }
  // }
  // removeDataItem(name: string | undefined, value: string): void {
  //   const itemIndex = this.data.findIndex(item => item.name === name);
  //   if (itemIndex !== -1) {
  //     // If the item exists, remove the value from its array
  //     this.data[itemIndex].values = this.data[itemIndex].values.filter(
  //       (v: any) => v !== value,
  //     );
  //     // Remove the entire item if the values array is empty
  //     if (this.data[itemIndex].values.length === 0) {
  //       this.data.splice(itemIndex, 1);
  //     }
  //   }
  // }
  chipRemoveNode(localeNameToRemove) {
    let indexToRemove = 0;
    let nodeToRemove;
    this.addRemoveDataService.dataSignal().forEach(category => {
      nodeToRemove = category.localeNames.find((localeName, i2) => {
        indexToRemove = i2;
        return localeName === localeNameToRemove;
      });
      if (nodeToRemove) {
        this.onCheckboxChange(category, indexToRemove, true);
      }
    });
  }
  onCheckboxChange(node, indexToRemove = 0, toggleChecked) {
    const {
      name,
      localeName,
      categoryName
    } = node;
    console.log(node);
    console.log(indexToRemove);
    this.isFetchingData.set(true);
    if (toggleChecked) {
      const valueChipRemove = node.values?.[indexToRemove];
      const localeNameChipRemove = node.localeNames?.[indexToRemove];
      this.addRemoveDataService.removeDataItem(node.name, valueChipRemove, localeNameChipRemove);
      this.treeControl.dataNodes?.forEach(x2 => {
        if (x2.expandable === false && x2.name === valueChipRemove) {
          console.log(x2);
          x2.isChecked = false;
        }
      });
    }
    if (node.isChecked) {
      this.addRemoveDataService.addDataItem(categoryName, name, localeName);
    } else {
      this.addRemoveDataService.removeDataItem(categoryName, name, localeName);
    }
  }
  resetAll() {
    this.isFetchingData.set(true);
    this.treeControl.dataNodes?.forEach(x2 => {
      if (x2.expandable === false) {
        x2.isChecked = false;
      }
    });
    this.addRemoveDataService.resetAll();
  }
  _getBodyAreas() {
    return this.bodyAreasService.getBodyAreas().pipe(tap(bodyAreasList => {
      this.bodyAreas = bodyAreasList;
      this.bodyAreas = this.bodyAreas.sort((a2, b2) => a2.name.localeCompare(b2.name));
    }));
  }
  _getMovements() {
    return this.movementsService.getMovements().pipe(tap(movementsList => {
      this.movements = movementsList;
      this.movements = this.movements.sort((a2, b2) => a2.name.localeCompare(b2.name));
    }));
  }
  _getStartingPositions() {
    return this.startingPositionsService.getStartingPositions().pipe(tap(startingPositionsList => {
      this.startingPositions = startingPositionsList;
      this.startingPositions = this.startingPositions.sort((a2, b2) => a2.name.localeCompare(b2.name));
    }));
  }
  _getEquipment() {
    return this.equipmentService.getEquipments().pipe(tap(equipmentList => {
      this.equipment = equipmentList;
      this.equipment = this.equipment.sort((a2, b2) => a2.name.localeCompare(b2.name));
    }));
  }
  // private _getMovements() {
  //   this.movementsService.getMovements().subscribe(movementList => {
  //     console.log(movementList);
  //     this.movements = movementList;
  //   });
  // }
  _getUserLanguageToken() {
    return this.localstorageService.getToken("userLanguage")?.split("-")[0];
  }
  toggleDrawer() {
    this.toggleDrawerSignal.emit();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    console.log(this.categoriesData);
    this.resetAll();
    console.log(this.categoriesData);
  }
  static {
    this.ɵfac = function SearchFilterComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SearchFilterComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _SearchFilterComponent,
      selectors: [["ui-search-filter"]],
      outputs: {
        toggleDrawerSignal: "toggleDrawerSignal"
      },
      decls: 16,
      vars: 3,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_FilterExercises_title$$LIBS_UI_SRC_LIB_PAGES_SEARCH_FILTER_SEARCH_FILTER_COMPONENT_TS_0 = goog.getMsg("Filters");
          i18n_0 = MSG_EXTERNAL_FilterExercises_title$$LIBS_UI_SRC_LIB_PAGES_SEARCH_FILTER_SEARCH_FILTER_COMPONENT_TS_0;
        } else {
          i18n_0 = "Filter";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_FilterExercises_clearAllChip$$LIBS_UI_SRC_LIB_PAGES_SEARCH_FILTER_SEARCH_FILTER_COMPONENT_TS_1 = goog.getMsg("Clear all");
          i18n_1 = MSG_EXTERNAL_FilterExercises_clearAllChip$$LIBS_UI_SRC_LIB_PAGES_SEARCH_FILTER_SEARCH_FILTER_COMPONENT_TS_1;
        } else {
          i18n_1 = "Alles l\xF6schen";
        }
        return [i18n_0, i18n_1, [1, "filter-title-wrapper"], [1, "title", "mat-title-large"], ["mat-icon-button", "", "aria-label", "Icon button with a close icon", 3, "click"], [1, "chips-selection-wrapper"], ["aria-label", "Category selection"], [1, "clear-filter", 3, "click"], [1, "category-data"], [1, "custom-mat-tree", 3, "dataSource", "treeControl"], ["matTreeNodePadding", "", 4, "matTreeNodeDef"], ["matTreeNodePadding", "", 4, "matTreeNodeDef", "matTreeNodeDefWhen"], ["matChipRemove", "", 3, "click"], ["matTreeNodePadding", ""], ["color", "primary", 3, "ngModelChange", "change", "ngModel"], ["mat-icon-button", "", "matTreeNodeToggle", ""], [1, "mat-icon-rtl-mirror"]];
      },
      template: function SearchFilterComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 2)(1, "h3", 3);
          ɵɵi18n(2, 0);
          ɵɵelementEnd();
          ɵɵelementStart(3, "button", 4);
          ɵɵlistener("click", function SearchFilterComponent_Template_button_click_3_listener() {
            return ctx.toggleDrawer();
          });
          ɵɵelementStart(4, "mat-icon");
          ɵɵtext(5, "close");
          ɵɵelementEnd()()();
          ɵɵelementStart(6, "div", 5)(7, "mat-chip-set", 6);
          ɵɵrepeaterCreate(8, SearchFilterComponent_For_9_Template, 2, 0, null, null, _forTrack0);
          ɵɵelementEnd();
          ɵɵelementStart(10, "mat-chip", 7);
          ɵɵlistener("click", function SearchFilterComponent_Template_mat_chip_click_10_listener() {
            return ctx.resetAll();
          });
          ɵɵi18n(11, 1);
          ɵɵelementEnd()();
          ɵɵelementStart(12, "div", 8)(13, "mat-tree", 9);
          ɵɵtemplate(14, SearchFilterComponent_mat_tree_node_14_Template, 3, 2, "mat-tree-node", 10)(15, SearchFilterComponent_mat_tree_node_15_Template, 5, 3, "mat-tree-node", 11);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance(8);
          ɵɵrepeater(ctx.addRemoveDataService.dataSignal());
          ɵɵadvance(5);
          ɵɵproperty("dataSource", ctx.dataSource)("treeControl", ctx.treeControl);
          ɵɵadvance(2);
          ɵɵproperty("matTreeNodeDefWhen", ctx.hasChild);
        }
      },
      dependencies: [MatIconButton, MatIcon, MatChip, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodePadding, MatCheckbox, FormsModule, NgControlStatus, NgModel, MatTreeNodeToggle, MatChipsModule, MatChipRemove, MatChipSet],
      styles: ["[_nghost-%COMP%]     .mat-mdc-chip.mdc-evolution-chip--with-trailing-action .mat-mdc-chip-action-label{max-width:260px;white-space:nowrap;overflow:hidden}.filter-title-wrapper[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center}.filter-title-wrapper[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{margin:16px}.filter-title-wrapper[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{margin:8px}.chips-selection-wrapper[_ngcontent-%COMP%]{margin:0 16px 16px}.chips-selection-wrapper[_ngcontent-%COMP%]   .clear-filter[_ngcontent-%COMP%]{margin-top:8px}\n/*# sourceMappingURL=search-filter.component-B4JVSFPW.css.map */"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(SearchFilterComponent, {
    className: "SearchFilterComponent",
    filePath: "libs/ui/src/lib/pages/search-filter/search-filter.component.ts",
    lineNumber: 126
  });
})();

// libs/ui/src/lib/pages/program-options-bar/program-options-bar.component.ts
var ProgramOptionsBarComponent = class _ProgramOptionsBarComponent {
  constructor() {
    this.programsService = inject(ProgramsService);
    this._snackBar = inject(MatSnackBar);
    this.dialog = inject(MatDialog);
    this.router = inject(Router);
    this.programDataService = inject(ProgramDataService);
    this.shareClientsDataService = inject(ShareClientsDataService);
    this.clientsService = inject(ClientsService);
    this.location = inject(Location);
    this.subscriptions = new Subscription();
    this.programId = this.programDataService.programId;
    this.clientInfo = this.shareClientsDataService.clientInfo;
    this.printProgramEvent = output();
  }
  openDeleteConfirmationDialog(itemId) {
    const dialogRef = this.dialog.open(DeleteConfirmationDialogComponent, {
      width: "312px",
      data: {
        title: "Ausgew\xE4hltes Programm l\xF6schen?",
        message: this.clientInfo().clientName ? "Durch das L\xF6schen des ausgew\xE4hlten Programms wird es aus dem Patientenprofil entfernt." : "Durch das L\xF6schen des ausgew\xE4hlten Programms wird es aus Ihrem Konto entfernt."
        // message:
        //   'Deleting the selected program will remove it from your account.',
      },
      panelClass: "custom-dialog"
    });
    const subscription = dialogRef.afterClosed().subscribe(result => {
      if (result) {
        console.log("User confirmed deletion");
        this.deleteProgram(itemId);
        dialogRef.close();
      } else {
        console.log("User canceled deletion");
        dialogRef.close();
      }
    });
    this.subscriptions.add(subscription);
  }
  deleteProgram(programId) {
    if (this.clientInfo().clientName) {
      const subscription = this.clientsService.deleteClientProgram(this.clientInfo().clientId, this.clientInfo().programPosition).subscribe(deletedProgram => {
        console.log(deletedProgram);
        lastValueFrom(timer(2e3)).then(() => {
          this.location.back();
        });
      });
      this.subscriptions.add(subscription);
    } else {
      const subscription = this.programsService.deleteProgram(programId).subscribe(() => {
        console.log(programId);
        lastValueFrom(timer(2e3)).then(() => {
          this.router.navigateByUrl(`programs`);
        });
      });
      this.subscriptions.add(subscription);
    }
    this._snackBar.open("Programm gel\xF6scht", "", {
      duration: 2e3,
      panelClass: ["custom-snackbar-style"]
    });
  }
  printProgram() {
    this.printProgramEvent.emit();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static {
    this.ɵfac = function ProgramOptionsBarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ProgramOptionsBarComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _ProgramOptionsBarComponent,
      selectors: [["ui-program-options-bar"]],
      outputs: {
        printProgramEvent: "printProgramEvent"
      },
      decls: 15,
      vars: 0,
      consts: [[1, "program-options-wrapper"], ["vertical", "", 2, "display", "inline-block", "height", "24px"], ["mat-icon-button", "", "matTooltip", "Email program", "aria-label", "Email icon button"], ["mat-icon-button", "", "matTooltip", "Share", "aria-label", "Share icon button"], ["mat-icon-button", "", "matTooltip", "Print", "aria-label", "Print icon button", 3, "click"], ["mat-icon-button", "", "matTooltip", "Delete", "aria-label", "Delete icon button", 3, "click"]],
      template: function ProgramOptionsBarComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 0);
          ɵɵelement(1, "mat-divider", 1);
          ɵɵelementStart(2, "button", 2)(3, "mat-icon");
          ɵɵtext(4, "mail_outline");
          ɵɵelementEnd()();
          ɵɵelementStart(5, "button", 3)(6, "mat-icon");
          ɵɵtext(7, "share");
          ɵɵelementEnd()();
          ɵɵelementStart(8, "button", 4);
          ɵɵlistener("click", function ProgramOptionsBarComponent_Template_button_click_8_listener() {
            return ctx.printProgram();
          });
          ɵɵelementStart(9, "mat-icon");
          ɵɵtext(10, "print_outline");
          ɵɵelementEnd()();
          ɵɵelement(11, "mat-divider", 1);
          ɵɵelementStart(12, "button", 5);
          ɵɵlistener("click", function ProgramOptionsBarComponent_Template_button_click_12_listener() {
            return ctx.openDeleteConfirmationDialog(ctx.programId());
          });
          ɵɵelementStart(13, "mat-icon");
          ɵɵtext(14, "delete_outline");
          ɵɵelementEnd()()();
        }
      },
      dependencies: [MatDivider, MatIconButton, MatTooltip, MatIcon],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(ProgramOptionsBarComponent, {
    className: "ProgramOptionsBarComponent",
    filePath: "libs/ui/src/lib/pages/program-options-bar/program-options-bar.component.ts",
    lineNumber: 32
  });
})();

// libs/ui/src/lib/components/exercise-search-btns-wrapper/exercise-search-btns-wrapper.component.ts
var ExerciseSearchBtnsWrapperComponent = class _ExerciseSearchBtnsWrapperComponent {
  constructor() {
    this.shareStateService = inject(ShareStateService);
    this.listOptionSignal = this.shareStateService.listOption;
    this.listOptionValue = output();
    effect(() => {
      this.listOption = this.listOptionSignal();
    });
  }
  changeListOption(listOptionValue) {
    this.listOptionSignal.set(listOptionValue);
    this.listOptionValue.emit(listOptionValue);
  }
  toggleDrawer() {
    this.drawerOpen = !this.drawerOpen;
  }
  static {
    this.ɵfac = function ExerciseSearchBtnsWrapperComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ExerciseSearchBtnsWrapperComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _ExerciseSearchBtnsWrapperComponent,
      selectors: [["ui-exercise-search-btns-wrapper"]],
      outputs: {
        listOptionValue: "listOptionValue"
      },
      decls: 9,
      vars: 1,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_listOptionAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_EXERCISE_SEARCH_BTNS_WRAPPER_EXERCISE_SEARCH_BTNS_WRAPPER_COMPONENT_TS_0 = goog.getMsg("List Option");
          i18n_0 = MSG_EXTERNAL_SearchSegmentedBtns_listOptionAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_EXERCISE_SEARCH_BTNS_WRAPPER_EXERCISE_SEARCH_BTNS_WRAPPER_COMPONENT_TS_0;
        } else {
          i18n_0 = "Listenoption";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_listOptionAll$$LIBS_UI_SRC_LIB_COMPONENTS_EXERCISE_SEARCH_BTNS_WRAPPER_EXERCISE_SEARCH_BTNS_WRAPPER_COMPONENT_TS_1 = goog.getMsg("All");
          i18n_1 = MSG_EXTERNAL_SearchSegmentedBtns_listOptionAll$$LIBS_UI_SRC_LIB_COMPONENTS_EXERCISE_SEARCH_BTNS_WRAPPER_EXERCISE_SEARCH_BTNS_WRAPPER_COMPONENT_TS_1;
        } else {
          i18n_1 = "Alle";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_listOptionSelected$$LIBS_UI_SRC_LIB_COMPONENTS_EXERCISE_SEARCH_BTNS_WRAPPER_EXERCISE_SEARCH_BTNS_WRAPPER_COMPONENT_TS_2 = goog.getMsg("Selected");
          i18n_2 = MSG_EXTERNAL_SearchSegmentedBtns_listOptionSelected$$LIBS_UI_SRC_LIB_COMPONENTS_EXERCISE_SEARCH_BTNS_WRAPPER_EXERCISE_SEARCH_BTNS_WRAPPER_COMPONENT_TS_2;
        } else {
          i18n_2 = "Ausgew\xE4hlt";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_SearchSegmentedBtns_listOptionFavorite$$LIBS_UI_SRC_LIB_COMPONENTS_EXERCISE_SEARCH_BTNS_WRAPPER_EXERCISE_SEARCH_BTNS_WRAPPER_COMPONENT_TS_3 = goog.getMsg("Favorite");
          i18n_3 = MSG_EXTERNAL_SearchSegmentedBtns_listOptionFavorite$$LIBS_UI_SRC_LIB_COMPONENTS_EXERCISE_SEARCH_BTNS_WRAPPER_EXERCISE_SEARCH_BTNS_WRAPPER_COMPONENT_TS_3;
        } else {
          i18n_3 = "Favorit";
        }
        return [i18n_1, i18n_2, i18n_3, [1, "search-segmented-btns"], [3, "toggleDrawerSignal"], ["name", "listOption", "aria-label", i18n_0, "hideSingleSelectionIndicator", "true", 1, "segmented-btns", 3, "ngModelChange", "change", "ngModel"], ["value", "all"], ["value", "selected"], ["value", "favorite"]];
      },
      template: function ExerciseSearchBtnsWrapperComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 3)(1, "ui-search", 4);
          ɵɵlistener("toggleDrawerSignal", function ExerciseSearchBtnsWrapperComponent_Template_ui_search_toggleDrawerSignal_1_listener() {
            return ctx.toggleDrawer();
          });
          ɵɵelementEnd();
          ɵɵelementStart(2, "mat-button-toggle-group", 5);
          ɵɵtwoWayListener("ngModelChange", function ExerciseSearchBtnsWrapperComponent_Template_mat_button_toggle_group_ngModelChange_2_listener($event) {
            ɵɵtwoWayBindingSet(ctx.listOption, $event) || (ctx.listOption = $event);
            return $event;
          });
          ɵɵlistener("change", function ExerciseSearchBtnsWrapperComponent_Template_mat_button_toggle_group_change_2_listener($event) {
            return ctx.changeListOption($event.value);
          });
          ɵɵelementStart(3, "mat-button-toggle", 6);
          ɵɵi18n(4, 0);
          ɵɵelementEnd();
          ɵɵelementStart(5, "mat-button-toggle", 7);
          ɵɵi18n(6, 1);
          ɵɵelementEnd();
          ɵɵelementStart(7, "mat-button-toggle", 8);
          ɵɵi18n(8, 2);
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵadvance(2);
          ɵɵtwoWayProperty("ngModel", ctx.listOption);
        }
      },
      dependencies: [CommonModule, FormsModule, NgControlStatus, NgModel, MatButtonToggleGroup, MatButtonToggle, SearchComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(ExerciseSearchBtnsWrapperComponent, {
    className: "ExerciseSearchBtnsWrapperComponent",
    filePath: "libs/ui/src/lib/components/exercise-search-btns-wrapper/exercise-search-btns-wrapper.component.ts",
    lineNumber: 33
  });
})();

// node_modules/@angular/material/fesm2022/menu.mjs
var _c019 = ["mat-menu-item", ""];
var _c114 = [[["mat-icon"], ["", "matMenuItemIcon", ""]], "*"];
var _c27 = ["mat-icon, [matMenuItemIcon]", "*"];
function MatMenuItem_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 2);
    ɵɵelement(1, "polygon", 3);
    ɵɵelementEnd();
  }
}
var _c36 = ["*"];
function MatMenu_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 0);
    ɵɵlistener("click", function MatMenu_ng_template_0_Template_div_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.closed.emit("click"));
    })("animationstart", function MatMenu_ng_template_0_Template_div_animationstart_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onAnimationStart($event.animationName));
    })("animationend", function MatMenu_ng_template_0_Template_div_animationend_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onAnimationDone($event.animationName));
    })("animationcancel", function MatMenu_ng_template_0_Template_div_animationcancel_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onAnimationDone($event.animationName));
    });
    ɵɵelementStart(1, "div", 1);
    ɵɵprojection(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._classList);
    ɵɵclassProp("mat-menu-panel-animations-disabled", ctx_r1._animationsDisabled)("mat-menu-panel-exit-animation", ctx_r1._panelAnimationState === "void")("mat-menu-panel-animating", ctx_r1._isAnimating);
    ɵɵproperty("id", ctx_r1.panelId);
    ɵɵattribute("aria-label", ctx_r1.ariaLabel || null)("aria-labelledby", ctx_r1.ariaLabelledby || null)("aria-describedby", ctx_r1.ariaDescribedby || null);
  }
}
var MAT_MENU_PANEL = new InjectionToken("MAT_MENU_PANEL");
var MatMenuItem = class _MatMenuItem {
  _elementRef = inject(ElementRef);
  _document = inject(DOCUMENT);
  _focusMonitor = inject(FocusMonitor);
  _parentMenu = inject(MAT_MENU_PANEL, {
    optional: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  /** ARIA role for the menu item. */
  role = "menuitem";
  /** Whether the menu item is disabled. */
  disabled = false;
  /** Whether ripples are disabled on the menu item. */
  disableRipple = false;
  /** Stream that emits when the menu item is hovered. */
  _hovered = new Subject();
  /** Stream that emits when the menu item is focused. */
  _focused = new Subject();
  /** Whether the menu item is highlighted. */
  _highlighted = false;
  /** Whether the menu item acts as a trigger for a sub-menu. */
  _triggersSubmenu = false;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
    this._parentMenu?.addItem?.(this);
  }
  /** Focuses the menu item. */
  focus(origin, options) {
    if (this._focusMonitor && origin) {
      this._focusMonitor.focusVia(this._getHostElement(), origin, options);
    } else {
      this._getHostElement().focus(options);
    }
    this._focused.next(this);
  }
  ngAfterViewInit() {
    if (this._focusMonitor) {
      this._focusMonitor.monitor(this._elementRef, false);
    }
  }
  ngOnDestroy() {
    if (this._focusMonitor) {
      this._focusMonitor.stopMonitoring(this._elementRef);
    }
    if (this._parentMenu && this._parentMenu.removeItem) {
      this._parentMenu.removeItem(this);
    }
    this._hovered.complete();
    this._focused.complete();
  }
  /** Used to set the `tabindex`. */
  _getTabIndex() {
    return this.disabled ? "-1" : "0";
  }
  /** Returns the host DOM element. */
  _getHostElement() {
    return this._elementRef.nativeElement;
  }
  /** Prevents the default element actions if it is disabled. */
  _checkDisabled(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Emits to the hover stream. */
  _handleMouseEnter() {
    this._hovered.next(this);
  }
  /** Gets the label to be used when determining whether the option should be focused. */
  getLabel() {
    const clone = this._elementRef.nativeElement.cloneNode(true);
    const icons = clone.querySelectorAll("mat-icon, .material-icons");
    for (let i2 = 0; i2 < icons.length; i2++) {
      icons[i2].remove();
    }
    return clone.textContent?.trim() || "";
  }
  _setHighlighted(isHighlighted) {
    this._highlighted = isHighlighted;
    this._changeDetectorRef.markForCheck();
  }
  _setTriggersSubmenu(triggersSubmenu) {
    this._triggersSubmenu = triggersSubmenu;
    this._changeDetectorRef.markForCheck();
  }
  _hasFocus() {
    return this._document && this._document.activeElement === this._getHostElement();
  }
  static ɵfac = function MatMenuItem_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenuItem)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatMenuItem,
    selectors: [["", "mat-menu-item", ""]],
    hostAttrs: [1, "mat-mdc-menu-item", "mat-focus-indicator"],
    hostVars: 8,
    hostBindings: function MatMenuItem_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function MatMenuItem_click_HostBindingHandler($event) {
          return ctx._checkDisabled($event);
        })("mouseenter", function MatMenuItem_mouseenter_HostBindingHandler() {
          return ctx._handleMouseEnter();
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.role)("tabindex", ctx._getTabIndex())("aria-disabled", ctx.disabled)("disabled", ctx.disabled || null);
        ɵɵclassProp("mat-mdc-menu-item-highlighted", ctx._highlighted)("mat-mdc-menu-item-submenu-trigger", ctx._triggersSubmenu);
      }
    },
    inputs: {
      role: "role",
      disabled: [2, "disabled", "disabled", booleanAttribute],
      disableRipple: [2, "disableRipple", "disableRipple", booleanAttribute]
    },
    exportAs: ["matMenuItem"],
    attrs: _c019,
    ngContentSelectors: _c27,
    decls: 5,
    vars: 3,
    consts: [[1, "mat-mdc-menu-item-text"], ["matRipple", "", 1, "mat-mdc-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"], ["viewBox", "0 0 5 10", "focusable", "false", "aria-hidden", "true", 1, "mat-mdc-menu-submenu-icon"], ["points", "0,0 5,5 0,10"]],
    template: function MatMenuItem_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c114);
        ɵɵprojection(0);
        ɵɵelementStart(1, "span", 0);
        ɵɵprojection(2, 1);
        ɵɵelementEnd();
        ɵɵelement(3, "div", 1);
        ɵɵtemplate(4, MatMenuItem_Conditional_4_Template, 2, 0, ":svg:svg", 2);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("matRippleDisabled", ctx.disableRipple || ctx.disabled)("matRippleTrigger", ctx._getHostElement());
        ɵɵadvance();
        ɵɵconditional(ctx._triggersSubmenu ? 4 : -1);
      }
    },
    dependencies: [MatRipple],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuItem, [{
    type: Component,
    args: [{
      selector: "[mat-menu-item]",
      exportAs: "matMenuItem",
      host: {
        "[attr.role]": "role",
        "class": "mat-mdc-menu-item mat-focus-indicator",
        "[class.mat-mdc-menu-item-highlighted]": "_highlighted",
        "[class.mat-mdc-menu-item-submenu-trigger]": "_triggersSubmenu",
        "[attr.tabindex]": "_getTabIndex()",
        "[attr.aria-disabled]": "disabled",
        "[attr.disabled]": "disabled || null",
        "(click)": "_checkDisabled($event)",
        "(mouseenter)": "_handleMouseEnter()"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      imports: [MatRipple],
      template: '<ng-content select="mat-icon, [matMenuItemIcon]"></ng-content>\n<span class="mat-mdc-menu-item-text"><ng-content></ng-content></span>\n<div class="mat-mdc-menu-ripple" matRipple\n     [matRippleDisabled]="disableRipple || disabled"\n     [matRippleTrigger]="_getHostElement()">\n</div>\n\n@if (_triggersSubmenu) {\n     <svg\n       class="mat-mdc-menu-submenu-icon"\n       viewBox="0 0 5 10"\n       focusable="false"\n       aria-hidden="true"><polygon points="0,0 5,5 0,10"/></svg>\n}\n'
    }]
  }], () => [], {
    role: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
function throwMatMenuInvalidPositionX() {
  throw Error(`xPosition value must be either 'before' or after'.
      Example: <mat-menu xPosition="before" #menu="matMenu"></mat-menu>`);
}
function throwMatMenuInvalidPositionY() {
  throw Error(`yPosition value must be either 'above' or below'.
      Example: <mat-menu yPosition="above" #menu="matMenu"></mat-menu>`);
}
function throwMatMenuRecursiveError() {
  throw Error(`matMenuTriggerFor: menu cannot contain its own trigger. Assign a menu that is not a parent of the trigger or move the trigger outside of the menu.`);
}
var MAT_MENU_CONTENT = new InjectionToken("MatMenuContent");
var MatMenuContent = class _MatMenuContent {
  _template = inject(TemplateRef);
  _appRef = inject(ApplicationRef);
  _injector = inject(Injector);
  _viewContainerRef = inject(ViewContainerRef);
  _document = inject(DOCUMENT);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _portal;
  _outlet;
  /** Emits when the menu content has been attached. */
  _attached = new Subject();
  constructor() {}
  /**
   * Attaches the content with a particular context.
   * @docs-private
   */
  attach(context = {}) {
    if (!this._portal) {
      this._portal = new TemplatePortal(this._template, this._viewContainerRef);
    }
    this.detach();
    if (!this._outlet) {
      this._outlet = new DomPortalOutlet(this._document.createElement("div"), null, this._appRef, this._injector);
    }
    const element = this._template.elementRef.nativeElement;
    element.parentNode.insertBefore(this._outlet.outletElement, element);
    this._changeDetectorRef.markForCheck();
    this._portal.attach(this._outlet, context);
    this._attached.next();
  }
  /**
   * Detaches the content.
   * @docs-private
   */
  detach() {
    if (this._portal?.isAttached) {
      this._portal.detach();
    }
  }
  ngOnDestroy() {
    this.detach();
    this._outlet?.dispose();
  }
  static ɵfac = function MatMenuContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenuContent)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatMenuContent,
    selectors: [["ng-template", "matMenuContent", ""]],
    features: [ɵɵProvidersFeature([{
      provide: MAT_MENU_CONTENT,
      useExisting: _MatMenuContent
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuContent, [{
    type: Directive,
    args: [{
      selector: "ng-template[matMenuContent]",
      providers: [{
        provide: MAT_MENU_CONTENT,
        useExisting: MatMenuContent
      }]
    }]
  }], () => [], null);
})();
var MAT_MENU_DEFAULT_OPTIONS = new InjectionToken("mat-menu-default-options", {
  providedIn: "root",
  factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY
});
function MAT_MENU_DEFAULT_OPTIONS_FACTORY() {
  return {
    overlapTrigger: false,
    xPosition: "after",
    yPosition: "below",
    backdropClass: "cdk-overlay-transparent-backdrop"
  };
}
var ENTER_ANIMATION = "_mat-menu-enter";
var EXIT_ANIMATION = "_mat-menu-exit";
var MatMenu = class _MatMenu {
  _elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _injector = inject(Injector);
  _keyManager;
  _xPosition;
  _yPosition;
  _firstItemFocusRef;
  _exitFallbackTimeout;
  /** Whether animations are currently disabled. */
  _animationsDisabled;
  /** All items inside the menu. Includes items nested inside another menu. */
  _allItems;
  /** Only the direct descendant menu items. */
  _directDescendantItems = new QueryList();
  /** Classes to be applied to the menu panel. */
  _classList = {};
  /** Current state of the panel animation. */
  _panelAnimationState = "void";
  /** Emits whenever an animation on the menu completes. */
  _animationDone = new Subject();
  /** Whether the menu is animating. */
  _isAnimating = false;
  /** Parent menu of the current menu panel. */
  parentMenu;
  /** Layout direction of the menu. */
  direction;
  /** Class or list of classes to be added to the overlay panel. */
  overlayPanelClass;
  /** Class to be added to the backdrop element. */
  backdropClass;
  /** aria-label for the menu panel. */
  ariaLabel;
  /** aria-labelledby for the menu panel. */
  ariaLabelledby;
  /** aria-describedby for the menu panel. */
  ariaDescribedby;
  /** Position of the menu in the X axis. */
  get xPosition() {
    return this._xPosition;
  }
  set xPosition(value) {
    if (value !== "before" && value !== "after" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwMatMenuInvalidPositionX();
    }
    this._xPosition = value;
    this.setPositionClasses();
  }
  /** Position of the menu in the Y axis. */
  get yPosition() {
    return this._yPosition;
  }
  set yPosition(value) {
    if (value !== "above" && value !== "below" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwMatMenuInvalidPositionY();
    }
    this._yPosition = value;
    this.setPositionClasses();
  }
  /** @docs-private */
  templateRef;
  /**
   * List of the items inside of a menu.
   * @deprecated
   * @breaking-change 8.0.0
   */
  items;
  /**
   * Menu content that will be rendered lazily.
   * @docs-private
   */
  lazyContent;
  /** Whether the menu should overlap its trigger. */
  overlapTrigger;
  /** Whether the menu has a backdrop. */
  hasBackdrop;
  /**
   * This method takes classes set on the host mat-menu element and applies them on the
   * menu template that displays in the overlay container.  Otherwise, it's difficult
   * to style the containing menu from outside the component.
   * @param classes list of class names
   */
  set panelClass(classes) {
    const previousPanelClass = this._previousPanelClass;
    const newClassList = __spreadValues({}, this._classList);
    if (previousPanelClass && previousPanelClass.length) {
      previousPanelClass.split(" ").forEach(className => {
        newClassList[className] = false;
      });
    }
    this._previousPanelClass = classes;
    if (classes && classes.length) {
      classes.split(" ").forEach(className => {
        newClassList[className] = true;
      });
      this._elementRef.nativeElement.className = "";
    }
    this._classList = newClassList;
  }
  _previousPanelClass;
  /**
   * This method takes classes set on the host mat-menu element and applies them on the
   * menu template that displays in the overlay container.  Otherwise, it's difficult
   * to style the containing menu from outside the component.
   * @deprecated Use `panelClass` instead.
   * @breaking-change 8.0.0
   */
  get classList() {
    return this.panelClass;
  }
  set classList(classes) {
    this.panelClass = classes;
  }
  /** Event emitted when the menu is closed. */
  closed = new EventEmitter();
  /**
   * Event emitted when the menu is closed.
   * @deprecated Switch to `closed` instead
   * @breaking-change 8.0.0
   */
  close = this.closed;
  panelId = inject(_IdGenerator).getId("mat-menu-panel-");
  constructor() {
    const defaultOptions = inject(MAT_MENU_DEFAULT_OPTIONS);
    this.overlayPanelClass = defaultOptions.overlayPanelClass || "";
    this._xPosition = defaultOptions.xPosition;
    this._yPosition = defaultOptions.yPosition;
    this.backdropClass = defaultOptions.backdropClass;
    this.overlapTrigger = defaultOptions.overlapTrigger;
    this.hasBackdrop = defaultOptions.hasBackdrop;
    this._animationsDisabled = inject(ANIMATION_MODULE_TYPE, {
      optional: true
    }) === "NoopAnimations";
  }
  ngOnInit() {
    this.setPositionClasses();
  }
  ngAfterContentInit() {
    this._updateDirectDescendants();
    this._keyManager = new FocusKeyManager(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd();
    this._keyManager.tabOut.subscribe(() => this.closed.emit("tab"));
    this._directDescendantItems.changes.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map(item => item._focused)))).subscribe(focusedItem => this._keyManager.updateActiveItem(focusedItem));
    this._directDescendantItems.changes.subscribe(itemsList => {
      const manager = this._keyManager;
      if (this._panelAnimationState === "enter" && manager.activeItem?._hasFocus()) {
        const items = itemsList.toArray();
        const index = Math.max(0, Math.min(items.length - 1, manager.activeItemIndex || 0));
        if (items[index] && !items[index].disabled) {
          manager.setActiveItem(index);
        } else {
          manager.setNextItemActive();
        }
      }
    });
  }
  ngOnDestroy() {
    this._keyManager?.destroy();
    this._directDescendantItems.destroy();
    this.closed.complete();
    this._firstItemFocusRef?.destroy();
    clearTimeout(this._exitFallbackTimeout);
  }
  /** Stream that emits whenever the hovered menu item changes. */
  _hovered() {
    const itemChanges = this._directDescendantItems.changes;
    return itemChanges.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map(item => item._hovered))));
  }
  /*
   * Registers a menu item with the menu.
   * @docs-private
   * @deprecated No longer being used. To be removed.
   * @breaking-change 9.0.0
   */
  addItem(_item) {}
  /**
   * Removes an item from the menu.
   * @docs-private
   * @deprecated No longer being used. To be removed.
   * @breaking-change 9.0.0
   */
  removeItem(_item) {}
  /** Handle a keyboard event from the menu, delegating to the appropriate action. */
  _handleKeydown(event) {
    const keyCode = event.keyCode;
    const manager = this._keyManager;
    switch (keyCode) {
      case ESCAPE:
        if (!hasModifierKey(event)) {
          event.preventDefault();
          this.closed.emit("keydown");
        }
        break;
      case LEFT_ARROW:
        if (this.parentMenu && this.direction === "ltr") {
          this.closed.emit("keydown");
        }
        break;
      case RIGHT_ARROW:
        if (this.parentMenu && this.direction === "rtl") {
          this.closed.emit("keydown");
        }
        break;
      default:
        if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
          manager.setFocusOrigin("keyboard");
        }
        manager.onKeydown(event);
        return;
    }
  }
  /**
   * Focus the first item in the menu.
   * @param origin Action from which the focus originated. Used to set the correct styling.
   */
  focusFirstItem(origin = "program") {
    this._firstItemFocusRef?.destroy();
    this._firstItemFocusRef = afterNextRender(() => {
      const menuPanel = this._resolvePanel();
      if (!menuPanel || !menuPanel.contains(document.activeElement)) {
        const manager = this._keyManager;
        manager.setFocusOrigin(origin).setFirstItemActive();
        if (!manager.activeItem && menuPanel) {
          menuPanel.focus();
        }
      }
    }, {
      injector: this._injector
    });
  }
  /**
   * Resets the active item in the menu. This is used when the menu is opened, allowing
   * the user to start from the first option when pressing the down arrow.
   */
  resetActiveItem() {
    this._keyManager.setActiveItem(-1);
  }
  /**
   * @deprecated No longer used and will be removed.
   * @breaking-change 21.0.0
   */
  setElevation(_depth) {}
  /**
   * Adds classes to the menu panel based on its position. Can be used by
   * consumers to add specific styling based on the position.
   * @param posX Position of the menu along the x axis.
   * @param posY Position of the menu along the y axis.
   * @docs-private
   */
  setPositionClasses(posX = this.xPosition, posY = this.yPosition) {
    this._classList = __spreadProps(__spreadValues({}, this._classList), {
      ["mat-menu-before"]: posX === "before",
      ["mat-menu-after"]: posX === "after",
      ["mat-menu-above"]: posY === "above",
      ["mat-menu-below"]: posY === "below"
    });
    this._changeDetectorRef.markForCheck();
  }
  /** Callback that is invoked when the panel animation completes. */
  _onAnimationDone(state2) {
    const isExit = state2 === EXIT_ANIMATION;
    if (isExit || state2 === ENTER_ANIMATION) {
      if (isExit) {
        clearTimeout(this._exitFallbackTimeout);
        this._exitFallbackTimeout = void 0;
      }
      this._animationDone.next(isExit ? "void" : "enter");
      this._isAnimating = false;
    }
  }
  _onAnimationStart(state2) {
    if (state2 === ENTER_ANIMATION || state2 === EXIT_ANIMATION) {
      this._isAnimating = true;
    }
  }
  _setIsOpen(isOpen) {
    this._panelAnimationState = isOpen ? "enter" : "void";
    if (isOpen) {
      if (this._keyManager.activeItemIndex === 0) {
        const menuPanel = this._resolvePanel();
        if (menuPanel) {
          menuPanel.scrollTop = 0;
        }
      }
    } else if (!this._animationsDisabled) {
      this._exitFallbackTimeout = setTimeout(() => this._onAnimationDone(EXIT_ANIMATION), 200);
    }
    if (this._animationsDisabled) {
      setTimeout(() => {
        this._onAnimationDone(isOpen ? ENTER_ANIMATION : EXIT_ANIMATION);
      });
    }
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Sets up a stream that will keep track of any newly-added menu items and will update the list
   * of direct descendants. We collect the descendants this way, because `_allItems` can include
   * items that are part of child menus, and using a custom way of registering items is unreliable
   * when it comes to maintaining the item order.
   */
  _updateDirectDescendants() {
    this._allItems.changes.pipe(startWith(this._allItems)).subscribe(items => {
      this._directDescendantItems.reset(items.filter(item => item._parentMenu === this));
      this._directDescendantItems.notifyOnChanges();
    });
  }
  /** Gets the menu panel DOM node. */
  _resolvePanel() {
    let menuPanel = null;
    if (this._directDescendantItems.length) {
      menuPanel = this._directDescendantItems.first._getHostElement().closest('[role="menu"]');
    }
    return menuPanel;
  }
  static ɵfac = function MatMenu_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenu)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatMenu,
    selectors: [["mat-menu"]],
    contentQueries: function MatMenu_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MAT_MENU_CONTENT, 5);
        ɵɵcontentQuery(dirIndex, MatMenuItem, 5);
        ɵɵcontentQuery(dirIndex, MatMenuItem, 4);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.lazyContent = _t2.first);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._allItems = _t2);
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.items = _t2);
      }
    },
    viewQuery: function MatMenu_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(TemplateRef, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.templateRef = _t2.first);
      }
    },
    hostVars: 3,
    hostBindings: function MatMenu_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-label", null)("aria-labelledby", null)("aria-describedby", null);
      }
    },
    inputs: {
      backdropClass: "backdropClass",
      ariaLabel: [0, "aria-label", "ariaLabel"],
      ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
      ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"],
      xPosition: "xPosition",
      yPosition: "yPosition",
      overlapTrigger: [2, "overlapTrigger", "overlapTrigger", booleanAttribute],
      hasBackdrop: [2, "hasBackdrop", "hasBackdrop", value => value == null ? null : booleanAttribute(value)],
      panelClass: [0, "class", "panelClass"],
      classList: "classList"
    },
    outputs: {
      closed: "closed",
      close: "close"
    },
    exportAs: ["matMenu"],
    features: [ɵɵProvidersFeature([{
      provide: MAT_MENU_PANEL,
      useExisting: _MatMenu
    }])],
    ngContentSelectors: _c36,
    decls: 1,
    vars: 0,
    consts: [["tabindex", "-1", "role", "menu", 1, "mat-mdc-menu-panel", 3, "click", "animationstart", "animationend", "animationcancel", "id"], [1, "mat-mdc-menu-content"]],
    template: function MatMenu_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, MatMenu_ng_template_0_Template, 3, 12, "ng-template");
      }
    },
    styles: ['mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenu, [{
    type: Component,
    args: [{
      selector: "mat-menu",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      exportAs: "matMenu",
      host: {
        "[attr.aria-label]": "null",
        "[attr.aria-labelledby]": "null",
        "[attr.aria-describedby]": "null"
      },
      providers: [{
        provide: MAT_MENU_PANEL,
        useExisting: MatMenu
      }],
      template: `<ng-template>
  <div
    class="mat-mdc-menu-panel"
    [id]="panelId"
    [class]="_classList"
    [class.mat-menu-panel-animations-disabled]="_animationsDisabled"
    [class.mat-menu-panel-exit-animation]="_panelAnimationState === 'void'"
    [class.mat-menu-panel-animating]="_isAnimating"
    (click)="closed.emit('click')"
    tabindex="-1"
    role="menu"
    (animationstart)="_onAnimationStart($event.animationName)"
    (animationend)="_onAnimationDone($event.animationName)"
    (animationcancel)="_onAnimationDone($event.animationName)"
    [attr.aria-label]="ariaLabel || null"
    [attr.aria-labelledby]="ariaLabelledby || null"
    [attr.aria-describedby]="ariaDescribedby || null">
    <div class="mat-mdc-menu-content">
      <ng-content></ng-content>
    </div>
  </div>
</ng-template>
`,
      styles: ['mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}']
    }]
  }], () => [], {
    _allItems: [{
      type: ContentChildren,
      args: [MatMenuItem, {
        descendants: true
      }]
    }],
    backdropClass: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    ariaDescribedby: [{
      type: Input,
      args: ["aria-describedby"]
    }],
    xPosition: [{
      type: Input
    }],
    yPosition: [{
      type: Input
    }],
    templateRef: [{
      type: ViewChild,
      args: [TemplateRef]
    }],
    items: [{
      type: ContentChildren,
      args: [MatMenuItem, {
        descendants: false
      }]
    }],
    lazyContent: [{
      type: ContentChild,
      args: [MAT_MENU_CONTENT]
    }],
    overlapTrigger: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    hasBackdrop: [{
      type: Input,
      args: [{
        transform: value => value == null ? null : booleanAttribute(value)
      }]
    }],
    panelClass: [{
      type: Input,
      args: ["class"]
    }],
    classList: [{
      type: Input
    }],
    closed: [{
      type: Output
    }],
    close: [{
      type: Output
    }]
  });
})();
var MAT_MENU_SCROLL_STRATEGY = new InjectionToken("mat-menu-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition();
  }
});
function MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition();
}
var MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {
  provide: MAT_MENU_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY
};
var passiveEventListenerOptions = {
  passive: true
};
var PANELS_TO_TRIGGERS = /* @__PURE__ */new WeakMap();
var MatMenuTrigger = class _MatMenuTrigger {
  _overlay = inject(Overlay);
  _element = inject(ElementRef);
  _viewContainerRef = inject(ViewContainerRef);
  _menuItemInstance = inject(MatMenuItem, {
    optional: true,
    self: true
  });
  _dir = inject(Directionality, {
    optional: true
  });
  _focusMonitor = inject(FocusMonitor);
  _ngZone = inject(NgZone);
  _scrollStrategy = inject(MAT_MENU_SCROLL_STRATEGY);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _cleanupTouchstart;
  _portal;
  _overlayRef = null;
  _menuOpen = false;
  _closingActionsSubscription = Subscription.EMPTY;
  _hoverSubscription = Subscription.EMPTY;
  _menuCloseSubscription = Subscription.EMPTY;
  _pendingRemoval;
  /**
   * We're specifically looking for a `MatMenu` here since the generic `MatMenuPanel`
   * interface lacks some functionality around nested menus and animations.
   */
  _parentMaterialMenu;
  /**
   * Cached value of the padding of the parent menu panel.
   * Used to offset sub-menus to compensate for the padding.
   */
  _parentInnerPadding;
  // Tracking input type is necessary so it's possible to only auto-focus
  // the first item of the list when the menu is opened via the keyboard
  _openedBy = void 0;
  /**
   * @deprecated
   * @breaking-change 8.0.0
   */
  get _deprecatedMatMenuTriggerFor() {
    return this.menu;
  }
  set _deprecatedMatMenuTriggerFor(v2) {
    this.menu = v2;
  }
  /** References the menu instance that the trigger is associated with. */
  get menu() {
    return this._menu;
  }
  set menu(menu) {
    if (menu === this._menu) {
      return;
    }
    this._menu = menu;
    this._menuCloseSubscription.unsubscribe();
    if (menu) {
      if (menu === this._parentMaterialMenu && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throwMatMenuRecursiveError();
      }
      this._menuCloseSubscription = menu.close.subscribe(reason => {
        this._destroyMenu(reason);
        if ((reason === "click" || reason === "tab") && this._parentMaterialMenu) {
          this._parentMaterialMenu.closed.emit(reason);
        }
      });
    }
    this._menuItemInstance?._setTriggersSubmenu(this.triggersSubmenu());
  }
  _menu;
  /** Data to be passed along to any lazily-rendered content. */
  menuData;
  /**
   * Whether focus should be restored when the menu is closed.
   * Note that disabling this option can have accessibility implications
   * and it's up to you to manage focus, if you decide to turn it off.
   */
  restoreFocus = true;
  /** Event emitted when the associated menu is opened. */
  menuOpened = new EventEmitter();
  /**
   * Event emitted when the associated menu is opened.
   * @deprecated Switch to `menuOpened` instead
   * @breaking-change 8.0.0
   */
  // tslint:disable-next-line:no-output-on-prefix
  onMenuOpen = this.menuOpened;
  /** Event emitted when the associated menu is closed. */
  menuClosed = new EventEmitter();
  /**
   * Event emitted when the associated menu is closed.
   * @deprecated Switch to `menuClosed` instead
   * @breaking-change 8.0.0
   */
  // tslint:disable-next-line:no-output-on-prefix
  onMenuClose = this.menuClosed;
  constructor() {
    const parentMenu = inject(MAT_MENU_PANEL, {
      optional: true
    });
    const renderer = inject(Renderer2);
    this._parentMaterialMenu = parentMenu instanceof MatMenu ? parentMenu : void 0;
    this._cleanupTouchstart = _bindEventWithOptions(renderer, this._element.nativeElement, "touchstart", event => {
      if (!isFakeTouchstartFromScreenReader(event)) {
        this._openedBy = "touch";
      }
    }, passiveEventListenerOptions);
  }
  ngAfterContentInit() {
    this._handleHover();
  }
  ngOnDestroy() {
    if (this.menu && this._ownsMenu(this.menu)) {
      PANELS_TO_TRIGGERS.delete(this.menu);
    }
    this._cleanupTouchstart();
    this._pendingRemoval?.unsubscribe();
    this._menuCloseSubscription.unsubscribe();
    this._closingActionsSubscription.unsubscribe();
    this._hoverSubscription.unsubscribe();
    if (this._overlayRef) {
      this._overlayRef.dispose();
      this._overlayRef = null;
    }
  }
  /** Whether the menu is open. */
  get menuOpen() {
    return this._menuOpen;
  }
  /** The text direction of the containing app. */
  get dir() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /** Whether the menu triggers a sub-menu or a top-level one. */
  triggersSubmenu() {
    return !!(this._menuItemInstance && this._parentMaterialMenu && this.menu);
  }
  /** Toggles the menu between the open and closed states. */
  toggleMenu() {
    return this._menuOpen ? this.closeMenu() : this.openMenu();
  }
  /** Opens the menu. */
  openMenu() {
    const menu = this.menu;
    if (this._menuOpen || !menu) {
      return;
    }
    this._pendingRemoval?.unsubscribe();
    const previousTrigger = PANELS_TO_TRIGGERS.get(menu);
    PANELS_TO_TRIGGERS.set(menu, this);
    if (previousTrigger && previousTrigger !== this) {
      previousTrigger.closeMenu();
    }
    const overlayRef = this._createOverlay(menu);
    const overlayConfig = overlayRef.getConfig();
    const positionStrategy = overlayConfig.positionStrategy;
    this._setPosition(menu, positionStrategy);
    overlayConfig.hasBackdrop = menu.hasBackdrop == null ? !this.triggersSubmenu() : menu.hasBackdrop;
    if (!overlayRef.hasAttached()) {
      overlayRef.attach(this._getPortal(menu));
      menu.lazyContent?.attach(this.menuData);
    }
    this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu());
    menu.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : void 0;
    menu.direction = this.dir;
    menu.focusFirstItem(this._openedBy || "program");
    this._setIsMenuOpen(true);
    if (menu instanceof MatMenu) {
      menu._setIsOpen(true);
      menu._directDescendantItems.changes.pipe(takeUntil(menu.close)).subscribe(() => {
        positionStrategy.withLockedPosition(false).reapplyLastPosition();
        positionStrategy.withLockedPosition(true);
      });
    }
  }
  /** Closes the menu. */
  closeMenu() {
    this.menu?.close.emit();
  }
  /**
   * Focuses the menu trigger.
   * @param origin Source of the menu trigger's focus.
   */
  focus(origin, options) {
    if (this._focusMonitor && origin) {
      this._focusMonitor.focusVia(this._element, origin, options);
    } else {
      this._element.nativeElement.focus(options);
    }
  }
  /**
   * Updates the position of the menu to ensure that it fits all options within the viewport.
   */
  updatePosition() {
    this._overlayRef?.updatePosition();
  }
  /** Closes the menu and does the necessary cleanup. */
  _destroyMenu(reason) {
    const overlayRef = this._overlayRef;
    const menu = this._menu;
    if (!overlayRef || !this.menuOpen) {
      return;
    }
    this._closingActionsSubscription.unsubscribe();
    this._pendingRemoval?.unsubscribe();
    if (menu instanceof MatMenu && this._ownsMenu(menu)) {
      this._pendingRemoval = menu._animationDone.pipe(take(1)).subscribe(() => {
        overlayRef.detach();
        menu.lazyContent?.detach();
      });
      menu._setIsOpen(false);
    } else {
      overlayRef.detach();
      menu?.lazyContent?.detach();
    }
    if (menu && this._ownsMenu(menu)) {
      PANELS_TO_TRIGGERS.delete(menu);
    }
    if (this.restoreFocus && (reason === "keydown" || !this._openedBy || !this.triggersSubmenu())) {
      this.focus(this._openedBy);
    }
    this._openedBy = void 0;
    this._setIsMenuOpen(false);
  }
  // set state rather than toggle to support triggers sharing a menu
  _setIsMenuOpen(isOpen) {
    if (isOpen !== this._menuOpen) {
      this._menuOpen = isOpen;
      this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();
      if (this.triggersSubmenu()) {
        this._menuItemInstance._setHighlighted(isOpen);
      }
      this._changeDetectorRef.markForCheck();
    }
  }
  /**
   * This method creates the overlay from the provided menu's template and saves its
   * OverlayRef so that it can be attached to the DOM when openMenu is called.
   */
  _createOverlay(menu) {
    if (!this._overlayRef) {
      const config = this._getOverlayConfig(menu);
      this._subscribeToPositions(menu, config.positionStrategy);
      this._overlayRef = this._overlay.create(config);
      this._overlayRef.keydownEvents().subscribe(event => {
        if (this.menu instanceof MatMenu) {
          this.menu._handleKeydown(event);
        }
      });
    }
    return this._overlayRef;
  }
  /**
   * This method builds the configuration object needed to create the overlay, the OverlayState.
   * @returns OverlayConfig
   */
  _getOverlayConfig(menu) {
    return new OverlayConfig({
      positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"),
      backdropClass: menu.backdropClass || "cdk-overlay-transparent-backdrop",
      panelClass: menu.overlayPanelClass,
      scrollStrategy: this._scrollStrategy(),
      direction: this._dir || "ltr"
    });
  }
  /**
   * Listens to changes in the position of the overlay and sets the correct classes
   * on the menu based on the new position. This ensures the animation origin is always
   * correct, even if a fallback position is used for the overlay.
   */
  _subscribeToPositions(menu, position) {
    if (menu.setPositionClasses) {
      position.positionChanges.subscribe(change => {
        this._ngZone.run(() => {
          const posX = change.connectionPair.overlayX === "start" ? "after" : "before";
          const posY = change.connectionPair.overlayY === "top" ? "below" : "above";
          menu.setPositionClasses(posX, posY);
        });
      });
    }
  }
  /**
   * Sets the appropriate positions on a position strategy
   * so the overlay connects with the trigger correctly.
   * @param positionStrategy Strategy whose position to update.
   */
  _setPosition(menu, positionStrategy) {
    let [originX, originFallbackX] = menu.xPosition === "before" ? ["end", "start"] : ["start", "end"];
    let [overlayY, overlayFallbackY] = menu.yPosition === "above" ? ["bottom", "top"] : ["top", "bottom"];
    let [originY, originFallbackY] = [overlayY, overlayFallbackY];
    let [overlayX, overlayFallbackX] = [originX, originFallbackX];
    let offsetY = 0;
    if (this.triggersSubmenu()) {
      overlayFallbackX = originX = menu.xPosition === "before" ? "start" : "end";
      originFallbackX = overlayX = originX === "end" ? "start" : "end";
      if (this._parentMaterialMenu) {
        if (this._parentInnerPadding == null) {
          const firstItem = this._parentMaterialMenu.items.first;
          this._parentInnerPadding = firstItem ? firstItem._getHostElement().offsetTop : 0;
        }
        offsetY = overlayY === "bottom" ? this._parentInnerPadding : -this._parentInnerPadding;
      }
    } else if (!menu.overlapTrigger) {
      originY = overlayY === "top" ? "bottom" : "top";
      originFallbackY = overlayFallbackY === "top" ? "bottom" : "top";
    }
    positionStrategy.withPositions([{
      originX,
      originY,
      overlayX,
      overlayY,
      offsetY
    }, {
      originX: originFallbackX,
      originY,
      overlayX: overlayFallbackX,
      overlayY,
      offsetY
    }, {
      originX,
      originY: originFallbackY,
      overlayX,
      overlayY: overlayFallbackY,
      offsetY: -offsetY
    }, {
      originX: originFallbackX,
      originY: originFallbackY,
      overlayX: overlayFallbackX,
      overlayY: overlayFallbackY,
      offsetY: -offsetY
    }]);
  }
  /** Returns a stream that emits whenever an action that should close the menu occurs. */
  _menuClosingActions() {
    const backdrop = this._overlayRef.backdropClick();
    const detachments = this._overlayRef.detachments();
    const parentClose = this._parentMaterialMenu ? this._parentMaterialMenu.closed : of();
    const hover = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(filter(active => this._menuOpen && active !== this._menuItemInstance)) : of();
    return merge(backdrop, parentClose, hover, detachments);
  }
  /** Handles mouse presses on the trigger. */
  _handleMousedown(event) {
    if (!isFakeMousedownFromScreenReader(event)) {
      this._openedBy = event.button === 0 ? "mouse" : void 0;
      if (this.triggersSubmenu()) {
        event.preventDefault();
      }
    }
  }
  /** Handles key presses on the trigger. */
  _handleKeydown(event) {
    const keyCode = event.keyCode;
    if (keyCode === ENTER || keyCode === SPACE) {
      this._openedBy = "keyboard";
    }
    if (this.triggersSubmenu() && (keyCode === RIGHT_ARROW && this.dir === "ltr" || keyCode === LEFT_ARROW && this.dir === "rtl")) {
      this._openedBy = "keyboard";
      this.openMenu();
    }
  }
  /** Handles click events on the trigger. */
  _handleClick(event) {
    if (this.triggersSubmenu()) {
      event.stopPropagation();
      this.openMenu();
    } else {
      this.toggleMenu();
    }
  }
  /** Handles the cases where the user hovers over the trigger. */
  _handleHover() {
    if (this.triggersSubmenu() && this._parentMaterialMenu) {
      this._hoverSubscription = this._parentMaterialMenu._hovered().subscribe(active => {
        if (active === this._menuItemInstance && !active.disabled) {
          this._openedBy = "mouse";
          this.openMenu();
        }
      });
    }
  }
  /** Gets the portal that should be attached to the overlay. */
  _getPortal(menu) {
    if (!this._portal || this._portal.templateRef !== menu.templateRef) {
      this._portal = new TemplatePortal(menu.templateRef, this._viewContainerRef);
    }
    return this._portal;
  }
  /**
   * Determines whether the trigger owns a specific menu panel, at the current point in time.
   * This allows us to distinguish the case where the same panel is passed into multiple triggers
   * and multiple are open at a time.
   */
  _ownsMenu(menu) {
    return PANELS_TO_TRIGGERS.get(menu) === this;
  }
  static ɵfac = function MatMenuTrigger_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenuTrigger)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatMenuTrigger,
    selectors: [["", "mat-menu-trigger-for", ""], ["", "matMenuTriggerFor", ""]],
    hostAttrs: [1, "mat-mdc-menu-trigger"],
    hostVars: 3,
    hostBindings: function MatMenuTrigger_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function MatMenuTrigger_click_HostBindingHandler($event) {
          return ctx._handleClick($event);
        })("mousedown", function MatMenuTrigger_mousedown_HostBindingHandler($event) {
          return ctx._handleMousedown($event);
        })("keydown", function MatMenuTrigger_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-haspopup", ctx.menu ? "menu" : null)("aria-expanded", ctx.menuOpen)("aria-controls", ctx.menuOpen ? ctx.menu.panelId : null);
      }
    },
    inputs: {
      _deprecatedMatMenuTriggerFor: [0, "mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"],
      menu: [0, "matMenuTriggerFor", "menu"],
      menuData: [0, "matMenuTriggerData", "menuData"],
      restoreFocus: [0, "matMenuTriggerRestoreFocus", "restoreFocus"]
    },
    outputs: {
      menuOpened: "menuOpened",
      onMenuOpen: "onMenuOpen",
      menuClosed: "menuClosed",
      onMenuClose: "onMenuClose"
    },
    exportAs: ["matMenuTrigger"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuTrigger, [{
    type: Directive,
    args: [{
      selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,
      host: {
        "class": "mat-mdc-menu-trigger",
        "[attr.aria-haspopup]": 'menu ? "menu" : null',
        "[attr.aria-expanded]": "menuOpen",
        "[attr.aria-controls]": "menuOpen ? menu.panelId : null",
        "(click)": "_handleClick($event)",
        "(mousedown)": "_handleMousedown($event)",
        "(keydown)": "_handleKeydown($event)"
      },
      exportAs: "matMenuTrigger"
    }]
  }], () => [], {
    _deprecatedMatMenuTriggerFor: [{
      type: Input,
      args: ["mat-menu-trigger-for"]
    }],
    menu: [{
      type: Input,
      args: ["matMenuTriggerFor"]
    }],
    menuData: [{
      type: Input,
      args: ["matMenuTriggerData"]
    }],
    restoreFocus: [{
      type: Input,
      args: ["matMenuTriggerRestoreFocus"]
    }],
    menuOpened: [{
      type: Output
    }],
    onMenuOpen: [{
      type: Output
    }],
    menuClosed: [{
      type: Output
    }],
    onMenuClose: [{
      type: Output
    }]
  });
})();
var MatMenuModule = class _MatMenuModule {
  static ɵfac = function MatMenuModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenuModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatMenuModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER],
    imports: [MatRippleModule, MatCommonModule, OverlayModule, CdkScrollableModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuModule, [{
    type: NgModule,
    args: [{
      imports: [MatRippleModule, MatCommonModule, OverlayModule, MatMenu, MatMenuItem, MatMenuContent, MatMenuTrigger],
      exports: [CdkScrollableModule, MatMenu, MatCommonModule, MatMenuItem, MatMenuContent, MatMenuTrigger],
      providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]
    }]
  }], null, null);
})();
var matMenuAnimations = {
  // Represents:
  // trigger('transformMenu', [
  //   state(
  //     'void',
  //     style({
  //       opacity: 0,
  //       transform: 'scale(0.8)',
  //     }),
  //   ),
  //   transition(
  //     'void => enter',
  //     animate(
  //       '120ms cubic-bezier(0, 0, 0.2, 1)',
  //       style({
  //         opacity: 1,
  //         transform: 'scale(1)',
  //       }),
  //     ),
  //   ),
  //   transition('* => void', animate('100ms 25ms linear', style({opacity: 0}))),
  // ])
  /**
   * This animation controls the menu panel's entry and exit from the page.
   *
   * When the menu panel is added to the DOM, it scales in and fades in its border.
   *
   * When the menu panel is removed from the DOM, it simply fades out after a brief
   * delay to display the ripple.
   */
  transformMenu: {
    type: 7,
    name: "transformMenu",
    definitions: [{
      type: 0,
      name: "void",
      styles: {
        type: 6,
        styles: {
          opacity: 0,
          transform: "scale(0.8)"
        },
        offset: null
      }
    }, {
      type: 1,
      expr: "void => enter",
      animation: {
        type: 4,
        styles: {
          type: 6,
          styles: {
            opacity: 1,
            transform: "scale(1)"
          },
          offset: null
        },
        timings: "120ms cubic-bezier(0, 0, 0.2, 1)"
      },
      options: null
    }, {
      type: 1,
      expr: "* => void",
      animation: {
        type: 4,
        styles: {
          type: 6,
          styles: {
            opacity: 0
          },
          offset: null
        },
        timings: "100ms 25ms linear"
      },
      options: null
    }],
    options: {}
  },
  // Represents:
  // trigger('fadeInItems', [
  //   // TODO(crisbeto): this is inside the `transformMenu`
  //   // now. Remove next time we do breaking changes.
  //   state('showing', style({opacity: 1})),
  //   transition('void => *', [
  //     style({opacity: 0}),
  //     animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'),
  //   ]),
  // ])
  /**
   * This animation fades in the background color and content of the menu panel
   * after its containing element is scaled in.
   */
  fadeInItems: {
    type: 7,
    name: "fadeInItems",
    definitions: [{
      type: 0,
      name: "showing",
      styles: {
        type: 6,
        styles: {
          opacity: 1
        },
        offset: null
      }
    }, {
      type: 1,
      expr: "void => *",
      animation: [{
        type: 6,
        styles: {
          opacity: 0
        },
        offset: null
      }, {
        type: 4,
        styles: null,
        timings: "400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)"
      }],
      options: null
    }],
    options: {}
  }
};
var fadeInItems = matMenuAnimations.fadeInItems;
var transformMenu = matMenuAnimations.transformMenu;

// node_modules/@angular/material/fesm2022/toolbar.mjs
var _c020 = ["*", [["mat-toolbar-row"]]];
var _c115 = ["*", "mat-toolbar-row"];
var MatToolbarRow = class _MatToolbarRow {
  static ɵfac = function MatToolbarRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatToolbarRow)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _MatToolbarRow,
    selectors: [["mat-toolbar-row"]],
    hostAttrs: [1, "mat-toolbar-row"],
    exportAs: ["matToolbarRow"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatToolbarRow, [{
    type: Directive,
    args: [{
      selector: "mat-toolbar-row",
      exportAs: "matToolbarRow",
      host: {
        "class": "mat-toolbar-row"
      }
    }]
  }], null, null);
})();
var MatToolbar = class _MatToolbar {
  _elementRef = inject(ElementRef);
  _platform = inject(Platform);
  _document = inject(DOCUMENT);
  // TODO: should be typed as `ThemePalette` but internal apps pass in arbitrary strings.
  /**
   * Theme color of the toolbar. This API is supported in M2 themes only, it has
   * no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/toolbar/styling.
   *
   * For information on applying color variants in M3, see
   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
   */
  color;
  /** Reference to all toolbar row elements that have been projected. */
  _toolbarRows;
  constructor() {}
  ngAfterViewInit() {
    if (this._platform.isBrowser) {
      this._checkToolbarMixedModes();
      this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes());
    }
  }
  /**
   * Throws an exception when developers are attempting to combine the different toolbar row modes.
   */
  _checkToolbarMixedModes() {
    if (this._toolbarRows.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      const isCombinedUsage = Array.from(this._elementRef.nativeElement.childNodes).filter(node => !(node.classList && node.classList.contains("mat-toolbar-row"))).filter(node => node.nodeType !== (this._document ? this._document.COMMENT_NODE : 8)).some(node => !!(node.textContent && node.textContent.trim()));
      if (isCombinedUsage) {
        throwToolbarMixedModesError();
      }
    }
  }
  static ɵfac = function MatToolbar_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatToolbar)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: _MatToolbar,
    selectors: [["mat-toolbar"]],
    contentQueries: function MatToolbar_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MatToolbarRow, 5);
      }
      if (rf & 2) {
        let _t2;
        ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx._toolbarRows = _t2);
      }
    },
    hostAttrs: [1, "mat-toolbar"],
    hostVars: 6,
    hostBindings: function MatToolbar_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassMap(ctx.color ? "mat-" + ctx.color : "");
        ɵɵclassProp("mat-toolbar-multiple-rows", ctx._toolbarRows.length > 0)("mat-toolbar-single-row", ctx._toolbarRows.length === 0);
      }
    },
    inputs: {
      color: "color"
    },
    exportAs: ["matToolbar"],
    ngContentSelectors: _c115,
    decls: 2,
    vars: 0,
    template: function MatToolbar_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c020);
        ɵɵprojection(0);
        ɵɵprojection(1, 1);
      }
    },
    styles: [".mat-toolbar{background:var(--mat-toolbar-container-background-color, var(--mat-sys-surface));color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface))}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font-family:var(--mat-toolbar-title-text-font, var(--mat-sys-title-large-font));font-size:var(--mat-toolbar-title-text-size, var(--mat-sys-title-large-size));line-height:var(--mat-toolbar-title-text-line-height, var(--mat-sys-title-large-line-height));font-weight:var(--mat-toolbar-title-text-weight, var(--mat-sys-title-large-weight));letter-spacing:var(--mat-toolbar-title-text-tracking, var(--mat-sys-title-large-tracking));margin:0}@media(forced-colors: active){.mat-toolbar{outline:solid 1px}}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar .mat-mdc-button-base.mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface));--mdc-outlined-button-label-text-color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface))}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap;height:var(--mat-toolbar-standard-height, 64px)}@media(max-width: 599px){.mat-toolbar-row,.mat-toolbar-single-row{height:var(--mat-toolbar-mobile-height, 56px)}}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%;min-height:var(--mat-toolbar-standard-height, 64px)}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:var(--mat-toolbar-mobile-height, 56px)}}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatToolbar, [{
    type: Component,
    args: [{
      selector: "mat-toolbar",
      exportAs: "matToolbar",
      host: {
        "class": "mat-toolbar",
        "[class]": 'color ? "mat-" + color : ""',
        "[class.mat-toolbar-multiple-rows]": "_toolbarRows.length > 0",
        "[class.mat-toolbar-single-row]": "_toolbarRows.length === 0"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      template: '<ng-content></ng-content>\n<ng-content select="mat-toolbar-row"></ng-content>\n',
      styles: [".mat-toolbar{background:var(--mat-toolbar-container-background-color, var(--mat-sys-surface));color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface))}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font-family:var(--mat-toolbar-title-text-font, var(--mat-sys-title-large-font));font-size:var(--mat-toolbar-title-text-size, var(--mat-sys-title-large-size));line-height:var(--mat-toolbar-title-text-line-height, var(--mat-sys-title-large-line-height));font-weight:var(--mat-toolbar-title-text-weight, var(--mat-sys-title-large-weight));letter-spacing:var(--mat-toolbar-title-text-tracking, var(--mat-sys-title-large-tracking));margin:0}@media(forced-colors: active){.mat-toolbar{outline:solid 1px}}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar .mat-mdc-button-base.mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface));--mdc-outlined-button-label-text-color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface))}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap;height:var(--mat-toolbar-standard-height, 64px)}@media(max-width: 599px){.mat-toolbar-row,.mat-toolbar-single-row{height:var(--mat-toolbar-mobile-height, 56px)}}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%;min-height:var(--mat-toolbar-standard-height, 64px)}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:var(--mat-toolbar-mobile-height, 56px)}}"]
    }]
  }], () => [], {
    color: [{
      type: Input
    }],
    _toolbarRows: [{
      type: ContentChildren,
      args: [MatToolbarRow, {
        descendants: true
      }]
    }]
  });
})();
function throwToolbarMixedModesError() {
  throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.");
}
var MatToolbarModule = class _MatToolbarModule {
  static ɵfac = function MatToolbarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatToolbarModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _MatToolbarModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    imports: [MatCommonModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatToolbarModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, MatToolbar, MatToolbarRow],
      exports: [MatToolbar, MatToolbarRow, MatCommonModule]
    }]
  }], null, null);
})();

// libs/ui/src/lib/components/toolbar-buttons/toolbar-buttons.component.ts
function ToolbarButtonsComponent_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 19);
    ɵɵlistener("click", function ToolbarButtonsComponent_Conditional_3_Conditional_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onBack());
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "arrow_back");
    ɵɵelementEnd()();
  }
}
function ToolbarButtonsComponent_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 18);
  }
}
function ToolbarButtonsComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ToolbarButtonsComponent_Conditional_3_Conditional_0_Template, 3, 0, "button", 17)(1, ToolbarButtonsComponent_Conditional_3_Conditional_1_Template, 1, 0, "img", 18);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵconditional(ctx_r2.backNavigation() ? 0 : 1);
  }
}
function ToolbarButtonsComponent_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 20);
  }
}
function ToolbarButtonsComponent_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 21);
  }
}
function ToolbarButtonsComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ToolbarButtonsComponent_Conditional_4_Conditional_0_Template, 1, 0, "img", 20)(1, ToolbarButtonsComponent_Conditional_4_Conditional_1_Template, 1, 0, "img", 21);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵconditional(ctx_r2.isDark() ? 0 : 1);
  }
}
function ToolbarButtonsComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.pageTitle());
  }
}
function ToolbarButtonsComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 8)(1, "mat-icon");
    ɵɵtext(2, "settings");
    ɵɵelementEnd()();
  }
}
function ToolbarButtonsComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 9);
    ɵɵelement(1, "img", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const menu_r4 = ɵɵreference(11);
    ɵɵproperty("matMenuTriggerFor", menu_r4);
    ɵɵadvance();
    ɵɵproperty("src", ctx_r2.profileThumbnail(), ɵɵsanitizeUrl);
  }
}
function ToolbarButtonsComponent_Conditional_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1, "more_vert");
    ɵɵelementEnd();
  }
}
function ToolbarButtonsComponent_Conditional_9_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1, "person");
    ɵɵelementEnd();
  }
}
function ToolbarButtonsComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 10);
    ɵɵtemplate(1, ToolbarButtonsComponent_Conditional_9_Conditional_1_Template, 2, 0, "mat-icon")(2, ToolbarButtonsComponent_Conditional_9_Conditional_2_Template, 2, 0, "mat-icon");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_3_0;
    const ctx_r2 = ɵɵnextContext();
    const menu_r4 = ɵɵreference(11);
    ɵɵproperty("matMenuTriggerFor", menu_r4);
    ɵɵadvance();
    ɵɵconditional(((tmp_3_0 = ctx_r2.screenSize()) == null ? null : tmp_3_0.isCompact) ? 1 : 2);
  }
}
function ToolbarButtonsComponent_Conditional_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 14)(1, "mat-icon");
    ɵɵtext(2, "settings");
    ɵɵelementEnd();
    ɵɵelementStart(3, "span");
    ɵɵi18n(4, 3);
    ɵɵelementEnd()();
  }
}
var ToolbarButtonsComponent = class _ToolbarButtonsComponent {
  constructor() {
    this.usersService = inject(UsersService);
    this.authService = inject(AuthService);
    this.themeManager = inject(ThemeManagerService);
    this.activePageTitle = inject(ActivePageService);
    this.location = inject(Location);
    this.router = inject(Router);
    this.screenSizeService = inject(ScreenSizeService);
    this.screenSize = this.screenSizeService.screenSize;
    this.pageTitle = this.activePageTitle.pageTitle;
    this.backNavigation = this.activePageTitle.backNavigation;
    this.isDark = this.themeManager.isDark;
    this.userName = this.usersService.userName;
    this.profileThumbnail = this.usersService.profileThumbnail;
  }
  getInitial(name) {
    return name.trim().charAt(0).toUpperCase();
  }
  onBack() {
    this.router.navigateByUrl("/");
  }
  logoutUser() {
    this.authService.logout();
  }
  static {
    this.ɵfac = function ToolbarButtonsComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ToolbarButtonsComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _ToolbarButtonsComponent,
      selectors: [["ui-toolbar-buttons"]],
      decls: 28,
      vars: 15,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_NavigationRail_settings$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_0 = goog.getMsg("Settings");
          i18n_0 = MSG_EXTERNAL_NavigationRail_settings$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_0;
        } else {
          i18n_0 = "Einstellungen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_NavigationRail_settingsAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_1 = goog.getMsg("Settings icon-button");
          i18n_1 = MSG_EXTERNAL_NavigationRail_settingsAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_1;
        } else {
          i18n_1 = "Einstellungen-Icon-Button";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_NavigationRail_profile$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_2 = goog.getMsg("Profile");
          i18n_2 = MSG_EXTERNAL_NavigationRail_profile$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_2;
        } else {
          i18n_2 = "Profil";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_NavigationRail_profileAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_3 = goog.getMsg("User icon-button with a menu");
          i18n_3 = MSG_EXTERNAL_NavigationRail_profileAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_3;
        } else {
          i18n_3 = "Benutzer-Icon-Button mit einem Men\xFC";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_NavigationRail_profileMenuItem$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_4 = goog.getMsg("Profile");
          i18n_4 = MSG_EXTERNAL_NavigationRail_profileMenuItem$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_4;
        } else {
          i18n_4 = "Profil";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_NavigationRail_logoutMenuItem$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_5 = goog.getMsg("Logout");
          i18n_5 = MSG_EXTERNAL_NavigationRail_logoutMenuItem$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_5;
        } else {
          i18n_5 = "Abmelden";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_backBtnTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_6 = goog.getMsg("Back");
          i18n_6 = MSG_EXTERNAL_PageToolbar_backBtnTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_6;
        } else {
          i18n_6 = "Zur\xFCck";
        }
        let i18n_7;
        if (false) {
          const MSG_EXTERNAL_PageToolbar_backButtonAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_7 = goog.getMsg("Arrow back icon button");
          i18n_7 = MSG_EXTERNAL_PageToolbar_backButtonAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_7;
        } else {
          i18n_7 = "Pfeil-Zur\xFCck-Symbolschaltfl\xE4che";
        }
        let i18n_8;
        if (false) {
          const MSG_EXTERNAL_NavigationRail_settings$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_8 = goog.getMsg("Settings");
          i18n_8 = MSG_EXTERNAL_NavigationRail_settings$$LIBS_UI_SRC_LIB_COMPONENTS_TOOLBAR_BUTTONS_TOOLBAR_BUTTONS_COMPONENT_TS_8;
        } else {
          i18n_8 = "Einstellungen";
        }
        return [["menu", "matMenu"], i18n_4, i18n_5, i18n_8, [1, "mat-toolbar"], [1, "menu-logo-wrapper"], [1, "logo"], [1, "page-title", "mat-headline-small"], ["mat-icon-button", "", "matTooltip", i18n_0, "routerLink", "/settings", "aria-label", i18n_1], [1, "circle-thumbnail", 3, "matMenuTriggerFor"], ["mat-icon-button", "", "matTooltip", i18n_2, "aria-label", i18n_3, 3, "matMenuTriggerFor"], [1, "menu-username"], [1, "circle"], [1, "mat-title-small"], ["mat-menu-item", "", "routerLink", "/settings", 2, "min-width", "200px"], ["mat-menu-item", "", "routerLink", "/profile", 2, "min-width", "200px"], ["mat-menu-item", "", 3, "click"], ["mat-icon-button", "", "matTooltip", i18n_6, "aria-label", i18n_7, 1, "back-button"], ["src", "assets/images/leaf-img.svg", "alt", ""], ["mat-icon-button", "", "matTooltip", i18n_6, "aria-label", i18n_7, 1, "back-button", 3, "click"], ["src", "assets/images/leaf-sanare-thin-dark-logo-2-DEMO.svg", "alt", ""], ["src", "assets/images/leaf-sanare-thin-light-logo-2-DEMO.svg", "alt", ""], ["alt", "Thumbnail", 1, "thumbnail-img", 3, "src"]];
      },
      template: function ToolbarButtonsComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "mat-toolbar", 4)(1, "div", 5)(2, "div", 6);
          ɵɵtemplate(3, ToolbarButtonsComponent_Conditional_3_Template, 2, 1)(4, ToolbarButtonsComponent_Conditional_4_Template, 2, 1);
          ɵɵelementEnd()();
          ɵɵtemplate(5, ToolbarButtonsComponent_Conditional_5_Template, 2, 1, "span", 7);
          ɵɵelementStart(6, "div");
          ɵɵtemplate(7, ToolbarButtonsComponent_Conditional_7_Template, 3, 0, "button", 8)(8, ToolbarButtonsComponent_Conditional_8_Template, 2, 2, "button", 9)(9, ToolbarButtonsComponent_Conditional_9_Template, 3, 2, "button", 10);
          ɵɵelementStart(10, "mat-menu", null, 0)(12, "div", 11)(13, "span", 12);
          ɵɵtext(14);
          ɵɵelementEnd();
          ɵɵelementStart(15, "span", 13);
          ɵɵtext(16);
          ɵɵelementEnd()();
          ɵɵtemplate(17, ToolbarButtonsComponent_Conditional_17_Template, 5, 0, "button", 14);
          ɵɵelementStart(18, "button", 15)(19, "mat-icon");
          ɵɵtext(20, "account_circle");
          ɵɵelementEnd();
          ɵɵelementStart(21, "span");
          ɵɵi18n(22, 1);
          ɵɵelementEnd()();
          ɵɵelementStart(23, "button", 16);
          ɵɵlistener("click", function ToolbarButtonsComponent_Template_button_click_23_listener() {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.logoutUser());
          });
          ɵɵelementStart(24, "mat-icon");
          ɵɵtext(25, "logout");
          ɵɵelementEnd();
          ɵɵelementStart(26, "span");
          ɵɵi18n(27, 2);
          ɵɵelementEnd()()()()();
        }
        if (rf & 2) {
          let tmp_3_0;
          let tmp_4_0;
          let tmp_7_0;
          let tmp_11_0;
          ɵɵclassProp("back-navigation-flex", ctx.backNavigation());
          ɵɵadvance();
          ɵɵclassProp("back-nav-item", ctx.backNavigation());
          ɵɵadvance(2);
          ɵɵconditional(((tmp_3_0 = ctx.screenSize()) == null ? null : tmp_3_0.isCompact) ? 3 : 4);
          ɵɵadvance(2);
          ɵɵconditional(((tmp_4_0 = ctx.screenSize()) == null ? null : tmp_4_0.isCompact) ? 5 : -1);
          ɵɵadvance();
          ɵɵclassProp("toolbar-buttons-container", ctx.profileThumbnail())("back-nav-margin", ctx.backNavigation());
          ɵɵadvance();
          ɵɵconditional(((tmp_7_0 = ctx.screenSize()) == null ? null : tmp_7_0.isCompact) === false ? 7 : -1);
          ɵɵadvance();
          ɵɵconditional(ctx.profileThumbnail() ? 8 : 9);
          ɵɵadvance(6);
          ɵɵtextInterpolate1(" ", ctx.getInitial(ctx.userName()), " ");
          ɵɵadvance(2);
          ɵɵtextInterpolate(ctx.userName());
          ɵɵadvance();
          ɵɵconditional(((tmp_11_0 = ctx.screenSize()) == null ? null : tmp_11_0.isCompact) ? 17 : -1);
        }
      },
      dependencies: [CommonModule, MatIconModule, MatIcon, MatButtonModule, MatIconButton, MatToolbarModule, MatToolbar, MatMenuModule, MatMenu, MatMenuItem, MatMenuTrigger, RouterLink],
      styles: [".mat-toolbar[_ngcontent-%COMP%]{position:relative;z-index:3;width:100%}.mat-toolbar[_ngcontent-%COMP%]   .toolbar-buttons-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;align-items:center;gap:4px}.mat-toolbar[_ngcontent-%COMP%]   .menu-logo-wrapper[_ngcontent-%COMP%]{display:flex;justify-content:flex-start;min-width:238px;padding-right:30px;padding-left:4px;flex:1 1 100%}.mat-toolbar[_ngcontent-%COMP%]   .menu-logo-wrapper[_ngcontent-%COMP%]   .logo[_ngcontent-%COMP%]{margin:18px 0 0 -4px}.mat-toolbar[_ngcontent-%COMP%]   .menu-logo-wrapper[_ngcontent-%COMP%]   .logo[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%}@media (max-width: 599px){.mat-toolbar[_ngcontent-%COMP%]{width:100vw;justify-content:space-between;position:sticky;align-items:center;padding:0 16px}.mat-toolbar.back-navigation-flex[_ngcontent-%COMP%]{justify-content:flex-start}.mat-toolbar[_ngcontent-%COMP%]   .menu-logo-wrapper[_ngcontent-%COMP%]{display:block;min-width:40px;flex:0;padding:0}.mat-toolbar[_ngcontent-%COMP%]   .menu-logo-wrapper.back-nav-item[_ngcontent-%COMP%]{margin-right:8px}.mat-toolbar[_ngcontent-%COMP%]   .menu-logo-wrapper[_ngcontent-%COMP%]   .logo[_ngcontent-%COMP%]{width:100%;margin:0}.mat-toolbar[_ngcontent-%COMP%]   .menu-logo-wrapper[_ngcontent-%COMP%]   .logo[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;margin-top:8px}.mat-toolbar[_ngcontent-%COMP%]   .back-nav-margin[_ngcontent-%COMP%]{margin-left:auto}.mat-toolbar[_ngcontent-%COMP%]   .page-title[_ngcontent-%COMP%]{padding:0}}.menu-username[_ngcontent-%COMP%]{display:flex;align-items:center;padding:12px;width:100%}.menu-username[_ngcontent-%COMP%]   .circle[_ngcontent-%COMP%]{margin-right:12px;width:24px;height:24px;background-color:#67b044;color:#fff;font-size:16px;font-weight:700;display:flex;align-items:center;justify-content:center;border-radius:50%;text-transform:uppercase}.circle-thumbnail[_ngcontent-%COMP%]{width:40px;height:40px;border-radius:50%;padding:0;cursor:pointer;overflow:hidden;-webkit-tap-highlight-color:transparent;user-select:none;-webkit-user-select:none;touch-action:manipulation}.thumbnail-img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;display:block;transition:opacity .2s ease}\n/*# sourceMappingURL=toolbar-buttons.component-VCPDVDVR.css.map */"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(ToolbarButtonsComponent, {
    className: "ToolbarButtonsComponent",
    filePath: "libs/ui/src/lib/components/toolbar-buttons/toolbar-buttons.component.ts",
    lineNumber: 26
  });
})();

// libs/ui/src/lib/components/favorite-programs/favorite-programs.component.ts
var _forTrack02 = ($index, $item) => $item.id;
function FavoriteProgramsComponent_For_7_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "img", 11);
    ɵɵelementEnd();
  }
}
function FavoriteProgramsComponent_For_7_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵelement(1, "img", 12);
    ɵɵelementEnd();
  }
}
function FavoriteProgramsComponent_For_7_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵlistener("click", function FavoriteProgramsComponent_For_7_Conditional_7_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const program_r3 = ɵɵnextContext().$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.openEditProgram(program_r3));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "edit");
    ɵɵelementEnd()();
  }
}
function FavoriteProgramsComponent_For_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4)(1, "mat-list-item")(2, "mat-icon", 5);
    ɵɵtemplate(3, FavoriteProgramsComponent_For_7_Conditional_3_Template, 2, 0, "div", 6)(4, FavoriteProgramsComponent_For_7_Conditional_4_Template, 2, 0, "div", 7);
    ɵɵelementEnd();
    ɵɵelementStart(5, "p", 8);
    ɵɵtext(6);
    ɵɵelementEnd()();
    ɵɵtemplate(7, FavoriteProgramsComponent_For_7_Conditional_7_Template, 3, 0, "button", 9);
    ɵɵelementStart(8, "button", 10);
    ɵɵlistener("click", function FavoriteProgramsComponent_For_7_Template_button_click_8_listener() {
      const program_r3 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.reuseEditProgram(program_r3));
    });
    ɵɵelementStart(9, "mat-icon");
    ɵɵtext(10, "person_add");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const program_r3 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵconditional(program_r3.isAdminProgram ? 3 : 4);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", program_r3.name, " ");
    ɵɵadvance();
    ɵɵconditional(!program_r3.isAdminProgram || ctx_r3.isAdmin() ? 7 : -1);
  }
}
var FavoriteProgramsComponent = class _FavoriteProgramsComponent {
  constructor() {
    this.isAdmin = input();
    this.themeSignal = input();
    this.favoritePrograms = input();
    this.reuseEditProgramEvent = output();
    this.openEditProgramEvent = output();
  }
  ngOnInit() {}
  reuseEditProgram(program) {
    this.reuseEditProgramEvent.emit(program);
  }
  openEditProgram(program) {
    this.openEditProgramEvent.emit(program);
  }
  static {
    this.ɵfac = function FavoriteProgramsComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _FavoriteProgramsComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _FavoriteProgramsComponent,
      selectors: [["ui-favorite-programs"]],
      inputs: {
        isAdmin: [1, "isAdmin"],
        themeSignal: [1, "themeSignal"],
        favoritePrograms: [1, "favoritePrograms"]
      },
      outputs: {
        reuseEditProgramEvent: "reuseEditProgramEvent",
        openEditProgramEvent: "openEditProgramEvent"
      },
      decls: 8,
      vars: 1,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_Dashboard_favoriteProgramsTitle$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_0 = goog.getMsg(" Favorite programs ");
          i18n_0 = MSG_EXTERNAL_Dashboard_favoriteProgramsTitle$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_0;
        } else {
          i18n_0 = " Lieblingsprogramme ";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_defaultProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_1 = goog.getMsg("Default program");
          i18n_1 = MSG_EXTERNAL_ProgramsList_defaultProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_1;
        } else {
          i18n_1 = "Standardprogramm";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_UsersProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_2 = goog.getMsg("User's program");
          i18n_2 = MSG_EXTERNAL_ProgramsList_UsersProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_2;
        } else {
          i18n_2 = "Benutzerprogramm";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_editProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_3 = goog.getMsg("Edit");
          i18n_3 = MSG_EXTERNAL_ProgramsList_editProgramTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_3;
        } else {
          i18n_3 = "Bearbeiten";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_editProgramAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_4 = goog.getMsg("Edit icon button");
          i18n_4 = MSG_EXTERNAL_ProgramsList_editProgramAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_4;
        } else {
          i18n_4 = "Symbolschaltfl\xE4che \u201EBearbeiten\u201C";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_addToClientTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_5 = goog.getMsg("Add to client");
          i18n_5 = MSG_EXTERNAL_ProgramsList_addToClientTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_5;
        } else {
          i18n_5 = "Zum Patienten hinzuf\xFCgen";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_ProgramsList_addToClientAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_6 = goog.getMsg("Add to client icon button");
          i18n_6 = MSG_EXTERNAL_ProgramsList_addToClientAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_PROGRAMS_FAVORITE_PROGRAMS_COMPONENT_TS_6;
        } else {
          i18n_6 = "Schaltfl\xE4che \u201EZum Client hinzuf\xFCgen\u201C";
        }
        return [i18n_0, [1, "favorite-programs-container"], [1, "mat-title-medium-margin-plus"], ["overlay-scrollbars", "", 1, "list-container", 3, "options", "defer"], [1, "list-item-wrapper"], ["matListItemIcon", ""], ["matTooltip", i18n_1, 1, "template-icon"], ["matTooltip", i18n_2, 1, "template-icon"], ["matListItemTitle", "", 1, "list-title"], ["mat-icon-button", "", "matTooltip", i18n_3, "aria-label", i18n_4], ["mat-icon-button", "", "matTooltip", i18n_5, "aria-label", i18n_6, 3, "click"], ["width", "16", "src", "assets/images/leaf-img.svg", "alt", ""], ["width", "14", "src", "assets/images/blue-user-icon.svg", "alt", ""], ["mat-icon-button", "", "matTooltip", i18n_3, "aria-label", i18n_4, 3, "click"]];
      },
      template: function FavoriteProgramsComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 1)(1, "h3", 2);
          ɵɵi18n(2, 0);
          ɵɵelementEnd();
          ɵɵelementStart(3, "div", 3)(4, "div")(5, "mat-list");
          ɵɵrepeaterCreate(6, FavoriteProgramsComponent_For_7_Template, 11, 3, "div", 4, _forTrack02);
          ɵɵelementEnd()()()();
        }
        if (rf & 2) {
          ɵɵadvance(3);
          ɵɵproperty("options", ctx.themeSignal());
          ɵɵadvance(3);
          ɵɵrepeater(ctx.favoritePrograms());
        }
      },
      dependencies: [CommonModule, MatIconModule, MatIcon, MatListModule, MatList, MatListItem, MatListItemIcon, MatListItemTitle, MatButtonModule, MatIconButton, MatTooltipModule, MatTooltip, OverlayscrollbarsModule, OverlayScrollbarsComponent],
      styles: ['.favorite-programs-container[_ngcontent-%COMP%]{height:100%;display:block;overflow:hidden;padding:16px;border-radius:16px}.favorite-programs-container[_ngcontent-%COMP%]   .list-container[_ngcontent-%COMP%]{height:86%;overflow-y:auto}.favorite-programs-container[_ngcontent-%COMP%]   .list-container[_ngcontent-%COMP%]   .list-item-wrapper[_ngcontent-%COMP%]{display:flex;align-items:center;padding-right:12px;margin-bottom:4px}.favorite-programs-container[_ngcontent-%COMP%]   .list-container[_ngcontent-%COMP%]   .list-item-wrapper[_ngcontent-%COMP%]   .list-title[_ngcontent-%COMP%]{white-space:wrap;margin:0}.favorite-programs-container[_ngcontent-%COMP%]   .list-container[_ngcontent-%COMP%]   .list-item-wrapper[_ngcontent-%COMP%]   .template-icon[_ngcontent-%COMP%]{bottom:4px;position:relative}.favorite-programs-container[_ngcontent-%COMP%]   .programs-list-wrapper-placeholder[_ngcontent-%COMP%]{height:calc(100vh - 238px);overflow-y:hidden}.favorite-programs-container[_ngcontent-%COMP%]   .programs-list-wrapper-placeholder[_ngcontent-%COMP%]   .program-list-skeleton[_ngcontent-%COMP%]{border-radius:8px;width:100%;height:78px;overflow:hidden;position:relative;margin-bottom:4px}.favorite-programs-container[_ngcontent-%COMP%]   .programs-list-wrapper-placeholder[_ngcontent-%COMP%]   .program-list-skeleton[_ngcontent-%COMP%]:after{position:absolute;inset:0;transform:translate(-100%);animation:_ngcontent-%COMP%_shimmer 1s infinite;content:""}@keyframes _ngcontent-%COMP%_shimmer{to{transform:translate(100%)}}@media (max-width: 599px){.favorite-programs-container[_ngcontent-%COMP%]   .favorite-programs-container[_ngcontent-%COMP%]{padding:8px}}\n/*# sourceMappingURL=favorite-programs.component-FZ4NVCNP.css.map */'],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(FavoriteProgramsComponent, {
    className: "FavoriteProgramsComponent",
    filePath: "libs/ui/src/lib/components/favorite-programs/favorite-programs.component.ts",
    lineNumber: 30
  });
})();

// libs/ui/src/lib/components/favorite-exercises/favorite-exercises.component.ts
var _forTrack03 = ($index, $item) => $item.id;
function FavoriteExercisesComponent_For_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7);
    ɵɵlistener("mouseenter", function FavoriteExercisesComponent_For_7_Template_div_mouseenter_0_listener() {
      ɵɵrestoreView(_r1);
      const videoPlayer_r2 = ɵɵreference(3);
      return ɵɵresetView(videoPlayer_r2.onMouseEnter());
    })("mouseleave", function FavoriteExercisesComponent_For_7_Template_div_mouseleave_0_listener() {
      ɵɵrestoreView(_r1);
      const videoPlayer_r2 = ɵɵreference(3);
      return ɵɵresetView(videoPlayer_r2.onMouseLeave());
    })("click", function FavoriteExercisesComponent_For_7_Template_div_click_0_listener() {
      const exercise_r3 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.viewExercise(exercise_r3.id));
    });
    ɵɵelementStart(1, "div", 8);
    ɵɵelement(2, "ui-video-player", 9, 0);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 10);
    ɵɵtext(5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const exercise_r3 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("videoSrc", exercise_r3.video)("thumbnail", exercise_r3.images == null ? null : exercise_r3.images.mainImg[0])("isModal", false)("isDash", true);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", exercise_r3.name[ctx_r3.selectedLanguage], " ");
  }
}
var FavoriteExercisesComponent = class _FavoriteExercisesComponent {
  constructor() {
    this.router = inject(Router);
    this.localstorageService = inject(LocalstorageService);
    this.favoriteExercises = input();
    this.themeSignal = input();
  }
  _getUserLanguageToken() {
    return this.localstorageService.getToken("userLanguage")?.split("-")[0];
  }
  ngOnInit() {
    this.selectedLanguage = this._getUserLanguageToken();
  }
  viewExercise(exerciseId) {
    this.router.navigate(["/exercise", exerciseId]);
  }
  static {
    this.ɵfac = function FavoriteExercisesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _FavoriteExercisesComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _FavoriteExercisesComponent,
      selectors: [["ui-favorite-exercises"]],
      inputs: {
        favoriteExercises: [1, "favoriteExercises"],
        themeSignal: [1, "themeSignal"]
      },
      decls: 8,
      vars: 1,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_Dashboard_favoriteExercisesTitle$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_EXERCISES_FAVORITE_EXERCISES_COMPONENT_TS_0 = goog.getMsg(" Favorite exercises ");
          i18n_0 = MSG_EXTERNAL_Dashboard_favoriteExercisesTitle$$LIBS_UI_SRC_LIB_COMPONENTS_FAVORITE_EXERCISES_FAVORITE_EXERCISES_COMPONENT_TS_0;
        } else {
          i18n_0 = " Lieblings\xFCbungen ";
        }
        return [["videoPlayer", ""], i18n_0, [1, "favorite-exercises-container"], [1, "mat-title-medium-margin-plus"], ["overlay-scrollbars", "", 1, "scroll-list-container", 3, "options", "defer"], [1, "dash-grid-container"], ["matRipple", "", 1, "grid-item"], ["matRipple", "", 1, "grid-item", 3, "mouseenter", "mouseleave", "click"], [1, "video-container"], [3, "videoSrc", "thumbnail", "isModal", "isDash"], [1, "exercise-name", "mat-body-medium"]];
      },
      template: function FavoriteExercisesComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 2)(1, "h3", 3);
          ɵɵi18n(2, 1);
          ɵɵelementEnd();
          ɵɵelementStart(3, "div", 4)(4, "div")(5, "div", 5);
          ɵɵrepeaterCreate(6, FavoriteExercisesComponent_For_7_Template, 6, 5, "div", 6, _forTrack03);
          ɵɵelementEnd()()()();
        }
        if (rf & 2) {
          ɵɵadvance(3);
          ɵɵproperty("options", ctx.themeSignal());
          ɵɵadvance(3);
          ɵɵrepeater(ctx.favoriteExercises());
        }
      },
      dependencies: [CommonModule, VideoPlayerComponent, OverlayscrollbarsModule, OverlayScrollbarsComponent, MatRippleModule, MatRipple],
      styles: [".favorite-exercises-container[_ngcontent-%COMP%]{border-radius:16px;height:100%;display:block;padding:16px;overflow:hidden}.favorite-exercises-container[_ngcontent-%COMP%]   .scroll-list-container[_ngcontent-%COMP%]{height:88%;overflow:hidden}.favorite-exercises-container[_ngcontent-%COMP%]   .scroll-list-container[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]   .dash-grid-container[_ngcontent-%COMP%]{min-width:0;width:100%;display:grid;gap:16px;grid-template-columns:repeat(2,minmax(0,1fr));grid-auto-rows:minmax(100px,110px);padding-right:10px}.favorite-exercises-container[_ngcontent-%COMP%]   .scroll-list-container[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]   .dash-grid-container[_ngcontent-%COMP%]   .grid-item[_ngcontent-%COMP%]{display:flex;flex-direction:row;gap:8px;align-items:center;border-radius:16px;padding:8px;cursor:pointer}.favorite-exercises-container[_ngcontent-%COMP%]   .scroll-list-container[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]   .dash-grid-container[_ngcontent-%COMP%]   .grid-item[_ngcontent-%COMP%]   .video-container[_ngcontent-%COMP%]{height:100%}\n/*# sourceMappingURL=favorite-exercises.component-OKPC33MJ.css.map */"],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(FavoriteExercisesComponent, {
    className: "FavoriteExercisesComponent",
    filePath: "libs/ui/src/lib/components/favorite-exercises/favorite-exercises.component.ts",
    lineNumber: 27
  });
})();

// libs/exercises/src/lib/pages/exercise-modal/exercise-modal.component.ts
var _c021 = a0 => ({
  "program-exercise": a0
});
function ExerciseModalComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 10)(1, "mat-icon");
    ɵɵtext(2, "arrow_back");
    ɵɵelementEnd()();
  }
}
function ExerciseModalComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h1", 19);
    ɵɵi18n(1, 7);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 20)(3, "mat-icon");
    ɵɵtext(4, "close");
    ɵɵelementEnd()();
  }
}
function ExerciseModalComponent_For_22_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const muscle_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(muscle_r1);
  }
}
function ExerciseModalComponent_For_28_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const bodyArea_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(bodyArea_r2.translations == null ? null : bodyArea_r2.translations[ctx_r2.selectedLang]);
  }
}
function ExerciseModalComponent_For_34_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const movement_r4 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(movement_r4.translations == null ? null : movement_r4.translations[ctx_r2.selectedLang]);
  }
}
function ExerciseModalComponent_For_40_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const startingPosition_r5 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(startingPosition_r5.translations == null ? null : startingPosition_r5.translations[ctx_r2.selectedLang]);
  }
}
function ExerciseModalComponent_For_46_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const equipment_r6 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(equipment_r6.translations[ctx_r2.selectedLang]);
  }
}
function ExerciseModalComponent_Conditional_47_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 23);
    ɵɵlistener("click", function ExerciseModalComponent_Conditional_47_Conditional_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.removeFromSelected(ctx_r2.data.exerciseCard));
    })("mouseenter", function ExerciseModalComponent_Conditional_47_Conditional_1_Template_button_mouseenter_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.showHoverIcon(true));
    })("mouseleave", function ExerciseModalComponent_Conditional_47_Conditional_1_Template_button_mouseleave_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.showHoverIcon(false));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("color", ctx_r2.isHovered ? "warn" : "primary");
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.isHovered ? "close" : "done");
  }
}
function ExerciseModalComponent_Conditional_47_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 24);
    ɵɵlistener("click", function ExerciseModalComponent_Conditional_47_Conditional_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.addToSelected(ctx_r2.data.exerciseCard));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "add");
    ɵɵelementEnd()();
  }
}
function ExerciseModalComponent_Conditional_47_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-dialog-actions", 18);
    ɵɵtemplate(1, ExerciseModalComponent_Conditional_47_Conditional_1_Template, 3, 2, "button", 21)(2, ExerciseModalComponent_Conditional_47_Conditional_2_Template, 3, 0, "button", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵconditional(ctx_r2.data.exerciseCard.isSelected ? 1 : 2);
  }
}
function ExerciseModalComponent_Conditional_48_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-dialog-actions");
  }
}
var ExerciseModalComponent = class _ExerciseModalComponent {
  constructor() {
    this.data = inject(MAT_DIALOG_DATA);
    this.selectedExercisesService = inject(SelectedExercisesService);
    this.themeManager = inject(ThemeManagerService);
    this.selectedLang = this.data.selectedLang;
    this.themeSignal = this.themeManager.themeSignal;
    this.isHovered = false;
  }
  addToSelected(exercise) {
    this.selectedExercisesService.addToSelected(exercise);
    console.log(this.selectedExercisesService.selectedExercises());
  }
  removeFromSelected(exercise) {
    this.selectedExercisesService.removeFromSelected(exercise);
    console.log(this.selectedExercisesService.selectedExercises());
  }
  showHoverIcon(isHovered) {
    this.isHovered = isHovered;
  }
  static {
    this.ɵfac = function ExerciseModalComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ExerciseModalComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _ExerciseModalComponent,
      selectors: [["exercises-single-modal"]],
      decls: 49,
      vars: 14,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_backToProgramsTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_0 = goog.getMsg("Back to programs");
          i18n_0 = MSG_EXTERNAL_ExerciseModal_backToProgramsTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_0;
        } else {
          i18n_0 = "Zur\xFCck zu den Programmen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_backToProgramsAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_1 = goog.getMsg("Arrow back icon-button");
          i18n_1 = MSG_EXTERNAL_ExerciseModal_backToProgramsAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_1;
        } else {
          i18n_1 = "Pfeil zur\xFCck Symbol-Schaltfl\xE4che";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_exerciseName$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_2 = goog.getMsg("Exercise name: ");
          i18n_2 = MSG_EXTERNAL_ExerciseModal_exerciseName$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_2;
        } else {
          i18n_2 = "\xDCbungsname: ";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_exerciseDescription$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_3 = goog.getMsg("Description: ");
          i18n_3 = MSG_EXTERNAL_ExerciseModal_exerciseDescription$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_3;
        } else {
          i18n_3 = "Beschreibung: ";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_muscles$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_4 = goog.getMsg("Muscles: ");
          i18n_4 = MSG_EXTERNAL_ExerciseModal_muscles$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_4;
        } else {
          i18n_4 = "Muskeln:";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_bodyAreas$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_5 = goog.getMsg("Body areas: ");
          i18n_5 = MSG_EXTERNAL_ExerciseModal_bodyAreas$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_5;
        } else {
          i18n_5 = "K\xF6rperbereiche:";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_movements$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_6 = goog.getMsg("Movements: ");
          i18n_6 = MSG_EXTERNAL_ExerciseModal_movements$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_6;
        } else {
          i18n_6 = "Bewegungen:";
        }
        let i18n_7;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_startingPositions$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_7 = goog.getMsg("Starting positions: ");
          i18n_7 = MSG_EXTERNAL_ExerciseModal_startingPositions$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_7;
        } else {
          i18n_7 = "Startpositionen:";
        }
        let i18n_8;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_equipment$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_8 = goog.getMsg("Equipment: ");
          i18n_8 = MSG_EXTERNAL_ExerciseModal_equipment$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_8;
        } else {
          i18n_8 = "Ausr\xFCstung: ";
        }
        let i18n_9;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_closeModalIconAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_9 = goog.getMsg("Icon button with a close icon");
          i18n_9 = MSG_EXTERNAL_ExerciseModal_closeModalIconAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_9;
        } else {
          i18n_9 = "Symbolschaltfl\xE4che mit einem Schlie\xDFen-Symbol";
        }
        let i18n_10;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_exerciseDetails$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_10 = goog.getMsg(" Exercise details ");
          i18n_10 = MSG_EXTERNAL_ExerciseModal_exerciseDetails$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_10;
        } else {
          i18n_10 = "\xDCbungsdetails";
        }
        let i18n_11;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_removeExerciseTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_11 = goog.getMsg("Remove exercise");
          i18n_11 = MSG_EXTERNAL_ExerciseModal_removeExerciseTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_11;
        } else {
          i18n_11 = "\xDCbung entfernen";
        }
        let i18n_12;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_removeExerciseAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_12 = goog.getMsg("Remove icon-button with a close icon");
          i18n_12 = MSG_EXTERNAL_ExerciseModal_removeExerciseAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_12;
        } else {
          i18n_12 = "Symbolschaltfl\xE4che \u201EEntfernen\u201C mit einem Schlie\xDFen-Symbol";
        }
        let i18n_13;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_addExerciseTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_13 = goog.getMsg("Add exercise");
          i18n_13 = MSG_EXTERNAL_ExerciseModal_addExerciseTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_13;
        } else {
          i18n_13 = "\xDCbung hinzuf\xFCgen";
        }
        let i18n_14;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_addExerciseAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_14 = goog.getMsg("Add icon button with a add icon");
          i18n_14 = MSG_EXTERNAL_ExerciseModal_addExerciseAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_EXERCISE_MODAL_EXERCISE_MODAL_COMPONENT_TS_14;
        } else {
          i18n_14 = "\xDCbung hinzuf\xFCgen";
        }
        return [i18n_2, i18n_3, i18n_4, i18n_5, i18n_6, i18n_7, i18n_8, i18n_10, [1, "confirmation-dialog-wrapper"], [1, "title-wrapper", 3, "ngClass"], ["mat-icon-button", "", "matTooltip", i18n_0, "aria-label", i18n_1, "mat-dialog-close", ""], ["overlay-scrollbars", "", 1, "dialog-content-wrapper", 3, "options", "defer", "ngClass"], [1, "modal-img-wrapper"], [3, "videoSrc", "thumbnail"], [1, "category-labels"], [1, "label"], [1, "category-value"], [1, "chips-category"], [1, "exercise-modal-actions"], ["mat-dialog-title", "", 1, "mat-title-large"], ["mat-icon-button", "", "mat-dialog-close", "", "aria-label", i18n_9], ["mat-fab", "", "matTooltip", i18n_11, "aria-label", i18n_12, 3, "color"], ["mat-fab", "", "matTooltip", i18n_13, "color", "primary", "aria-label", i18n_14], ["mat-fab", "", "matTooltip", i18n_11, "aria-label", i18n_12, 3, "click", "mouseenter", "mouseleave", "color"], ["mat-fab", "", "matTooltip", i18n_13, "color", "primary", "aria-label", i18n_14, 3, "click"]];
      },
      template: function ExerciseModalComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 8)(1, "div", 9);
          ɵɵtemplate(2, ExerciseModalComponent_Conditional_2_Template, 3, 0, "button", 10)(3, ExerciseModalComponent_Conditional_3_Template, 5, 0);
          ɵɵelementEnd();
          ɵɵelementStart(4, "div", 11)(5, "div", 12);
          ɵɵelement(6, "ui-video-player", 13);
          ɵɵelementEnd();
          ɵɵelementStart(7, "div", 14)(8, "span", 15);
          ɵɵi18n(9, 0);
          ɵɵelementEnd();
          ɵɵelementStart(10, "span", 16);
          ɵɵtext(11);
          ɵɵelementEnd()();
          ɵɵelementStart(12, "div", 14)(13, "span", 15);
          ɵɵi18n(14, 1);
          ɵɵelementEnd();
          ɵɵelementStart(15, "span", 16);
          ɵɵtext(16);
          ɵɵelementEnd()();
          ɵɵelementStart(17, "div", 14)(18, "span", 15);
          ɵɵi18n(19, 2);
          ɵɵelementEnd();
          ɵɵelementStart(20, "mat-chip-set");
          ɵɵrepeaterCreate(21, ExerciseModalComponent_For_22_Template, 2, 1, "mat-chip", 17, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵelementStart(23, "div", 14)(24, "span", 15);
          ɵɵi18n(25, 3);
          ɵɵelementEnd();
          ɵɵelementStart(26, "mat-chip-set");
          ɵɵrepeaterCreate(27, ExerciseModalComponent_For_28_Template, 2, 1, "mat-chip", 17, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵelementStart(29, "div", 14)(30, "span", 15);
          ɵɵi18n(31, 4);
          ɵɵelementEnd();
          ɵɵelementStart(32, "mat-chip-set");
          ɵɵrepeaterCreate(33, ExerciseModalComponent_For_34_Template, 2, 1, "mat-chip", 17, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵelementStart(35, "div", 14)(36, "span", 15);
          ɵɵi18n(37, 5);
          ɵɵelementEnd();
          ɵɵelementStart(38, "mat-chip-set");
          ɵɵrepeaterCreate(39, ExerciseModalComponent_For_40_Template, 2, 1, "mat-chip", 17, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵelementStart(41, "div", 14)(42, "span", 15);
          ɵɵi18n(43, 6);
          ɵɵelementEnd();
          ɵɵelementStart(44, "mat-chip-set");
          ɵɵrepeaterCreate(45, ExerciseModalComponent_For_46_Template, 2, 1, "mat-chip", 17, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()()();
          ɵɵtemplate(47, ExerciseModalComponent_Conditional_47_Template, 3, 1, "mat-dialog-actions", 18)(48, ExerciseModalComponent_Conditional_48_Template, 1, 0, "mat-dialog-actions");
          ɵɵelementEnd();
        }
        if (rf & 2) {
          ɵɵadvance();
          ɵɵproperty("ngClass", ɵɵpureFunction1(10, _c021, ctx.data.isProgramExercise));
          ɵɵadvance();
          ɵɵconditional(ctx.data.isProgramExercise ? 2 : -1);
          ɵɵadvance();
          ɵɵconditional(!ctx.data.isProgramExercise ? 3 : -1);
          ɵɵadvance();
          ɵɵproperty("options", ctx.themeSignal())("ngClass", ɵɵpureFunction1(12, _c021, ctx.data.isProgramExercise));
          ɵɵadvance(2);
          ɵɵproperty("videoSrc", ctx.data.fullExercise.video)("thumbnail", ctx.data.fullExercise.images == null ? null : ctx.data.fullExercise.images.mainImg);
          ɵɵadvance(5);
          ɵɵtextInterpolate(ctx.data.fullExercise.name[ctx.selectedLang]);
          ɵɵadvance(5);
          ɵɵtextInterpolate(ctx.data.fullExercise.description[ctx.selectedLang]);
          ɵɵadvance(5);
          ɵɵrepeater(ctx.data.fullExercise.muscles);
          ɵɵadvance(6);
          ɵɵrepeater(ctx.data.fullExercise.bodyAreas);
          ɵɵadvance(6);
          ɵɵrepeater(ctx.data.fullExercise.movements);
          ɵɵadvance(6);
          ɵɵrepeater(ctx.data.fullExercise.startingPositions);
          ɵɵadvance(6);
          ɵɵrepeater(ctx.data.fullExercise.equipments);
          ɵɵadvance(2);
          ɵɵconditional(!ctx.data.isProgramExercise ? 47 : 48);
        }
      },
      dependencies: [NgClass, MatIconButton, MatTooltip, MatDialogClose, MatIcon, MatDialogTitle, OverlayscrollbarsModule, OverlayScrollbarsComponent, MatChipSet, MatChip, MatDialogActions, MatFabButton, VideoPlayerComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(ExerciseModalComponent, {
    className: "ExerciseModalComponent",
    filePath: "libs/exercises/src/lib/pages/exercise-modal/exercise-modal.component.ts",
    lineNumber: 44
  });
})();

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i2 = 0; i2 < descendantsWithId.length; i2++) {
    descendantsWithId[i2].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i2 = 0; i2 < descendantElements.length; i2++) {
      callback(descendantElements[i2], cloneElements[i2]);
    }
  }
}
var cloneUniqueId = 0;
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context = clone.getContext("2d");
  if (context) {
    try {
      context.drawImage(source, 0, 0);
    } catch {}
  }
}
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
function isInsideClientRect(clientRect, x2, y2) {
  const {
    top,
    bottom,
    left,
    right
  } = clientRect;
  return y2 >= top && y2 <= bottom && x2 >= left && x2 <= right;
}
function adjustDomRect(domRect, top, left) {
  domRect.top += top;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
var ParentPositionTracker = class {
  _document;
  /** Cached positions of the scrollable parent elements. */
  positions = /* @__PURE__ */new Map();
  constructor(_document) {
    this._document = _document;
  }
  /** Clears the cached positions. */
  clear() {
    this.positions.clear();
  }
  /** Caches the positions. Should be called at the beginning of a drag sequence. */
  cache(elements) {
    this.clear();
    this.positions.set(this._document, {
      scrollPosition: this.getViewportScrollPosition()
    });
    elements.forEach(element => {
      this.positions.set(element, {
        scrollPosition: {
          top: element.scrollTop,
          left: element.scrollLeft
        },
        clientRect: getMutableClientRect(element)
      });
    });
  }
  /** Handles scrolling while a drag is taking place. */
  handleScroll(event) {
    const target = _getEventTarget(event);
    const cachedPosition = this.positions.get(target);
    if (!cachedPosition) {
      return null;
    }
    const scrollPosition = cachedPosition.scrollPosition;
    let newTop;
    let newLeft;
    if (target === this._document) {
      const viewportScrollPosition = this.getViewportScrollPosition();
      newTop = viewportScrollPosition.top;
      newLeft = viewportScrollPosition.left;
    } else {
      newTop = target.scrollTop;
      newLeft = target.scrollLeft;
    }
    const topDifference = scrollPosition.top - newTop;
    const leftDifference = scrollPosition.left - newLeft;
    this.positions.forEach((position, node) => {
      if (position.clientRect && target !== node && target.contains(node)) {
        adjustDomRect(position.clientRect, topDifference, leftDifference);
      }
    });
    scrollPosition.top = newTop;
    scrollPosition.left = newLeft;
    return {
      top: topDifference,
      left: leftDifference
    };
  }
  /**
   * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,
   * instead of going through the `ViewportRuler`, because the first value the ruler looks at is
   * the top/left offset of the `document.documentElement` which works for most cases, but breaks
   * if the element is offset by something like the `BlockScrollStrategy`.
   */
  getViewportScrollPosition() {
    return {
      top: window.scrollY,
      left: window.scrollX
    };
  }
};
function getRootNode(viewRef, _document) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document.createElement("div");
  rootNodes.forEach(node => wrapper.appendChild(node));
  return wrapper;
}
function extendStyles(dest, source, importantProperties2) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties2?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
function toggleVisibility(element, enable, importantProperties2) {
  extendStyles(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties2);
}
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
function getTransform(x2, y2) {
  return `translate3d(${Math.round(x2)}px, ${Math.round(y2)}px, 0)`;
}
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find(prop => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map(part => part.trim());
}
var importantProperties = /* @__PURE__ */new Set([
// Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
"position"]);
var PreviewRef = class {
  _document;
  _rootElement;
  _direction;
  _initialDomRect;
  _previewTemplate;
  _previewClass;
  _pickupPositionOnPage;
  _initialTransform;
  _zIndex;
  _renderer;
  /** Reference to the view of the preview element. */
  _previewEmbeddedView;
  /** Reference to the preview element. */
  _preview;
  get element() {
    return this._preview;
  }
  constructor(_document, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex, _renderer) {
    this._document = _document;
    this._rootElement = _rootElement;
    this._direction = _direction;
    this._initialDomRect = _initialDomRect;
    this._previewTemplate = _previewTemplate;
    this._previewClass = _previewClass;
    this._pickupPositionOnPage = _pickupPositionOnPage;
    this._initialTransform = _initialTransform;
    this._zIndex = _zIndex;
    this._renderer = _renderer;
  }
  attach(parent2) {
    this._preview = this._createPreview();
    parent2.appendChild(this._preview);
    if (supportsPopover(this._preview)) {
      this._preview["showPopover"]();
    }
  }
  destroy() {
    this._preview.remove();
    this._previewEmbeddedView?.destroy();
    this._preview = this._previewEmbeddedView = null;
  }
  setTransform(value) {
    this._preview.style.transform = value;
  }
  getBoundingClientRect() {
    return this._preview.getBoundingClientRect();
  }
  addClass(className) {
    this._preview.classList.add(className);
  }
  getTransitionDuration() {
    return getTransformTransitionDurationInMs(this._preview);
  }
  addEventListener(name, handler) {
    return this._renderer.listen(this._preview, name, handler);
  }
  _createPreview() {
    const previewConfig = this._previewTemplate;
    const previewClass = this._previewClass;
    const previewTemplate = previewConfig ? previewConfig.template : null;
    let preview;
    if (previewTemplate && previewConfig) {
      const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
      const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
      viewRef.detectChanges();
      preview = getRootNode(viewRef, this._document);
      this._previewEmbeddedView = viewRef;
      if (previewConfig.matchSize) {
        matchElementSize(preview, rootRect);
      } else {
        preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
      }
    } else {
      preview = deepCloneNode(this._rootElement);
      matchElementSize(preview, this._initialDomRect);
      if (this._initialTransform) {
        preview.style.transform = this._initialTransform;
      }
    }
    extendStyles(preview.style, {
      // It's important that we disable the pointer events on the preview, because
      // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.
      "pointer-events": "none",
      // If the preview has a margin, it can throw off our positioning so we reset it. The reset
      // value for `margin-right` needs to be `auto` when opened as a popover, because our
      // positioning is always top/left based, but native popover seems to position itself
      // to the top/right if `<html>` or `<body>` have `dir="rtl"` (see #29604). Setting it
      // to `auto` pushed it to the top/left corner in RTL and is a noop in LTR.
      "margin": supportsPopover(preview) ? "0 auto 0 0" : "0",
      "position": "fixed",
      "top": "0",
      "left": "0",
      "z-index": this._zIndex + ""
    }, importantProperties);
    toggleNativeDragInteractions(preview, false);
    preview.classList.add("cdk-drag-preview");
    preview.setAttribute("popover", "manual");
    preview.setAttribute("dir", this._direction);
    if (previewClass) {
      if (Array.isArray(previewClass)) {
        previewClass.forEach(className => preview.classList.add(className));
      } else {
        preview.classList.add(previewClass);
      }
    }
    return preview;
  }
};
function supportsPopover(element) {
  return "showPopover" in element;
}
var passiveEventListenerOptions2 = {
  passive: true
};
var activeEventListenerOptions = {
  passive: false
};
var activeCapturingEventOptions$1 = {
  passive: false,
  capture: true
};
var MOUSE_EVENT_IGNORE_TIME = 800;
var dragImportantProperties = /* @__PURE__ */new Set([
// Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
"position"]);
var DragRef = class {
  _config;
  _document;
  _ngZone;
  _viewportRuler;
  _dragDropRegistry;
  _renderer;
  _rootElementCleanups;
  _cleanupShadowRootSelectStart;
  /** Element displayed next to the user's pointer while the element is dragged. */
  _preview;
  /** Container into which to insert the preview. */
  _previewContainer;
  /** Reference to the view of the placeholder element. */
  _placeholderRef;
  /** Element that is rendered instead of the draggable item while it is being sorted. */
  _placeholder;
  /** Coordinates within the element at which the user picked up the element. */
  _pickupPositionInElement;
  /** Coordinates on the page at which the user picked up the element. */
  _pickupPositionOnPage;
  /**
   * Anchor node used to save the place in the DOM where the element was
   * picked up so that it can be restored at the end of the drag sequence.
   */
  _anchor;
  /**
   * CSS `transform` applied to the element when it isn't being dragged. We need a
   * passive transform in order for the dragged element to retain its new position
   * after the user has stopped dragging and because we need to know the relative
   * position in case they start dragging again. This corresponds to `element.style.transform`.
   */
  _passiveTransform = {
    x: 0,
    y: 0
  };
  /** CSS `transform` that is applied to the element while it's being dragged. */
  _activeTransform = {
    x: 0,
    y: 0
  };
  /** Inline `transform` value that the element had before the first dragging sequence. */
  _initialTransform;
  /**
   * Whether the dragging sequence has been started. Doesn't
   * necessarily mean that the element has been moved.
   */
  _hasStartedDragging = signal(false);
  /** Whether the element has moved since the user started dragging it. */
  _hasMoved;
  /** Drop container in which the DragRef resided when dragging began. */
  _initialContainer;
  /** Index at which the item started in its initial container. */
  _initialIndex;
  /** Cached positions of scrollable parent elements. */
  _parentPositions;
  /** Emits when the item is being moved. */
  _moveEvents = new Subject();
  /** Keeps track of the direction in which the user is dragging along each axis. */
  _pointerDirectionDelta;
  /** Pointer position at which the last change in the delta occurred. */
  _pointerPositionAtLastDirectionChange;
  /** Position of the pointer at the last pointer event. */
  _lastKnownPointerPosition;
  /**
   * Root DOM node of the drag instance. This is the element that will
   * be moved around as the user is dragging.
   */
  _rootElement;
  /**
   * Nearest ancestor SVG, relative to which coordinates are calculated if dragging SVGElement
   */
  _ownerSVGElement;
  /**
   * Inline style value of `-webkit-tap-highlight-color` at the time the
   * dragging was started. Used to restore the value once we're done dragging.
   */
  _rootElementTapHighlight;
  /** Subscription to pointer movement events. */
  _pointerMoveSubscription = Subscription.EMPTY;
  /** Subscription to the event that is dispatched when the user lifts their pointer. */
  _pointerUpSubscription = Subscription.EMPTY;
  /** Subscription to the viewport being scrolled. */
  _scrollSubscription = Subscription.EMPTY;
  /** Subscription to the viewport being resized. */
  _resizeSubscription = Subscription.EMPTY;
  /**
   * Time at which the last touch event occurred. Used to avoid firing the same
   * events multiple times on touch devices where the browser will fire a fake
   * mouse event for each touch event, after a certain time.
   */
  _lastTouchEventTime;
  /** Time at which the last dragging sequence was started. */
  _dragStartTime;
  /** Cached reference to the boundary element. */
  _boundaryElement = null;
  /** Whether the native dragging interactions have been enabled on the root element. */
  _nativeInteractionsEnabled = true;
  /** Client rect of the root element when the dragging sequence has started. */
  _initialDomRect;
  /** Cached dimensions of the preview element. Should be read via `_getPreviewRect`. */
  _previewRect;
  /** Cached dimensions of the boundary element. */
  _boundaryRect;
  /** Element that will be used as a template to create the draggable item's preview. */
  _previewTemplate;
  /** Template for placeholder element rendered to show where a draggable would be dropped. */
  _placeholderTemplate;
  /** Elements that can be used to drag the draggable item. */
  _handles = [];
  /** Registered handles that are currently disabled. */
  _disabledHandles = /* @__PURE__ */new Set();
  /** Droppable container that the draggable is a part of. */
  _dropContainer;
  /** Layout direction of the item. */
  _direction = "ltr";
  /** Ref that the current drag item is nested in. */
  _parentDragRef;
  /**
   * Cached shadow root that the element is placed in. `null` means that the element isn't in
   * the shadow DOM and `undefined` means that it hasn't been resolved yet. Should be read via
   * `_getShadowRoot`, not directly.
   */
  _cachedShadowRoot;
  /** Axis along which dragging is locked. */
  lockAxis;
  /**
   * Amount of milliseconds to wait after the user has put their
   * pointer down before starting to drag the element.
   */
  dragStartDelay = 0;
  /** Class to be added to the preview element. */
  previewClass;
  /**
   * If the parent of the dragged element has a `scale` transform, it can throw off the
   * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
   */
  scale = 1;
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
  }
  set disabled(value) {
    if (value !== this._disabled) {
      this._disabled = value;
      this._toggleNativeDragInteractions();
      this._handles.forEach(handle => toggleNativeDragInteractions(handle, value));
    }
  }
  _disabled = false;
  /** Emits as the drag sequence is being prepared. */
  beforeStarted = new Subject();
  /** Emits when the user starts dragging the item. */
  started = new Subject();
  /** Emits when the user has released a drag item, before any animations have started. */
  released = new Subject();
  /** Emits when the user stops dragging an item in the container. */
  ended = new Subject();
  /** Emits when the user has moved the item into a new container. */
  entered = new Subject();
  /** Emits when the user removes the item its container by dragging it into another container. */
  exited = new Subject();
  /** Emits when the user drops the item inside a container. */
  dropped = new Subject();
  /**
   * Emits as the user is dragging the item. Use with caution,
   * because this event will fire for every pixel that the user has dragged.
   */
  moved = this._moveEvents;
  /** Arbitrary data that can be attached to the drag item. */
  data;
  /**
   * Function that can be used to customize the logic of how the position of the drag item
   * is limited while it's being dragged. Gets called with a point containing the current position
   * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
   * Should return a point describing where the item should be rendered.
   */
  constrainPosition;
  constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry, _renderer) {
    this._config = _config;
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
    this._renderer = _renderer;
    this.withRootElement(element).withParent(_config.parentDragRef || null);
    this._parentPositions = new ParentPositionTracker(_document);
    _dragDropRegistry.registerDragItem(this);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._placeholder;
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the currently-visible element that represents the drag item.
   * While dragging this is the placeholder, otherwise it's the root element.
   */
  getVisibleElement() {
    return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
  }
  /** Registers the handles that can be used to drag the element. */
  withHandles(handles) {
    this._handles = handles.map(handle => coerceElement(handle));
    this._handles.forEach(handle => toggleNativeDragInteractions(handle, this.disabled));
    this._toggleNativeDragInteractions();
    const disabledHandles = /* @__PURE__ */new Set();
    this._disabledHandles.forEach(handle => {
      if (this._handles.indexOf(handle) > -1) {
        disabledHandles.add(handle);
      }
    });
    this._disabledHandles = disabledHandles;
    return this;
  }
  /**
   * Registers the template that should be used for the drag preview.
   * @param template Template that from which to stamp out the preview.
   */
  withPreviewTemplate(template) {
    this._previewTemplate = template;
    return this;
  }
  /**
   * Registers the template that should be used for the drag placeholder.
   * @param template Template that from which to stamp out the placeholder.
   */
  withPlaceholderTemplate(template) {
    this._placeholderTemplate = template;
    return this;
  }
  /**
   * Sets an alternate drag root element. The root element is the element that will be moved as
   * the user is dragging. Passing an alternate root element is useful when trying to enable
   * dragging on an element that you might not have access to.
   */
  withRootElement(rootElement) {
    const element = coerceElement(rootElement);
    if (element !== this._rootElement) {
      this._removeRootElementListeners();
      this._rootElementCleanups = this._ngZone.runOutsideAngular(() => [_bindEventWithOptions(this._renderer, element, "mousedown", this._pointerDown, activeEventListenerOptions), _bindEventWithOptions(this._renderer, element, "touchstart", this._pointerDown, passiveEventListenerOptions2), _bindEventWithOptions(this._renderer, element, "dragstart", this._nativeDragStart, activeEventListenerOptions)]);
      this._initialTransform = void 0;
      this._rootElement = element;
    }
    if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
      this._ownerSVGElement = this._rootElement.ownerSVGElement;
    }
    return this;
  }
  /**
   * Element to which the draggable's position will be constrained.
   */
  withBoundaryElement(boundaryElement) {
    this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
    this._resizeSubscription.unsubscribe();
    if (boundaryElement) {
      this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
    }
    return this;
  }
  /** Sets the parent ref that the ref is nested in.  */
  withParent(parent2) {
    this._parentDragRef = parent2;
    return this;
  }
  /** Removes the dragging functionality from the DOM element. */
  dispose() {
    this._removeRootElementListeners();
    if (this.isDragging()) {
      this._rootElement?.remove();
    }
    this._anchor?.remove();
    this._destroyPreview();
    this._destroyPlaceholder();
    this._dragDropRegistry.removeDragItem(this);
    this._removeListeners();
    this.beforeStarted.complete();
    this.started.complete();
    this.released.complete();
    this.ended.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this._moveEvents.complete();
    this._handles = [];
    this._disabledHandles.clear();
    this._dropContainer = void 0;
    this._resizeSubscription.unsubscribe();
    this._parentPositions.clear();
    this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null;
  }
  /** Checks whether the element is currently being dragged. */
  isDragging() {
    return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._rootElement.style.transform = this._initialTransform || "";
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform = {
      x: 0,
      y: 0
    };
  }
  /**
   * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.
   * @param handle Handle element that should be disabled.
   */
  disableHandle(handle) {
    if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
      this._disabledHandles.add(handle);
      toggleNativeDragInteractions(handle, true);
    }
  }
  /**
   * Enables a handle, if it has been disabled.
   * @param handle Handle element to be enabled.
   */
  enableHandle(handle) {
    if (this._disabledHandles.has(handle)) {
      this._disabledHandles.delete(handle);
      toggleNativeDragInteractions(handle, this.disabled);
    }
  }
  /** Sets the layout direction of the draggable item. */
  withDirection(direction) {
    this._direction = direction;
    return this;
  }
  /** Sets the container that the item is part of. */
  _withDropContainer(container) {
    this._dropContainer = container;
  }
  /**
   * Gets the current position in pixels the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
    return {
      x: position.x,
      y: position.y
    };
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform.x = value.x;
    this._passiveTransform.y = value.y;
    if (!this._dropContainer) {
      this._applyRootElementTransform(value.x, value.y);
    }
    return this;
  }
  /**
   * Sets the container into which to insert the preview element.
   * @param value Container into which to insert the preview.
   */
  withPreviewContainer(value) {
    this._previewContainer = value;
    return this;
  }
  /** Updates the item's sort order based on the last-known pointer position. */
  _sortFromLastPointerPosition() {
    const position = this._lastKnownPointerPosition;
    if (position && this._dropContainer) {
      this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
    }
  }
  /** Unsubscribes from the global subscriptions. */
  _removeListeners() {
    this._pointerMoveSubscription.unsubscribe();
    this._pointerUpSubscription.unsubscribe();
    this._scrollSubscription.unsubscribe();
    this._cleanupShadowRootSelectStart?.();
    this._cleanupShadowRootSelectStart = void 0;
  }
  /** Destroys the preview element and its ViewRef. */
  _destroyPreview() {
    this._preview?.destroy();
    this._preview = null;
  }
  /** Destroys the placeholder element and its ViewRef. */
  _destroyPlaceholder() {
    this._placeholder?.remove();
    this._placeholderRef?.destroy();
    this._placeholder = this._placeholderRef = null;
  }
  /** Handler for the `mousedown`/`touchstart` events. */
  _pointerDown = event => {
    this.beforeStarted.next();
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        this._initializeDragSequence(targetHandle, event);
      }
    } else if (!this.disabled) {
      this._initializeDragSequence(this._rootElement, event);
    }
  };
  /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */
  _pointerMove = event => {
    const pointerPosition = this._getPointerPositionOnPage(event);
    if (!this._hasStartedDragging()) {
      const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
      const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
      const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
      if (isOverThreshold) {
        const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
        const container = this._dropContainer;
        if (!isDelayElapsed) {
          this._endDragSequence(event);
          return;
        }
        if (!container || !container.isDragging() && !container.isReceiving()) {
          if (event.cancelable) {
            event.preventDefault();
          }
          this._hasStartedDragging.set(true);
          this._ngZone.run(() => this._startDragSequence(event));
        }
      }
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
    this._hasMoved = true;
    this._lastKnownPointerPosition = pointerPosition;
    this._updatePointerDirectionDelta(constrainedPointerPosition);
    if (this._dropContainer) {
      this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
    } else {
      const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
      const activeTransform = this._activeTransform;
      activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
      activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
      this._applyRootElementTransform(activeTransform.x, activeTransform.y);
    }
    if (this._moveEvents.observers.length) {
      this._ngZone.run(() => {
        this._moveEvents.next({
          source: this,
          pointerPosition: constrainedPointerPosition,
          event,
          distance: this._getDragDistance(constrainedPointerPosition),
          delta: this._pointerDirectionDelta
        });
      });
    }
  };
  /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */
  _pointerUp = event => {
    this._endDragSequence(event);
  };
  /**
   * Clears subscriptions and stops the dragging sequence.
   * @param event Browser event object that ended the sequence.
   */
  _endDragSequence(event) {
    if (!this._dragDropRegistry.isDragging(this)) {
      return;
    }
    this._removeListeners();
    this._dragDropRegistry.stopDragging(this);
    this._toggleNativeDragInteractions();
    if (this._handles) {
      this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
    }
    if (!this._hasStartedDragging()) {
      return;
    }
    this.released.next({
      source: this,
      event
    });
    if (this._dropContainer) {
      this._dropContainer._stopScrolling();
      this._animatePreviewToPlaceholder().then(() => {
        this._cleanupDragArtifacts(event);
        this._cleanupCachedDimensions();
        this._dragDropRegistry.stopDragging(this);
      });
    } else {
      this._passiveTransform.x = this._activeTransform.x;
      const pointerPosition = this._getPointerPositionOnPage(event);
      this._passiveTransform.y = this._activeTransform.y;
      this._ngZone.run(() => {
        this.ended.next({
          source: this,
          distance: this._getDragDistance(pointerPosition),
          dropPoint: pointerPosition,
          event
        });
      });
      this._cleanupCachedDimensions();
      this._dragDropRegistry.stopDragging(this);
    }
  }
  /** Starts the dragging sequence. */
  _startDragSequence(event) {
    if (isTouchEvent(event)) {
      this._lastTouchEventTime = Date.now();
    }
    this._toggleNativeDragInteractions();
    const shadowRoot = this._getShadowRoot();
    const dropContainer = this._dropContainer;
    if (shadowRoot) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupShadowRootSelectStart = _bindEventWithOptions(this._renderer, shadowRoot, "selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
      });
    }
    if (dropContainer) {
      const element = this._rootElement;
      const parent2 = element.parentNode;
      const placeholder = this._placeholder = this._createPlaceholderElement();
      const anchor = this._anchor = this._anchor || this._document.createComment(typeof ngDevMode === "undefined" || ngDevMode ? "cdk-drag-anchor" : "");
      parent2.insertBefore(anchor, element);
      this._initialTransform = element.style.transform || "";
      this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3, this._renderer);
      this._preview.attach(this._getPreviewInsertionPoint(parent2, shadowRoot));
      toggleVisibility(element, false, dragImportantProperties);
      this._document.body.appendChild(parent2.replaceChild(placeholder, element));
      this.started.next({
        source: this,
        event
      });
      dropContainer.start();
      this._initialContainer = dropContainer;
      this._initialIndex = dropContainer.getItemIndex(this);
    } else {
      this.started.next({
        source: this,
        event
      });
      this._initialContainer = this._initialIndex = void 0;
    }
    this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
  }
  /**
   * Sets up the different variables and subscriptions
   * that will be necessary for the dragging sequence.
   * @param referenceElement Element that started the drag sequence.
   * @param event Browser event object that started the sequence.
   */
  _initializeDragSequence(referenceElement, event) {
    if (this._parentDragRef) {
      event.stopPropagation();
    }
    const isDragging = this.isDragging();
    const isTouchSequence = isTouchEvent(event);
    const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
    const rootElement = this._rootElement;
    const target = _getEventTarget(event);
    const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
    const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
    if (target && target.draggable && event.type === "mousedown") {
      event.preventDefault();
    }
    if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
      return;
    }
    if (this._handles.length) {
      const rootStyles = rootElement.style;
      this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
      rootStyles.webkitTapHighlightColor = "transparent";
    }
    this._hasMoved = false;
    this._hasStartedDragging.set(this._hasMoved);
    this._removeListeners();
    this._initialDomRect = this._rootElement.getBoundingClientRect();
    this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
    this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
    this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(scrollEvent => this._updateOnScroll(scrollEvent));
    if (this._boundaryElement) {
      this._boundaryRect = getMutableClientRect(this._boundaryElement);
    }
    const previewTemplate = this._previewTemplate;
    this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
      x: 0,
      y: 0
    } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
    const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
    this._pointerDirectionDelta = {
      x: 0,
      y: 0
    };
    this._pointerPositionAtLastDirectionChange = {
      x: pointerPosition.x,
      y: pointerPosition.y
    };
    this._dragStartTime = Date.now();
    this._dragDropRegistry.startDragging(this, event);
  }
  /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */
  _cleanupDragArtifacts(event) {
    toggleVisibility(this._rootElement, true, dragImportantProperties);
    this._anchor.parentNode.replaceChild(this._rootElement, this._anchor);
    this._destroyPreview();
    this._destroyPlaceholder();
    this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
    this._ngZone.run(() => {
      const container = this._dropContainer;
      const currentIndex = container.getItemIndex(this);
      const pointerPosition = this._getPointerPositionOnPage(event);
      const distance = this._getDragDistance(pointerPosition);
      const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
      this.ended.next({
        source: this,
        distance,
        dropPoint: pointerPosition,
        event
      });
      this.dropped.next({
        item: this,
        currentIndex,
        previousIndex: this._initialIndex,
        container,
        previousContainer: this._initialContainer,
        isPointerOverContainer,
        distance,
        dropPoint: pointerPosition,
        event
      });
      container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
      this._dropContainer = this._initialContainer;
    });
  }
  /**
   * Updates the item's position in its drop container, or moves it
   * into a new one, depending on its current drag position.
   */
  _updateActiveDropContainer({
    x: x2,
    y: y2
  }, {
    x: rawX,
    y: rawY
  }) {
    let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x2, y2);
    if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x2, y2)) {
      newContainer = this._initialContainer;
    }
    if (newContainer && newContainer !== this._dropContainer) {
      this._ngZone.run(() => {
        this.exited.next({
          item: this,
          container: this._dropContainer
        });
        this._dropContainer.exit(this);
        this._dropContainer = newContainer;
        this._dropContainer.enter(this, x2, y2, newContainer === this._initialContainer &&
        // If we're re-entering the initial container and sorting is disabled,
        // put item the into its starting index to begin with.
        newContainer.sortingDisabled ? this._initialIndex : void 0);
        this.entered.next({
          item: this,
          container: newContainer,
          currentIndex: newContainer.getItemIndex(this)
        });
      });
    }
    if (this.isDragging()) {
      this._dropContainer._startScrollingIfNecessary(rawX, rawY);
      this._dropContainer._sortItem(this, x2, y2, this._pointerDirectionDelta);
      if (this.constrainPosition) {
        this._applyPreviewTransform(x2, y2);
      } else {
        this._applyPreviewTransform(x2 - this._pickupPositionInElement.x, y2 - this._pickupPositionInElement.y);
      }
    }
  }
  /**
   * Animates the preview element from its current position to the location of the drop placeholder.
   * @returns Promise that resolves when the animation completes.
   */
  _animatePreviewToPlaceholder() {
    if (!this._hasMoved) {
      return Promise.resolve();
    }
    const placeholderRect = this._placeholder.getBoundingClientRect();
    this._preview.addClass("cdk-drag-animating");
    this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
    const duration = this._preview.getTransitionDuration();
    if (duration === 0) {
      return Promise.resolve();
    }
    return this._ngZone.runOutsideAngular(() => {
      return new Promise(resolve => {
        const handler = event => {
          if (!event || this._preview && _getEventTarget(event) === this._preview.element && event.propertyName === "transform") {
            cleanupListener();
            resolve();
            clearTimeout(timeout);
          }
        };
        const timeout = setTimeout(handler, duration * 1.5);
        const cleanupListener = this._preview.addEventListener("transitionend", handler);
      });
    });
  }
  /** Creates an element that will be shown instead of the current element while dragging. */
  _createPlaceholderElement() {
    const placeholderConfig = this._placeholderTemplate;
    const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
    let placeholder;
    if (placeholderTemplate) {
      this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
      this._placeholderRef.detectChanges();
      placeholder = getRootNode(this._placeholderRef, this._document);
    } else {
      placeholder = deepCloneNode(this._rootElement);
    }
    placeholder.style.pointerEvents = "none";
    placeholder.classList.add("cdk-drag-placeholder");
    return placeholder;
  }
  /**
   * Figures out the coordinates at which an element was picked up.
   * @param referenceElement Element that initiated the dragging.
   * @param event Event that initiated the dragging.
   */
  _getPointerPositionInElement(elementRect, referenceElement, event) {
    const handleElement = referenceElement === this._rootElement ? null : referenceElement;
    const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
    const point = isTouchEvent(event) ? event.targetTouches[0] : event;
    const scrollPosition = this._getViewportScrollPosition();
    const x2 = point.pageX - referenceRect.left - scrollPosition.left;
    const y2 = point.pageY - referenceRect.top - scrollPosition.top;
    return {
      x: referenceRect.left - elementRect.left + x2,
      y: referenceRect.top - elementRect.top + y2
    };
  }
  /** Determines the point of the page that was touched by the user. */
  _getPointerPositionOnPage(event) {
    const scrollPosition = this._getViewportScrollPosition();
    const point = isTouchEvent(event) ?
    // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
    // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`
    // to have a value, but Firefox in device emulation mode has a bug where both can be empty
    // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid
    // throwing an error. The value returned here will be incorrect, but since this only
    // breaks inside a developer tool and the value is only used for secondary information,
    // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.
    event.touches[0] || event.changedTouches[0] || {
      pageX: 0,
      pageY: 0
    } : event;
    const x2 = point.pageX - scrollPosition.left;
    const y2 = point.pageY - scrollPosition.top;
    if (this._ownerSVGElement) {
      const svgMatrix = this._ownerSVGElement.getScreenCTM();
      if (svgMatrix) {
        const svgPoint = this._ownerSVGElement.createSVGPoint();
        svgPoint.x = x2;
        svgPoint.y = y2;
        return svgPoint.matrixTransform(svgMatrix.inverse());
      }
    }
    return {
      x: x2,
      y: y2
    };
  }
  /** Gets the pointer position on the page, accounting for any position constraints. */
  _getConstrainedPointerPosition(point) {
    const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
    let {
      x: x2,
      y: y2
    } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
    if (this.lockAxis === "x" || dropContainerLock === "x") {
      y2 = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
    } else if (this.lockAxis === "y" || dropContainerLock === "y") {
      x2 = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
    }
    if (this._boundaryRect) {
      const {
        x: pickupX,
        y: pickupY
      } = !this.constrainPosition ? this._pickupPositionInElement : {
        x: 0,
        y: 0
      };
      const boundaryRect = this._boundaryRect;
      const {
        width: previewWidth,
        height: previewHeight
      } = this._getPreviewRect();
      const minY = boundaryRect.top + pickupY;
      const maxY = boundaryRect.bottom - (previewHeight - pickupY);
      const minX = boundaryRect.left + pickupX;
      const maxX = boundaryRect.right - (previewWidth - pickupX);
      x2 = clamp$1(x2, minX, maxX);
      y2 = clamp$1(y2, minY, maxY);
    }
    return {
      x: x2,
      y: y2
    };
  }
  /** Updates the current drag delta, based on the user's current pointer position on the page. */
  _updatePointerDirectionDelta(pointerPositionOnPage) {
    const {
      x: x2,
      y: y2
    } = pointerPositionOnPage;
    const delta = this._pointerDirectionDelta;
    const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
    const changeX = Math.abs(x2 - positionSinceLastChange.x);
    const changeY = Math.abs(y2 - positionSinceLastChange.y);
    if (changeX > this._config.pointerDirectionChangeThreshold) {
      delta.x = x2 > positionSinceLastChange.x ? 1 : -1;
      positionSinceLastChange.x = x2;
    }
    if (changeY > this._config.pointerDirectionChangeThreshold) {
      delta.y = y2 > positionSinceLastChange.y ? 1 : -1;
      positionSinceLastChange.y = y2;
    }
    return delta;
  }
  /** Toggles the native drag interactions, based on how many handles are registered. */
  _toggleNativeDragInteractions() {
    if (!this._rootElement || !this._handles) {
      return;
    }
    const shouldEnable = this._handles.length > 0 || !this.isDragging();
    if (shouldEnable !== this._nativeInteractionsEnabled) {
      this._nativeInteractionsEnabled = shouldEnable;
      toggleNativeDragInteractions(this._rootElement, shouldEnable);
    }
  }
  /** Removes the manually-added event listeners from the root element. */
  _removeRootElementListeners() {
    this._rootElementCleanups?.forEach(cleanup => cleanup());
    this._rootElementCleanups = void 0;
  }
  /**
   * Applies a `transform` to the root element, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyRootElementTransform(x2, y2) {
    const scale = 1 / this.scale;
    const transform = getTransform(x2 * scale, y2 * scale);
    const styles = this._rootElement.style;
    if (this._initialTransform == null) {
      this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
    }
    styles.transform = combineTransforms(transform, this._initialTransform);
  }
  /**
   * Applies a `transform` to the preview, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyPreviewTransform(x2, y2) {
    const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
    const transform = getTransform(x2, y2);
    this._preview.setTransform(combineTransforms(transform, initialTransform));
  }
  /**
   * Gets the distance that the user has dragged during the current drag sequence.
   * @param currentPosition Current position of the user's pointer.
   */
  _getDragDistance(currentPosition) {
    const pickupPosition = this._pickupPositionOnPage;
    if (pickupPosition) {
      return {
        x: currentPosition.x - pickupPosition.x,
        y: currentPosition.y - pickupPosition.y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */
  _cleanupCachedDimensions() {
    this._boundaryRect = this._previewRect = void 0;
    this._parentPositions.clear();
  }
  /**
   * Checks whether the element is still inside its boundary after the viewport has been resized.
   * If not, the position is adjusted so that the element fits again.
   */
  _containInsideBoundaryOnResize() {
    let {
      x: x2,
      y: y2
    } = this._passiveTransform;
    if (x2 === 0 && y2 === 0 || this.isDragging() || !this._boundaryElement) {
      return;
    }
    const elementRect = this._rootElement.getBoundingClientRect();
    const boundaryRect = this._boundaryElement.getBoundingClientRect();
    if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
      return;
    }
    const leftOverflow = boundaryRect.left - elementRect.left;
    const rightOverflow = elementRect.right - boundaryRect.right;
    const topOverflow = boundaryRect.top - elementRect.top;
    const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
    if (boundaryRect.width > elementRect.width) {
      if (leftOverflow > 0) {
        x2 += leftOverflow;
      }
      if (rightOverflow > 0) {
        x2 -= rightOverflow;
      }
    } else {
      x2 = 0;
    }
    if (boundaryRect.height > elementRect.height) {
      if (topOverflow > 0) {
        y2 += topOverflow;
      }
      if (bottomOverflow > 0) {
        y2 -= bottomOverflow;
      }
    } else {
      y2 = 0;
    }
    if (x2 !== this._passiveTransform.x || y2 !== this._passiveTransform.y) {
      this.setFreeDragPosition({
        y: y2,
        x: x2
      });
    }
  }
  /** Gets the drag start delay, based on the event type. */
  _getDragStartDelay(event) {
    const value = this.dragStartDelay;
    if (typeof value === "number") {
      return value;
    } else if (isTouchEvent(event)) {
      return value.touch;
    }
    return value ? value.mouse : 0;
  }
  /** Updates the internal state of the draggable element when scrolling has occurred. */
  _updateOnScroll(event) {
    const scrollDifference = this._parentPositions.handleScroll(event);
    if (scrollDifference) {
      const target = _getEventTarget(event);
      if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
        adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
      }
      this._pickupPositionOnPage.x += scrollDifference.left;
      this._pickupPositionOnPage.y += scrollDifference.top;
      if (!this._dropContainer) {
        this._activeTransform.x -= scrollDifference.left;
        this._activeTransform.y -= scrollDifference.top;
        this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
      }
    }
  }
  /** Gets the scroll position of the viewport. */
  _getViewportScrollPosition() {
    return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (this._cachedShadowRoot === void 0) {
      this._cachedShadowRoot = _getShadowRoot(this._rootElement);
    }
    return this._cachedShadowRoot;
  }
  /** Gets the element into which the drag preview should be inserted. */
  _getPreviewInsertionPoint(initialParent, shadowRoot) {
    const previewContainer = this._previewContainer || "global";
    if (previewContainer === "parent") {
      return initialParent;
    }
    if (previewContainer === "global") {
      const documentRef = this._document;
      return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
    }
    return coerceElement(previewContainer);
  }
  /** Lazily resolves and returns the dimensions of the preview. */
  _getPreviewRect() {
    if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
      this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
    }
    return this._previewRect;
  }
  /** Handles a native `dragstart` event. */
  _nativeDragStart = event => {
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        event.preventDefault();
      }
    } else if (!this.disabled) {
      event.preventDefault();
    }
  };
  /** Gets a handle that is the target of an event. */
  _getTargetHandle(event) {
    return this._handles.find(handle => {
      return event.target && (event.target === handle || handle.contains(event.target));
    });
  }
};
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function shadowDomSelectStart(event) {
  event.preventDefault();
}
function moveItemInArray(array, fromIndex, toIndex) {
  const from2 = clamp(fromIndex, array.length - 1);
  const to = clamp(toIndex, array.length - 1);
  if (from2 === to) {
    return;
  }
  const target = array[from2];
  const delta = to < from2 ? -1 : 1;
  for (let i2 = from2; i2 !== to; i2 += delta) {
    array[i2] = array[i2 + delta];
  }
  array[to] = target;
}
function copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {
  const to = clamp(targetIndex, targetArray.length);
  if (currentArray.length) {
    targetArray.splice(to, 0, currentArray[currentIndex]);
  }
}
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
var SingleAxisSortStrategy = class {
  _dragDropRegistry;
  /** Root element container of the drop list. */
  _element;
  /** Function used to determine if an item can be sorted into a specific index. */
  _sortPredicate;
  /** Cache of the dimensions of all the items inside the container. */
  _itemPositions = [];
  /**
   * Draggable items that are currently active inside the container. Includes the items
   * that were there at the start of the sequence, as well as any items that have been dragged
   * in, but haven't been dropped yet.
   */
  _activeDraggables;
  /** Direction in which the list is oriented. */
  orientation = "vertical";
  /** Layout direction of the drop list. */
  direction;
  constructor(_dragDropRegistry) {
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * Keeps track of the item that was last swapped with the dragged item, as well as what direction
   * the pointer was moving in when the swap occurred and whether the user's pointer continued to
   * overlap with the swapped item after the swapping occurred.
   */
  _previousSwap = {
    drag: null,
    delta: 0,
    overlaps: false
  };
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const siblings = this._itemPositions;
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
    if (newIndex === -1 && siblings.length > 0) {
      return null;
    }
    const isHorizontal = this.orientation === "horizontal";
    const currentIndex = siblings.findIndex(currentItem => currentItem.drag === item);
    const siblingAtNewPosition = siblings[newIndex];
    const currentPosition = siblings[currentIndex].clientRect;
    const newPosition = siblingAtNewPosition.clientRect;
    const delta = currentIndex > newIndex ? 1 : -1;
    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
    const oldOrder = siblings.slice();
    moveItemInArray(siblings, currentIndex, newIndex);
    siblings.forEach((sibling, index) => {
      if (oldOrder[index] === sibling) {
        return;
      }
      const isDraggedItem = sibling.drag === item;
      const offset = isDraggedItem ? itemOffset : siblingOffset;
      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
      sibling.offset += offset;
      const transformAmount = Math.round(sibling.offset * (1 / sibling.drag.scale));
      if (isHorizontal) {
        elementToOffset.style.transform = combineTransforms(`translate3d(${transformAmount}px, 0, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, 0, offset);
      } else {
        elementToOffset.style.transform = combineTransforms(`translate3d(0, ${transformAmount}px, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, offset, 0);
      }
    });
    this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
    this._previousSwap.drag = siblingAtNewPosition.drag;
    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
    return {
      previousIndex: currentIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    const newIndex = index == null || index < 0 ?
    // We use the coordinates of where the item entered the drop
    // zone to figure out at which index it should be inserted.
    this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
    const activeDraggables = this._activeDraggables;
    const currentIndex = activeDraggables.indexOf(item);
    const placeholder = item.getPlaceholderElement();
    let newPositionReference = activeDraggables[newIndex];
    if (newPositionReference === item) {
      newPositionReference = activeDraggables[newIndex + 1];
    }
    if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
      newPositionReference = activeDraggables[0];
    }
    if (currentIndex > -1) {
      activeDraggables.splice(currentIndex, 1);
    }
    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
      const element = newPositionReference.getRootElement();
      element.parentElement.insertBefore(placeholder, element);
      activeDraggables.splice(newIndex, 0, item);
    } else {
      this._element.appendChild(placeholder);
      activeDraggables.push(item);
    }
    placeholder.style.transform = "";
    this._cacheItemPositions();
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeDraggables = items.slice();
    this._cacheItemPositions();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    this._activeDraggables?.forEach(item => {
      const rootElement = item.getRootElement();
      if (rootElement) {
        const initialTransform = this._itemPositions.find(p2 => p2.drag === item)?.initialTransform;
        rootElement.style.transform = initialTransform || "";
      }
    });
    this._itemPositions = [];
    this._activeDraggables = [];
    this._previousSwap.drag = null;
    this._previousSwap.delta = 0;
    this._previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeDraggables;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    const items = this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
    return items.findIndex(currentItem => currentItem.drag === item);
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll(topDifference, leftDifference) {
    this._itemPositions.forEach(({
      clientRect
    }) => {
      adjustDomRect(clientRect, topDifference, leftDifference);
    });
    this._itemPositions.forEach(({
      drag
    }) => {
      if (this._dragDropRegistry.isDragging(drag)) {
        drag._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    this._element = container;
  }
  /** Refreshes the position cache of the items and sibling containers. */
  _cacheItemPositions() {
    const isHorizontal = this.orientation === "horizontal";
    this._itemPositions = this._activeDraggables.map(drag => {
      const elementToMeasure = drag.getVisibleElement();
      return {
        drag,
        offset: 0,
        initialTransform: elementToMeasure.style.transform || "",
        clientRect: getMutableClientRect(elementToMeasure)
      };
    }).sort((a2, b2) => {
      return isHorizontal ? a2.clientRect.left - b2.clientRect.left : a2.clientRect.top - b2.clientRect.top;
    });
  }
  /**
   * Gets the offset in pixels by which the item that is being dragged should be moved.
   * @param currentPosition Current position of the item.
   * @param newPosition Position of the item where the current item should be moved.
   * @param delta Direction in which the user is moving.
   */
  _getItemOffsetPx(currentPosition, newPosition, delta) {
    const isHorizontal = this.orientation === "horizontal";
    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
    if (delta === -1) {
      itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
    }
    return itemOffset;
  }
  /**
   * Gets the offset in pixels by which the items that aren't being dragged should be moved.
   * @param currentIndex Index of the item currently being dragged.
   * @param siblings All of the items in the list.
   * @param delta Direction in which the user is moving.
   */
  _getSiblingOffsetPx(currentIndex, siblings, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const currentPosition = siblings[currentIndex].clientRect;
    const immediateSibling = siblings[currentIndex + delta * -1];
    let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
    if (immediateSibling) {
      const start = isHorizontal ? "left" : "top";
      const end = isHorizontal ? "right" : "bottom";
      if (delta === -1) {
        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
      } else {
        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
      }
    }
    return siblingOffset;
  }
  /**
   * Checks if pointer is entering in the first position
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _shouldEnterAsFirstChild(pointerX, pointerY) {
    if (!this._activeDraggables.length) {
      return false;
    }
    const itemPositions = this._itemPositions;
    const isHorizontal = this.orientation === "horizontal";
    const reversed = itemPositions[0].drag !== this._activeDraggables[0];
    if (reversed) {
      const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
      return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
    } else {
      const firstItemRect = itemPositions[0].clientRect;
      return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const index = this._itemPositions.findIndex(({
      drag,
      clientRect
    }) => {
      if (drag === item) {
        return false;
      }
      if (delta) {
        const direction = isHorizontal ? delta.x : delta.y;
        if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
          return false;
        }
      }
      return isHorizontal ?
      // Round these down since most browsers report client rects with
      // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.
      pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
    });
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
};
var MixedSortStrategy = class {
  _document;
  _dragDropRegistry;
  /** Root element container of the drop list. */
  _element;
  /** Function used to determine if an item can be sorted into a specific index. */
  _sortPredicate;
  /** Lazily-resolved root node containing the list. Use `_getRootNode` to read this. */
  _rootNode;
  /**
   * Draggable items that are currently active inside the container. Includes the items
   * that were there at the start of the sequence, as well as any items that have been dragged
   * in, but haven't been dropped yet.
   */
  _activeItems;
  /**
   * Keeps track of the item that was last swapped with the dragged item, as well as what direction
   * the pointer was moving in when the swap occurred and whether the user's pointer continued to
   * overlap with the swapped item after the swapping occurred.
   */
  _previousSwap = {
    drag: null,
    deltaX: 0,
    deltaY: 0,
    overlaps: false
  };
  /**
   * Keeps track of the relationship between a node and its next sibling. This information
   * is used to restore the DOM to the order it was in before dragging started.
   */
  _relatedNodes = [];
  constructor(_document, _dragDropRegistry) {
    this._document = _document;
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    const childNodes = this._element.childNodes;
    this._relatedNodes = [];
    for (let i2 = 0; i2 < childNodes.length; i2++) {
      const node = childNodes[i2];
      this._relatedNodes.push([node, node.nextSibling]);
    }
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);
    const previousSwap = this._previousSwap;
    if (newIndex === -1 || this._activeItems[newIndex] === item) {
      return null;
    }
    const toSwapWith = this._activeItems[newIndex];
    if (previousSwap.drag === toSwapWith && previousSwap.overlaps && previousSwap.deltaX === pointerDelta.x && previousSwap.deltaY === pointerDelta.y) {
      return null;
    }
    const previousIndex = this.getItemIndex(item);
    const current = item.getPlaceholderElement();
    const overlapElement = toSwapWith.getRootElement();
    if (newIndex > previousIndex) {
      overlapElement.after(current);
    } else {
      overlapElement.before(current);
    }
    moveItemInArray(this._activeItems, previousIndex, newIndex);
    const newOverlapElement = this._getRootNode().elementFromPoint(pointerX, pointerY);
    previousSwap.deltaX = pointerDelta.x;
    previousSwap.deltaY = pointerDelta.y;
    previousSwap.drag = toSwapWith;
    previousSwap.overlaps = overlapElement === newOverlapElement || overlapElement.contains(newOverlapElement);
    return {
      previousIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    let enterIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
    if (enterIndex === -1) {
      enterIndex = this._getClosestItemIndexToPointer(item, pointerX, pointerY);
    }
    const targetItem = this._activeItems[enterIndex];
    const currentIndex = this._activeItems.indexOf(item);
    if (currentIndex > -1) {
      this._activeItems.splice(currentIndex, 1);
    }
    if (targetItem && !this._dragDropRegistry.isDragging(targetItem)) {
      this._activeItems.splice(enterIndex, 0, item);
      targetItem.getRootElement().before(item.getPlaceholderElement());
    } else {
      this._activeItems.push(item);
      this._element.appendChild(item.getPlaceholderElement());
    }
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeItems = items.slice();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    const root = this._element;
    const previousSwap = this._previousSwap;
    for (let i2 = this._relatedNodes.length - 1; i2 > -1; i2--) {
      const [node, nextSibling] = this._relatedNodes[i2];
      if (node.parentNode === root && node.nextSibling !== nextSibling) {
        if (nextSibling === null) {
          root.appendChild(node);
        } else if (nextSibling.parentNode === root) {
          root.insertBefore(node, nextSibling);
        }
      }
    }
    this._relatedNodes = [];
    this._activeItems = [];
    previousSwap.drag = null;
    previousSwap.deltaX = previousSwap.deltaY = 0;
    previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeItems;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    return this._activeItems.indexOf(item);
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll() {
    this._activeItems.forEach(item => {
      if (this._dragDropRegistry.isDragging(item)) {
        item._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    if (container !== this._element) {
      this._element = container;
      this._rootNode = void 0;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY) {
    const elementAtPoint = this._getRootNode().elementFromPoint(Math.floor(pointerX), Math.floor(pointerY));
    const index = elementAtPoint ? this._activeItems.findIndex(item2 => {
      const root = item2.getRootElement();
      return elementAtPoint === root || root.contains(elementAtPoint);
    }) : -1;
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
  /** Lazily resolves the list's root node. */
  _getRootNode() {
    if (!this._rootNode) {
      this._rootNode = _getShadowRoot(this._element) || this._document;
    }
    return this._rootNode;
  }
  /**
   * Finds the index of the item that's closest to the item being dragged.
   * @param item Item being dragged.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _getClosestItemIndexToPointer(item, pointerX, pointerY) {
    if (this._activeItems.length === 0) {
      return -1;
    }
    if (this._activeItems.length === 1) {
      return 0;
    }
    let minDistance = Infinity;
    let minIndex = -1;
    for (let i2 = 0; i2 < this._activeItems.length; i2++) {
      const current = this._activeItems[i2];
      if (current !== item) {
        const {
          x: x2,
          y: y2
        } = current.getRootElement().getBoundingClientRect();
        const distance = Math.hypot(pointerX - x2, pointerY - y2);
        if (distance < minDistance) {
          minDistance = distance;
          minIndex = i2;
        }
      }
    }
    return minIndex;
  }
};
var DROP_PROXIMITY_THRESHOLD = 0.05;
var SCROLL_PROXIMITY_THRESHOLD = 0.05;
var AutoScrollVerticalDirection;
(function (AutoScrollVerticalDirection2) {
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["NONE"] = 0] = "NONE";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["UP"] = 1] = "UP";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["DOWN"] = 2] = "DOWN";
})(AutoScrollVerticalDirection || (AutoScrollVerticalDirection = {}));
var AutoScrollHorizontalDirection;
(function (AutoScrollHorizontalDirection2) {
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["NONE"] = 0] = "NONE";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["LEFT"] = 1] = "LEFT";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["RIGHT"] = 2] = "RIGHT";
})(AutoScrollHorizontalDirection || (AutoScrollHorizontalDirection = {}));
var DropListRef = class {
  _dragDropRegistry;
  _ngZone;
  _viewportRuler;
  /** Element that the drop list is attached to. */
  element;
  /** Whether starting a dragging sequence from this container is disabled. */
  disabled = false;
  /** Whether sorting items within the list is disabled. */
  sortingDisabled = false;
  /** Locks the position of the draggable elements inside the container along the specified axis. */
  lockAxis;
  /**
   * Whether auto-scrolling the view when the user
   * moves their pointer close to the edges is disabled.
   */
  autoScrollDisabled = false;
  /** Number of pixels to scroll for each frame when auto-scrolling an element. */
  autoScrollStep = 2;
  /**
   * Function that is used to determine whether an item
   * is allowed to be moved into a drop container.
   */
  enterPredicate = () => true;
  /** Function that is used to determine whether an item can be sorted into a particular index. */
  sortPredicate = () => true;
  /** Emits right before dragging has started. */
  beforeStarted = new Subject();
  /**
   * Emits when the user has moved a new drag item into this container.
   */
  entered = new Subject();
  /**
   * Emits when the user removes an item from the container
   * by dragging it into another container.
   */
  exited = new Subject();
  /** Emits when the user drops an item inside the container. */
  dropped = new Subject();
  /** Emits as the user is swapping items while actively dragging. */
  sorted = new Subject();
  /** Emits when a dragging sequence is started in a list connected to the current one. */
  receivingStarted = new Subject();
  /** Emits when a dragging sequence is stopped from a list connected to the current one. */
  receivingStopped = new Subject();
  /** Arbitrary data that can be attached to the drop list. */
  data;
  /** Element that is the direct parent of the drag items. */
  _container;
  /** Whether an item in the list is being dragged. */
  _isDragging = false;
  /** Keeps track of the positions of any parent scrollable elements. */
  _parentPositions;
  /** Strategy being used to sort items within the list. */
  _sortStrategy;
  /** Cached `DOMRect` of the drop list. */
  _domRect;
  /** Draggable items in the container. */
  _draggables = [];
  /** Drop lists that are connected to the current one. */
  _siblings = [];
  /** Connected siblings that currently have a dragged item. */
  _activeSiblings = /* @__PURE__ */new Set();
  /** Subscription to the window being scrolled. */
  _viewportScrollSubscription = Subscription.EMPTY;
  /** Vertical direction in which the list is currently scrolling. */
  _verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  /** Horizontal direction in which the list is currently scrolling. */
  _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  /** Node that is being auto-scrolled. */
  _scrollNode;
  /** Used to signal to the current auto-scroll sequence when to stop. */
  _stopScrollTimers = new Subject();
  /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */
  _cachedShadowRoot = null;
  /** Reference to the document. */
  _document;
  /** Elements that can be scrolled while the user is dragging. */
  _scrollableElements = [];
  /** Initial value for the element's `scroll-snap-type` style. */
  _initialScrollSnap;
  /** Direction of the list's layout. */
  _direction = "ltr";
  constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {
    this._dragDropRegistry = _dragDropRegistry;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    const coercedElement = this.element = coerceElement(element);
    this._document = _document;
    this.withOrientation("vertical").withElementContainer(coercedElement);
    _dragDropRegistry.registerDropContainer(this);
    this._parentPositions = new ParentPositionTracker(_document);
  }
  /** Removes the drop list functionality from the DOM element. */
  dispose() {
    this._stopScrolling();
    this._stopScrollTimers.complete();
    this._viewportScrollSubscription.unsubscribe();
    this.beforeStarted.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this.sorted.complete();
    this.receivingStarted.complete();
    this.receivingStopped.complete();
    this._activeSiblings.clear();
    this._scrollNode = null;
    this._parentPositions.clear();
    this._dragDropRegistry.removeDropContainer(this);
  }
  /** Whether an item from this list is currently being dragged. */
  isDragging() {
    return this._isDragging;
  }
  /** Starts dragging an item. */
  start() {
    this._draggingStarted();
    this._notifyReceivingSiblings();
  }
  /**
   * Attempts to move an item into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    this._draggingStarted();
    if (index == null && this.sortingDisabled) {
      index = this._draggables.indexOf(item);
    }
    this._sortStrategy.enter(item, pointerX, pointerY, index);
    this._cacheParentPositions();
    this._notifyReceivingSiblings();
    this.entered.next({
      item,
      container: this,
      currentIndex: this.getItemIndex(item)
    });
  }
  /**
   * Removes an item from the container after it was dragged into another container by the user.
   * @param item Item that was dragged out.
   */
  exit(item) {
    this._reset();
    this.exited.next({
      item,
      container: this
    });
  }
  /**
   * Drops an item into this container.
   * @param item Item being dropped into the container.
   * @param currentIndex Index at which the item should be inserted.
   * @param previousIndex Index of the item when dragging started.
   * @param previousContainer Container from which the item got dragged in.
   * @param isPointerOverContainer Whether the user's pointer was over the
   *    container when the item was dropped.
   * @param distance Distance the user has dragged since the start of the dragging sequence.
   * @param event Event that triggered the dropping sequence.
   *
   * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.
   */
  drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
    this._reset();
    this.dropped.next({
      item,
      currentIndex,
      previousIndex,
      container: this,
      previousContainer,
      isPointerOverContainer,
      distance,
      dropPoint,
      event
    });
  }
  /**
   * Sets the draggable items that are a part of this list.
   * @param items Items that are a part of this list.
   */
  withItems(items) {
    const previousItems = this._draggables;
    this._draggables = items;
    items.forEach(item => item._withDropContainer(this));
    if (this.isDragging()) {
      const draggedItems = previousItems.filter(item => item.isDragging());
      if (draggedItems.every(item => items.indexOf(item) === -1)) {
        this._reset();
      } else {
        this._sortStrategy.withItems(this._draggables);
      }
    }
    return this;
  }
  /** Sets the layout direction of the drop list. */
  withDirection(direction) {
    this._direction = direction;
    if (this._sortStrategy instanceof SingleAxisSortStrategy) {
      this._sortStrategy.direction = direction;
    }
    return this;
  }
  /**
   * Sets the containers that are connected to this one. When two or more containers are
   * connected, the user will be allowed to transfer items between them.
   * @param connectedTo Other containers that the current containers should be connected to.
   */
  connectedTo(connectedTo) {
    this._siblings = connectedTo.slice();
    return this;
  }
  /**
   * Sets the orientation of the container.
   * @param orientation New orientation for the container.
   */
  withOrientation(orientation) {
    if (orientation === "mixed") {
      this._sortStrategy = new MixedSortStrategy(this._document, this._dragDropRegistry);
    } else {
      const strategy = new SingleAxisSortStrategy(this._dragDropRegistry);
      strategy.direction = this._direction;
      strategy.orientation = orientation;
      this._sortStrategy = strategy;
    }
    this._sortStrategy.withElementContainer(this._container);
    this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
    return this;
  }
  /**
   * Sets which parent elements are can be scrolled while the user is dragging.
   * @param elements Elements that can be scrolled.
   */
  withScrollableParents(elements) {
    const element = this._container;
    this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
    return this;
  }
  /**
   * Configures the drop list so that a different element is used as the container for the
   * dragged items. This is useful for the cases when one might not have control over the
   * full DOM that sets up the dragging.
   * Note that the alternate container needs to be a descendant of the drop list.
   * @param container New element container to be assigned.
   */
  withElementContainer(container) {
    if (container === this._container) {
      return this;
    }
    const element = coerceElement(this.element);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && container !== element && !element.contains(container)) {
      throw new Error("Invalid DOM structure for drop list. Alternate container element must be a descendant of the drop list.");
    }
    const oldContainerIndex = this._scrollableElements.indexOf(this._container);
    const newContainerIndex = this._scrollableElements.indexOf(container);
    if (oldContainerIndex > -1) {
      this._scrollableElements.splice(oldContainerIndex, 1);
    }
    if (newContainerIndex > -1) {
      this._scrollableElements.splice(newContainerIndex, 1);
    }
    if (this._sortStrategy) {
      this._sortStrategy.withElementContainer(container);
    }
    this._cachedShadowRoot = null;
    this._scrollableElements.unshift(container);
    this._container = container;
    return this;
  }
  /** Gets the scrollable parents that are registered with this drop container. */
  getScrollableParents() {
    return this._scrollableElements;
  }
  /**
   * Figures out the index of an item in the container.
   * @param item Item whose index should be determined.
   */
  getItemIndex(item) {
    return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
  }
  /**
   * Whether the list is able to receive the item that
   * is currently being dragged inside a connected drop list.
   */
  isReceiving() {
    return this._activeSiblings.size > 0;
  }
  /**
   * Sorts an item inside the container based on its position.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  _sortItem(item, pointerX, pointerY, pointerDelta) {
    if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
      return;
    }
    const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
    if (result) {
      this.sorted.next({
        previousIndex: result.previousIndex,
        currentIndex: result.currentIndex,
        container: this,
        item
      });
    }
  }
  /**
   * Checks whether the user's pointer is close to the edges of either the
   * viewport or the drop list and starts the auto-scroll sequence.
   * @param pointerX User's pointer position along the x axis.
   * @param pointerY User's pointer position along the y axis.
   */
  _startScrollingIfNecessary(pointerX, pointerY) {
    if (this.autoScrollDisabled) {
      return;
    }
    let scrollNode;
    let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
    let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
    this._parentPositions.positions.forEach((position, element) => {
      if (element === this._document || !position.clientRect || scrollNode) {
        return;
      }
      if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
        [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._direction, pointerX, pointerY);
        if (verticalScrollDirection || horizontalScrollDirection) {
          scrollNode = element;
        }
      }
    });
    if (!verticalScrollDirection && !horizontalScrollDirection) {
      const {
        width,
        height
      } = this._viewportRuler.getViewportSize();
      const domRect = {
        width,
        height,
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
      verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
      horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
      scrollNode = window;
    }
    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
      this._verticalScrollDirection = verticalScrollDirection;
      this._horizontalScrollDirection = horizontalScrollDirection;
      this._scrollNode = scrollNode;
      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
        this._ngZone.runOutsideAngular(this._startScrollInterval);
      } else {
        this._stopScrolling();
      }
    }
  }
  /** Stops any currently-running auto-scroll sequences. */
  _stopScrolling() {
    this._stopScrollTimers.next();
  }
  /** Starts the dragging sequence within the list. */
  _draggingStarted() {
    const styles = this._container.style;
    this.beforeStarted.next();
    this._isDragging = true;
    if ((typeof ngDevMode === "undefined" || ngDevMode) &&
    // Prevent the check from running on apps not using an alternate container. Ideally we
    // would always run it, but introducing it at this stage would be a breaking change.
    this._container !== coerceElement(this.element)) {
      for (const drag of this._draggables) {
        if (!drag.isDragging() && drag.getVisibleElement().parentNode !== this._container) {
          throw new Error("Invalid DOM structure for drop list. All items must be placed directly inside of the element container.");
        }
      }
    }
    this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
    styles.scrollSnapType = styles.msScrollSnapType = "none";
    this._sortStrategy.start(this._draggables);
    this._cacheParentPositions();
    this._viewportScrollSubscription.unsubscribe();
    this._listenToScrollEvents();
  }
  /** Caches the positions of the configured scrollable parents. */
  _cacheParentPositions() {
    this._parentPositions.cache(this._scrollableElements);
    this._domRect = this._parentPositions.positions.get(this._container).clientRect;
  }
  /** Resets the container to its initial state. */
  _reset() {
    this._isDragging = false;
    const styles = this._container.style;
    styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
    this._siblings.forEach(sibling => sibling._stopReceiving(this));
    this._sortStrategy.reset();
    this._stopScrolling();
    this._viewportScrollSubscription.unsubscribe();
    this._parentPositions.clear();
  }
  /** Starts the interval that'll auto-scroll the element. */
  _startScrollInterval = () => {
    this._stopScrolling();
    interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
      const node = this._scrollNode;
      const scrollStep = this.autoScrollStep;
      if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {
        node.scrollBy(0, -scrollStep);
      } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {
        node.scrollBy(0, scrollStep);
      }
      if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {
        node.scrollBy(-scrollStep, 0);
      } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {
        node.scrollBy(scrollStep, 0);
      }
    });
  };
  /**
   * Checks whether the user's pointer is positioned over the container.
   * @param x Pointer position along the X axis.
   * @param y Pointer position along the Y axis.
   */
  _isOverContainer(x2, y2) {
    return this._domRect != null && isInsideClientRect(this._domRect, x2, y2);
  }
  /**
   * Figures out whether an item should be moved into a sibling
   * drop container, based on its current position.
   * @param item Drag item that is being moved.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _getSiblingContainerFromPosition(item, x2, y2) {
    return this._siblings.find(sibling => sibling._canReceive(item, x2, y2));
  }
  /**
   * Checks whether the drop list can receive the passed-in item.
   * @param item Item that is being dragged into the list.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _canReceive(item, x2, y2) {
    if (!this._domRect || !isInsideClientRect(this._domRect, x2, y2) || !this.enterPredicate(item, this)) {
      return false;
    }
    const elementFromPoint = this._getShadowRoot().elementFromPoint(x2, y2);
    if (!elementFromPoint) {
      return false;
    }
    return elementFromPoint === this._container || this._container.contains(elementFromPoint);
  }
  /**
   * Called by one of the connected drop lists when a dragging sequence has started.
   * @param sibling Sibling in which dragging has started.
   */
  _startReceiving(sibling, items) {
    const activeSiblings = this._activeSiblings;
    if (!activeSiblings.has(sibling) && items.every(item => {
      return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
    })) {
      activeSiblings.add(sibling);
      this._cacheParentPositions();
      this._listenToScrollEvents();
      this.receivingStarted.next({
        initiator: sibling,
        receiver: this,
        items
      });
    }
  }
  /**
   * Called by a connected drop list when dragging has stopped.
   * @param sibling Sibling whose dragging has stopped.
   */
  _stopReceiving(sibling) {
    this._activeSiblings.delete(sibling);
    this._viewportScrollSubscription.unsubscribe();
    this.receivingStopped.next({
      initiator: sibling,
      receiver: this
    });
  }
  /**
   * Starts listening to scroll events on the viewport.
   * Used for updating the internal state of the list.
   */
  _listenToScrollEvents() {
    this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(event => {
      if (this.isDragging()) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
        }
      } else if (this.isReceiving()) {
        this._cacheParentPositions();
      }
    });
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (!this._cachedShadowRoot) {
      const shadowRoot = _getShadowRoot(this._container);
      this._cachedShadowRoot = shadowRoot || this._document;
    }
    return this._cachedShadowRoot;
  }
  /** Notifies any siblings that may potentially receive the item. */
  _notifyReceivingSiblings() {
    const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter(item => item.isDragging());
    this._siblings.forEach(sibling => sibling._startReceiving(this, draggedItems));
  }
};
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
    return AutoScrollVerticalDirection.UP;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return AutoScrollVerticalDirection.DOWN;
  }
  return AutoScrollVerticalDirection.NONE;
}
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return AutoScrollHorizontalDirection.LEFT;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return AutoScrollHorizontalDirection.RIGHT;
  }
  return AutoScrollHorizontalDirection.NONE;
}
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === AutoScrollVerticalDirection.UP) {
      if (scrollTop > 0) {
        verticalScrollDirection = AutoScrollVerticalDirection.UP;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
      }
    } else {
      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
var capturingEventOptions = {
  capture: true
};
var activeCapturingEventOptions = {
  passive: false,
  capture: true
};
var _ResetsLoader = class __ResetsLoader {
  static ɵfac = function _ResetsLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __ResetsLoader)();
  };
  static ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
    type: __ResetsLoader,
    selectors: [["ng-component"]],
    hostAttrs: ["cdk-drag-resets-container", ""],
    decls: 0,
    vars: 0,
    template: function _ResetsLoader_Template(rf, ctx) {},
    styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_ResetsLoader, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "cdk-drag-resets-container": ""
      },
      styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}"]
    }]
  }], null, null);
})();
var DragDropRegistry = class _DragDropRegistry {
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _styleLoader = inject(_CdkPrivateStyleLoader);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupDocumentTouchmove;
  /** Registered drop container instances. */
  _dropInstances = /* @__PURE__ */new Set();
  /** Registered drag item instances. */
  _dragInstances = /* @__PURE__ */new Set();
  /** Drag item instances that are currently being dragged. */
  _activeDragInstances = signal([]);
  /** Keeps track of the event listeners that we've bound to the `document`. */
  _globalListeners;
  /**
   * Predicate function to check if an item is being dragged.  Moved out into a property,
   * because it'll be called a lot and we don't want to create a new function every time.
   */
  _draggingPredicate = item => item.isDragging();
  /**
   * Map tracking DOM nodes and their corresponding drag directives. Note that this is different
   * from looking through the `_dragInstances` and getting their root node, because the root node
   * isn't necessarily the node that the directive is set on.
   */
  _domNodesToDirectives = null;
  /**
   * Emits the `touchmove` or `mousemove` events that are dispatched
   * while the user is dragging a drag item instance.
   */
  pointerMove = new Subject();
  /**
   * Emits the `touchend` or `mouseup` events that are dispatched
   * while the user is dragging a drag item instance.
   */
  pointerUp = new Subject();
  /**
   * Emits when the viewport has been scrolled while the user is dragging an item.
   * @deprecated To be turned into a private member. Use the `scrolled` method instead.
   * @breaking-change 13.0.0
   */
  scroll = new Subject();
  constructor() {}
  /** Adds a drop container to the registry. */
  registerDropContainer(drop) {
    if (!this._dropInstances.has(drop)) {
      this._dropInstances.add(drop);
    }
  }
  /** Adds a drag item instance to the registry. */
  registerDragItem(drag) {
    this._dragInstances.add(drag);
    if (this._dragInstances.size === 1) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupDocumentTouchmove?.();
        this._cleanupDocumentTouchmove = _bindEventWithOptions(this._renderer, this._document, "touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
      });
    }
  }
  /** Removes a drop container from the registry. */
  removeDropContainer(drop) {
    this._dropInstances.delete(drop);
  }
  /** Removes a drag item instance from the registry. */
  removeDragItem(drag) {
    this._dragInstances.delete(drag);
    this.stopDragging(drag);
    if (this._dragInstances.size === 0) {
      this._cleanupDocumentTouchmove?.();
    }
  }
  /**
   * Starts the dragging sequence for a drag instance.
   * @param drag Drag instance which is being dragged.
   * @param event Event that initiated the dragging.
   */
  startDragging(drag, event) {
    if (this._activeDragInstances().indexOf(drag) > -1) {
      return;
    }
    this._styleLoader.load(_ResetsLoader);
    this._activeDragInstances.update(instances => [...instances, drag]);
    if (this._activeDragInstances().length === 1) {
      const isTouchEvent2 = event.type.startsWith("touch");
      const endEventHandler = e2 => this.pointerUp.next(e2);
      const toBind = [
      // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't
      // the document. See https://github.com/angular/components/issues/17144.
      ["scroll", e2 => this.scroll.next(e2), capturingEventOptions],
      // Preventing the default action on `mousemove` isn't enough to disable text selection
      // on Safari so we need to prevent the selection event as well. Alternatively this can
      // be done by setting `user-select: none` on the `body`, however it has causes a style
      // recalculation which can be expensive on pages with a lot of elements.
      ["selectstart", this._preventDefaultWhileDragging, activeCapturingEventOptions]];
      if (isTouchEvent2) {
        toBind.push(["touchend", endEventHandler, capturingEventOptions], ["touchcancel", endEventHandler, capturingEventOptions]);
      } else {
        toBind.push(["mouseup", endEventHandler, capturingEventOptions]);
      }
      if (!isTouchEvent2) {
        toBind.push(["mousemove", e2 => this.pointerMove.next(e2), activeCapturingEventOptions]);
      }
      this._ngZone.runOutsideAngular(() => {
        this._globalListeners = toBind.map(([name, handler, options]) => _bindEventWithOptions(this._renderer, this._document, name, handler, options));
      });
    }
  }
  /** Stops dragging a drag item instance. */
  stopDragging(drag) {
    this._activeDragInstances.update(instances => {
      const index = instances.indexOf(drag);
      if (index > -1) {
        instances.splice(index, 1);
        return [...instances];
      }
      return instances;
    });
    if (this._activeDragInstances().length === 0) {
      this._clearGlobalListeners();
    }
  }
  /** Gets whether a drag item instance is currently being dragged. */
  isDragging(drag) {
    return this._activeDragInstances().indexOf(drag) > -1;
  }
  /**
   * Gets a stream that will emit when any element on the page is scrolled while an item is being
   * dragged.
   * @param shadowRoot Optional shadow root that the current dragging sequence started from.
   *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can
   *   be used to include an additional top-level listener at the shadow root level.
   */
  scrolled(shadowRoot) {
    const streams = [this.scroll];
    if (shadowRoot && shadowRoot !== this._document) {
      streams.push(new Observable(observer => {
        return this._ngZone.runOutsideAngular(() => {
          const cleanup = _bindEventWithOptions(this._renderer, shadowRoot, "scroll", event => {
            if (this._activeDragInstances().length) {
              observer.next(event);
            }
          }, capturingEventOptions);
          return () => {
            cleanup();
          };
        });
      }));
    }
    return merge(...streams);
  }
  /**
   * Tracks the DOM node which has a draggable directive.
   * @param node Node to track.
   * @param dragRef Drag directive set on the node.
   */
  registerDirectiveNode(node, dragRef) {
    this._domNodesToDirectives ??= /* @__PURE__ */new WeakMap();
    this._domNodesToDirectives.set(node, dragRef);
  }
  /**
   * Stops tracking a draggable directive node.
   * @param node Node to stop tracking.
   */
  removeDirectiveNode(node) {
    this._domNodesToDirectives?.delete(node);
  }
  /**
   * Gets the drag directive corresponding to a specific DOM node, if any.
   * @param node Node for which to do the lookup.
   */
  getDragDirectiveForNode(node) {
    return this._domNodesToDirectives?.get(node) || null;
  }
  ngOnDestroy() {
    this._dragInstances.forEach(instance => this.removeDragItem(instance));
    this._dropInstances.forEach(instance => this.removeDropContainer(instance));
    this._domNodesToDirectives = null;
    this._clearGlobalListeners();
    this.pointerMove.complete();
    this.pointerUp.complete();
  }
  /**
   * Event listener that will prevent the default browser action while the user is dragging.
   * @param event Event whose default action should be prevented.
   */
  _preventDefaultWhileDragging = event => {
    if (this._activeDragInstances().length > 0) {
      event.preventDefault();
    }
  };
  /** Event listener for `touchmove` that is bound even if no dragging is happening. */
  _persistentTouchmoveListener = event => {
    if (this._activeDragInstances().length > 0) {
      if (this._activeDragInstances().some(this._draggingPredicate)) {
        event.preventDefault();
      }
      this.pointerMove.next(event);
    }
  };
  /** Clears out the global event listeners from the `document`. */
  _clearGlobalListeners() {
    this._globalListeners?.forEach(cleanup => cleanup());
    this._globalListeners = void 0;
  }
  static ɵfac = function DragDropRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDropRegistry)();
  };
  static ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
    token: _DragDropRegistry,
    factory: _DragDropRegistry.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var DEFAULT_CONFIG = {
  dragStartThreshold: 5,
  pointerDirectionChangeThreshold: 5
};
var DragDrop = class _DragDrop {
  _document = inject(DOCUMENT);
  _ngZone = inject(NgZone);
  _viewportRuler = inject(ViewportRuler);
  _dragDropRegistry = inject(DragDropRegistry);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  constructor() {}
  /**
   * Turns an element into a draggable item.
   * @param element Element to which to attach the dragging functionality.
   * @param config Object used to configure the dragging behavior.
   */
  createDrag(element, config = DEFAULT_CONFIG) {
    return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);
  }
  /**
   * Turns an element into a drop list.
   * @param element Element to which to attach the drop list functionality.
   */
  createDropList(element) {
    return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
  }
  static ɵfac = function DragDrop_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDrop)();
  };
  static ɵprov = /* @__PURE__ */ɵɵdefineInjectable({
    token: _DragDrop,
    factory: _DragDrop.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
function assertElementNode(node, name) {
  if (node.nodeType !== 1) {
    throw Error(`${name} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
var CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
var CdkDragHandle = class _CdkDragHandle {
  element = inject(ElementRef);
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  /** Emits when the state of the handle has changed. */
  _stateChanges = new Subject();
  /** Whether starting to drag through this handle is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._stateChanges.next(this);
  }
  _disabled = false;
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDragHandle");
    }
    this._parentDrag?._addHandle(this);
  }
  ngAfterViewInit() {
    if (!this._parentDrag) {
      let parent2 = this.element.nativeElement.parentElement;
      while (parent2) {
        const ref = this._dragDropRegistry.getDragDirectiveForNode(parent2);
        if (ref) {
          this._parentDrag = ref;
          ref._addHandle(this);
          break;
        }
        parent2 = parent2.parentElement;
      }
    }
  }
  ngOnDestroy() {
    this._parentDrag?._removeHandle(this);
    this._stateChanges.complete();
  }
  static ɵfac = function CdkDragHandle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragHandle)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkDragHandle,
    selectors: [["", "cdkDragHandle", ""]],
    hostAttrs: [1, "cdk-drag-handle"],
    inputs: {
      disabled: [2, "cdkDragHandleDisabled", "disabled", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_HANDLE,
      useExisting: _CdkDragHandle
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
    type: Directive,
    args: [{
      selector: "[cdkDragHandle]",
      host: {
        "class": "cdk-drag-handle"
      },
      providers: [{
        provide: CDK_DRAG_HANDLE,
        useExisting: CdkDragHandle
      }]
    }]
  }], () => [], {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragHandleDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
var CDK_DROP_LIST = new InjectionToken("CdkDropList");
var CdkDrag = class _CdkDrag {
  element = inject(ElementRef);
  dropContainer = inject(CDK_DROP_LIST, {
    optional: true,
    skipSelf: true
  });
  _ngZone = inject(NgZone);
  _viewContainerRef = inject(ViewContainerRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  _selfHandle = inject(CDK_DRAG_HANDLE, {
    optional: true,
    self: true
  });
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  _destroyed = new Subject();
  _handles = new BehaviorSubject([]);
  _previewTemplate;
  _placeholderTemplate;
  /** Reference to the underlying drag instance. */
  _dragRef;
  /** Arbitrary data to attach to this drag instance. */
  data;
  /** Locks the position of the dragged element along the specified axis. */
  lockAxis;
  /**
   * Selector that will be used to determine the root draggable element, starting from
   * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful
   * when trying to enable dragging on an element that you might not have access to.
   */
  rootElementSelector;
  /**
   * Node or selector that will be used to determine the element to which the draggable's
   * position will be constrained. If a string is passed in, it'll be used as a selector that
   * will be matched starting from the element's parent and going up the DOM until a match
   * has been found.
   */
  boundaryElement;
  /**
   * Amount of milliseconds to wait after the user has put their
   * pointer down before starting to drag the element.
   */
  dragStartDelay;
  /**
   * Sets the position of a `CdkDrag` that is outside of a drop container.
   * Can be used to restore the element's position for a returning user.
   */
  freeDragPosition;
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);
  }
  set disabled(value) {
    this._disabled = value;
    this._dragRef.disabled = this._disabled;
  }
  _disabled;
  /**
   * Function that can be used to customize the logic of how the position of the drag item
   * is limited while it's being dragged. Gets called with a point containing the current position
   * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
   * Should return a point describing where the item should be rendered.
   */
  constrainPosition;
  /** Class to be added to the preview element. */
  previewClass;
  /**
   * Configures the place into which the preview of the item will be inserted. Can be configured
   * globally through `CDK_DROP_LIST`. Possible values:
   * - `global` - Preview will be inserted at the bottom of the `<body>`. The advantage is that
   * you don't have to worry about `overflow: hidden` or `z-index`, but the item won't retain
   * its inherited styles.
   * - `parent` - Preview will be inserted into the parent of the drag item. The advantage is that
   * inherited styles will be preserved, but it may be clipped by `overflow: hidden` or not be
   * visible due to `z-index`. Furthermore, the preview is going to have an effect over selectors
   * like `:nth-child` and some flexbox configurations.
   * - `ElementRef<HTMLElement> | HTMLElement` - Preview will be inserted into a specific element.
   * Same advantages and disadvantages as `parent`.
   */
  previewContainer;
  /**
   * If the parent of the dragged element has a `scale` transform, it can throw off the
   * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
   */
  scale = 1;
  /** Emits when the user starts dragging the item. */
  started = new EventEmitter();
  /** Emits when the user has released a drag item, before any animations have started. */
  released = new EventEmitter();
  /** Emits when the user stops dragging an item in the container. */
  ended = new EventEmitter();
  /** Emits when the user has moved the item into a new container. */
  entered = new EventEmitter();
  /** Emits when the user removes the item its container by dragging it into another container. */
  exited = new EventEmitter();
  /** Emits when the user drops the item inside a container. */
  dropped = new EventEmitter();
  /**
   * Emits as the user is dragging the item. Use with caution,
   * because this event will fire for every pixel that the user has dragged.
   */
  moved = new Observable(observer => {
    const subscription = this._dragRef.moved.pipe(map(movedEvent => ({
      source: this,
      pointerPosition: movedEvent.pointerPosition,
      event: movedEvent.event,
      delta: movedEvent.delta,
      distance: movedEvent.distance
    }))).subscribe(observer);
    return () => {
      subscription.unsubscribe();
    };
  });
  _injector = inject(Injector);
  constructor() {
    const dropContainer = this.dropContainer;
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    const dragDrop = inject(DragDrop);
    this._dragRef = dragDrop.createDrag(this.element, {
      dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,
      pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ? config.pointerDirectionChangeThreshold : 5,
      zIndex: config?.zIndex
    });
    this._dragRef.data = this;
    this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this);
    if (config) {
      this._assignDefaults(config);
    }
    if (dropContainer) {
      this._dragRef._withDropContainer(dropContainer._dropListRef);
      dropContainer.addItem(this);
      dropContainer._dropListRef.beforeStarted.pipe(takeUntil(this._destroyed)).subscribe(() => {
        this._dragRef.scale = this.scale;
      });
    }
    this._syncInputs(this._dragRef);
    this._handleEvents(this._dragRef);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._dragRef.getPlaceholderElement();
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._dragRef.getRootElement();
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._dragRef.reset();
  }
  /**
   * Gets the pixel coordinates of the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    return this._dragRef.getFreeDragPosition();
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._dragRef.setFreeDragPosition(value);
  }
  ngAfterViewInit() {
    afterNextRender(() => {
      this._updateRootElement();
      this._setupHandlesListener();
      this._dragRef.scale = this.scale;
      if (this.freeDragPosition) {
        this._dragRef.setFreeDragPosition(this.freeDragPosition);
      }
    }, {
      injector: this._injector
    });
  }
  ngOnChanges(changes) {
    const rootSelectorChange = changes["rootElementSelector"];
    const positionChange = changes["freeDragPosition"];
    if (rootSelectorChange && !rootSelectorChange.firstChange) {
      this._updateRootElement();
    }
    this._dragRef.scale = this.scale;
    if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
      this._dragRef.setFreeDragPosition(this.freeDragPosition);
    }
  }
  ngOnDestroy() {
    if (this.dropContainer) {
      this.dropContainer.removeItem(this);
    }
    this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement);
    this._ngZone.runOutsideAngular(() => {
      this._handles.complete();
      this._destroyed.next();
      this._destroyed.complete();
      this._dragRef.dispose();
    });
  }
  _addHandle(handle) {
    const handles = this._handles.getValue();
    handles.push(handle);
    this._handles.next(handles);
  }
  _removeHandle(handle) {
    const handles = this._handles.getValue();
    const index = handles.indexOf(handle);
    if (index > -1) {
      handles.splice(index, 1);
      this._handles.next(handles);
    }
  }
  _setPreviewTemplate(preview) {
    this._previewTemplate = preview;
  }
  _resetPreviewTemplate(preview) {
    if (preview === this._previewTemplate) {
      this._previewTemplate = null;
    }
  }
  _setPlaceholderTemplate(placeholder) {
    this._placeholderTemplate = placeholder;
  }
  _resetPlaceholderTemplate(placeholder) {
    if (placeholder === this._placeholderTemplate) {
      this._placeholderTemplate = null;
    }
  }
  /** Syncs the root element with the `DragRef`. */
  _updateRootElement() {
    const element = this.element.nativeElement;
    let rootElement = element;
    if (this.rootElementSelector) {
      rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) :
      // Comment tag doesn't have closest method, so use parent's one.
      element.parentElement?.closest(this.rootElementSelector);
    }
    if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
      assertElementNode(rootElement, "cdkDrag");
    }
    this._dragRef.withRootElement(rootElement || element);
  }
  /** Gets the boundary element, based on the `boundaryElement` value. */
  _getBoundaryElement() {
    const boundary = this.boundaryElement;
    if (!boundary) {
      return null;
    }
    if (typeof boundary === "string") {
      return this.element.nativeElement.closest(boundary);
    }
    return coerceElement(boundary);
  }
  /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */
  _syncInputs(ref) {
    ref.beforeStarted.subscribe(() => {
      if (!ref.isDragging()) {
        const dir = this._dir;
        const dragStartDelay = this.dragStartDelay;
        const placeholder = this._placeholderTemplate ? {
          template: this._placeholderTemplate.templateRef,
          context: this._placeholderTemplate.data,
          viewContainer: this._viewContainerRef
        } : null;
        const preview = this._previewTemplate ? {
          template: this._previewTemplate.templateRef,
          context: this._previewTemplate.data,
          matchSize: this._previewTemplate.matchSize,
          viewContainer: this._viewContainerRef
        } : null;
        ref.disabled = this.disabled;
        ref.lockAxis = this.lockAxis;
        ref.scale = this.scale;
        ref.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
        ref.constrainPosition = this.constrainPosition;
        ref.previewClass = this.previewClass;
        ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
        if (dir) {
          ref.withDirection(dir.value);
        }
      }
    });
    ref.beforeStarted.pipe(take(1)).subscribe(() => {
      if (this._parentDrag) {
        ref.withParent(this._parentDrag._dragRef);
        return;
      }
      let parent2 = this.element.nativeElement.parentElement;
      while (parent2) {
        const parentDrag = this._dragDropRegistry.getDragDirectiveForNode(parent2);
        if (parentDrag) {
          ref.withParent(parentDrag._dragRef);
          break;
        }
        parent2 = parent2.parentElement;
      }
    });
  }
  /** Handles the events from the underlying `DragRef`. */
  _handleEvents(ref) {
    ref.started.subscribe(startEvent => {
      this.started.emit({
        source: this,
        event: startEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.released.subscribe(releaseEvent => {
      this.released.emit({
        source: this,
        event: releaseEvent.event
      });
    });
    ref.ended.subscribe(endEvent => {
      this.ended.emit({
        source: this,
        distance: endEvent.distance,
        dropPoint: endEvent.dropPoint,
        event: endEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe(enterEvent => {
      this.entered.emit({
        container: enterEvent.container.data,
        item: this,
        currentIndex: enterEvent.currentIndex
      });
    });
    ref.exited.subscribe(exitEvent => {
      this.exited.emit({
        container: exitEvent.container.data,
        item: this
      });
    });
    ref.dropped.subscribe(dropEvent => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        item: this,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
    });
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      dragStartDelay,
      constrainPosition,
      previewClass,
      boundaryElement,
      draggingDisabled,
      rootElementSelector,
      previewContainer
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.dragStartDelay = dragStartDelay || 0;
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
    if (constrainPosition) {
      this.constrainPosition = constrainPosition;
    }
    if (previewClass) {
      this.previewClass = previewClass;
    }
    if (boundaryElement) {
      this.boundaryElement = boundaryElement;
    }
    if (rootElementSelector) {
      this.rootElementSelector = rootElementSelector;
    }
    if (previewContainer) {
      this.previewContainer = previewContainer;
    }
  }
  /** Sets up the listener that syncs the handles with the drag ref. */
  _setupHandlesListener() {
    this._handles.pipe(
    // Sync the new handles with the DragRef.
    tap(handles => {
      const handleElements = handles.map(handle => handle.element);
      if (this._selfHandle && this.rootElementSelector) {
        handleElements.push(this.element);
      }
      this._dragRef.withHandles(handleElements);
    }),
    // Listen if the state of any of the handles changes.
    switchMap(handles => {
      return merge(...handles.map(item => item._stateChanges.pipe(startWith(item))));
    }), takeUntil(this._destroyed)).subscribe(handleInstance => {
      const dragRef = this._dragRef;
      const handle = handleInstance.element.nativeElement;
      handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
    });
  }
  static ɵfac = function CdkDrag_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDrag)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkDrag,
    selectors: [["", "cdkDrag", ""]],
    hostAttrs: [1, "cdk-drag"],
    hostVars: 4,
    hostBindings: function CdkDrag_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
      }
    },
    inputs: {
      data: [0, "cdkDragData", "data"],
      lockAxis: [0, "cdkDragLockAxis", "lockAxis"],
      rootElementSelector: [0, "cdkDragRootElement", "rootElementSelector"],
      boundaryElement: [0, "cdkDragBoundary", "boundaryElement"],
      dragStartDelay: [0, "cdkDragStartDelay", "dragStartDelay"],
      freeDragPosition: [0, "cdkDragFreeDragPosition", "freeDragPosition"],
      disabled: [2, "cdkDragDisabled", "disabled", booleanAttribute],
      constrainPosition: [0, "cdkDragConstrainPosition", "constrainPosition"],
      previewClass: [0, "cdkDragPreviewClass", "previewClass"],
      previewContainer: [0, "cdkDragPreviewContainer", "previewContainer"],
      scale: [2, "cdkDragScale", "scale", numberAttribute]
    },
    outputs: {
      started: "cdkDragStarted",
      released: "cdkDragReleased",
      ended: "cdkDragEnded",
      entered: "cdkDragEntered",
      exited: "cdkDragExited",
      dropped: "cdkDragDropped",
      moved: "cdkDragMoved"
    },
    exportAs: ["cdkDrag"],
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PARENT,
      useExisting: _CdkDrag
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]",
      exportAs: "cdkDrag",
      host: {
        "class": "cdk-drag",
        "[class.cdk-drag-disabled]": "disabled",
        "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
      },
      providers: [{
        provide: CDK_DRAG_PARENT,
        useExisting: CdkDrag
      }]
    }]
  }], () => [], {
    data: [{
      type: Input,
      args: ["cdkDragData"]
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDragLockAxis"]
    }],
    rootElementSelector: [{
      type: Input,
      args: ["cdkDragRootElement"]
    }],
    boundaryElement: [{
      type: Input,
      args: ["cdkDragBoundary"]
    }],
    dragStartDelay: [{
      type: Input,
      args: ["cdkDragStartDelay"]
    }],
    freeDragPosition: [{
      type: Input,
      args: ["cdkDragFreeDragPosition"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragDisabled",
        transform: booleanAttribute
      }]
    }],
    constrainPosition: [{
      type: Input,
      args: ["cdkDragConstrainPosition"]
    }],
    previewClass: [{
      type: Input,
      args: ["cdkDragPreviewClass"]
    }],
    previewContainer: [{
      type: Input,
      args: ["cdkDragPreviewContainer"]
    }],
    scale: [{
      type: Input,
      args: [{
        alias: "cdkDragScale",
        transform: numberAttribute
      }]
    }],
    started: [{
      type: Output,
      args: ["cdkDragStarted"]
    }],
    released: [{
      type: Output,
      args: ["cdkDragReleased"]
    }],
    ended: [{
      type: Output,
      args: ["cdkDragEnded"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDragEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDragExited"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDragDropped"]
    }],
    moved: [{
      type: Output,
      args: ["cdkDragMoved"]
    }]
  });
})();
var CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
var CdkDropListGroup = class _CdkDropListGroup {
  /** Drop lists registered inside the group. */
  _items = /* @__PURE__ */new Set();
  /** Whether starting a dragging sequence from inside this group is disabled. */
  disabled = false;
  ngOnDestroy() {
    this._items.clear();
  }
  static ɵfac = function CdkDropListGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDropListGroup)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkDropListGroup,
    selectors: [["", "cdkDropListGroup", ""]],
    inputs: {
      disabled: [2, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
    },
    exportAs: ["cdkDropListGroup"],
    features: [ɵɵProvidersFeature([{
      provide: CDK_DROP_LIST_GROUP,
      useExisting: _CdkDropListGroup
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
    type: Directive,
    args: [{
      selector: "[cdkDropListGroup]",
      exportAs: "cdkDropListGroup",
      providers: [{
        provide: CDK_DROP_LIST_GROUP,
        useExisting: CdkDropListGroup
      }]
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListGroupDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkDropList = class _CdkDropList {
  element = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollDispatcher = inject(ScrollDispatcher);
  _dir = inject(Directionality, {
    optional: true
  });
  _group = inject(CDK_DROP_LIST_GROUP, {
    optional: true,
    skipSelf: true
  });
  /** Emits when the list has been destroyed. */
  _destroyed = new Subject();
  /** Whether the element's scrollable parents have been resolved. */
  _scrollableParentsResolved;
  /** Keeps track of the drop lists that are currently on the page. */
  static _dropLists = [];
  /** Reference to the underlying drop list instance. */
  _dropListRef;
  /**
   * Other draggable containers that this container is connected to and into which the
   * container's items can be transferred. Can either be references to other drop containers,
   * or their unique IDs.
   */
  connectedTo = [];
  /** Arbitrary data to attach to this container. */
  data;
  /** Direction in which the list is oriented. */
  orientation;
  /**
   * Unique ID for the drop zone. Can be used as a reference
   * in the `connectedTo` of another `CdkDropList`.
   */
  id = inject(_IdGenerator).getId("cdk-drop-list-");
  /** Locks the position of the draggable elements inside the container along the specified axis. */
  lockAxis;
  /** Whether starting a dragging sequence from this container is disabled. */
  get disabled() {
    return this._disabled || !!this._group && this._group.disabled;
  }
  set disabled(value) {
    this._dropListRef.disabled = this._disabled = value;
  }
  _disabled;
  /** Whether sorting within this drop list is disabled. */
  sortingDisabled;
  /**
   * Function that is used to determine whether an item
   * is allowed to be moved into a drop container.
   */
  enterPredicate = () => true;
  /** Functions that is used to determine whether an item can be sorted into a particular index. */
  sortPredicate = () => true;
  /** Whether to auto-scroll the view when the user moves their pointer close to the edges. */
  autoScrollDisabled;
  /** Number of pixels to scroll for each frame when auto-scrolling an element. */
  autoScrollStep;
  /**
   * Selector that will be used to resolve an alternate element container for the drop list.
   * Passing an alternate container is useful for the cases where one might not have control
   * over the parent node of the draggable items within the list (e.g. due to content projection).
   * This allows for usages like:
   *
   * ```
   * <div cdkDropList cdkDropListElementContainer=".inner">
   *   <div class="inner">
   *     <div cdkDrag></div>
   *   </div>
   * </div>
   * ```
   */
  elementContainerSelector;
  /** Emits when the user drops an item inside the container. */
  dropped = new EventEmitter();
  /**
   * Emits when the user has moved a new drag item into this container.
   */
  entered = new EventEmitter();
  /**
   * Emits when the user removes an item from the container
   * by dragging it into another container.
   */
  exited = new EventEmitter();
  /** Emits as the user is swapping items while actively dragging. */
  sorted = new EventEmitter();
  /**
   * Keeps track of the items that are registered with this container. Historically we used to
   * do this with a `ContentChildren` query, however queries don't handle transplanted views very
   * well which means that we can't handle cases like dragging the headers of a `mat-table`
   * correctly. What we do instead is to have the items register themselves with the container
   * and then we sort them based on their position in the DOM.
   */
  _unsortedItems = /* @__PURE__ */new Set();
  constructor() {
    const dragDrop = inject(DragDrop);
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDropList");
    }
    this._dropListRef = dragDrop.createDropList(this.element);
    this._dropListRef.data = this;
    if (config) {
      this._assignDefaults(config);
    }
    this._dropListRef.enterPredicate = (drag, drop) => {
      return this.enterPredicate(drag.data, drop.data);
    };
    this._dropListRef.sortPredicate = (index, drag, drop) => {
      return this.sortPredicate(index, drag.data, drop.data);
    };
    this._setupInputSyncSubscription(this._dropListRef);
    this._handleEvents(this._dropListRef);
    _CdkDropList._dropLists.push(this);
    if (this._group) {
      this._group._items.add(this);
    }
  }
  /** Registers an items with the drop list. */
  addItem(item) {
    this._unsortedItems.add(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Removes an item from the drop list. */
  removeItem(item) {
    this._unsortedItems.delete(item);
    this._syncItemsWithRef();
  }
  /** Gets the registered items in the list, sorted by their position in the DOM. */
  getSortedItems() {
    return Array.from(this._unsortedItems).sort((a2, b2) => {
      const documentPosition = a2._dragRef.getVisibleElement().compareDocumentPosition(b2._dragRef.getVisibleElement());
      return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });
  }
  ngOnDestroy() {
    const index = _CdkDropList._dropLists.indexOf(this);
    if (index > -1) {
      _CdkDropList._dropLists.splice(index, 1);
    }
    if (this._group) {
      this._group._items.delete(this);
    }
    this._unsortedItems.clear();
    this._dropListRef.dispose();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */
  _setupInputSyncSubscription(ref) {
    if (this._dir) {
      this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe(value => ref.withDirection(value));
    }
    ref.beforeStarted.subscribe(() => {
      const siblings = coerceArray(this.connectedTo).map(drop => {
        if (typeof drop === "string") {
          const correspondingDropList = _CdkDropList._dropLists.find(list => list.id === drop);
          if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
            console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
          }
          return correspondingDropList;
        }
        return drop;
      });
      if (this._group) {
        this._group._items.forEach(drop => {
          if (siblings.indexOf(drop) === -1) {
            siblings.push(drop);
          }
        });
      }
      if (!this._scrollableParentsResolved) {
        const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map(scrollable => scrollable.getElementRef().nativeElement);
        this._dropListRef.withScrollableParents(scrollableParents);
        this._scrollableParentsResolved = true;
      }
      if (this.elementContainerSelector) {
        const container = this.element.nativeElement.querySelector(this.elementContainerSelector);
        if (!container && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new Error(`CdkDropList could not find an element container matching the selector "${this.elementContainerSelector}"`);
        }
        ref.withElementContainer(container);
      }
      ref.disabled = this.disabled;
      ref.lockAxis = this.lockAxis;
      ref.sortingDisabled = this.sortingDisabled;
      ref.autoScrollDisabled = this.autoScrollDisabled;
      ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
      ref.connectedTo(siblings.filter(drop => drop && drop !== this).map(list => list._dropListRef)).withOrientation(this.orientation);
    });
  }
  /** Handles events from the underlying DropListRef. */
  _handleEvents(ref) {
    ref.beforeStarted.subscribe(() => {
      this._syncItemsWithRef();
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe(event => {
      this.entered.emit({
        container: this,
        item: event.item.data,
        currentIndex: event.currentIndex
      });
    });
    ref.exited.subscribe(event => {
      this.exited.emit({
        container: this,
        item: event.item.data
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.sorted.subscribe(event => {
      this.sorted.emit({
        previousIndex: event.previousIndex,
        currentIndex: event.currentIndex,
        container: this,
        item: event.item.data
      });
    });
    ref.dropped.subscribe(dropEvent => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        item: dropEvent.item.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      draggingDisabled,
      sortingDisabled,
      listAutoScrollDisabled,
      listOrientation
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
    this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
    this.orientation = listOrientation || "vertical";
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
  }
  /** Syncs up the registered drag items with underlying drop list ref. */
  _syncItemsWithRef() {
    this._dropListRef.withItems(this.getSortedItems().map(item => item._dragRef));
  }
  static ɵfac = function CdkDropList_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDropList)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkDropList,
    selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
    hostAttrs: [1, "cdk-drop-list"],
    hostVars: 7,
    hostBindings: function CdkDropList_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.id);
        ɵɵclassProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
      }
    },
    inputs: {
      connectedTo: [0, "cdkDropListConnectedTo", "connectedTo"],
      data: [0, "cdkDropListData", "data"],
      orientation: [0, "cdkDropListOrientation", "orientation"],
      id: "id",
      lockAxis: [0, "cdkDropListLockAxis", "lockAxis"],
      disabled: [2, "cdkDropListDisabled", "disabled", booleanAttribute],
      sortingDisabled: [2, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
      enterPredicate: [0, "cdkDropListEnterPredicate", "enterPredicate"],
      sortPredicate: [0, "cdkDropListSortPredicate", "sortPredicate"],
      autoScrollDisabled: [2, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
      autoScrollStep: [0, "cdkDropListAutoScrollStep", "autoScrollStep"],
      elementContainerSelector: [0, "cdkDropListElementContainer", "elementContainerSelector"]
    },
    outputs: {
      dropped: "cdkDropListDropped",
      entered: "cdkDropListEntered",
      exited: "cdkDropListExited",
      sorted: "cdkDropListSorted"
    },
    exportAs: ["cdkDropList"],
    features: [ɵɵProvidersFeature([
    // Prevent child drop lists from picking up the same group as their parent.
    {
      provide: CDK_DROP_LIST_GROUP,
      useValue: void 0
    }, {
      provide: CDK_DROP_LIST,
      useExisting: _CdkDropList
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
    type: Directive,
    args: [{
      selector: "[cdkDropList], cdk-drop-list",
      exportAs: "cdkDropList",
      providers: [
      // Prevent child drop lists from picking up the same group as their parent.
      {
        provide: CDK_DROP_LIST_GROUP,
        useValue: void 0
      }, {
        provide: CDK_DROP_LIST,
        useExisting: CdkDropList
      }],
      host: {
        "class": "cdk-drop-list",
        "[attr.id]": "id",
        "[class.cdk-drop-list-disabled]": "disabled",
        "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
        "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
      }
    }]
  }], () => [], {
    connectedTo: [{
      type: Input,
      args: ["cdkDropListConnectedTo"]
    }],
    data: [{
      type: Input,
      args: ["cdkDropListData"]
    }],
    orientation: [{
      type: Input,
      args: ["cdkDropListOrientation"]
    }],
    id: [{
      type: Input
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDropListLockAxis"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListDisabled",
        transform: booleanAttribute
      }]
    }],
    sortingDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListSortingDisabled",
        transform: booleanAttribute
      }]
    }],
    enterPredicate: [{
      type: Input,
      args: ["cdkDropListEnterPredicate"]
    }],
    sortPredicate: [{
      type: Input,
      args: ["cdkDropListSortPredicate"]
    }],
    autoScrollDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListAutoScrollDisabled",
        transform: booleanAttribute
      }]
    }],
    autoScrollStep: [{
      type: Input,
      args: ["cdkDropListAutoScrollStep"]
    }],
    elementContainerSelector: [{
      type: Input,
      args: ["cdkDropListElementContainer"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDropListDropped"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDropListEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDropListExited"]
    }],
    sorted: [{
      type: Output,
      args: ["cdkDropListSorted"]
    }]
  });
})();
var CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
var CdkDragPreview = class _CdkDragPreview {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  /** Context data to be added to the preview template instance. */
  data;
  /** Whether the preview should preserve the same size as the item that is being dragged. */
  matchSize = false;
  constructor() {
    this._drag?._setPreviewTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPreviewTemplate(this);
  }
  static ɵfac = function CdkDragPreview_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragPreview)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkDragPreview,
    selectors: [["ng-template", "cdkDragPreview", ""]],
    inputs: {
      data: "data",
      matchSize: [2, "matchSize", "matchSize", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PREVIEW,
      useExisting: _CdkDragPreview
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPreview]",
      providers: [{
        provide: CDK_DRAG_PREVIEW,
        useExisting: CdkDragPreview
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }],
    matchSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
var CdkDragPlaceholder = class _CdkDragPlaceholder {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  /** Context data to be added to the placeholder template instance. */
  data;
  constructor() {
    this._drag?._setPlaceholderTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPlaceholderTemplate(this);
  }
  static ɵfac = function CdkDragPlaceholder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragPlaceholder)();
  };
  static ɵdir = /* @__PURE__ */ɵɵdefineDirective({
    type: _CdkDragPlaceholder,
    selectors: [["ng-template", "cdkDragPlaceholder", ""]],
    inputs: {
      data: "data"
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PLACEHOLDER,
      useExisting: _CdkDragPlaceholder
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPlaceholder]",
      providers: [{
        provide: CDK_DRAG_PLACEHOLDER,
        useExisting: CdkDragPlaceholder
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }]
  });
})();
var DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
var DragDropModule = class _DragDropModule {
  static ɵfac = function DragDropModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDropModule)();
  };
  static ɵmod = /* @__PURE__ */ɵɵdefineNgModule({
    type: _DragDropModule
  });
  static ɵinj = /* @__PURE__ */ɵɵdefineInjector({
    providers: [DragDrop],
    imports: [CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
    type: NgModule,
    args: [{
      imports: DRAG_DROP_DIRECTIVES,
      exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
      providers: [DragDrop]
    }]
  }], null, null);
})();

// libs/exercises/src/lib/pages/selected-expansion-panel/selected-expansion-panel.component.ts
function SelectedExpansionPanelComponent_For_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 38);
  }
}
function SelectedExpansionPanelComponent_For_4_Conditional_26_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "span");
    ɵɵi18n(2, 8);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const selectedExercise_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance(4);
    ɵɵtextInterpolate(selectedExercise_r2.pause);
  }
}
function SelectedExpansionPanelComponent_For_4_Conditional_27_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "span");
    ɵɵi18n(2, 9);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const selectedExercise_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance(4);
    ɵɵtextInterpolate(selectedExercise_r2.weight);
  }
}
function SelectedExpansionPanelComponent_For_4_Conditional_28_For_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1, ", ");
    ɵɵelementEnd();
  }
}
function SelectedExpansionPanelComponent_For_4_Conditional_28_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵtemplate(2, SelectedExpansionPanelComponent_For_4_Conditional_28_For_4_Conditional_2_Template, 2, 0, "span");
  }
  if (rf & 2) {
    const equipment_r3 = ctx.$implicit;
    const ɵ$index_84_r4 = ctx.$index;
    const ɵ$count_84_r5 = ctx.$count;
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(equipment_r3.translations[ctx_r5.selectedLanguage]);
    ɵɵadvance();
    ɵɵconditional(!(ɵ$index_84_r4 === ɵ$count_84_r5 - 1) ? 2 : -1);
  }
}
function SelectedExpansionPanelComponent_For_4_Conditional_28_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "span");
    ɵɵi18n(2, 10);
    ɵɵelementEnd();
    ɵɵrepeaterCreate(3, SelectedExpansionPanelComponent_For_4_Conditional_28_For_4_Template, 3, 2, null, null, ɵɵrepeaterTrackByIdentity);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const selectedExercise_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance(3);
    ɵɵrepeater(selectedExercise_r2.equipments);
  }
}
function SelectedExpansionPanelComponent_For_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-expansion-panel", 14);
    ɵɵtemplate(1, SelectedExpansionPanelComponent_For_4_div_1_Template, 1, 0, "div", 15);
    ɵɵelementStart(2, "mat-expansion-panel-header", 16)(3, "div", 17)(4, "span", 18);
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "span")(7, "mat-icon");
    ɵɵtext(8, "drag_indicator");
    ɵɵelementEnd()()();
    ɵɵelementStart(9, "mat-panel-title")(10, "div", 19);
    ɵɵelement(11, "img", 20);
    ɵɵelementEnd();
    ɵɵelementStart(12, "span", 21);
    ɵɵtext(13);
    ɵɵelementEnd()();
    ɵɵelementStart(14, "mat-panel-description", 22)(15, "div", 23)(16, "div")(17, "span");
    ɵɵi18n(18, 0);
    ɵɵelementEnd();
    ɵɵelementStart(19, "span");
    ɵɵtext(20);
    ɵɵelementEnd()();
    ɵɵelementStart(21, "div")(22, "span");
    ɵɵi18n(23, 1);
    ɵɵelementEnd();
    ɵɵelementStart(24, "span");
    ɵɵtext(25);
    ɵɵelementEnd()();
    ɵɵtemplate(26, SelectedExpansionPanelComponent_For_4_Conditional_26_Template, 5, 1, "div")(27, SelectedExpansionPanelComponent_For_4_Conditional_27_Template, 5, 1, "div")(28, SelectedExpansionPanelComponent_For_4_Conditional_28_Template, 5, 0, "div");
    ɵɵelementEnd();
    ɵɵelementStart(29, "div", 24)(30, "button", 25);
    ɵɵlistener("click", function SelectedExpansionPanelComponent_For_4_Template_button_click_30_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r5 = ɵɵnextContext();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r5.removeFromSelected(selectedExercise_r2));
    });
    ɵɵelementStart(31, "mat-icon");
    ɵɵtext(32, "delete_outline");
    ɵɵelementEnd()();
    ɵɵelementStart(33, "button", 26);
    ɵɵlistener("click", function SelectedExpansionPanelComponent_For_4_Template_button_click_33_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r5 = ɵɵnextContext();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r5.showExerciseModal(selectedExercise_r2.id, selectedExercise_r2, false));
    });
    ɵɵelementStart(34, "mat-icon");
    ɵɵtext(35, "info_outline");
    ɵɵelementEnd()()()()();
    ɵɵelementStart(36, "div", 27)(37, "div", 28)(38, "mat-form-field", 29)(39, "mat-label");
    ɵɵi18n(40, 2);
    ɵɵelementEnd();
    ɵɵelementStart(41, "input", 30);
    ɵɵtwoWayListener("ngModelChange", function SelectedExpansionPanelComponent_For_4_Template_input_ngModelChange_41_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r5 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(selectedExercise_r2.name[ctx_r5.selectedLanguage], $event) || (selectedExercise_r2.name[ctx_r5.selectedLanguage] = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd()();
    ɵɵelementStart(42, "mat-form-field", 31)(43, "mat-label");
    ɵɵi18n(44, 3);
    ɵɵelementEnd();
    ɵɵelementStart(45, "textarea", 32);
    ɵɵtwoWayListener("ngModelChange", function SelectedExpansionPanelComponent_For_4_Template_textarea_ngModelChange_45_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r5 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(selectedExercise_r2.description[ctx_r5.selectedLanguage], $event) || (selectedExercise_r2.description[ctx_r5.selectedLanguage] = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd()()();
    ɵɵelementStart(46, "div", 33)(47, "mat-form-field", 34)(48, "mat-label");
    ɵɵi18n(49, 4);
    ɵɵelementEnd();
    ɵɵelementStart(50, "input", 35);
    ɵɵtwoWayListener("ngModelChange", function SelectedExpansionPanelComponent_For_4_Template_input_ngModelChange_50_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      ɵɵtwoWayBindingSet(selectedExercise_r2.sets, $event) || (selectedExercise_r2.sets = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd()();
    ɵɵelementStart(51, "mat-form-field", 29)(52, "mat-label");
    ɵɵi18n(53, 5);
    ɵɵelementEnd();
    ɵɵelementStart(54, "input", 35);
    ɵɵtwoWayListener("ngModelChange", function SelectedExpansionPanelComponent_For_4_Template_input_ngModelChange_54_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      ɵɵtwoWayBindingSet(selectedExercise_r2.reps, $event) || (selectedExercise_r2.reps = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd()();
    ɵɵelementStart(55, "mat-form-field", 29)(56, "mat-label");
    ɵɵi18n(57, 6);
    ɵɵelementEnd();
    ɵɵelementStart(58, "input", 36);
    ɵɵtwoWayListener("ngModelChange", function SelectedExpansionPanelComponent_For_4_Template_input_ngModelChange_58_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      ɵɵtwoWayBindingSet(selectedExercise_r2.pause, $event) || (selectedExercise_r2.pause = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd()();
    ɵɵelementStart(59, "mat-form-field", 29)(60, "mat-label");
    ɵɵi18n(61, 7);
    ɵɵelementEnd();
    ɵɵelementStart(62, "input", 37);
    ɵɵtwoWayListener("ngModelChange", function SelectedExpansionPanelComponent_For_4_Template_input_ngModelChange_62_listener($event) {
      const selectedExercise_r2 = ɵɵrestoreView(_r1).$implicit;
      ɵɵtwoWayBindingSet(selectedExercise_r2.weight, $event) || (selectedExercise_r2.weight = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd()()()()();
  }
  if (rf & 2) {
    const selectedExercise_r2 = ctx.$implicit;
    const ɵ$index_7_r7 = ctx.$index;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("cdkDragPreviewClass", ctx_r5.previewClass)("hideToggle", false)("expanded", ctx_r5.isExpanded);
    ɵɵadvance(5);
    ɵɵtextInterpolate(ɵ$index_7_r7 + 1);
    ɵɵadvance(6);
    ɵɵproperty("src", selectedExercise_r2.images == null ? null : selectedExercise_r2.images.mainImg, ɵɵsanitizeUrl)("alt", selectedExercise_r2.name[ctx_r5.selectedLanguage]);
    ɵɵadvance(2);
    ɵɵtextInterpolate(selectedExercise_r2.name[ctx_r5.selectedLanguage]);
    ɵɵadvance(7);
    ɵɵtextInterpolate(selectedExercise_r2.sets);
    ɵɵadvance(5);
    ɵɵtextInterpolate(selectedExercise_r2.reps);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r2.pause ? 26 : -1);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r2.weight ? 27 : -1);
    ɵɵadvance();
    ɵɵconditional(selectedExercise_r2.equipments.length !== 0 ? 28 : -1);
    ɵɵadvance(13);
    ɵɵtwoWayProperty("ngModel", selectedExercise_r2.name[ctx_r5.selectedLanguage]);
    ɵɵadvance(4);
    ɵɵtwoWayProperty("ngModel", selectedExercise_r2.description[ctx_r5.selectedLanguage]);
    ɵɵadvance(5);
    ɵɵtwoWayProperty("ngModel", selectedExercise_r2.sets);
    ɵɵadvance(4);
    ɵɵtwoWayProperty("ngModel", selectedExercise_r2.reps);
    ɵɵadvance(4);
    ɵɵtwoWayProperty("ngModel", selectedExercise_r2.pause);
    ɵɵadvance(4);
    ɵɵtwoWayProperty("ngModel", selectedExercise_r2.weight);
  }
}
var SelectedExpansionPanelComponent = class _SelectedExpansionPanelComponent {
  constructor() {
    this.selectedExercisesService = inject(SelectedExercisesService);
    this._snackBar = inject(MatSnackBar);
    this.dialog = inject(MatDialog);
    this.exercisesService = inject(ExercisesService);
    this.localstorageService = inject(LocalstorageService);
    this.previewClass = "expansion-panel-custom-preview";
    this.selectedExercises = this.selectedExercisesService.selectedExercises;
    this.isExpanded = false;
    this.subscriptions = new Subscription();
    this.themeManager = inject(ThemeManagerService);
    this.themeSignal = this.themeManager.themeSignal;
  }
  ngOnInit() {
    this.selectedLanguage = this._getUserLanguageToken();
  }
  togglePanel(index) {
    const panelToToggle = this.panels.toArray()[index];
    if (panelToToggle) {
      panelToToggle.toggle();
    }
  }
  _getExercise(exerciseId) {
    return this.exercisesService.getExercise(exerciseId);
  }
  showExerciseModal(exerciseId, exerciseCard, isProgramExercise) {
    const subscription = this._getExercise(exerciseId).subscribe(exercise => {
      this.dialog.open(ExerciseModalComponent, {
        data: {
          fullExercise: exercise,
          exerciseCard,
          isProgramExercise,
          selectedLang: this.selectedLanguage
        },
        width: "500px",
        // height: '736px',
        panelClass: ["custom-dialog", isProgramExercise ? "custom-shadow" : ""],
        // disableClose: isProgramExercise,
        // hasBackdrop: isProgramExercise ? false : true,
        backdropClass: isProgramExercise ? "custom-backdrop" : ""
        // enterAnimationDuration: 0,
      });
    });
    this.subscriptions.add(subscription);
  }
  drop(event) {
    moveItemInArray(this.selectedExercises(), event.previousIndex, event.currentIndex);
  }
  // Remove and undo with message snackbar
  removeFromSelected(exercise) {
    this.selectedExercisesService.removeFromSelected(exercise);
    this.removedExercise = exercise;
    const snackBarRef = this._snackBar.open("\xDCbung gel\xF6scht", "R\xFCckg\xE4ngig", {
      duration: 4e3,
      panelClass: ["custom-snackbar-style"]
    });
    const subscription = snackBarRef.onAction().subscribe(() => this.undoRemove());
    this.subscriptions.add(subscription);
    console.log(this.selectedExercisesService.selectedExercises());
  }
  undoRemove() {
    if (this.removedExercise) {
      this.selectedExercisesService.addToSelected(this.removedExercise);
      this.removedExercise = null;
    }
  }
  _getUserLanguageToken() {
    return this.localstorageService.getToken("userLanguage")?.split("-")[0];
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static {
    this.ɵfac = function SelectedExpansionPanelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SelectedExpansionPanelComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _SelectedExpansionPanelComponent,
      selectors: [["exercises-selected-expansion-panel"]],
      viewQuery: function SelectedExpansionPanelComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(MatExpansionPanel, 5);
        }
        if (rf & 2) {
          let _t2;
          ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.panels = _t2);
        }
      },
      inputs: {
        exercise: "exercise"
      },
      decls: 5,
      vars: 1,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_EditProgram_removeExerciseTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_0 = goog.getMsg("Delete");
          i18n_0 = MSG_EXTERNAL_EditProgram_removeExerciseTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_0;
        } else {
          i18n_0 = "L\xF6schen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_EditProgram_removeExerciseAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_1 = goog.getMsg("Delete icon-button with a delete icon");
          i18n_1 = MSG_EXTERNAL_EditProgram_removeExerciseAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_1;
        } else {
          i18n_1 = "Symbol \u201EL\xF6schen\u201C \u2013 Schaltfl\xE4che mit einem L\xF6schsymbol";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_EditProgram_detailsTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_2 = goog.getMsg("Details");
          i18n_2 = MSG_EXTERNAL_EditProgram_detailsTooltip$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_2;
        } else {
          i18n_2 = "Einzelheiten";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_EditProgram_detailsAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_3 = goog.getMsg("Info icon-button with a info icon");
          i18n_3 = MSG_EXTERNAL_EditProgram_detailsAriaLabel$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_3;
        } else {
          i18n_3 = "Infosymbol-Schaltfl\xE4che mit einem Infosymbol";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseNamePlaceholder$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_4 = goog.getMsg("Enter exercise name");
          i18n_4 = MSG_EXTERNAL_EditProgram_exerciseNamePlaceholder$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_4;
        } else {
          i18n_4 = "Geben Sie den \xDCbungsnamen ein";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseDescriptionPlaceholder$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_5 = goog.getMsg("Enter exercise description");
          i18n_5 = MSG_EXTERNAL_EditProgram_exerciseDescriptionPlaceholder$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_5;
        } else {
          i18n_5 = "\xDCbungsbeschreibung eingeben";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseSets$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_6 = goog.getMsg("Sets: ");
          i18n_6 = MSG_EXTERNAL_EditProgram_exerciseSets$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_6;
        } else {
          i18n_6 = "S\xE4tze: ";
        }
        let i18n_7;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseReps$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_7 = goog.getMsg("Reps: ");
          i18n_7 = MSG_EXTERNAL_EditProgram_exerciseReps$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_7;
        } else {
          i18n_7 = "Wdhl:\xA0";
        }
        let i18n_8;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseName$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_8 = goog.getMsg("Name");
          i18n_8 = MSG_EXTERNAL_EditProgram_exerciseName$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_8;
        } else {
          i18n_8 = "Name";
        }
        let i18n_9;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseDescription$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_9 = goog.getMsg("Description");
          i18n_9 = MSG_EXTERNAL_EditProgram_exerciseDescription$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_9;
        } else {
          i18n_9 = "Beschreibung";
        }
        let i18n_10;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseSetsNoDots$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_10 = goog.getMsg("Sets");
          i18n_10 = MSG_EXTERNAL_EditProgram_exerciseSetsNoDots$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_10;
        } else {
          i18n_10 = "S\xE4tze";
        }
        let i18n_11;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseRepsNoDots$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_11 = goog.getMsg("Repetitions");
          i18n_11 = MSG_EXTERNAL_EditProgram_exerciseRepsNoDots$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_11;
        } else {
          i18n_11 = "Wiederholungen";
        }
        let i18n_12;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exercisePauseNoDots$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_12 = goog.getMsg("Pause");
          i18n_12 = MSG_EXTERNAL_EditProgram_exercisePauseNoDots$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_12;
        } else {
          i18n_12 = "Pause";
        }
        let i18n_13;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseWeightNoDots$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_13 = goog.getMsg("Weight");
          i18n_13 = MSG_EXTERNAL_EditProgram_exerciseWeightNoDots$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_13;
        } else {
          i18n_13 = "Gewicht";
        }
        let i18n_14;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exercisePause$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_14 = goog.getMsg("Pause: ");
          i18n_14 = MSG_EXTERNAL_EditProgram_exercisePause$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_14;
        } else {
          i18n_14 = "Pause: ";
        }
        let i18n_15;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseWeight$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_15 = goog.getMsg("Weight: ");
          i18n_15 = MSG_EXTERNAL_EditProgram_exerciseWeight$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_15;
        } else {
          i18n_15 = "Gewicht: ";
        }
        let i18n_16;
        if (false) {
          const MSG_EXTERNAL_EditProgram_exerciseEquipment$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_16 = goog.getMsg("Eq: ");
          i18n_16 = MSG_EXTERNAL_EditProgram_exerciseEquipment$$LIBS_EXERCISES_SRC_LIB_PAGES_SELECTED_EXPANSION_PANEL_SELECTED_EXPANSION_PANEL_COMPONENT_TS_16;
        } else {
          i18n_16 = "Ausr: ";
        }
        return [i18n_6, i18n_7, i18n_8, i18n_9, i18n_10, i18n_11, i18n_12, i18n_13, i18n_14, i18n_15, i18n_16, ["overlay-scrollbars", "", 1, "selected-expansion-panel-wrapper", 3, "options", "defer"], ["cdkDropList", "", 1, "edit-program-list", 3, "cdkDropListDropped"], ["multi", ""], ["cdkDrag", "", 1, "exer-expansion-panel", 3, "cdkDragPreviewClass", "hideToggle", "expanded"], ["class", "exercise-card-placeholder expansion-panel-placeholder", 4, "cdkDragPlaceholder"], ["collapsedHeight", "80px", 1, "exer-expansion-panel-header"], ["cdkDragHandle", "", 1, "expansion-panel-handle"], [1, "handle-number"], [1, "img-wrapper", "expanded-panels"], [1, "selected-exercise-img", "expansion-img", 3, "src", "alt"], [1, "title-name", "mat-body-medium"], [1, "panel-description"], [1, "session-overview", "mat-body-medium"], [1, "options-wrapper"], ["mat-icon-button", "", "matTooltip", i18n_0, "aria-label", i18n_1, 3, "click"], ["mat-icon-button", "", "matTooltip", i18n_2, "aria-label", i18n_3, 3, "click"], [1, "panel-content"], [1, "name-description-label"], ["appearance", "outline"], ["matInput", "", "type", "text", "maxlength", "100", "placeholder", i18n_4, 3, "ngModelChange", "ngModel"], ["appearance", "outline", 1, "description-text-area"], ["matInput", "", "cdkTextareaAutosize", "", "placeholder", i18n_5, 3, "ngModelChange", "ngModel"], [1, "exercise-session"], ["appearance", "outline", 1, "panel-input"], ["matInput", "", "type", "number", "min", "0", "placeholder", "10", "value", "10", 3, "ngModelChange", "ngModel"], ["matInput", "", "type", "text", "placeholder", "30s", 3, "ngModelChange", "ngModel"], ["matInput", "", "type", "text", "placeholder", "2kg", 3, "ngModelChange", "ngModel"], [1, "exercise-card-placeholder", "expansion-panel-placeholder"]];
      },
      template: function SelectedExpansionPanelComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "div", 11)(1, "div", 12);
          ɵɵlistener("cdkDropListDropped", function SelectedExpansionPanelComponent_Template_div_cdkDropListDropped_1_listener($event) {
            return ctx.drop($event);
          });
          ɵɵelementStart(2, "mat-accordion", 13);
          ɵɵrepeaterCreate(3, SelectedExpansionPanelComponent_For_4_Template, 63, 18, "mat-expansion-panel", 14, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()()();
        }
        if (rf & 2) {
          ɵɵproperty("options", ctx.themeSignal());
          ɵɵadvance(3);
          ɵɵrepeater(ctx.selectedExercises());
        }
      },
      dependencies: [OverlayscrollbarsModule, OverlayScrollbarsComponent, CdkDropList, MatAccordion, MatExpansionPanel, CdkDrag, CdkDragPlaceholder, MatExpansionPanelHeader, CdkDragHandle, MatIcon, MatExpansionPanelTitle, MatExpansionPanelDescription, MatIconButton, MatTooltip, MatFormField, MatLabel, MatInput, FormsModule, DefaultValueAccessor, NumberValueAccessor, NgControlStatus, MaxLengthValidator, MinValidator, NgModel, CdkTextareaAutosize],
      styles: [".selected-expansion-panel-wrapper[_ngcontent-%COMP%]{height:calc(100vh - 320px);overflow-y:scroll;width:100%}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]{padding:2px}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]{padding:0;pointer-events:auto;cursor:auto}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]:hover   .expansion-panel-handle[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{visibility:visible}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]{padding-left:46px}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   mat-panel-title[_ngcontent-%COMP%]{width:120px;overflow:hidden;margin-right:32px;margin-left:16px}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .panel-description[_ngcontent-%COMP%]{padding-right:8px}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .panel-description[_ngcontent-%COMP%]   .session-overview[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;gap:0px;flex:1}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .panel-description[_ngcontent-%COMP%]   .session-overview[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{flex:1 0 45%;box-sizing:border-box}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .panel-description[_ngcontent-%COMP%]   .options-wrapper[_ngcontent-%COMP%]{align-self:center;padding-top:4px}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]{display:flex;gap:16px;padding-top:16px;padding-left:30px;justify-content:space-evenly}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]   .name-description-label[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:16px;flex:3}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]   .name-description-label[_ngcontent-%COMP%]   .mat-mdc-form-field-subscript-wrapper[_ngcontent-%COMP%]{height:0}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]   .exercise-session[_ngcontent-%COMP%]{flex:1;display:flex;flex-direction:column;gap:16px}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]   .exercise-session[_ngcontent-%COMP%]   .panel-input[_ngcontent-%COMP%]   .mat-mdc-form-field-subscript-wrapper[_ngcontent-%COMP%]{height:0}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .expansion-panel-handle[_ngcontent-%COMP%]{position:absolute;top:28px;left:0;cursor:move;width:28px;height:28px;padding:5px;margin-left:8px;display:flex;align-items:center}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .expansion-panel-handle[_ngcontent-%COMP%]   .handle-number[_ngcontent-%COMP%]{margin-right:10px;margin-top:-5px}.selected-expansion-panel-wrapper[_ngcontent-%COMP%]   .edit-program-list[_ngcontent-%COMP%]   .exer-expansion-panel[_ngcontent-%COMP%]   .expansion-panel-handle[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{visibility:hidden}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .expansion-img[_ngcontent-%COMP%]{margin-left:8px;width:64px;height:64px}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .expansion-panel-handle[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{visibility:visible}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]{padding-left:46px}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .title-name[_ngcontent-%COMP%]{margin-left:-8px}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   mat-panel-title[_ngcontent-%COMP%]{width:120px;overflow:hidden;margin-right:32px;margin-left:16px}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .panel-description[_ngcontent-%COMP%]{padding-right:8px}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .panel-description[_ngcontent-%COMP%]   .session-overview[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;gap:0px;flex:1}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .panel-description[_ngcontent-%COMP%]   .session-overview[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{flex:1 0 45%;box-sizing:border-box}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .exer-expansion-panel-header[_ngcontent-%COMP%]   .panel-description[_ngcontent-%COMP%]   .options-wrapper[_ngcontent-%COMP%]{align-self:center;padding-top:4px}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]{display:flex;gap:16px;padding-top:16px;padding-left:30px;justify-content:space-evenly}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]   .name-description-label[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:16px;flex:3}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]   .name-description-label[_ngcontent-%COMP%]   .mat-mdc-form-field-subscript-wrapper[_ngcontent-%COMP%]{height:0}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]   .exercise-session[_ngcontent-%COMP%]{flex:1;display:flex;flex-direction:column;gap:16px}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .panel-content[_ngcontent-%COMP%]   .exercise-session[_ngcontent-%COMP%]   .panel-input[_ngcontent-%COMP%]   .mat-mdc-form-field-subscript-wrapper[_ngcontent-%COMP%]{height:0}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .expansion-panel-handle[_ngcontent-%COMP%]{position:absolute;top:28px;left:0;cursor:move;width:28px;height:28px;padding:5px;margin-left:8px;display:flex;align-items:center}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .expansion-panel-handle[_ngcontent-%COMP%]   .handle-number[_ngcontent-%COMP%]{margin-right:10px;margin-top:-5px}.expansion-panel-custom-preview[_ngcontent-%COMP%]   .expansion-panel-handle[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{visibility:hidden}\n/*# sourceMappingURL=selected-expansion-panel.component-35NZ7B7D.css.map */"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(SelectedExpansionPanelComponent, {
    className: "SelectedExpansionPanelComponent",
    filePath: "libs/exercises/src/lib/pages/selected-expansion-panel/selected-expansion-panel.component.ts",
    lineNumber: 70
  });
})();

// libs/exercises/src/lib/pages/full-exercise/full-exercise.component.ts
var FullExerciseComponent_Defer_4_DepsFn = () => [import("./chunk-KHCTXGYH.js").then(m2 => m2.VideoPlayerComponent)];
function FullExerciseComponent_Defer_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵelement(1, "ui-video-player", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("videoSrc", ctx_r0.exercise.video)("thumbnail", ctx_r0.exercise.images == null ? null : ctx_r0.exercise.images.mainImg)("isModal", true);
  }
}
function FullExerciseComponent_DeferPlaceholder_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵelement(1, "div", 22);
    ɵɵelementEnd();
  }
}
function FullExerciseComponent_For_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const muscle_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(muscle_r2);
  }
}
function FullExerciseComponent_For_30_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const bodyArea_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(bodyArea_r3.translations == null ? null : bodyArea_r3.translations[ctx_r0.selectedLanguage]);
  }
}
function FullExerciseComponent_For_36_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const movement_r4 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(movement_r4.translations == null ? null : movement_r4.translations[ctx_r0.selectedLanguage]);
  }
}
function FullExerciseComponent_For_42_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const startingPosition_r5 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(startingPosition_r5.translations == null ? null : startingPosition_r5.translations[ctx_r0.selectedLanguage]);
  }
}
function FullExerciseComponent_For_48_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-chip", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const equipment_r6 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(equipment_r6.translations[ctx_r0.selectedLanguage]);
  }
}
var FullExerciseComponent = class _FullExerciseComponent {
  constructor() {
    this.location = inject(Location);
    this.exercisesService = inject(ExercisesService);
    this.localstorageService = inject(LocalstorageService);
    this.themeManager = inject(ThemeManagerService);
    this.programsService = inject(ProgramsService);
    this.dialog = inject(MatDialog);
    this.exerciseId = input("");
    this.themeSignal = this.themeManager.themeSignal;
    this.dataSourceAllPrograms = new MatTableDataSource();
    this.subscriptions = new Subscription();
  }
  ngOnInit() {
    this.selectedLanguage = this._getUserLanguageToken();
    this.exercisesService.getExercise(this.exerciseId()).subscribe(exercise => {
      this.exercise = exercise;
      this.dataSourceAllPrograms.data = exercise.programs;
    });
  }
  _getUserLanguageToken() {
    return this.localstorageService.getToken("userLanguage")?.split("-")[0];
  }
  viewProgramModal(programId) {
    const subscription = this.programsService.getProgram(programId).subscribe(program => {
      const dialogRef = this.dialog.open(ProgramModalComponent, {
        width: "500px",
        // height: '736px',
        data: {
          title: "Programminfo",
          program,
          selectedLang: this.selectedLanguage,
          isClient: false
        },
        // disableClose: true, // Disable closing when clicked outside
        panelClass: "custom-dialog"
        // enterAnimationDuration: 0,
      });
      const subscription2 = dialogRef.afterClosed().subscribe(result => {
        console.log("Program modal exited");
      });
      this.subscriptions.add(subscription2);
    });
    this.subscriptions.add(subscription);
  }
  onBack() {
    this.location.back();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static {
    this.ɵfac = function FullExerciseComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _FullExerciseComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _FullExerciseComponent,
      selectors: [["full-exercise"]],
      inputs: {
        exerciseId: [1, "exerciseId"]
      },
      decls: 51,
      vars: 7,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_exerciseName$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_0 = goog.getMsg("Exercise name: ");
          i18n_0 = MSG_EXTERNAL_ExerciseModal_exerciseName$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_0;
        } else {
          i18n_0 = "\xDCbungsname: ";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_exerciseDescription$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_1 = goog.getMsg("Description: ");
          i18n_1 = MSG_EXTERNAL_ExerciseModal_exerciseDescription$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_1;
        } else {
          i18n_1 = "Beschreibung: ";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_muscles$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_2 = goog.getMsg("Muscles: ");
          i18n_2 = MSG_EXTERNAL_ExerciseModal_muscles$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_2;
        } else {
          i18n_2 = "Muskeln:";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_bodyAreas$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_3 = goog.getMsg("Body areas: ");
          i18n_3 = MSG_EXTERNAL_ExerciseModal_bodyAreas$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_3;
        } else {
          i18n_3 = "K\xF6rperbereiche:";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_movements$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_4 = goog.getMsg("Movements: ");
          i18n_4 = MSG_EXTERNAL_ExerciseModal_movements$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_4;
        } else {
          i18n_4 = "Bewegungen:";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_startingPositions$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_5 = goog.getMsg("Starting positions: ");
          i18n_5 = MSG_EXTERNAL_ExerciseModal_startingPositions$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_5;
        } else {
          i18n_5 = "Startpositionen:";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_ExerciseModal_equipment$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_6 = goog.getMsg("Equipment: ");
          i18n_6 = MSG_EXTERNAL_ExerciseModal_equipment$$LIBS_EXERCISES_SRC_LIB_PAGES_FULL_EXERCISE_FULL_EXERCISE_COMPONENT_TS_6;
        } else {
          i18n_6 = "Ausr\xFCstung: ";
        }
        return [i18n_0, i18n_1, i18n_2, i18n_3, i18n_4, i18n_5, i18n_6, [500], [3, "cancelEvent", "pageType", "editMode"], [1, "content-container"], ["overlay-scrollbars", "", 1, "exercise-info-wrapper", 3, "options", "defer"], [1, "info-flex-container"], [1, "dialog-content-wrapper"], [1, "category-labels"], [1, "label"], [1, "category-value"], [1, "chips-category"], [1, "programs-wrapper"], [1, "ui-programs-table", 3, "viewProgramEvent", "dataSource", "isClient"], [1, "exercise-video-wrapper"], [3, "videoSrc", "thumbnail", "isModal"], [1, "video-skeleton-wrapper"], [1, "video-skeleton"]];
      },
      template: function FullExerciseComponent_Template(rf, ctx) {
        if (rf & 1) {
          ɵɵelementStart(0, "ui-page-toolbar", 8);
          ɵɵlistener("cancelEvent", function FullExerciseComponent_Template_ui_page_toolbar_cancelEvent_0_listener() {
            return ctx.onBack();
          });
          ɵɵelementEnd();
          ɵɵelementStart(1, "div", 9);
          ɵɵtemplate(2, FullExerciseComponent_Defer_2_Template, 2, 3)(3, FullExerciseComponent_DeferPlaceholder_3_Template, 2, 0);
          ɵɵdefer(4, 2, FullExerciseComponent_Defer_4_DepsFn, null, 3, null, null, 7, ɵɵdeferEnableTimerScheduling);
          ɵɵdeferOnIdle();
          ɵɵelementStart(6, "div", 10)(7, "div", 11)(8, "div", 12)(9, "div", 13)(10, "span", 14);
          ɵɵi18n(11, 0);
          ɵɵelementEnd();
          ɵɵelementStart(12, "span", 15);
          ɵɵtext(13);
          ɵɵelementEnd()();
          ɵɵelementStart(14, "div", 13)(15, "span", 14);
          ɵɵi18n(16, 1);
          ɵɵelementEnd();
          ɵɵelementStart(17, "span", 15);
          ɵɵtext(18);
          ɵɵelementEnd()();
          ɵɵelementStart(19, "div", 13)(20, "span", 14);
          ɵɵi18n(21, 2);
          ɵɵelementEnd();
          ɵɵelementStart(22, "mat-chip-set");
          ɵɵrepeaterCreate(23, FullExerciseComponent_For_24_Template, 2, 1, "mat-chip", 16, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵelementStart(25, "div", 13)(26, "span", 14);
          ɵɵi18n(27, 3);
          ɵɵelementEnd();
          ɵɵelementStart(28, "mat-chip-set");
          ɵɵrepeaterCreate(29, FullExerciseComponent_For_30_Template, 2, 1, "mat-chip", 16, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵelementStart(31, "div", 13)(32, "span", 14);
          ɵɵi18n(33, 4);
          ɵɵelementEnd();
          ɵɵelementStart(34, "mat-chip-set");
          ɵɵrepeaterCreate(35, FullExerciseComponent_For_36_Template, 2, 1, "mat-chip", 16, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵelementStart(37, "div", 13)(38, "span", 14);
          ɵɵi18n(39, 5);
          ɵɵelementEnd();
          ɵɵelementStart(40, "mat-chip-set");
          ɵɵrepeaterCreate(41, FullExerciseComponent_For_42_Template, 2, 1, "mat-chip", 16, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()();
          ɵɵelementStart(43, "div", 13)(44, "span", 14);
          ɵɵi18n(45, 6);
          ɵɵelementEnd();
          ɵɵelementStart(46, "mat-chip-set");
          ɵɵrepeaterCreate(47, FullExerciseComponent_For_48_Template, 2, 1, "mat-chip", 16, ɵɵrepeaterTrackByIdentity);
          ɵɵelementEnd()()();
          ɵɵelementStart(49, "div", 17)(50, "ui-basic-programs-table", 18);
          ɵɵlistener("viewProgramEvent", function FullExerciseComponent_Template_ui_basic_programs_table_viewProgramEvent_50_listener($event) {
            return ctx.viewProgramModal($event);
          });
          ɵɵelementEnd()()()()();
        }
        if (rf & 2) {
          ɵɵproperty("pageType", "exercise")("editMode", true);
          ɵɵadvance(6);
          ɵɵproperty("options", ctx.themeSignal());
          ɵɵadvance(7);
          ɵɵtextInterpolate(ctx.exercise.name[ctx.selectedLanguage]);
          ɵɵadvance(5);
          ɵɵtextInterpolate(ctx.exercise.description[ctx.selectedLanguage]);
          ɵɵadvance(5);
          ɵɵrepeater(ctx.exercise.muscles);
          ɵɵadvance(6);
          ɵɵrepeater(ctx.exercise.bodyAreas);
          ɵɵadvance(6);
          ɵɵrepeater(ctx.exercise.movements);
          ɵɵadvance(6);
          ɵɵrepeater(ctx.exercise.startingPositions);
          ɵɵadvance(6);
          ɵɵrepeater(ctx.exercise.equipments);
          ɵɵadvance(3);
          ɵɵproperty("dataSource", ctx.dataSourceAllPrograms)("isClient", false);
        }
      },
      dependencies: [CommonModule, PageToolbarComponent, MatChipsModule, MatChip, MatChipSet, OverlayscrollbarsModule, OverlayScrollbarsComponent, BasicProgramsTableComponent],
      styles: ['.content-container[_ngcontent-%COMP%]{height:100%;display:flex;flex-direction:row;gap:16px}.content-container[_ngcontent-%COMP%]   .exercise-video-wrapper[_ngcontent-%COMP%]{flex:1 1 0;height:100%;border-radius:16px}.content-container[_ngcontent-%COMP%]   .video-skeleton-wrapper[_ngcontent-%COMP%]{flex:1 1 0}.content-container[_ngcontent-%COMP%]   .video-skeleton-wrapper[_ngcontent-%COMP%]   .video-skeleton[_ngcontent-%COMP%]{position:relative;aspect-ratio:1/1;border-radius:16px;overflow:hidden}.content-container[_ngcontent-%COMP%]   .video-skeleton-wrapper[_ngcontent-%COMP%]   .video-skeleton[_ngcontent-%COMP%]:after{position:absolute;inset:0;transform:translate(-100%);animation:_ngcontent-%COMP%_shimmer 1s infinite;content:""}@keyframes _ngcontent-%COMP%_shimmer{to{transform:translate(100%)}}.content-container[_ngcontent-%COMP%]   .exercise-info-wrapper[_ngcontent-%COMP%]{flex:2 1 0;height:calc(100vh - 166px);overflow:hidden;min-width:0}.content-container[_ngcontent-%COMP%]   .exercise-info-wrapper[_ngcontent-%COMP%]   .info-flex-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:16px}.content-container[_ngcontent-%COMP%]   .exercise-info-wrapper[_ngcontent-%COMP%]   .info-flex-container[_ngcontent-%COMP%]   .dialog-content-wrapper[_ngcontent-%COMP%], .content-container[_ngcontent-%COMP%]   .exercise-info-wrapper[_ngcontent-%COMP%]   .info-flex-container[_ngcontent-%COMP%]   .programs-wrapper[_ngcontent-%COMP%]{border-radius:16px;padding:16px}\n/*# sourceMappingURL=full-exercise.component-2SGJKLUE.css.map */'],
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(FullExerciseComponent, {
    className: "FullExerciseComponent",
    filePath: "libs/exercises/src/lib/pages/full-exercise/full-exercise.component.ts",
    lineNumber: 46
  });
})();

// libs/ui/src/lib/components/basic-programs-table/basic-programs-table.component.ts
var _c022 = () => [5, 10, 25, 100];
function BasicProgramsTableComponent_th_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 24);
    ɵɵi18n(1, 3);
    ɵɵelementEnd();
  }
}
function BasicProgramsTableComponent_td_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 25)(1, "span", 26);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const row_r2 = ctx.$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(row_r2.name);
  }
}
function BasicProgramsTableComponent_th_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 27);
  }
}
function BasicProgramsTableComponent_td_19_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 31);
    ɵɵlistener("click", function BasicProgramsTableComponent_td_19_Conditional_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const row_r4 = ɵɵnextContext().$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.addProgramToClient(row_r4.id));
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "add");
    ɵɵelementEnd()();
  }
}
function BasicProgramsTableComponent_td_19_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 25)(1, "div", 28)(2, "button", 29);
    ɵɵlistener("click", function BasicProgramsTableComponent_td_19_Template_button_click_2_listener() {
      const row_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.viewProgramModal(row_r4.id));
    });
    ɵɵelementStart(3, "mat-icon");
    ɵɵtext(4, "visibility");
    ɵɵelementEnd()();
    ɵɵtemplate(5, BasicProgramsTableComponent_td_19_Conditional_5_Template, 3, 0, "button", 30);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance(5);
    ɵɵconditional(ctx_r4.isClient() ? 5 : -1);
  }
}
function BasicProgramsTableComponent_tr_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 32);
  }
}
function BasicProgramsTableComponent_tr_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 33);
  }
}
function BasicProgramsTableComponent_tr_22_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 34)(1, "td", 35);
    ɵɵi18n(2, 4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const input_r7 = ɵɵreference(10);
    ɵɵadvance(2);
    ɵɵi18nExp(input_r7.value);
    ɵɵi18nApply(2);
  }
}
var BasicProgramsTableComponent = class _BasicProgramsTableComponent {
  constructor() {
    this.shareStateService = inject(ShareStateService);
    this.displayedColumns = ["name", "options"];
    this.dataSource = new MatTableDataSource();
    this.isClient = input();
    this.getProgramsEvent = output();
    this.viewProgramEvent = output();
    this.addProgramToClientEvent = output();
    this.themeManager = inject(ThemeManagerService);
    this.themeSignal = this.themeManager.themeSignal;
  }
  getPrograms(listOption) {
    console.log(this.dataSource.data);
    this.getProgramsEvent.emit(listOption);
    console.log(this.dataSource.data);
  }
  viewProgramModal(programId) {
    this.viewProgramEvent.emit(programId);
  }
  addProgramToClient(programId) {
    this.addProgramToClientEvent.emit(programId);
  }
  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }
  static {
    this.ɵfac = function BasicProgramsTableComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BasicProgramsTableComponent)();
    };
  }
  static {
    this.ɵcmp = /* @__PURE__ */ɵɵdefineComponent({
      type: _BasicProgramsTableComponent,
      selectors: [["ui-basic-programs-table"]],
      viewQuery: function BasicProgramsTableComponent_Query(rf, ctx) {
        if (rf & 1) {
          ɵɵviewQuery(MatSort, 5);
          ɵɵviewQuery(MatPaginator, 5);
        }
        if (rf & 2) {
          let _t2;
          ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.sort = _t2.first);
          ɵɵqueryRefresh(_t2 = ɵɵloadQuery()) && (ctx.paginator = _t2.first);
        }
      },
      inputs: {
        dataSource: "dataSource",
        isClient: [1, "isClient"]
      },
      outputs: {
        getProgramsEvent: "getProgramsEvent",
        viewProgramEvent: "viewProgramEvent",
        addProgramToClientEvent: "addProgramToClientEvent"
      },
      features: [ɵɵProvidersFeature([{
        provide: MatPaginatorIntl,
        useClass: PaginatorI18nService
      }])],
      decls: 24,
      vars: 6,
      consts: () => {
        let i18n_0;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_searchInputPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_0 = goog.getMsg("Ex. Seated back stretch");
          i18n_0 = MSG_EXTERNAL_ClientFormBasicProgramsTable_searchInputPlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_0;
        } else {
          i18n_0 = "z.B. R\xFCckendehnung im Sitzen";
        }
        let i18n_1;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_selectPageOfProgramsAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_1 = goog.getMsg("Select page of programs");
          i18n_1 = MSG_EXTERNAL_ClientFormBasicProgramsTable_selectPageOfProgramsAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_1;
        } else {
          i18n_1 = "Seite mit Programmen ausw\xE4hlen";
        }
        let i18n_2;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_titlePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_2 = goog.getMsg(" List of program templates ");
          i18n_2 = MSG_EXTERNAL_ClientFormBasicProgramsTable_titlePlaceholder$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_2;
        } else {
          i18n_2 = "Liste der Programmvorlagen";
        }
        let i18n_3;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_searchInputLabel$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_3 = goog.getMsg("Search");
          i18n_3 = MSG_EXTERNAL_ClientFormBasicProgramsTable_searchInputLabel$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_3;
        } else {
          i18n_3 = "Suchen";
        }
        let i18n_4;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_tableColumnName$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_4 = goog.getMsg(" Name ");
          i18n_4 = MSG_EXTERNAL_ClientFormBasicProgramsTable_tableColumnName$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_4;
        } else {
          i18n_4 = " Name ";
        }
        let i18n_5;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_viewButtonTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_5 = goog.getMsg("View");
          i18n_5 = MSG_EXTERNAL_ClientFormBasicProgramsTable_viewButtonTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_5;
        } else {
          i18n_5 = "Sicht";
        }
        let i18n_6;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_viewButtonAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_6 = goog.getMsg("View icon button");
          i18n_6 = MSG_EXTERNAL_ClientFormBasicProgramsTable_viewButtonAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_6;
        } else {
          i18n_6 = "Schaltfl\xE4che \u201ESymbol anzeigen\u201C";
        }
        let i18n_7;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_addToClientButtonTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_7 = goog.getMsg("Add to client");
          i18n_7 = MSG_EXTERNAL_ClientFormBasicProgramsTable_addToClientButtonTooltip$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_7;
        } else {
          i18n_7 = "Zum Patienten hinzuf\xFCgen";
        }
        let i18n_8;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_addToClientButtonAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_8 = goog.getMsg("Add icon button");
          i18n_8 = MSG_EXTERNAL_ClientFormBasicProgramsTable_addToClientButtonAriaLabel$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_8;
        } else {
          i18n_8 = "Schaltfl\xE4che \u201ESymbol hinzuf\xFCgen\u201C";
        }
        let i18n_9;
        if (false) {
          const MSG_EXTERNAL_ClientFormBasicProgramsTable_noDataMatching$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_9 = goog.getMsg(' No data matching the filter "{$interpolation}" ', {
            "interpolation": "\uFFFD0\uFFFD"
          }, {
            original_code: {
              "interpolation": "{{ input.value }}"
            }
          });
          i18n_9 = MSG_EXTERNAL_ClientFormBasicProgramsTable_noDataMatching$$LIBS_UI_SRC_LIB_COMPONENTS_BASIC_PROGRAMS_TABLE_BASIC_PROGRAMS_TABLE_COMPONENT_TS_9;
        } else {
          i18n_9 = "Keine Daten, die dem Filter \"" + "\uFFFD0\uFFFD" + "\" entsprechen";
        }
        return [["input", ""], i18n_2, i18n_3, i18n_4, i18n_9, [1, "table-wrapper", "basic-table-wrapper"], [1, "programs-filter-container", "all-programs-input-wrapp"], [1, "all-program-list-title"], [1, "mat-title-large"], ["vertical", "", 2, "display", "inline-block", "height", "24px"], ["appearance", "outline", 1, "basic-program-filter"], ["matInput", "", "placeholder", i18n_0, 3, "keyup"], [1, "programs-table"], ["overlay-scrollbars", "", 1, "table-scroll-container", 3, "options", "defer"], ["mat-table", "", "matSort", "", 1, "mat-basic-program-table", 3, "dataSource"], ["matColumnDef", "name"], ["mat-header-cell", "", "mat-sort-header", "", 4, "matHeaderCellDef"], ["mat-cell", "", 4, "matCellDef"], ["matColumnDef", "options"], ["mat-header-cell", "", 4, "matHeaderCellDef"], ["mat-header-row", "", 4, "matHeaderRowDef"], ["mat-row", "", "class", "table-rows truncate", 4, "matRowDef", "matRowDefColumns"], ["class", "mat-row", 4, "matNoDataRow"], ["pageSize", "10", "aria-label", i18n_1, 1, "mat-basic-program-paginator", 3, "pageSizeOptions"], ["mat-header-cell", "", "mat-sort-header", ""], ["mat-cell", ""], [1, "name-cell-width"], ["mat-header-cell", ""], [1, "program-options"], ["mat-icon-button", "", "matTooltip", i18n_5, "aria-label", i18n_6, 3, "click"], ["mat-icon-button", "", "matTooltip", i18n_7, "aria-label", i18n_8], ["mat-icon-button", "", "matTooltip", i18n_7, "aria-label", i18n_8, 3, "click"], ["mat-header-row", ""], ["mat-row", "", 1, "table-rows", "truncate"], [1, "mat-row"], ["colspan", "4", 1, "mat-cell"]];
      },
      template: function BasicProgramsTableComponent_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = ɵɵgetCurrentView();
          ɵɵelementStart(0, "div", 5)(1, "div", 6)(2, "div", 7)(3, "h3", 8);
          ɵɵi18n(4, 1);
          ɵɵelementEnd()();
          ɵɵelement(5, "mat-divider", 9);
          ɵɵelementStart(6, "mat-form-field", 10)(7, "mat-label");
          ɵɵi18n(8, 2);
          ɵɵelementEnd();
          ɵɵelementStart(9, "input", 11, 0);
          ɵɵlistener("keyup", function BasicProgramsTableComponent_Template_input_keyup_9_listener($event) {
            ɵɵrestoreView(_r1);
            return ɵɵresetView(ctx.applyFilter($event));
          });
          ɵɵelementEnd()()();
          ɵɵelementStart(11, "div", 12)(12, "div", 13)(13, "table", 14);
          ɵɵelementContainerStart(14, 15);
          ɵɵtemplate(15, BasicProgramsTableComponent_th_15_Template, 2, 0, "th", 16)(16, BasicProgramsTableComponent_td_16_Template, 3, 1, "td", 17);
          ɵɵelementContainerEnd();
          ɵɵelementContainerStart(17, 18);
          ɵɵtemplate(18, BasicProgramsTableComponent_th_18_Template, 1, 0, "th", 19)(19, BasicProgramsTableComponent_td_19_Template, 6, 1, "td", 17);
          ɵɵelementContainerEnd();
          ɵɵtemplate(20, BasicProgramsTableComponent_tr_20_Template, 1, 0, "tr", 20)(21, BasicProgramsTableComponent_tr_21_Template, 1, 0, "tr", 21)(22, BasicProgramsTableComponent_tr_22_Template, 3, 1, "tr", 22);
          ɵɵelementEnd()();
          ɵɵelement(23, "mat-paginator", 23);
          ɵɵelementEnd()();
        }
        if (rf & 2) {
          ɵɵadvance(12);
          ɵɵproperty("options", ctx.themeSignal());
          ɵɵadvance();
          ɵɵproperty("dataSource", ctx.dataSource);
          ɵɵadvance(7);
          ɵɵproperty("matHeaderRowDef", ctx.displayedColumns);
          ɵɵadvance();
          ɵɵproperty("matRowDefColumns", ctx.displayedColumns);
          ɵɵadvance(2);
          ɵɵproperty("pageSizeOptions", ɵɵpureFunction0(5, _c022));
        }
      },
      dependencies: [MatDivider, MatFormField, MatLabel, MatInput, OverlayscrollbarsModule, OverlayScrollbarsComponent, MatTable, MatSort, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatSortHeader, MatCellDef, MatCell, MatIconButton, MatTooltip, MatIcon, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatNoDataRow, MatPaginatorModule, MatPaginator],
      styles: ['.basic-table-wrapper[_ngcontent-%COMP%]{height:calc(100vh - 222px);overflow:hidden;border-radius:16px;padding:16px}.basic-table-wrapper[_ngcontent-%COMP%]   .all-programs-input-wrapp[_ngcontent-%COMP%]{gap:16px;align-items:center;margin-bottom:16px}.basic-table-wrapper[_ngcontent-%COMP%]   .all-programs-input-wrapp[_ngcontent-%COMP%]   .all-program-list-title[_ngcontent-%COMP%]{margin:0}.basic-table-wrapper[_ngcontent-%COMP%]   .all-programs-input-wrapp[_ngcontent-%COMP%]   .all-program-list-title[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{margin:0;white-space:nowrap}[_nghost-%COMP%]     .mat-mdc-form-field-subscript-wrapper, .mat-mdc-form-field-bottom-align[_ngcontent-%COMP%]{display:none}.programs-table[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:space-between;height:calc(100vh - 316px);overflow-y:hidden;margin-top:-4px}.programs-table[_ngcontent-%COMP%]   .table-scroll-container[_ngcontent-%COMP%]{height:calc(100vh - 390px);overflow-y:scroll}.programs-table[_ngcontent-%COMP%]   .table-scroll-container[_ngcontent-%COMP%]   .mat-basic-program-table[_ngcontent-%COMP%]   .table-rows[_ngcontent-%COMP%]{height:48px}.mat-column-name[_ngcontent-%COMP%]{width:240px}.mat-column-options[_ngcontent-%COMP%]{width:128px;padding-left:0}.programs-table-skeleton[_ngcontent-%COMP%]{width:100%;height:440px;overflow:hidden}.programs-table-skeleton[_ngcontent-%COMP%]   .row-skeleton[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:center;gap:14px;height:48px;border-bottom-width:1px;border-bottom-style:solid}.programs-table-skeleton[_ngcontent-%COMP%]   .row-skeleton[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{border-radius:16px;min-width:193px;height:30px;overflow:hidden;position:relative;width:100%}.programs-table-skeleton[_ngcontent-%COMP%]   .row-skeleton[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:after{position:absolute;inset:0;transform:translate(-100%);animation:_ngcontent-%COMP%_shimmer 1s infinite;content:""}@keyframes _ngcontent-%COMP%_shimmer{to{transform:translate(100%)}}.programs-table-skeleton[_ngcontent-%COMP%]   .row-skeleton[_ngcontent-%COMP%]:last-of-type{border-bottom:0}\n/*# sourceMappingURL=basic-programs-table.component-Z7QY3FMC.css.map */']
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(BasicProgramsTableComponent, {
    className: "BasicProgramsTableComponent",
    filePath: "libs/ui/src/lib/components/basic-programs-table/basic-programs-table.component.ts",
    lineNumber: 72
  });
})();
export { ExercisesService, ShareDataService, ShareStateService, SelectedExercisesService, ProgramDataService, ProgramClientsDataService, ProgramsService, IsClientValidService, ClientsService, ShareClientsDataService, DropListTransferItemService, MatDialogRef, MAT_DIALOG_DATA, MatDialog, MatDialogTitle, MatDialogActions, ThemeManagerService, PaginatorI18nService, ActivePageService, toSignal, ScreenSizeService, PageToolbarComponent, MatOption, MatSelect, MatSelectModule, MatPaginatorIntl, MatPaginator, MatPaginatorModule, MatSort, MatSortHeader, MatSortModule, MatTable, MatCellDef, MatHeaderCellDef, MatColumnDef, MatHeaderCell, MatCell, MatHeaderRowDef, MatRowDef, MatHeaderRow, MatRow, MatNoDataRow, MatTableModule, MatTableDataSource, OverlayScrollbarsComponent, OverlayscrollbarsModule, BasicProgramsTableComponent, _MatInternalFormField, DateAdapter, MAT_DATE_FORMATS, provideNativeDateAdapter, MatProgressSpinner, MatProgressSpinnerModule, ClientFullEditFormComponent, DeleteConfirmationDialogComponent, ClientFullEditProgramsComponent, ProgramsTableComponent, FilterSelectClientsComponent, SearchFilterComponent, ExerciseSearchBtnsWrapperComponent, MatMenuItem, MatMenu, MatMenuTrigger, MatMenuModule, ToolbarButtonsComponent, FavoriteProgramsComponent, FavoriteExercisesComponent, ExerciseModalComponent, moveItemInArray, copyArrayItem, CdkDrag, CdkDropListGroup, CdkDropList, CdkDragPlaceholder, SelectedExpansionPanelComponent, FullExerciseComponent };
/**i18n:e33dda9241aa0d3f81605574177eca303a560132442e585b3107f4f1b4a47a86*/
//# sourceMappingURL=chunk-AZCPHFRJ.js.map