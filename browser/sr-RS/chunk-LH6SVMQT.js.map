{"version":3,"mappings":"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","names":["TOKEN","LocalstorageService","constructor","token","setToken","data","localStorage","setItem","getToken","getItem","removeToken","removeItem","fac","i","prov","_","factory","providedIn","PRIMARY_OUTLET","RouteTitleKey","Symbol","ParamsAsMap","params","has","name","Object","prototype","hasOwnProperty","call","get","v","Array","isArray","getAll","keys","convertToParamMap","defaultUrlMatcher","segments","segmentGroup","route","parts","path","split","length","pathMatch","hasChildren","posParams","index","part","segment","substring","consumed","slice","shallowEqualArrays","a","b","shallowEqual","k1","getDataKeys","undefined","k2","key","equalArraysOrString","obj","getOwnPropertySymbols","aSorted","sort","bSorted","every","val","last","wrapIntoObservable","value","isObservable","_isPromise","from","Promise","resolve","of","pathCompareMap","exact","equalSegmentGroups","subset","containsSegmentGroup","paramCompareMap","equalParams","containsParams","ignored","containsTree","container","containee","options","paths","root","matrixParams","queryParams","fragment","equalPath","matrixParamsMatch","numberOfChildren","c","children","containsSegmentGroupHelper","containeePaths","current","next","containerPaths","containeeSegment","parameters","UrlTree","_queryParamMap","UrlSegmentGroup","queryParamMap","toString","DEFAULT_SERIALIZER","serialize","parent","values","forEach","serializePaths","UrlSegment","_parameterMap","parameterMap","serializePath","equalSegments","as","bs","mapChildrenIntoArray","fn","res","entries","childOutlet","child","concat","UrlSerializer","t","DefaultUrlSerializer","parse","url","p","UrlParser","parseRootSegment","parseQueryParams","parseFragment","tree","serializeSegment","query","serializeQueryParams","encodeUriFragment","map","join","primary","k","push","encodeUriString","s","encodeURIComponent","replace","encodeUriQuery","encodeURI","encodeUriSegment","decode","decodeURIComponent","decodeQuery","serializeMatrixParams","strParams","filter","SEGMENT_RE","matchSegments","str","match","MATRIX_PARAM_SEGMENT_RE","matchMatrixKeySegments","QUERY_PARAM_RE","matchQueryParams","QUERY_PARAM_VALUE_RE","matchUrlQueryParamValue","remaining","consumeOptional","peekStartsWith","parseChildren","parseQueryParam","parseSegment","capture","parseParens","_RuntimeError","ngDevMode","parseMatrixParams","parseParam","valueMatch","decodedKey","decodedVal","currentVal","allowPrimary","outletName","indexOf","startsWith","createRoot","rootCandidate","squashSegmentGroup","newChildren","childCandidate","grandChildOutlet","grandChild","mergeTrivialChildren","isUrlTree","createUrlTreeFromSnapshot","relativeTo","commands","relativeToUrlSegmentGroup","createSegmentGroupFromRoute","createUrlTreeFromSegmentGroup","targetGroup","createSegmentGroupFromRouteRecursive","currentRoute","childOutlets","childSnapshot","outlet","rootSegmentGroup","nav","computeNavigation","toRoot","position","findStartingPositionForTargetGroup","newSegmentGroup","processChildren","updateSegmentGroupChildren","updateSegmentGroup","isMatrixParams","command","outlets","segmentPath","isCommandWithOutlets","oldRoot","oldSegmentGroup","qp","replaceSegment","newRoot","oldSegment","newSegment","Navigation","isAbsolute","numberOfDoubleDots","cmdWithOutlet","find","reduce","cmd","cmdIdx","urlPart","partIndex","Position","target","NaN","modifier","createPositionApplyingDoubleDots","group","g","ci","dd","getOutlets","startIndex","m","prefixedWith","slicedCommands","commandIndex","pathIndex","createNewSegmentGroup","some","o","childrenOfEmptyChild","currentCommandIndex","currentPathIndex","noMatch","curr","compare","createNewSegmentChildren","stringify","IMPERATIVE_NAVIGATION","EventType","NavigationStart","NavigationEnd","NavigationCancel","NavigationError","RoutesRecognized","ResolveStart","ResolveEnd","GuardsCheckStart","GuardsCheckEnd","RouteConfigLoadStart","RouteConfigLoadEnd","ChildActivationStart","ChildActivationEnd","ActivationStart","ActivationEnd","Scroll","NavigationSkipped","RouterEvent","id","type","navigationTrigger","restoredState","urlAfterRedirects","NavigationCancellationCode","Redirect","SupersededByNewNavigation","NoDataFromResolver","GuardRejected","NavigationSkippedCode","IgnoredSameUrlNavigation","IgnoredByUrlHandlingStrategy","reason","code","error","state","shouldActivate","snapshot","routeConfig","BeforeActivateRoutes","RedirectRequest","navigationBehaviorOptions","getOrCreateRouteInjectorIfNeeded","currentInjector","providers","_injector","createEnvironmentInjector","getOutlet","sortByMatchingOutlets","routes","sortedConfig","r","getClosestRouteInjector","_loadedInjector","OutletContext","rootInjector","attachRef","injector","ChildrenOutletContexts","contexts","Map","onChildOutletCreated","childName","context","getOrCreateContext","set","onChildOutletDestroyed","getContext","onOutletDeactivated","onOutletReAttached","inject","EnvironmentInjector","defineInjectable","Tree","_root","pathFromRoot","n","findNode","firstChild","siblings","findPath","cc","node","unshift","TreeNode","nodeChildrenAsMap","RouterState","setRouterState","createEmptyState","rootComponent","createEmptyStateSnapshot","emptyUrl","BehaviorSubject","emptyParams","emptyData","emptyQueryParams","activated","ActivatedRoute","ActivatedRouteSnapshot","RouterStateSnapshot","urlSubject","paramsSubject","queryParamsSubject","fragmentSubject","dataSubject","component","_futureSnapshot","_routerState","_paramMap","title","futureSnapshot","pipe","d","paramMap","getInherited","paramsInheritanceStrategy","inherited","loadComponent","__spreadValues","_resolvedData","hasStaticTitle","_resolve","matched","serializeNode","advanceActivatedRoute","currentSnapshot","nextSnapshot","equalParamsAndUrlSegments","equalUrlParams","parentsMismatch","config","ROUTER_OUTLET_DATA","InjectionToken","RouterOutlet","activatedComponentRef","_activatedRoute","activateEvents","EventEmitter","deactivateEvents","attachEvents","detachEvents","routerOutletData","input","parentContexts","inject","location","ViewContainerRef","changeDetector","ChangeDetectorRef","inputBinder","INPUT_BINDER","optional","supportsBindingToComponentInputs","ngOnChanges","changes","firstChange","previousValue","isTrackedInParentContexts","deactivate","initializeOutletWithName","ngOnDestroy","unsubscribeFromRouteData","ngOnInit","attach","activateWith","isActivated","instance","activatedRoute","activatedRouteData","detach","cmp","emit","ref","insert","hostView","bindActivatedRouteToOutletComponent","destroy","environmentInjector","childContexts","OutletInjector","createComponent","markForCheck","dir","R","selectors","inputs","outputs","exportAs","features","NgOnChangesFeature","outletData","__ngOutletInjector","parentInjector","notFoundValue","createRouterState","routeReuseStrategy","prevState","createNode","shouldReuseRoute","createOrReuseChildren","shouldAttach","detachedRouteHandle","retrieve","createActivatedRoute","RedirectCommand","redirectTo","NAVIGATION_CANCELING_ERROR","redirectingNavigationError","urlSerializer","redirect","navigationCancelingError","message","Error","cancellationCode","isRedirectingNavigationCancelingError","isNavigationCancelingError","activateRoutes","rootContexts","forwardEvent","inputBindingEnabled","ActivateRoutes","targetRouterState","currentRouterState","activate","futureState","currState","futureRoot","currRoot","deactivateChildRoutes","activateChildRoutes","futureNode","currNode","futureChild","childOutletName","deactivateRoutes","deactivateRouteAndItsChildren","parentContext","future","shouldDetach","detachAndStoreRouteSubtree","deactivateRouteAndOutlet","treeNode","componentRef","store","stored","CanActivate","CanDeactivate","getAllRouteGuards","getChildRouteGuards","getCanActivateChild","canActivateChild","guards","getTokenOrFunctionIdentity","tokenOrFunction","NOT_FOUND","result","_isInjectable","futurePath","checks","canDeactivateChecks","canActivateChecks","prevChildren","getRouteGuards","shouldRun","shouldRunGuardsAndResolvers","runGuardsAndResolvers","mode","isFunction","isBoolean","isCanLoad","guard","canLoad","isCanActivate","canActivate","isCanActivateChild","isCanDeactivate","canDeactivate","isCanMatch","canMatch","isEmptyError","e","EmptyError","INITIAL_VALUE","prioritizedGuardValue","switchMap","obs","combineLatest","take","startWith","results","isRedirect","item","checkGuards","mergeMap","targetSnapshot","__spreadProps","guardsResult","runCanDeactivateChecks","runCanActivateChecks","futureRSS","currRSS","check","runCanDeactivate","first","concatMap","fireChildActivationStart","fireActivationStart","runCanActivateChild","runCanActivate","futureARS","canActivateObservables","defer","closestInjector","guardVal","runInInjectionContext","canActivateChildGuardsMapped","reverse","guardsMapped","currARS","canDeactivateObservables","runCanLoadGuards","canLoadObservables","injectionToken","redirectIfUrlTree","tap","runCanMatchGuards","canMatchObservables","NoMatch","AbsoluteRedirect","urlTree","noMatch$1","throwError","namedOutletsRedirect","canLoadFails","ApplyRedirects","lineralizeSegments","applyRedirectCommands","redirectToFn","newRedirect","newTree","applyRedirectCreateUrlTree","createSegmentGroup","createQueryParams","redirectToParams","actualParams","sourceName","updatedSegments","createSegments","redirectToSegments","actualSegments","findPosParam","findOrReturn","redirectToUrlSegment","pos","idx","splice","consumedSegments","remainingSegments","positionalParamSegments","matchWithChecks","createWildcardMatchResult","matcher","slicedSegments","containsEmptyPathMatchesWithNamedOutlets","createChildrenForEmptyPaths","containsEmptyPathMatches","addEmptyPathsToChildrenIfNeeded","emptyPathMatch","primarySegment","noLeftoversInUrl","NoLeftoversInUrl","recognize$1","configLoader","rootComponentType","Recognizer","recognize","MAX_ALLOWED_REDIRECTS","applyRedirects","absoluteRedirectCount","allowRedirects","noMatchError","rootSnapshot","rootNode","routeState","freeze","processSegmentGroup","catchError","parentRoute","processSegment","scan","outletChildren","defaultIfEmpty","last$1","mergedChildren","mergeEmptyPathMatches","sortActivatedRouteSnapshots","processSegmentAgainstRoute","x","rawSegment","matchSegmentAgainstRoute","expandSegmentAgainstRouteUsingRedirect","getData","_loadedComponent","getResolve","newSegments","matchResult","getChildConfig","childConfig","childInjector","matchedOnOutlet","loadChildren","_loadedRoutes","shouldLoadResult","cfg","nodes","localeCompare","hasEmptyPathConfig","mergedNodes","Set","duplicateEmptyPathNode","resultNode","add","mergedNode","serializer","extractedUrl","resolveData","routesWithResolversToRun","routesNeedingDataUpdates","newRoute","flattenRouteTree","routesProcessed","runResolve","takeLast","size","EMPTY","descendants","flat","resolveNode","resolvedData","getResolver","resolver","resolverValue","switchTap","nextResult","TitleStrategy","buildTitle","pageTitle","getResolvedTitleForRoute","DefaultTitleStrategy","updateTitle","setTitle","Title","ROUTER_CONFIGURATION","EmptyOutletComponent","cmp","W","decls","vars","template","rf","ctx","F","dependencies","encapsulation","standardizeConfig","ROUTES","RouterConfigLoader","componentLoaders","WeakMap","childrenLoaders","onLoadStartListener","onLoadEndListener","compiler","Compiler","loadRunner","maybeUnwrapDefaultExport","finalize","delete","loader","ConnectableObservable","Subject","refCount","NgModuleFactory","compileModuleAsync","factoryOrRoutes","rawRoutes","requireStandaloneComponents","create","self","isWrappedDefaultExport","default","UrlHandlingStrategy","DefaultUrlHandlingStrategy","shouldProcessUrl","extract","merge","newUrlPart","wholeUrl","CREATE_VIEW_TRANSITION","NAVIGATION_ERROR_HANDLER","NavigationTransitions","currentNavigation","currentTransition","lastSuccessfulNavigation","events","transitionAbortSubject","destroyRef","DestroyRef","Location","titleStrategy","urlHandlingStrategy","createViewTransition","navigationErrorHandler","navigationId","hasRequestedNavigation","transitions","afterPreactivation","destroyed","onLoadStart","onLoadEnd","onDestroy","complete","handleNavigationRequest","request","rawUrl","setupNavigations","router","overallTransitionState","completed","errored","cancelNavigationTransition","initialUrl","targetBrowserUrl","extras","browserUrl","trigger","source","previousNavigation","urlTransition","navigated","isUpdatingInternalState","isUpdatedBrowserUrl","onSameUrlNavigation","finalUrl","routesRecognized","currentRawUrl","navStart","skipLocationChange","replaceUrl","guardsStart","evt","guardsEnd","resolveStart","dataResolved","resolveEnd","loadComponents","loaders","loadedComponent","viewTransitionStarted","takeUntil","err","navigationError","navigationErrorHandlerResult","ee","resolveNavigationPromiseOnError","reject","navCancel","currentUrlTree","currentBrowserUrl","isBrowserTriggeredNavigation","RouteReuseStrategy","DefaultRouteReuseStrategy","BaseRouteReuseStrategy","detachedTree","gi","__ngFactoryType__","StateManager","HistoryStateManager","canceledNavigationResolution","urlUpdateStrategy","getCurrentUrlTree","rawUrlTree","getRawUrlTree","currentPageId","lastSuccessfulId","getState","browserPageId","routerPageId","routerState","getRouterState","stateMemento","createStateMemento","registerNonRouterCurrentEntryChangeListener","listener","subscribe","event","handleRouterEvent","setBrowserUrl","restoreHistory","transition","isCurrentPathEqualTo","currentBrowserPageId","generateNgRouterState","replaceState","go","navigation","restoringFromCaughtError","targetPagePosition","historyGo","resetState","resetUrlToCurrentUrlTree","routerPageId","afterNextNavigation","action","exactMatchOptions","subsetMatchOptions","Router","stateManager","disposed","nonRouterCurrentEntryChangeSubscription","console","_Console","pendingTasks","_PendingTasksInternal","navigationTransitions","_events","componentInputBindingEnabled","resetConfig","warn","subscribeToNavigationEvents","eventsSubscription","Subscription","subscription","opts","mergedTree","info","scheduleNavigation","promise","isPublicRouterEvent","resetRootComponentType","initialNavigation","setUpLocationChangeListener","navigateToSyncWithBrowser","setTimeout","stateCopy","parseUrl","serializeUrl","getCurrentNavigation","dispose","unsubscribe","createUrlTree","navigationExtras","queryParamsHandling","preserveFragment","f","q","defaultQueryParamsHandling","removeEmptyProps","relativeToSnapshot","navigateByUrl","navigate","validateCommands","isActive","matchOptions","priorPromise","rej","taskId","queueMicrotask","remove","catch","RouterLink","tabIndexAttribute","renderer","el","locationStrategy","href","isAnchorElement","onChanges","tagName","nativeElement","toLowerCase","updateHref","setTabIndexIfNotOnNativeEl","newTabIndex","applyAttributeValue","routerLinkInput","routerLink","commandsOrUrlTree","onClick","button","ctrlKey","shiftKey","altKey","metaKey","prepareExternalUrl","sanitizedValue","__sanitizeUrlOrResourceUrl","attrName","attrValue","setAttribute","removeAttribute","directiveInject","injectAttribute","Renderer2","ElementRef","LocationStrategy","defineDirective","hostVars","hostBindings","z","$event","me","booleanAttribute","RouterLinkActive","element","cdr","link","links","classes","routerEventsSubscription","linkInputChangesSubscription","_isActive","routerLinkActiveOptions","ariaCurrentWhenActive","isActiveChange","update","ngAfterContentInit","mergeAll","subscribeToEachLinkOnChanges","allLinkChanges","toArray","isLinkActive","routerLinkActive","hasActiveLinks","addClass","removeClass","isActiveMatchOptions","isActiveCheckFn","contentQueries","dirIndex","Ce","_t","ROUTER_SCROLLER","provideRouter","makeEnvironmentProviders","provide","multi","useValue","useFactory","rootRoute","deps","APP_BOOTSTRAP_LISTENER","getBootstrapListener","feature","providers","routerFeature","kind","kind","Injector","bootstrappedComponentRef","ApplicationRef","components","bootstrapDone","BOOTSTRAP_DONE","INITIAL_NAVIGATION","ROUTER_PRELOADER","InjectFlags","Optional","setUpPreloading","init","componentTypes","closed","withEnabledBlockingInitialNavigation","APP_INITIALIZER","locationInitialized","LOCATION_INITIALIZED","then","environment","production","apiURL","AuthService","http","HttpClient","tokenService","apiURLUsers","login","email","password","post","logout","AuthGuard","localStorageToken","tokenDecode","JSON","atob","userId","_tokenExpired","exp","window","pathname","includes","isAdmin","expiration","Math","floor","Date","getTime","_CdkTextFieldStyleLoader","defineComponent","hostAttrs","styles","changeDetection","listenerOptions","passive","AutofillMonitor","_platform","Platform","_ngZone","NgZone","_renderer","RendererFactory2","createRenderer","_styleLoader","_CdkPrivateStyleLoader","_monitoredElements","monitor","elementOrRef","isBrowser","load","coerceElement","subject","cssClass","animationName","classList","contains","run","isAutofilled","unlisten","runOutsideAngular","_bindEventWithOptions","stopMonitoring","_info","CdkTextareaAutosize","_elementRef","_resizeEvents","_previousValue","_initialHeight","_destroyed","_listenerCleanups","_minRows","_maxRows","_enabled","_previousMinRows","_textareaElement","minRows","coerceNumberProperty","_setMinHeight","maxRows","_setMaxHeight","enabled","resizeToFitContent","reset","placeholder","_cachedPlaceholderHeight","_cacheTextareaPlaceholderHeight","_cachedLineHeight","_cachedScrollTop","_document","DOCUMENT","_hasFocus","_isViewInited","minHeight","style","maxHeight","ngAfterViewInit","height","listen","_handleFocusEvent","auditTime","cleanup","_cacheTextareaLineHeight","textareaClone","cloneNode","cloneStyles","rows","visibility","border","padding","top","bottom","left","right","overflow","parentNode","appendChild","clientHeight","_measureScrollHeight","previousMargin","marginBottom","isFirefox","FIREFOX","needsMarginFiller","measuringClass","scrollHeight","ngDoCheck","force","scrollTop","textarea","max","requestAnimationFrame","_scrollToCaretPosition","_noopInputHandler","selectionStart","selectionEnd","isStopped","setSelectionRange","TextFieldModule","mod","defineNgModule","inj","xe","MAT_INPUT_VALUE_ACCESSOR","SingleBoxSharedResizeObserver","_box","_resizeSubject","_resizeObserver","_elementObservables","ResizeObserver","observe","Observable","observer","box","unobserve","entry","shareReplay","bufferSize","clear","SharedResizeObserver","_cleanupErrorListener","_observers","_c0","_c1","_c2","_c3","_c4","_c5","_c6","_c7","_c8","_c9","MatFormField_ng_template_0_Conditional_0_Conditional_2_Template","MatFormField_ng_template_0_Conditional_0_Template","E","Bs","ctx_r1","nextContext","ae","_shouldLabelFloat","_hasOutline","_labelId","_control","disableAutomaticLabeling","y","M","hideRequiredMarker","required","MatFormField_ng_template_0_Template","js","_hasFloatingLabel","MatFormField_Conditional_4_Template","MatFormField_Conditional_6_Conditional_1_ng_template_0_Template","MatFormField_Conditional_6_Conditional_1_Template","qs","J","_i","MatFormField_Conditional_6_Template","Hs","_forceDisplayInfixLabel","MatFormField_Conditional_7_Template","MatFormField_Conditional_8_Template","MatFormField_Conditional_10_ng_template_0_Template","MatFormField_Conditional_10_Template","Xs","MatFormField_Conditional_12_Template","MatFormField_Conditional_13_Template","MatFormField_Conditional_14_Template","MatFormField_Case_16_Template","MatFormField_Case_17_Conditional_1_Template","Ie","_hintLabelId","ir","hintLabel","MatFormField_Case_17_Template","tl","MatLabel","MAT_ERROR","MatError","_IdGenerator","getId","HostAttributeToken","rt","ProvidersFeature","useExisting","MatHint","align","U","MAT_PREFIX","MatPrefix","_isTextSelector","_isText","MAT_SUFFIX","MatSuffix","FLOATING_LABEL_PARENT","MatFormFieldFloatingLabel","floating","_floating","monitorResize","_handleResize","_monitorResize","_subscribeToResize","_resizeSubscription","_parent","getWidth","estimateScrollWidth","_handleLabelResized","htmlEl","offsetParent","scrollWidth","clone","setProperty","document","documentElement","ACTIVATE_CLASS","DEACTIVATING_CLASS","MatFormFieldLineRipple","_cleanupTransitionEnd","ngZone","_handleTransitionEnd","isDeactivating","propertyName","MatFormFieldNotchedOutline","open","_notch","label","querySelector","transitionDuration","_setNotchWidth","labelWidth","width","viewQuery","B","Ts","I","A","attrs","ngContentSelectors","consts","vi","MatFormFieldControl","stateChanges","ngControl","focused","empty","shouldLabelFloat","disabled","errorState","controlType","autofilled","userAriaDescribedBy","MAT_FORM_FIELD","MAT_FORM_FIELD_DEFAULT_OPTIONS","DEFAULT_APPEARANCE","DEFAULT_FLOAT_LABEL","DEFAULT_SUBSCRIPT_SIZING","FLOATING_LABEL_DEFAULT_DOCKED_TRANSFORM","MatFormField","_changeDetectorRef","_dir","Directionality","_idGenerator","_defaults","_textField","_iconPrefixContainer","_textPrefixContainer","_iconSuffixContainer","_textSuffixContainer","_floatingLabel","_notchedOutline","_lineRipple","_formFieldControl","_prefixChildren","_suffixChildren","_errorChildren","_hintChildren","_labelChild","contentChild","_hideRequiredMarker","coerceBooleanProperty","color","floatLabel","_floatLabel","appearance","_appearance","oldValue","newAppearance","_needsOutlineLabelOffsetUpdate","subscriptSizing","_subscriptSizing","_hintLabel","_processHints","_hasIconPrefix","_hasTextPrefix","_hasIconSuffix","_hasTextSuffix","_explicitFormFieldControl","_isFocused","_previousControl","_previousControlValidatorFn","_stateChanges","_valueChanges","_describedByChanges","_animationsDisabled","defaults","Boolean","ANIMATION_MODULE_TYPE","_updateFocusState","detectChanges","_assertFormFieldControl","_initializeSubscript","_initializePrefixAndSuffix","_initializeOutlineLabelOffsetSubscriptions","ngAfterContentChecked","_initializeControl","control","validator","getLabelId","computed","getConnectedOverlayOrigin","_animateAndLockLabel","previousControl","classPrefix","pairwise","prevErrorState","prevDescribedBy","currentErrorState","currentDescribedBy","_syncDescribedByIds","valueChanges","_checkPrefixAndSuffixTypes","_validateHints","toggle","afterRender","_updateOutlineLabelOffset","change","_shouldAlwaysFloat","_shouldForward","prop","_getDisplayedMessages","_refreshOutlineNotchWidth","ids","startHint","hint","endHint","setDescribedByIds","floatingLabel","transform","_isAttachedToDom","iconPrefixContainer","textPrefixContainer","iconSuffixContainer","textSuffixContainer","iconPrefixContainerWidth","getBoundingClientRect","textPrefixContainerWidth","iconSuffixContainerWidth","textSuffixContainerWidth","negate","prefixWidth","labelHorizontalOffset","prefixAndSuffixWidth","getRootNode","er","tr","ks","Ds","Ps","Fs","Ns","_r1","getCurrentView","Us","$s","nr","Et","It","onContainerClick","Gs","Vs","Zs","Ys","Js","tmp_16_0","NgTemplateOutlet","ErrorStateMatcher","isErrorState","form","invalid","touched","submitted","_ErrorStateTracker","_defaultMatcher","_parentFormGroup","_parentForm","updateErrorState","oldState","newState","MatFormFieldModule","defineInjector","imports","MatCommonModule","ObserversModule","MAT_INPUT_INVALID_TYPES","MAT_INPUT_CONFIG","MatInput","NgControl","_autofillMonitor","_formField","_uid","_previousNativeValue","_inputValueAccessor","_signalBasedValueAccessor","_previousPlaceholder","_errorStateTracker","_config","_cleanupIosKeyup","_cleanupWebkitWheel","_formFieldDescribedBy","_isServer","_isNativeSelect","_isTextarea","_isInFormField","_disabled","_id","_required","hasValidator","Validators","_type","prevType","_validateType","getSupportedInputTypes","_ensureWheelDefaultBehavior","errorStateMatcher","readonly","_readonly","disabledInteractive","_neverEmptyInputTypes","parentForm","NgForm","parentFormGroup","FormGroupDirective","defaultErrorStateMatcher","accessor","nodeName","isSignal","IOS","_iOSKeyupListener","multiple","effect","_dirtyCheckNativeValue","_dirtyCheckPlaceholder","focus","_focusChanged","isFocused","_onInput","newValue","_getPlaceholder","_isNeverEmpty","_isBadInput","validity","badInput","selectElement","firstOption","selectedIndex","existingDescribedBy","getAttribute","toAssign","exclude","_isInlineSelect","_webkitBlinkWheelListener","BLINK","WEBKIT","_getReadonlyAttribute","MatInputModule","UsersService","signal","userName","userFavorites","favExercises","favPrograms","getUsers","getUser","createUser","user","updateUser","put","deleteUser","getFavorites","favoritesData","firstName","lastName","favorites","updateFavorites","patch","getUserLanguage","updateUserLanguage","userLanguageCode","loginAsGuest","Breakpoints","XSmall","Small","Medium","Large","XLarge","Handset","Tablet","Web","HandsetPortrait","TabletPortrait","WebPortrait","HandsetLandscape","TabletLandscape","WebLandscape","SimpleSnackBar_Conditional_2_Template","bi","MatSnackBarContainer_ng_template_4_Template","MAX_TIMEOUT","pow","MatSnackBarRef","_overlayRef","containerInstance","_afterDismissed","_afterOpened","_onAction","_durationTimeoutId","_dismissedByAction","_onExit","_finishDismiss","dismiss","exit","clearTimeout","dismissWithAction","closeWithAction","_dismissAfter","duration","min","_open","dismissedByAction","afterDismissed","afterOpened","_onEnter","onAction","MAT_SNACK_BAR_DATA","MatSnackBarConfig","politeness","announcementMessage","viewContainerRef","panelClass","direction","horizontalPosition","verticalPosition","MatSnackBarLabel","MatSnackBarActions","MatSnackBarAction","SimpleSnackBar","snackBarRef","hasAction","dl","MatButton","ENTER_ANIMATION","EXIT_ANIMATION","MatSnackBarContainer","BasePortalOutlet","_rendersRef","snackBarConfig","_trackedModals","_enterFallback","_exitFallback","_renders","_announceDelay","_announceTimeoutId","_portalOutlet","_onAnnounce","_animationState","_live","_label","_role","_liveElementId","manualCleanup","attachComponentPortal","portal","_assertNotAttached","_afterPortalAttached","attachTemplatePortal","attachDomPortal","onAnimationEnd","_completeExit","enter","_screenReaderAnnounce","_clearFromModals","panelClasses","_exposeToModals","labelClass","modals","querySelectorAll","modal","ariaOwns","trim","hasAttached","inertElement","liveElement","focusedElement","activeElement","HTMLElement","CdkPortalOutlet","cl","InheritDefinitionFeature","ul","MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY","MAT_SNACK_BAR_DEFAULT_OPTIONS","MatSnackBar","_overlay","Overlay","LiveAnnouncer","_breakpointObserver","BreakpointObserver","_parentSnackBar","skipSelf","_defaultConfig","_snackBarRefAtThisLevel","simpleSnackBarComponent","snackBarContainerComponent","handsetCssClass","_openedSnackBarRef","openFromComponent","_attach","openFromTemplate","_attachSnackBarContainer","overlayRef","userInjector","containerPortal","ComponentPortal","containerRef","content","userConfig","_createOverlay","TemplateRef","TemplatePortal","$implicit","_createInjector","contentRef","detachments","overlayElement","matches","announce","_animateSnackBar","overlayConfig","OverlayConfig","positionStrategy","global","isRtl","isLeft","isRight","centerHorizontally","xl","elementStart","i18n","elementEnd","yl","Cl","Sl","text","LoginComponent","formBuilder","FormBuilder","auth","localstorageService","authGuard","usersService","_snackBar","isSubmitted","isGuestSubmitted","authError","authMessage","subscriptions","_initLoginForm","loginFormGroup","onSubmit","loginForm","log","isAdminPath","userLanguage","origin","status","onSubmitGuest","controls","i18n_0","$localize","element","template","LoginComponent_Conditional_17_Template","LoginComponent_Conditional_18_Template","LoginComponent_Conditional_23_Template","LoginComponent_Conditional_24_Template","listener","advance","property","conditional","hasError","classProp","FormsModule","NgNoValidate","DefaultValueAccessor","NgControlStatus","NgControlStatusGroup","ReactiveFormsModule","FormControlName","MatButtonModule","usersRoutes","Jt","De","ga","ie","Dr","Jl","ed","td","h","je","mo","j","po","kd","l","xo","Ye","ti","Ke","Eo","Io","ii","ni","ri","u","Oo","oi","w","Je","Lo","ko","Do","No","Iu","C"],"ignoreList":[],"sources":["libs/users/src/lib/services/localstorage.service.ts","../../packages/router/src/shared.ts","../../packages/router/src/utils/collection.ts","../../packages/router/src/url_tree.ts","../../packages/router/src/create_url_tree.ts","../../packages/router/src/events.ts","../../packages/router/src/utils/config.ts","../../packages/router/src/router_outlet_context.ts","../../packages/router/src/utils/tree.ts","../../packages/router/src/router_state.ts","../../packages/router/src/directives/router_outlet.ts","../../packages/router/src/create_router_state.ts","../../packages/router/src/models.ts","../../packages/router/src/navigation_canceling_error.ts","../../packages/router/src/operators/activate_routes.ts","../../packages/router/src/utils/preactivation.ts","../../packages/router/src/utils/type_guards.ts","../../packages/router/src/operators/prioritized_guard_value.ts","../../packages/router/src/operators/check_guards.ts","../../packages/router/src/apply_redirects.ts","../../packages/router/src/utils/config_matching.ts","../../packages/router/src/recognize.ts","../../packages/router/src/operators/recognize.ts","../../packages/router/src/operators/resolve_data.ts","../../packages/router/src/operators/switch_tap.ts","../../packages/router/src/page_title_strategy.ts","../../packages/router/src/router_config.ts","../../packages/router/src/components/empty_outlet.ts","../../packages/router/src/router_config_loader.ts","../../packages/router/src/url_handling_strategy.ts","../../packages/router/src/utils/view_transition.ts","../../packages/router/src/navigation_transition.ts","../../packages/router/src/route_reuse_strategy.ts","../../packages/router/src/statemanager/state_manager.ts","../../packages/router/src/utils/navigations.ts","../../packages/router/src/router.ts","../../packages/router/src/directives/router_link.ts","../../packages/router/src/directives/router_link_active.ts","../../packages/router/src/router_scroller.ts","../../packages/router/src/provide_router.ts","environments/environment.prod.ts","libs/users/src/lib/services/auth.service.ts","libs/users/src/lib/services/auth-guard.service.ts","../../src/cdk/text-field/text-field-style-loader.ts","../../src/cdk/text-field/autofill.ts","../../src/cdk/text-field/autosize.ts","../../src/cdk/text-field/text-field-module.ts","../../src/material/input/input-value-accessor.ts","../../src/cdk/observers/private/shared-resize-observer.ts","../../src/material/form-field/directives/label.ts","../../src/material/form-field/form-field.html","../../src/material/form-field/directives/error.ts","../../src/material/form-field/directives/hint.ts","../../src/material/form-field/directives/prefix.ts","../../src/material/form-field/directives/suffix.ts","../../src/material/form-field/directives/floating-label.ts","../../src/material/form-field/directives/line-ripple.ts","../../src/material/form-field/directives/notched-outline.ts","../../src/material/form-field/directives/notched-outline.html","../../src/material/form-field/form-field-control.ts","../../src/material/form-field/form-field.ts","../../src/material/core/error/error-options.ts","../../src/material/core/common-behaviors/error-state.ts","../../src/material/form-field/module.ts","../../src/material/input/input.ts","../../src/material/input/module.ts","libs/users/src/lib/services/users.service.ts","../../src/cdk/layout/breakpoints.ts","../../src/material/snack-bar/snack-bar-ref.ts","../../src/material/snack-bar/simple-snack-bar.html","../../src/material/snack-bar/snack-bar-config.ts","../../src/material/snack-bar/snack-bar-content.ts","../../src/material/snack-bar/simple-snack-bar.ts","../../src/material/snack-bar/snack-bar-container.ts","../../src/material/snack-bar/snack-bar-container.html","../../src/material/snack-bar/snack-bar.ts","libs/users/src/lib/pages/login/login.component.html","libs/users/src/lib/pages/login/login.component.ts","libs/users/src/lib/users.routes.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\nconst TOKEN = 'jwtToken'\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalstorageService {\n  token = TOKEN;\n  constructor() { }\n\n  setToken(token: string,data: string){\n    localStorage.setItem(token, data)\n  }\n\n  getToken(token: string): string | null {\n    return localStorage.getItem(token);\n  }\n\n  removeToken() {\n    localStorage.removeItem(TOKEN);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {Route, UrlMatchResult} from './models';\nimport type {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\n */\nexport const RouteTitleKey = /* @__PURE__ */ Symbol('RouteTitle');\n\n/**\n * A collection of matrix and query URL parameters.\n * @see {@link convertToParamMap}\n * @see {@link ParamMap}\n *\n * @publicApi\n */\nexport type Params = {\n  [key: string]: any;\n};\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport interface ParamMap {\n  /**\n   * Reports whether the map contains a given parameter.\n   * @param name The parameter name.\n   * @returns True if the map contains the given parameter, false otherwise.\n   */\n  has(name: string): boolean;\n  /**\n   * Retrieves a single value for a parameter.\n   * @param name The parameter name.\n   * @return The parameter's single value,\n   * or the first value if the parameter has multiple values,\n   * or `null` when there is no such parameter.\n   */\n  get(name: string): string | null;\n  /**\n   * Retrieves multiple values for a parameter.\n   * @param name The parameter name.\n   * @return An array containing one or more values,\n   * or an empty array if there is no such parameter.\n   *\n   */\n  getAll(name: string): string[];\n\n  /** Names of the parameters in the map. */\n  readonly keys: string[];\n}\n\nclass ParamsAsMap implements ParamMap {\n  private params: Params;\n\n  constructor(params: Params) {\n    this.params = params || {};\n  }\n\n  has(name: string): boolean {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n\n  get(name: string): string | null {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n\n  getAll(name: string): string[] {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n\n  get keys(): string[] {\n    return Object.keys(this.params);\n  }\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\n/**\n * Matches the route configuration (`route`) against the actual URL (`segments`).\n *\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\n *\n * @param segments The remaining unmatched segments in the current navigation\n * @param segmentGroup The current segment group being matched\n * @param route The `Route` to match against.\n *\n * @see {@link UrlMatchResult}\n * @see {@link Route}\n *\n * @returns The resulting match information or `null` if the `route` should not match.\n * @publicApi\n */\nexport function defaultUrlMatcher(\n  segments: UrlSegment[],\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n): UrlMatchResult | null {\n  const parts = route.path!.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (\n    route.pathMatch === 'full' &&\n    (segmentGroup.hasChildren() || parts.length < segments.length)\n  ) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const posParams: {[key: string]: UrlSegment} = {};\n\n  // Check each config part against the actual URL\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part[0] === ':';\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {consumed: segments.slice(0, parts.length), posParams};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {isPromise as isPromise} from '@angular/core';\nimport {from, isObservable, Observable, of} from 'rxjs';\n\nexport function shallowEqualArrays(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(\n  a: {[key: string | symbol]: any},\n  b: {[key: string | symbol]: any},\n): boolean {\n  // While `undefined` should never be possible, it would sometimes be the case in IE 11\n  // and pre-chromium Edge. The check below accounts for this edge case.\n  const k1 = a ? getDataKeys(a) : undefined;\n  const k2 = b ? getDataKeys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key: string | symbol;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Gets the keys of an object, including `symbol` keys.\n */\nexport function getDataKeys(obj: Object): Array<string | symbol> {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\n\n/**\n * Test equality for arrays of strings or a string.\n */\nexport function equalArraysOrString(a: string | string[], b: string | string[]) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: T[]): T | null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\nexport function wrapIntoObservable<T>(value: T | Promise<T> | Observable<T>): Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, RuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\nimport {equalArraysOrString, shallowEqual} from './utils/collection';\n\n/**\n * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n * for the current router state.\n *\n * @publicApi\n * @see {@link Router#isActive}\n */\nexport interface IsActiveMatchOptions {\n  /**\n   * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n   *\n   * The matrix parameter matching is dependent on the strategy for matching the\n   * segments. That is, if the `paths` option is set to `'subset'`, only\n   * the matrix parameters of the matching segments will be compared.\n   *\n   * - `'exact'`: Requires that matching segments also have exact matrix parameter\n   * matches.\n   * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n   * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n   * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n   */\n  matrixParams: 'exact' | 'subset' | 'ignored';\n  /**\n   * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n   *\n   * - `'exact'`: the query parameters must match exactly.\n   * - `'subset'`: the active `UrlTree` may contain extra parameters,\n   * but must match the key and value of any that exist in the `UrlTree` in question.\n   * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n   */\n  queryParams: 'exact' | 'subset' | 'ignored';\n  /**\n   * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n   *\n   * - `'exact'`: all segments in each `UrlTree` must match.\n   * - `'subset'`: a `UrlTree` will be determined to be active if it\n   * is a subtree of the active route. That is, the active route may contain extra\n   * segments, but must at least have all the segments of the `UrlTree` in question.\n   */\n  paths: 'exact' | 'subset';\n  /**\n   * - `'exact'`: indicates that the `UrlTree` fragments must be equal.\n   * - `'ignored'`: the fragments will not be compared when determining if a\n   * `UrlTree` is active.\n   */\n  fragment: 'exact' | 'ignored';\n}\n\ntype ParamMatchOptions = 'exact' | 'subset' | 'ignored';\n\ntype PathCompareFn = (\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n) => boolean;\ntype ParamCompareFn = (container: Params, containee: Params) => boolean;\n\nconst pathCompareMap: Record<IsActiveMatchOptions['paths'], PathCompareFn> = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup,\n};\nconst paramCompareMap: Record<ParamMatchOptions, ParamCompareFn> = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true,\n};\n\nexport function containsTree(\n  container: UrlTree,\n  containee: UrlTree,\n  options: IsActiveMatchOptions,\n): boolean {\n  return (\n    pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n    paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n    !(options.fragment === 'exact' && container.fragment !== containee.fragment)\n  );\n}\n\nfunction equalParams(container: Params, containee: Params): boolean {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n\nfunction equalSegmentGroups(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n): boolean {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n      return false;\n  }\n  return true;\n}\n\nfunction containsParams(container: Params, containee: Params): boolean {\n  return (\n    Object.keys(containee).length <= Object.keys(container).length &&\n    Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]))\n  );\n}\n\nfunction containsSegmentGroup(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  matrixParams: ParamMatchOptions,\n): boolean {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\n\nfunction containsSegmentGroupHelper(\n  container: UrlSegmentGroup,\n  containee: UrlSegmentGroup,\n  containeePaths: UrlSegment[],\n  matrixParams: ParamMatchOptions,\n): boolean {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(\n      container.children[PRIMARY_OUTLET],\n      containee,\n      next,\n      matrixParams,\n    );\n  }\n}\n\nfunction matrixParamsMatch(\n  containerPaths: UrlSegment[],\n  containeePaths: UrlSegment[],\n  options: ParamMatchOptions,\n) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlTree {\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  constructor(\n    /** The root segment group of the URL tree */\n    public root: UrlSegmentGroup = new UrlSegmentGroup([], {}),\n    /** The query params of the URL */\n    public queryParams: Params = {},\n    /** The fragment of the URL */\n    public fragment: string | null = null,\n  ) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new RuntimeError(\n          RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT,\n          'The root `UrlSegmentGroup` should not contain `segments`. ' +\n            'Instead, these segments belong in the `children` so they can be associated with a named outlet.',\n        );\n      }\n    }\n  }\n\n  get queryParamMap(): ParamMap {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport class UrlSegmentGroup {\n  /** The parent node in the url tree */\n  parent: UrlSegmentGroup | null = null;\n\n  constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    public segments: UrlSegment[],\n    /** The list of children of this group */\n    public children: {[key: string]: UrlSegmentGroup},\n  ) {\n    Object.values(children).forEach((v) => (v.parent = this));\n  }\n\n  /** Whether the segment has child segments */\n  hasChildren(): boolean {\n    return this.numberOfChildren > 0;\n  }\n\n  /** Number of child segments */\n  get numberOfChildren(): number {\n    return Object.keys(this.children).length;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePaths(this);\n  }\n}\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n *### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlSegment {\n  /** @internal */\n  _parameterMap?: ParamMap;\n\n  constructor(\n    /** The path part of a URL segment */\n    public path: string,\n\n    /** The matrix parameters associated with a segment */\n    public parameters: {[name: string]: string},\n  ) {}\n\n  get parameterMap(): ParamMap {\n    this._parameterMap ??= convertToParamMap(this.parameters);\n    return this._parameterMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return serializePath(this);\n  }\n}\n\nexport function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\n\nexport function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\n\nexport function mapChildrenIntoArray<T>(\n  segment: UrlSegmentGroup,\n  fn: (v: UrlSegmentGroup, k: string) => T[],\n): T[] {\n  let res: T[] = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => new DefaultUrlSerializer()})\nexport abstract class UrlSerializer {\n  /** Parse a url into a `UrlTree` */\n  abstract parse(url: string): UrlTree;\n\n  /** Converts a `UrlTree` into a url */\n  abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport class DefaultUrlSerializer implements UrlSerializer {\n  /** Parses a url into a `UrlTree` */\n  parse(url: string): UrlTree {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n\n  /** Converts a `UrlTree` into a url */\n  serialize(tree: UrlTree): string {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment =\n      typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n\n    return `${segment}${query}${fragment}`;\n  }\n}\n\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n\nexport function serializePaths(segment: UrlSegmentGroup): string {\n  return segment.segments.map((p) => serializePath(p)).join('/');\n}\n\nfunction serializeSegment(segment: UrlSegmentGroup, root: boolean): string {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET]\n      ? serializeSegment(segment.children[PRIMARY_OUTLET], false)\n      : '';\n    const children: string[] = [];\n\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n  } else {\n    const children = mapChildrenIntoArray(segment, (v: UrlSegmentGroup, k: string) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n\n    // use no parenthesis if the only child is a primary outlet route\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\n\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s: string): string {\n  return encodeURIComponent(s)\n    .replace(/%40/g, '@')\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',');\n}\n\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriQuery(s: string): string {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriFragment(s: string): string {\n  return encodeURI(s);\n}\n\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriSegment(s: string): string {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n\nexport function decode(s: string): string {\n  return decodeURIComponent(s);\n}\n\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nexport function decodeQuery(s: string): string {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n\nexport function serializePath(path: UrlSegment): string {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\n\nfunction serializeMatrixParams(params: {[key: string]: string}): string {\n  return Object.entries(params)\n    .map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`)\n    .join('');\n}\n\nfunction serializeQueryParams(params: {[key: string]: any}): string {\n  const strParams: string[] = Object.entries(params)\n    .map(([name, value]) => {\n      return Array.isArray(value)\n        ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&')\n        : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n    })\n    .filter((s) => s);\n\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\n\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str: string): string {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str: string): string {\n  const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str: string): string {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str: string): string {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nclass UrlParser {\n  private remaining: string;\n\n  constructor(private url: string) {\n    this.remaining = url;\n  }\n\n  parseRootSegment(): UrlSegmentGroup {\n    this.consumeOptional('/');\n\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n\n    // The root segment group never has segments\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n\n  parseQueryParams(): Params {\n    const params: Params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n\n  parseFragment(): string | null {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n\n  private parseChildren(): {[outlet: string]: UrlSegmentGroup} {\n    if (this.remaining === '') {\n      return {};\n    }\n\n    this.consumeOptional('/');\n\n    const segments: UrlSegment[] = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n\n    let children: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n\n    let res: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n\n    return res;\n  }\n\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  private parseSegment(): UrlSegment {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new RuntimeError(\n        RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Empty path url segment cannot have parameters: '${this.remaining}'.`,\n      );\n    }\n\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n\n  private parseMatrixParams(): {[key: string]: string} {\n    const params: {[key: string]: string} = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n\n  private parseParam(params: {[key: string]: string}): void {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    params[decode(key)] = decode(value);\n  }\n\n  // Parse a single query parameter `name[=value]`\n  private parseQueryParam(params: Params): void {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n\n    if (params.hasOwnProperty(decodedKey)) {\n      // Append to existing values\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      // Create a new value\n      params[decodedKey] = decodedVal;\n    }\n  }\n\n  // parse `(a/b//outlet_name:c/d)`\n  private parseParens(allowPrimary: boolean): {[outlet: string]: UrlSegmentGroup} {\n    const segments: {[key: string]: UrlSegmentGroup} = {};\n    this.capture('(');\n\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n\n      const next = this.remaining[path.length];\n\n      // if is is not one of these characters, then the segment was unescaped\n      // or the group was not closed\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new RuntimeError(\n          RuntimeErrorCode.UNPARSABLE_URL,\n          (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`,\n        );\n      }\n\n      let outletName: string = undefined!;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n\n      const children = this.parseChildren();\n      segments[outletName] =\n        Object.keys(children).length === 1\n          ? children[PRIMARY_OUTLET]\n          : new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n\n    return segments;\n  }\n\n  private peekStartsWith(str: string): boolean {\n    return this.remaining.startsWith(str);\n  }\n\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  private consumeOptional(str: string): boolean {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n\n  private capture(str: string): void {\n    if (!this.consumeOptional(str)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`,\n      );\n    }\n  }\n}\n\nexport function createRoot(rootCandidate: UrlSegmentGroup) {\n  return rootCandidate.segments.length > 0\n    ? new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate})\n    : rootCandidate;\n}\n\n/**\n * Recursively\n * - merges primary segment children into their parents\n * - drops empty children (those which have no segments and no children themselves). This latter\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\n * segment.\n * - merges named outlets without a primary segment sibling into the children. This prevents\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\n * root but the `a` route lives under an empty path primary route.\n */\nexport function squashSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n  const newChildren: Record<string, UrlSegmentGroup> = {};\n  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n    const childCandidate = squashSegmentGroup(child);\n    // moves named children in an empty path primary child into this group\n    if (\n      childOutlet === PRIMARY_OUTLET &&\n      childCandidate.segments.length === 0 &&\n      childCandidate.hasChildren()\n    ) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    } // don't add empty children\n    else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\n\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\nfunction mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nexport function isUrlTree(v: any): v is UrlTree {\n  return v instanceof UrlTree;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from './errors';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {createRoot, squashSegmentGroup, UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\nimport {last, shallowEqual} from './utils/collection';\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```ts\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nexport function createUrlTreeFromSnapshot(\n  relativeTo: ActivatedRouteSnapshot,\n  commands: any[],\n  queryParams: Params | null = null,\n  fragment: string | null = null,\n): UrlTree {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\n\nexport function createSegmentGroupFromRoute(route: ActivatedRouteSnapshot): UrlSegmentGroup {\n  let targetGroup: UrlSegmentGroup | undefined;\n\n  function createSegmentGroupFromRouteRecursive(\n    currentRoute: ActivatedRouteSnapshot,\n  ): UrlSegmentGroup {\n    const childOutlets: {[outlet: string]: UrlSegmentGroup} = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n\n  return targetGroup ?? rootSegmentGroup;\n}\n\nexport function createUrlTreeFromSegmentGroup(\n  relativeTo: UrlSegmentGroup,\n  commands: any[],\n  queryParams: Params | null,\n  fragment: string | null,\n): UrlTree {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren\n    ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands)\n    : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\n\nfunction isMatrixParams(command: any): boolean {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\nfunction isCommandWithOutlets(command: any): command is {outlets: {[key: string]: any}} {\n  return typeof command === 'object' && command != null && command.outlets;\n}\n\nfunction tree(\n  oldRoot: UrlSegmentGroup,\n  oldSegmentGroup: UrlSegmentGroup,\n  newSegmentGroup: UrlSegmentGroup,\n  queryParams: Params | null,\n  fragment: string | null,\n): UrlTree {\n  let qp: any = {};\n  if (queryParams) {\n    Object.entries(queryParams).forEach(([name, value]) => {\n      qp[name] = Array.isArray(value) ? value.map((v: any) => `${v}`) : `${value}`;\n    });\n  }\n\n  let rootCandidate: UrlSegmentGroup;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\n\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\nfunction replaceSegment(\n  current: UrlSegmentGroup,\n  oldSegment: UrlSegmentGroup,\n  newSegment: UrlSegmentGroup,\n): UrlSegmentGroup {\n  const children: {[key: string]: UrlSegmentGroup} = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nclass Navigation {\n  constructor(\n    public isAbsolute: boolean,\n    public numberOfDoubleDots: number,\n    public commands: any[],\n  ) {\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new RuntimeError(\n        RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Root segment cannot have matrix parameters',\n      );\n    }\n\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          '{outlets:{}} has to be the last command',\n      );\n    }\n  }\n\n  public toRoot(): boolean {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\n\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands: any[]): Navigation {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n\n  const res: any[] = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets: {[k: string]: any} = {};\n        Object.entries(cmd.outlets).forEach(([name, commands]) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {outlets}];\n      }\n\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') {\n          // skip './a'\n        } else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n\n      return res;\n    }\n\n    return [...res, cmd];\n  }, []);\n\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nclass Position {\n  constructor(\n    public segmentGroup: UrlSegmentGroup,\n    public processChildren: boolean,\n    public index: number,\n  ) {}\n}\n\nfunction findStartingPositionForTargetGroup(\n  nav: Navigation,\n  root: UrlSegmentGroup,\n  target: UrlSegmentGroup,\n): Position {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n\n  if (!target) {\n    // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n    // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n    // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n    // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\n\nfunction createPositionApplyingDoubleDots(\n  group: UrlSegmentGroup,\n  index: number,\n  numberOfDoubleDots: number,\n): Position {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent!;\n    if (!g) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_DOUBLE_DOTS,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\",\n      );\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\n\nfunction getOutlets(commands: unknown[]): {[k: string]: unknown[] | string} {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n\n  return {[PRIMARY_OUTLET]: commands};\n}\n\nfunction updateSegmentGroup(\n  segmentGroup: UrlSegmentGroup | undefined,\n  startIndex: number,\n  commands: any[],\n): UrlSegmentGroup {\n  segmentGroup ??= new UrlSegmentGroup([], {});\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(\n      segmentGroup.segments.slice(m.pathIndex),\n      segmentGroup.children,\n    );\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n\nfunction updateSegmentGroupChildren(\n  segmentGroup: UrlSegmentGroup,\n  startIndex: number,\n  commands: any[],\n): UrlSegmentGroup {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children: {[key: string]: UrlSegmentGroup} = {};\n    // If the set of commands applies to anything other than the primary outlet and the child\n    // segment is an empty path primary segment on its own, we want to apply the commands to the\n    // empty child path rather than here. The outcome is that the empty primary child is effectively\n    // removed from the final output UrlTree. Imagine the following config:\n    //\n    // {path: '', children: [{path: '**', outlet: 'popup'}]}.\n    //\n    // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\n    // navigation with commands\n    // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\n    // root segment because that would result in\n    // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\n    // the `ActivatedRoute` rather than updating the existing one.\n    //\n    // Because empty paths do not appear in the URL segments and the fact that the segments used in\n    // the output `UrlTree` are squashed to eliminate these empty paths where possible\n    // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\n    // it can be hard to determine what is the right thing to do when applying commands to a\n    // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\n    // This code effectively \"squashes\" empty path primary routes when they have no siblings on\n    // the same level of the tree.\n    if (\n      Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) &&\n      segmentGroup.children[PRIMARY_OUTLET] &&\n      segmentGroup.numberOfChildren === 1 &&\n      segmentGroup.children[PRIMARY_OUTLET].segments.length === 0\n    ) {\n      const childrenOfEmptyChild = updateSegmentGroupChildren(\n        segmentGroup.children[PRIMARY_OUTLET],\n        startIndex,\n        commands,\n      );\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n\nfunction prefixedWith(segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n\n  const noMatch = {match: false, pathIndex: 0, commandIndex: 0};\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    // Do not try to consume command as part of the prefixing if it has outlets because it can\n    // contain outlets other than the one being processed. Consuming the outlets command would\n    // result in other outlets being ignored.\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next =\n      currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n\n  return {match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex};\n}\n\nfunction createNewSegmentGroup(\n  segmentGroup: UrlSegmentGroup,\n  startIndex: number,\n  commands: any[],\n): UrlSegmentGroup {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n\n    // if we start with an object literal, we need to reuse the path part from the segment\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = i < commands.length - 1 ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\n\nfunction createNewSegmentChildren(outlets: {[name: string]: unknown[] | string}): {\n  [outlet: string]: UrlSegmentGroup;\n} {\n  const children: {[outlet: string]: UrlSegmentGroup} = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n\nfunction stringify(params: {[key: string]: any}): {[key: string]: string} {\n  const res: {[key: string]: string} = {};\n  Object.entries(params).forEach(([k, v]) => (res[k] = `${v}`));\n  return res;\n}\n\nfunction compare(path: string, params: {[key: string]: any}, segment: UrlSegment): boolean {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NavigationBehaviorOptions, Route} from './models';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport {UrlTree} from './url_tree';\n\n/**\n * Identifies the call or event that triggered a navigation.\n *\n * * 'imperative': Triggered by `router.navigateByUrl()` or `router.navigate()`.\n * * 'popstate' : Triggered by a `popstate` event.\n * * 'hashchange'-: Triggered by a `hashchange` event.\n *\n * @publicApi\n */\nexport type NavigationTrigger = 'imperative' | 'popstate' | 'hashchange';\nexport const IMPERATIVE_NAVIGATION = 'imperative';\n\n/**\n * Identifies the type of a router event.\n *\n * @publicApi\n */\nexport enum EventType {\n  NavigationStart,\n  NavigationEnd,\n  NavigationCancel,\n  NavigationError,\n  RoutesRecognized,\n  ResolveStart,\n  ResolveEnd,\n  GuardsCheckStart,\n  GuardsCheckEnd,\n  RouteConfigLoadStart,\n  RouteConfigLoadEnd,\n  ChildActivationStart,\n  ChildActivationEnd,\n  ActivationStart,\n  ActivationEnd,\n  Scroll,\n  NavigationSkipped,\n}\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event | RouterEvent): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see {@link Event}\n * @see [Router events summary](guide/routing/router-reference#router-events)\n * @publicApi\n */\nexport class RouterEvent {\n  constructor(\n    /** A unique ID that the router assigns to every router navigation. */\n    public id: number,\n    /** The URL that is the destination for this navigation. */\n    public url: string,\n  ) {}\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport class NavigationStart extends RouterEvent {\n  readonly type = EventType.NavigationStart;\n\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   * @see {@link NavigationEnd}\n   * @see {@link NavigationCancel}\n   * @see {@link NavigationError}\n   */\n  navigationTrigger?: NavigationTrigger;\n\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   */\n  restoredState?: {[k: string]: any; navigationId: number} | null;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    navigationTrigger: NavigationTrigger = 'imperative',\n    /** @docsNotRequired */\n    restoredState: {[k: string]: any; navigationId: number} | null = null,\n  ) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationCancel}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nexport class NavigationEnd extends RouterEvent {\n  readonly type = EventType.NavigationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * A code for the `NavigationCancel` event of the `Router` to indicate the\n * reason a navigation failed.\n *\n * @publicApi\n */\nexport enum NavigationCancellationCode {\n  /**\n   * A navigation failed because a guard returned a `UrlTree` to redirect.\n   */\n  Redirect,\n  /**\n   * A navigation failed because a more recent navigation started.\n   */\n  SupersededByNewNavigation,\n  /**\n   * A navigation failed because one of the resolvers completed without emitting a value.\n   */\n  NoDataFromResolver,\n  /**\n   * A navigation failed because a guard returned `false`.\n   */\n  GuardRejected,\n}\n\n/**\n * A code for the `NavigationSkipped` event of the `Router` to indicate the\n * reason a navigation was skipped.\n *\n * @publicApi\n */\nexport enum NavigationSkippedCode {\n  /**\n   * A navigation was skipped because the navigation URL was the same as the current Router URL.\n   */\n  IgnoredSameUrlNavigation,\n  /**\n   * A navigation was skipped because the configured `UrlHandlingStrategy` return `false` for both\n   * the current Router URL and the target of the navigation.\n   *\n   * @see {@link UrlHandlingStrategy}\n   */\n  IgnoredByUrlHandlingStrategy,\n}\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nexport class NavigationCancel extends RouterEvent {\n  readonly type = EventType.NavigationCancel;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /**\n     * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n     * instead for a stable cancellation reason that can be used in production.\n     */\n    public reason: string,\n    /**\n     * A code to indicate why the navigation was canceled. This cancellation code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    readonly code?: NavigationCancellationCode,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation is skipped.\n * This can happen for a couple reasons including onSameUrlHandling\n * is set to `ignore` and the navigation URL is not different than the\n * current state.\n *\n * @publicApi\n */\nexport class NavigationSkipped extends RouterEvent {\n  readonly type = EventType.NavigationSkipped;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /**\n     * A description of why the navigation was skipped. For debug purposes only. Use `code`\n     * instead for a stable skipped reason that can be used in production.\n     */\n    public reason: string,\n    /**\n     * A code to indicate why the navigation was skipped. This code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    readonly code?: NavigationSkippedCode,\n  ) {\n    super(id, url);\n  }\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationCancel}\n *\n * @publicApi\n */\nexport class NavigationError extends RouterEvent {\n  readonly type = EventType.NavigationError;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public error: any,\n    /**\n     * The target of the navigation when the error occurred.\n     *\n     * Note that this can be `undefined` because an error could have occurred before the\n     * `RouterStateSnapshot` was created for the navigation.\n     */\n    readonly target?: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport class RoutesRecognized extends RouterEvent {\n  readonly type = EventType.RoutesRecognized;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see {@link GuardsCheckEnd}\n *\n * @publicApi\n */\nexport class GuardsCheckStart extends RouterEvent {\n  readonly type = EventType.GuardsCheckStart;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see {@link GuardsCheckStart}\n *\n * @publicApi\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  readonly type = EventType.GuardsCheckEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n    /** @docsNotRequired */\n    public shouldActivate: boolean,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see {@link ResolveEnd}\n *\n * @publicApi\n */\nexport class ResolveStart extends RouterEvent {\n  readonly type = EventType.ResolveStart;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ResolveEnd extends RouterEvent {\n  readonly type = EventType.ResolveEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    id: number,\n    /** @docsNotRequired */\n    url: string,\n    /** @docsNotRequired */\n    public urlAfterRedirects: string,\n    /** @docsNotRequired */\n    public state: RouterStateSnapshot,\n  ) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see {@link RouteConfigLoadEnd}\n *\n * @publicApi\n */\nexport class RouteConfigLoadStart {\n  readonly type = EventType.RouteConfigLoadStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public route: Route,\n  ) {}\n  toString(): string {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see {@link RouteConfigLoadStart}\n *\n * @publicApi\n */\nexport class RouteConfigLoadEnd {\n  readonly type = EventType.RouteConfigLoadEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public route: Route,\n  ) {}\n  toString(): string {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see {@link ChildActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ChildActivationStart {\n  readonly type = EventType.ChildActivationStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see {@link ChildActivationStart}\n * @see {@link ResolveStart}\n * @publicApi\n */\nexport class ChildActivationEnd {\n  readonly type = EventType.ChildActivationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ActivationStart {\n  readonly type = EventType.ActivationStart;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationStart}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nexport class ActivationEnd {\n  readonly type = EventType.ActivationEnd;\n\n  constructor(\n    /** @docsNotRequired */\n    public snapshot: ActivatedRouteSnapshot,\n  ) {}\n  toString(): string {\n    const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport class Scroll {\n  readonly type = EventType.Scroll;\n\n  constructor(\n    /** @docsNotRequired */\n    readonly routerEvent: NavigationEnd | NavigationSkipped,\n\n    /** @docsNotRequired */\n    readonly position: [number, number] | null,\n\n    /** @docsNotRequired */\n    readonly anchor: string | null,\n  ) {}\n\n  toString(): string {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\n\nexport class BeforeActivateRoutes {}\nexport class RedirectRequest {\n  constructor(\n    readonly url: UrlTree,\n    readonly navigationBehaviorOptions: NavigationBehaviorOptions | undefined,\n  ) {}\n}\nexport type PrivateRouterEvents = BeforeActivateRoutes | RedirectRequest;\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The events occur in the following sequence:\n *\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\n * the router [lazy loads](guide/routing/common-router-tasks#lazy-loading) a route configuration.\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\n * and the routes are recognized.\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\n * phase of routing.\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\n * begins activating a route's children.\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\n * phase of routing successfully.\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\n * phase of routing.\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\n * phase of routing successfully.\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\n * activating a route's children.\n * * [ActivationEnd](api/router/ActivationEnd): When the router finishes activating a route.\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\n * * [NavigationError](api/router/NavigationError): When navigation fails\n * due to an unexpected error.\n * * [Scroll](api/router/Scroll): When the user scrolls.\n *\n * @publicApi\n */\nexport type Event =\n  | NavigationStart\n  | NavigationEnd\n  | NavigationCancel\n  | NavigationError\n  | RoutesRecognized\n  | GuardsCheckStart\n  | GuardsCheckEnd\n  | RouteConfigLoadStart\n  | RouteConfigLoadEnd\n  | ChildActivationStart\n  | ChildActivationEnd\n  | ActivationStart\n  | ActivationEnd\n  | Scroll\n  | ResolveStart\n  | ResolveEnd\n  | NavigationSkipped;\n\nexport function stringifyEvent(routerEvent: Event): string {\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationSkipped:\n      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.Scroll:\n      const pos = routerEvent.position\n        ? `${routerEvent.position[0]}, ${routerEvent.position[1]}`\n        : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  createEnvironmentInjector,\n  EnvironmentInjector,\n  isStandalone,\n  Type,\n  isNgModule as isNgModule,\n  RuntimeError as RuntimeError,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Route, Routes} from '../models';\nimport {ActivatedRouteSnapshot} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\n * `currentInjector`.\n *\n * @param route The route that might have providers\n * @param currentInjector The parent injector of the `Route`\n */\nexport function getOrCreateRouteInjectorIfNeeded(\n  route: Route,\n  currentInjector: EnvironmentInjector,\n) {\n  if (route.providers && !route._injector) {\n    route._injector = createEnvironmentInjector(\n      route.providers,\n      currentInjector,\n      `Route: ${route.path}`,\n    );\n  }\n  return route._injector ?? currentInjector;\n}\n\nexport function getLoadedRoutes(route: Route): Route[] | undefined {\n  return route._loadedRoutes;\n}\n\nexport function getLoadedInjector(route: Route): EnvironmentInjector | undefined {\n  return route._loadedInjector;\n}\nexport function getLoadedComponent(route: Route): Type<unknown> | undefined {\n  return route._loadedComponent;\n}\n\nexport function getProvidersInjector(route: Route): EnvironmentInjector | undefined {\n  return route._injector;\n}\n\nexport function validateConfig(\n  config: Routes,\n  parentPath: string = '',\n  requireStandaloneComponents = false,\n): void {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    const route: Route = config[i];\n    const fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\n\nexport function assertStandalone(fullPath: string, component: Type<unknown> | undefined) {\n  if (component && isNgModule(component)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n      `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` +\n        `but it must be used with standalone components. Use 'loadChildren' instead.`,\n    );\n  } else if (component && !isStandalone(component)) {\n    throw new RuntimeError(\n      RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n      `Invalid configuration of route '${fullPath}'. The component must be standalone.`,\n    );\n  }\n}\n\nfunction validateNode(route: Route, fullPath: string, requireStandaloneComponents: boolean): void {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `,\n      );\n    }\n    if (Array.isArray(route)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': Array cannot be specified`,\n      );\n    }\n    if (\n      !route.redirectTo &&\n      !route.component &&\n      !route.loadComponent &&\n      !route.children &&\n      !route.loadChildren &&\n      route.outlet &&\n      route.outlet !== PRIMARY_OUTLET\n    ) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`,\n      );\n    }\n    if (route.redirectTo && route.children) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`,\n      );\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`,\n      );\n    }\n    if (route.children && route.loadChildren) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`,\n      );\n    }\n    if (route.redirectTo && (route.component || route.loadComponent)) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`,\n      );\n    }\n    if (route.component && route.loadComponent) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`,\n      );\n    }\n    if (route.redirectTo && route.canActivate) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation ` +\n          `so canActivate will never be executed.`,\n      );\n    }\n    if (route.path && route.matcher) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`,\n      );\n    }\n    if (\n      route.redirectTo === void 0 &&\n      !route.component &&\n      !route.loadComponent &&\n      !route.children &&\n      !route.loadChildren\n    ) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`,\n      );\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`,\n      );\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '${fullPath}': path cannot start with a slash`,\n      );\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTE_CONFIG,\n        `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`,\n      );\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\n\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\nexport function getOutlet(route: Route): string {\n  return route.outlet || PRIMARY_OUTLET;\n}\n\n/**\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n * The order of the configs is otherwise preserved.\n */\nexport function sortByMatchingOutlets(routes: Routes, outletName: string): Routes {\n  const sortedConfig = routes.filter((r) => getOutlet(r) === outletName);\n  sortedConfig.push(...routes.filter((r) => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\n\n/**\n * Gets the first injector in the snapshot's parent tree.\n *\n * If the `Route` has a static list of providers, the returned injector will be the one created from\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\n * loaded config or their static providers.\n *\n * Returns `null` if there is neither this nor any parents have a stored injector.\n *\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\n * also used for getting the correct injector to use for creating components.\n */\nexport function getClosestRouteInjector(\n  snapshot: ActivatedRouteSnapshot | undefined,\n): EnvironmentInjector | null {\n  if (!snapshot) return null;\n\n  // If the current route has its own injector, which is created from the static providers on the\n  // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n  // include the lazy loaded injector from this route.\n  if (snapshot.routeConfig?._injector) {\n    return snapshot.routeConfig._injector;\n  }\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    // Note that the order here is important. `_loadedInjector` stored on the route with\n    // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n    // is created from the static providers on that parent route, so it applies to the children as\n    // well, but only if there is no lazy loaded NgModuleRef injector.\n    if (route?._loadedInjector) return route._loadedInjector;\n    if (route?._injector) return route._injector;\n  }\n\n  return null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef, EnvironmentInjector, Injectable} from '@angular/core';\n\nimport type {RouterOutletContract} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\nimport {getClosestRouteInjector} from './utils/config';\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport class OutletContext {\n  outlet: RouterOutletContract | null = null;\n  route: ActivatedRoute | null = null;\n  children: ChildrenOutletContexts;\n  attachRef: ComponentRef<any> | null = null;\n  get injector(): EnvironmentInjector {\n    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n  }\n\n  constructor(private readonly rootInjector: EnvironmentInjector) {\n    this.children = new ChildrenOutletContexts(this.rootInjector);\n  }\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class ChildrenOutletContexts {\n  // contexts for child outlets, by name.\n  private contexts = new Map<string, OutletContext>();\n\n  /** @nodoc */\n  constructor(private rootInjector: EnvironmentInjector) {}\n\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName: string, outlet: RouterOutletContract): void {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName: string): void {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n      context.attachRef = null;\n    }\n  }\n\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated(): Map<string, OutletContext> {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n\n  onOutletReAttached(contexts: Map<string, OutletContext>) {\n    this.contexts = contexts;\n  }\n\n  getOrCreateContext(childName: string): OutletContext {\n    let context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext(this.rootInjector);\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n\n  getContext(childName: string): OutletContext | null {\n    return this.contexts.get(childName) || null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport class Tree<T> {\n  /** @internal */\n  _root: TreeNode<T>;\n\n  constructor(root: TreeNode<T>) {\n    this._root = root;\n  }\n\n  get root(): T {\n    return this._root.value;\n  }\n\n  /**\n   * @internal\n   */\n  parent(t: T): T | null {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n\n  /**\n   * @internal\n   */\n  children(t: T): T[] {\n    const n = findNode(t, this._root);\n    return n ? n.children.map((t) => t.value) : [];\n  }\n\n  /**\n   * @internal\n   */\n  firstChild(t: T): T | null {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n\n  /**\n   * @internal\n   */\n  siblings(t: T): T[] {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n\n    const c = p[p.length - 2].children.map((c) => c.value);\n    return c.filter((cc) => cc !== t);\n  }\n\n  /**\n   * @internal\n   */\n  pathFromRoot(t: T): T[] {\n    return findPath(t, this._root).map((s) => s.value);\n  }\n}\n\n// DFS for the node matching the value\nfunction findNode<T>(value: T, node: TreeNode<T>): TreeNode<T> | null {\n  if (value === node.value) return node;\n\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n\n  return null;\n}\n\n// Return the path to the node with the given value using DFS\nfunction findPath<T>(value: T, node: TreeNode<T>): TreeNode<T>[] {\n  if (value === node.value) return [node];\n\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n\n  return [];\n}\n\nexport class TreeNode<T> {\n  constructor(\n    public value: T,\n    public children: TreeNode<T>[],\n  ) {}\n\n  toString(): string {\n    return `TreeNode(${this.value})`;\n  }\n}\n\n// Return the list of T indexed by outlet name\nexport function nodeChildrenAsMap<T extends {outlet: string}>(node: TreeNode<T> | null) {\n  const map: {[outlet: string]: TreeNode<T>} = {};\n\n  if (node) {\n    node.children.forEach((child) => (map[child.value.outlet] = child));\n  }\n\n  return map;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Type} from '@angular/core';\nimport {BehaviorSubject, Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Data, ResolveData, Route} from './models';\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET, RouteTitleKey} from './shared';\nimport {equalSegments, UrlSegment} from './url_tree';\nimport {shallowEqual, shallowEqualArrays} from './utils/collection';\nimport {Tree, TreeNode} from './utils/tree';\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see {@link ActivatedRoute}\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nexport class RouterState extends Tree<ActivatedRoute> {\n  /** @internal */\n  constructor(\n    root: TreeNode<ActivatedRoute>,\n    /** The current snapshot of the router state */\n    public snapshot: RouterStateSnapshot,\n  ) {\n    super(root);\n    setRouterState(<RouterState>this, root);\n  }\n\n  override toString(): string {\n    return this.snapshot.toString();\n  }\n}\n\nexport function createEmptyState(rootComponent: Type<any> | null): RouterState {\n  const snapshot = createEmptyStateSnapshot(rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject<string | null>('');\n  const activated = new ActivatedRoute(\n    emptyUrl,\n    emptyParams,\n    emptyQueryParams,\n    fragment,\n    emptyData,\n    PRIMARY_OUTLET,\n    rootComponent,\n    snapshot.root,\n  );\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode<ActivatedRoute>(activated, []), snapshot);\n}\n\nexport function createEmptyStateSnapshot(rootComponent: Type<any> | null): RouterStateSnapshot {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot(\n    [],\n    emptyParams,\n    emptyQueryParams,\n    fragment,\n    emptyData,\n    PRIMARY_OUTLET,\n    rootComponent,\n    null,\n    {},\n  );\n  return new RouterStateSnapshot('', new TreeNode<ActivatedRouteSnapshot>(activated, []));\n}\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nexport class ActivatedRoute {\n  /** The current snapshot of this route */\n  snapshot!: ActivatedRouteSnapshot;\n  /** @internal */\n  _futureSnapshot: ActivatedRouteSnapshot;\n  /** @internal */\n  _routerState!: RouterState;\n  /** @internal */\n  _paramMap?: Observable<ParamMap>;\n  /** @internal */\n  _queryParamMap?: Observable<ParamMap>;\n\n  /** An Observable of the resolved route title */\n  readonly title: Observable<string | undefined>;\n\n  /** An observable of the URL segments matched by this route. */\n  public url: Observable<UrlSegment[]>;\n  /** An observable of the matrix parameters scoped to this route. */\n  public params: Observable<Params>;\n  /** An observable of the query parameters shared by all the routes. */\n  public queryParams: Observable<Params>;\n  /** An observable of the URL fragment shared by all the routes. */\n  public fragment: Observable<string | null>;\n  /** An observable of the static and resolved data of this route. */\n  public data: Observable<Data>;\n\n  /** @internal */\n  constructor(\n    /** @internal */\n    public urlSubject: BehaviorSubject<UrlSegment[]>,\n    /** @internal */\n    public paramsSubject: BehaviorSubject<Params>,\n    /** @internal */\n    public queryParamsSubject: BehaviorSubject<Params>,\n    /** @internal */\n    public fragmentSubject: BehaviorSubject<string | null>,\n    /** @internal */\n    public dataSubject: BehaviorSubject<Data>,\n    /** The outlet name of the route, a constant. */\n    public outlet: string,\n    /** The component of the route, a constant. */\n    public component: Type<any> | null,\n    futureSnapshot: ActivatedRouteSnapshot,\n  ) {\n    this._futureSnapshot = futureSnapshot;\n    this.title = this.dataSubject?.pipe(map((d: Data) => d[RouteTitleKey])) ?? of(undefined);\n    // TODO(atscott): Verify that these can be changed to `.asObservable()` with TGP.\n    this.url = urlSubject;\n    this.params = paramsSubject;\n    this.queryParams = queryParamsSubject;\n    this.fragment = fragmentSubject;\n    this.data = dataSubject;\n  }\n\n  /** The configuration used to match this route. */\n  get routeConfig(): Route | null {\n    return this._futureSnapshot.routeConfig;\n  }\n\n  /** The root of the router state. */\n  get root(): ActivatedRoute {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree. */\n  get parent(): ActivatedRoute | null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree. */\n  get firstChild(): ActivatedRoute | null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree. */\n  get children(): ActivatedRoute[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route. */\n  get pathFromRoot(): ActivatedRoute[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  /**\n   * An Observable that contains a map of the required and optional parameters\n   * specific to the route.\n   * The map supports retrieving single and multiple values from the same parameter.\n   */\n  get paramMap(): Observable<ParamMap> {\n    this._paramMap ??= this.params.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    return this._paramMap;\n  }\n\n  /**\n   * An Observable that contains a map of the query parameters available to all routes.\n   * The map supports retrieving single and multiple values from the query parameter.\n   */\n  get queryParamMap(): Observable<ParamMap> {\n    this._queryParamMap ??= this.queryParams.pipe(\n      map((p: Params): ParamMap => convertToParamMap(p)),\n    );\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\n\nexport type ParamsInheritanceStrategy = 'emptyOnly' | 'always';\n\n/** @internal */\nexport type Inherited = {\n  params: Params;\n  data: Data;\n  resolve: Data;\n};\n\n/**\n * Returns the inherited params, data, and resolve for a given route.\n *\n * By default, we do not inherit parent data unless the current route is path-less or the parent\n * route is component-less.\n */\nexport function getInherited(\n  route: ActivatedRouteSnapshot,\n  parent: ActivatedRouteSnapshot | null,\n  paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n): Inherited {\n  let inherited: Inherited;\n  const {routeConfig} = route;\n  if (\n    parent !== null &&\n    (paramsInheritanceStrategy === 'always' ||\n      // inherit parent data if route is empty path\n      routeConfig?.path === '' ||\n      // inherit parent data if parent was componentless\n      (!parent.component && !parent.routeConfig?.loadComponent))\n  ) {\n    inherited = {\n      params: {...parent.params, ...route.params},\n      data: {...parent.data, ...route.data},\n      resolve: {\n        // Snapshots are created with data inherited from parent and guards (i.e. canActivate) can\n        // change data because it's not frozen...\n        // This first line could be deleted chose to break/disallow mutating the `data` object in\n        // guards.\n        // Note that data from parents still override this mutated data so anyone relying on this\n        // might be surprised that it doesn't work if parent data is inherited but otherwise does.\n        ...route.data,\n        // Ensure inherited resolved data overrides inherited static data\n        ...parent.data,\n        // static data from the current route overrides any inherited data\n        ...routeConfig?.data,\n        // resolved data from current route overrides everything\n        ...route._resolvedData,\n      },\n    };\n  } else {\n    inherited = {\n      params: {...route.params},\n      data: {...route.data},\n      resolve: {...route.data, ...(route._resolvedData ?? {})},\n    };\n  }\n\n  if (routeConfig && hasStaticTitle(routeConfig)) {\n    inherited.resolve[RouteTitleKey] = routeConfig.title;\n  }\n  return inherited;\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class ActivatedRouteSnapshot {\n  /** The configuration used to match this route **/\n  public readonly routeConfig: Route | null;\n  /** @internal */\n  _resolve: ResolveData;\n  /** @internal */\n  _resolvedData?: Data;\n  /** @internal */\n  _routerState!: RouterStateSnapshot;\n  /** @internal */\n  _paramMap?: ParamMap;\n  /** @internal */\n  _queryParamMap?: ParamMap;\n\n  /** The resolved route title */\n  get title(): string | undefined {\n    // Note: This _must_ be a getter because the data is mutated in the resolvers. Title will not be\n    // available at the time of class instantiation.\n    return this.data?.[RouteTitleKey];\n  }\n\n  /** @internal */\n  constructor(\n    /** The URL segments matched by this route */\n    public url: UrlSegment[],\n    /**\n     *  The matrix parameters scoped to this route.\n     *\n     *  You can compute all params (or data) in the router state or to get params outside\n     *  of an activated component by traversing the `RouterState` tree as in the following\n     *  example:\n     *  ```ts\n     *  collectRouteParams(router: Router) {\n     *    let params = {};\n     *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\n     *    while (stack.length > 0) {\n     *      const route = stack.pop()!;\n     *      params = {...params, ...route.params};\n     *      stack.push(...route.children);\n     *    }\n     *    return params;\n     *  }\n     *  ```\n     */\n    public params: Params,\n    /** The query parameters shared by all the routes */\n    public queryParams: Params,\n    /** The URL fragment shared by all the routes */\n    public fragment: string | null,\n    /** The static and resolved data of this route */\n    public data: Data,\n    /** The outlet name of the route */\n    public outlet: string,\n    /** The component of the route */\n    public component: Type<any> | null,\n    routeConfig: Route | null,\n    resolve: ResolveData,\n  ) {\n    this.routeConfig = routeConfig;\n    this._resolve = resolve;\n  }\n\n  /** The root of the router state */\n  get root(): ActivatedRouteSnapshot {\n    return this._routerState.root;\n  }\n\n  /** The parent of this route in the router state tree */\n  get parent(): ActivatedRouteSnapshot | null {\n    return this._routerState.parent(this);\n  }\n\n  /** The first child of this route in the router state tree */\n  get firstChild(): ActivatedRouteSnapshot | null {\n    return this._routerState.firstChild(this);\n  }\n\n  /** The children of this route in the router state tree */\n  get children(): ActivatedRouteSnapshot[] {\n    return this._routerState.children(this);\n  }\n\n  /** The path from the root of the router state tree to this route */\n  get pathFromRoot(): ActivatedRouteSnapshot[] {\n    return this._routerState.pathFromRoot(this);\n  }\n\n  get paramMap(): ParamMap {\n    this._paramMap ??= convertToParamMap(this.params);\n    return this._paramMap;\n  }\n\n  get queryParamMap(): ParamMap {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    const url = this.url.map((segment) => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {\n  /** @internal */\n  constructor(\n    /** The url from which this snapshot was created */\n    public url: string,\n    root: TreeNode<ActivatedRouteSnapshot>,\n  ) {\n    super(root);\n    setRouterState(<RouterStateSnapshot>this, root);\n  }\n\n  override toString(): string {\n    return serializeNode(this._root);\n  }\n}\n\nfunction setRouterState<U, T extends {_routerState: U}>(state: U, node: TreeNode<T>): void {\n  node.value._routerState = state;\n  node.children.forEach((c) => setRouterState(state, c));\n}\n\nfunction serializeNode(node: TreeNode<ActivatedRouteSnapshot>): string {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\n\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\nexport function advanceActivatedRoute(route: ActivatedRoute): void {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParamsSubject.next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragmentSubject.next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.paramsSubject.next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.urlSubject.next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.dataSubject.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n\n    // this is for resolved data\n    route.dataSubject.next(route._futureSnapshot.data);\n  }\n}\n\nexport function equalParamsAndUrlSegments(\n  a: ActivatedRouteSnapshot,\n  b: ActivatedRouteSnapshot,\n): boolean {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n\n  return (\n    equalUrlParams &&\n    !parentsMismatch &&\n    (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent!))\n  );\n}\n\nexport function hasStaticTitle(config: Route) {\n  return typeof config.title === 'string' || config.title === null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ChangeDetectorRef,\n  ComponentRef,\n  Directive,\n  EnvironmentInjector,\n  EventEmitter,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  reflectComponentType,\n  SimpleChanges,\n  ViewContainerRef,\n  RuntimeError as RuntimeError,\n  Signal,\n  input,\n} from '@angular/core';\nimport {combineLatest, of, Subscription} from 'rxjs';\nimport {switchMap} from 'rxjs/operators';\n\nimport {RuntimeErrorCode} from '../errors';\nimport {Data} from '../models';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * An `InjectionToken` provided by the `RouterOutlet` and can be set using the `routerOutletData`\n * input.\n *\n * When unset, this value is `null` by default.\n *\n * @usageNotes\n *\n * To set the data from the template of the component with `router-outlet`:\n * ```html\n * <router-outlet [routerOutletData]=\"{name: 'Angular'}\" />\n * ```\n *\n * To read the data in the routed component:\n * ```ts\n * data = inject(ROUTER_OUTLET_DATA) as Signal<{name: string}>;\n * ```\n *\n * @publicApi\n */\nexport const ROUTER_OUTLET_DATA = new InjectionToken<Signal<unknown | undefined>>(\n  ngDevMode ? 'RouterOutlet data' : '',\n);\n\n/**\n * An interface that defines the contract for developing a component outlet for the `Router`.\n *\n * An outlet acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * A router outlet should register itself with the `Router` via\n * `ChildrenOutletContexts#onChildOutletCreated` and unregister with\n * `ChildrenOutletContexts#onChildOutletDestroyed`. When the `Router` identifies a matched `Route`,\n * it looks for a registered outlet in the `ChildrenOutletContexts` and activates it.\n *\n * @see {@link ChildrenOutletContexts}\n * @publicApi\n */\nexport interface RouterOutletContract {\n  /**\n   * Whether the given outlet is activated.\n   *\n   * An outlet is considered \"activated\" if it has an active component.\n   */\n  isActivated: boolean;\n\n  /** The instance of the activated component or `null` if the outlet is not activated. */\n  component: Object | null;\n\n  /**\n   * The `Data` of the `ActivatedRoute` snapshot.\n   */\n  activatedRouteData: Data;\n\n  /**\n   * The `ActivatedRoute` for the outlet or `null` if the outlet is not activated.\n   */\n  activatedRoute: ActivatedRoute | null;\n\n  /**\n   * Called by the `Router` when the outlet should activate (create a component).\n   */\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector): void;\n\n  /**\n   * A request to destroy the currently activated component.\n   *\n   * When a `RouteReuseStrategy` indicates that an `ActivatedRoute` should be removed but stored for\n   * later re-use rather than destroyed, the `Router` will call `detach` instead.\n   */\n  deactivate(): void;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree.\n   *\n   * This is similar to `deactivate`, but the activated component should _not_ be destroyed.\n   * Instead, it is returned so that it can be reattached later via the `attach` method.\n   */\n  detach(): ComponentRef<unknown>;\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree.\n   */\n  attach(ref: ComponentRef<unknown>, activatedRoute: ActivatedRoute): void;\n\n  /**\n   * Emits an activate event when a new component is instantiated\n   **/\n  activateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a deactivate event when a component is destroyed.\n   */\n  deactivateEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  attachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  detachEvents?: EventEmitter<unknown>;\n\n  /**\n   * Used to indicate that the outlet is able to bind data from the `Router` to the outlet\n   * component's inputs.\n   *\n   * When this is `undefined` or `false` and the developer has opted in to the\n   * feature using `withComponentInputBinding`, a warning will be logged in dev mode if this outlet\n   * is used in the application.\n   */\n  readonly supportsBindingToComponentInputs?: true;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```html\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```html\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see {@link RouterLink}\n * @see {@link Route}\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: 'router-outlet',\n  exportAs: 'outlet',\n})\nexport class RouterOutlet implements OnDestroy, OnInit, RouterOutletContract {\n  private activated: ComponentRef<any> | null = null;\n  /** @internal */\n  get activatedComponentRef(): ComponentRef<any> | null {\n    return this.activated;\n  }\n  private _activatedRoute: ActivatedRoute | null = null;\n  /**\n   * The name of the outlet\n   *\n   */\n  @Input() name = PRIMARY_OUTLET;\n\n  @Output('activate') activateEvents = new EventEmitter<any>();\n  @Output('deactivate') deactivateEvents = new EventEmitter<any>();\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  @Output('attach') attachEvents = new EventEmitter<unknown>();\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  @Output('detach') detachEvents = new EventEmitter<unknown>();\n\n  /**\n   * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\n   *\n   * When unset, the value of the token is `undefined` by default.\n   */\n  readonly routerOutletData = input<unknown>(undefined);\n\n  private parentContexts = inject(ChildrenOutletContexts);\n  private location = inject(ViewContainerRef);\n  private changeDetector = inject(ChangeDetectorRef);\n  private inputBinder = inject(INPUT_BINDER, {optional: true});\n  /** @nodoc */\n  readonly supportsBindingToComponentInputs = true;\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['name']) {\n      const {firstChange, previousValue} = changes['name'];\n      if (firstChange) {\n        // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\n        // input is set at all, we need to centrally handle the first change there.\n        return;\n      }\n\n      // unregister with the old name\n      if (this.isTrackedInParentContexts(previousValue)) {\n        this.deactivate();\n        this.parentContexts.onChildOutletDestroyed(previousValue);\n      }\n      // register the new name\n      this.initializeOutletWithName();\n    }\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    // Ensure that the registered outlet is this one before removing it on the context.\n    if (this.isTrackedInParentContexts(this.name)) {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n    this.inputBinder?.unsubscribeFromRouteData(this);\n  }\n\n  private isTrackedInParentContexts(outletName: string) {\n    return this.parentContexts.getContext(outletName)?.outlet === this;\n  }\n\n  /** @nodoc */\n  ngOnInit(): void {\n    this.initializeOutletWithName();\n  }\n\n  private initializeOutletWithName() {\n    this.parentContexts.onChildOutletCreated(this.name, this);\n    if (this.activated) {\n      return;\n    }\n\n    // If the outlet was not instantiated at the time the route got activated we need to populate\n    // the outlet when it is initialized (ie inside a NgIf)\n    const context = this.parentContexts.getContext(this.name);\n    if (context?.route) {\n      if (context.attachRef) {\n        // `attachRef` is populated when there is an existing component to mount\n        this.attach(context.attachRef, context.route);\n      } else {\n        // otherwise the component defined in the configuration is created\n        this.activateWith(context.route, context.injector);\n      }\n    }\n  }\n\n  get isActivated(): boolean {\n    return !!this.activated;\n  }\n\n  /**\n   * @returns The currently activated component instance.\n   * @throws An error if the outlet is not activated.\n   */\n  get component(): Object {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    return this.activated.instance;\n  }\n\n  get activatedRoute(): ActivatedRoute {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    return this._activatedRoute as ActivatedRoute;\n  }\n\n  get activatedRouteData(): Data {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  detach(): ComponentRef<any> {\n    if (!this.activated)\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_NOT_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated',\n      );\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.detachEvents.emit(cmp.instance);\n    return cmp;\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute) {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.attachEvents.emit(ref.instance);\n  }\n\n  deactivate(): void {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n\n  activateWith(activatedRoute: ActivatedRoute, environmentInjector: EnvironmentInjector) {\n    if (this.isActivated) {\n      throw new RuntimeError(\n        RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          'Cannot activate an already activated outlet',\n      );\n    }\n    this._activatedRoute = activatedRoute;\n    const location = this.location;\n    const snapshot = activatedRoute.snapshot;\n    const component = snapshot.component!;\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(\n      activatedRoute,\n      childContexts,\n      location.injector,\n      this.routerOutletData,\n    );\n\n    this.activated = location.createComponent(component, {\n      index: location.length,\n      injector,\n      environmentInjector: environmentInjector,\n    });\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.activateEvents.emit(this.activated.instance);\n  }\n}\n\nclass OutletInjector implements Injector {\n  /**\n   * This injector has a special handing for the `ActivatedRoute` and\n   * `ChildrenOutletContexts` tokens: it returns corresponding values for those\n   * tokens dynamically. This behavior is different from the regular injector logic,\n   * when we initialize and store a value, which is later returned for all inject\n   * requests.\n   *\n   * In some cases (e.g. when using `@defer`), this dynamic behavior requires special\n   * handling. This function allows to identify an instance of the `OutletInjector` and\n   * create an instance of it without referring to the class itself (so this logic can\n   * be invoked from the `core` package). This helps to retain dynamic behavior for the\n   * mentioned tokens.\n   *\n   * Note: it's a temporary solution and we should explore how to support this case better.\n   */\n  private __ngOutletInjector(parentInjector: Injector) {\n    return new OutletInjector(this.route, this.childContexts, parentInjector, this.outletData);\n  }\n\n  constructor(\n    private route: ActivatedRoute,\n    private childContexts: ChildrenOutletContexts,\n    private parent: Injector,\n    private outletData: Signal<unknown>,\n  ) {}\n\n  get(token: any, notFoundValue?: any): any {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n\n    if (token === ROUTER_OUTLET_DATA) {\n      return this.outletData;\n    }\n\n    return this.parent.get(token, notFoundValue);\n  }\n}\n\nexport const INPUT_BINDER = new InjectionToken<RoutedComponentInputBinder>('');\n\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\n@Injectable()\nexport class RoutedComponentInputBinder {\n  private outletDataSubscriptions = new Map<RouterOutlet, Subscription>();\n\n  bindActivatedRouteToOutletComponent(outlet: RouterOutlet) {\n    this.unsubscribeFromRouteData(outlet);\n    this.subscribeToRouteData(outlet);\n  }\n\n  unsubscribeFromRouteData(outlet: RouterOutlet) {\n    this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n    this.outletDataSubscriptions.delete(outlet);\n  }\n\n  private subscribeToRouteData(outlet: RouterOutlet) {\n    const {activatedRoute} = outlet;\n    const dataSubscription = combineLatest([\n      activatedRoute.queryParams,\n      activatedRoute.params,\n      activatedRoute.data,\n    ])\n      .pipe(\n        switchMap(([queryParams, params, data], index) => {\n          data = {...queryParams, ...params, ...data};\n          // Get the first result from the data subscription synchronously so it's available to\n          // the component as soon as possible (and doesn't require a second change detection).\n          if (index === 0) {\n            return of(data);\n          }\n          // Promise.resolve is used to avoid synchronously writing the wrong data when\n          // two of the Observables in the `combineLatest` stream emit one after\n          // another.\n          return Promise.resolve(data);\n        }),\n      )\n      .subscribe((data) => {\n        // Outlet may have been deactivated or changed names to be associated with a different\n        // route\n        if (\n          !outlet.isActivated ||\n          !outlet.activatedComponentRef ||\n          outlet.activatedRoute !== activatedRoute ||\n          activatedRoute.component === null\n        ) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n\n        const mirror = reflectComponentType(activatedRoute.component);\n        if (!mirror) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n\n        for (const {templateName} of mirror.inputs) {\n          outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n        }\n      });\n\n    this.outletDataSubscriptions.set(outlet, dataSubscription);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BehaviorSubject} from 'rxjs';\n\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from './route_reuse_strategy';\nimport {\n  ActivatedRoute,\n  ActivatedRouteSnapshot,\n  RouterState,\n  RouterStateSnapshot,\n} from './router_state';\nimport {TreeNode} from './utils/tree';\n\nexport function createRouterState(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: RouterStateSnapshot,\n  prevState: RouterState,\n): RouterState {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n\nfunction createNode(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: TreeNode<ActivatedRouteSnapshot>,\n  prevState?: TreeNode<ActivatedRoute>,\n): TreeNode<ActivatedRoute> {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode<ActivatedRoute>(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      // retrieve an activated route that is used to be displayed, but is not currently displayed\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree = (detachedRouteHandle as DetachedRouteHandleInternal).route;\n        tree.value._futureSnapshot = curr.value;\n        tree.children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n        return tree;\n      }\n    }\n\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n    return new TreeNode<ActivatedRoute>(value, children);\n  }\n}\n\nfunction createOrReuseChildren(\n  routeReuseStrategy: RouteReuseStrategy,\n  curr: TreeNode<ActivatedRouteSnapshot>,\n  prevState: TreeNode<ActivatedRoute>,\n) {\n  return curr.children.map((child) => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\n\nfunction createActivatedRoute(c: ActivatedRouteSnapshot) {\n  return new ActivatedRoute(\n    new BehaviorSubject(c.url),\n    new BehaviorSubject(c.params),\n    new BehaviorSubject(c.queryParams),\n    new BehaviorSubject(c.fragment),\n    new BehaviorSubject(c.data),\n    c.outlet,\n    c.component,\n    c,\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EnvironmentInjector,\n  EnvironmentProviders,\n  NgModuleFactory,\n  Provider,\n  ProviderToken,\n  Type,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport type {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport type {UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\n\n/**\n * How to handle a navigation request to the current URL. One of:\n *\n * - `'ignore'` : The router ignores the request if it is the same as the current state.\n * - `'reload'` : The router processes the URL even if it is not different from the current state.\n * One example of when you might want to use this option is if a `canMatch` guard depends on the\n * application state and initially rejects navigation to a route. After fixing the state, you want\n * to re-navigate to the same URL so that the route with the `canMatch` guard can activate.\n *\n * Note that this only configures whether or not the Route reprocesses the URL and triggers related\n * actions and events like redirects, guards, and resolvers. By default, the router re-uses a\n * component instance when it re-navigates to the same component type without visiting a different\n * component first. This behavior is configured by the `RouteReuseStrategy`. In order to reload\n * routed components on same url navigation, you need to set `onSameUrlNavigation` to `'reload'`\n * _and_ provide a `RouteReuseStrategy` which returns `false` for `shouldReuseRoute`. Additionally,\n * resolvers and most guards for routes do not run unless the path or path params have changed\n * (configured by `runGuardsAndResolvers`).\n *\n * @publicApi\n * @see {@link RouteReuseStrategy}\n * @see {@link RunGuardsAndResolvers}\n * @see {@link NavigationBehaviorOptions}\n * @see {@link RouterConfigOptions}\n */\nexport type OnSameUrlNavigation = 'reload' | 'ignore';\n\n/**\n * The `InjectionToken` and `@Injectable` classes for guards and resolvers are deprecated in favor\n * of plain JavaScript functions instead. Dependency injection can still be achieved using the\n * [`inject`](api/core/inject) function from `@angular/core` and an injectable class can be used as\n * a functional guard using [`inject`](api/core/inject): `canActivate: [() =>\n * inject(myGuard).canActivate()]`.\n *\n * @deprecated\n * @see {@link CanMatchFn}\n * @see {@link CanLoadFn}\n * @see {@link CanActivateFn}\n * @see {@link CanActivateChildFn}\n * @see {@link CanDeactivateFn}\n * @see {@link ResolveFn}\n * @see {@link /api/core/inject inject}\n * @publicApi\n */\nexport type DeprecatedGuard = ProviderToken<any> | any;\n\n/**\n * The supported types that can be returned from a `Router` guard.\n *\n * @see [Routing guide](guide/routing/common-router-tasks#preventing-unauthorized-access)\n * @publicApi\n */\nexport type GuardResult = boolean | UrlTree | RedirectCommand;\n\n/**\n * Can be returned by a `Router` guard to instruct the `Router` to redirect rather than continue\n * processing the path of the in-flight navigation. The `redirectTo` indicates _where_ the new\n * navigation should go to and the optional `navigationBehaviorOptions` can provide more information\n * about _how_ to perform the navigation.\n *\n * ```ts\n * const route: Route = {\n *   path: \"user/:userId\",\n *   component: User,\n *   canActivate: [\n *     () => {\n *       const router = inject(Router);\n *       const authService = inject(AuthenticationService);\n *\n *       if (!authService.isLoggedIn()) {\n *         const loginPath = router.parseUrl(\"/login\");\n *         return new RedirectCommand(loginPath, {\n *           skipLocationChange: \"true\",\n *         });\n *       }\n *\n *       return true;\n *     },\n *   ],\n * };\n * ```\n * @see [Routing guide](guide/routing/common-router-tasks#preventing-unauthorized-access)\n *\n * @publicApi\n */\nexport class RedirectCommand {\n  constructor(\n    readonly redirectTo: UrlTree,\n    readonly navigationBehaviorOptions?: NavigationBehaviorOptions,\n  ) {}\n}\n\n/**\n * Type used to represent a value which may be synchronous or async.\n *\n * @publicApi\n */\nexport type MaybeAsync<T> = T | Observable<T> | Promise<T>;\n\n/**\n * Represents a route configuration for the Router service.\n * An array of `Route` objects, used in `Router.config` and for nested route configurations\n * in `Route.children`.\n *\n * @see {@link Route}\n * @see {@link Router}\n * @see [Router configuration guide](guide/routing/router-reference#configuration)\n * @publicApi\n */\nexport type Routes = Route[];\n\n/**\n * Represents the result of matching URLs with a custom matching function.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @see {@link UrlMatcher}\n * @publicApi\n */\nexport type UrlMatchResult = {\n  consumed: UrlSegment[];\n  posParams?: {[name: string]: UrlSegment};\n};\n\n/**\n * A function for matching a route against URLs. Implement a custom URL matcher\n * for `Route.matcher` when a combination of `path` and `pathMatch`\n * is not expressive enough. Cannot be used together with `path` and `pathMatch`.\n *\n * The function takes the following arguments and returns a `UrlMatchResult` object.\n * * *segments* : An array of URL segments.\n * * *group* : A segment group.\n * * *route* : The route to match against.\n *\n * The following example implementation matches HTML files.\n *\n * ```ts\n * export function htmlFiles(url: UrlSegment[]) {\n *   return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * export const routes = [{ matcher: htmlFiles, component: AnyComponent }];\n * ```\n *\n * @publicApi\n */\nexport type UrlMatcher = (\n  segments: UrlSegment[],\n  group: UrlSegmentGroup,\n  route: Route,\n) => UrlMatchResult | null;\n\n/**\n *\n * Represents static data associated with a particular route.\n *\n * @see {@link Route#data}\n *\n * @publicApi\n */\nexport type Data = {\n  [key: string | symbol]: any;\n};\n\n/**\n *\n * Represents the resolved data associated with a particular route.\n *\n * Returning a `RedirectCommand` directs the router to cancel the current navigation and redirect to\n * the location provided in the `RedirectCommand`. Note that there are no ordering guarantees when\n * resolvers execute. If multiple resolvers would return a `RedirectCommand`, only the first one\n * returned will be used.\n *\n * @see {@link Route#resolve}\n *\n * @publicApi\n */\nexport type ResolveData = {\n  [key: string | symbol]: ResolveFn<unknown> | DeprecatedGuard;\n};\n\n/**\n * An ES Module object with a default export of the given type.\n *\n * @see {@link Route#loadComponent}\n * @see {@link LoadChildrenCallback}\n *\n * @publicApi\n */\nexport interface DefaultExport<T> {\n  /**\n   * Default exports are bound under the name `\"default\"`, per the ES Module spec:\n   * https://tc39.es/ecma262/#table-export-forms-mapping-to-exportentry-records\n   */\n  default: T;\n}\n\n/**\n *\n * A function that is called to resolve a collection of lazy-loaded routes.\n * Must be an arrow function of the following form:\n * `() => import('...').then(mod => mod.MODULE)`\n * or\n * `() => import('...').then(mod => mod.ROUTES)`\n *\n * For example:\n *\n * ```ts\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n * or\n * ```ts\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.routes').then(mod => mod.ROUTES),\n * }];\n * ```\n *\n * If the lazy-loaded routes are exported via a `default` export, the `.then` can be omitted:\n * ```ts\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.routes'),\n * }];\n * ```\n *\n * @see {@link Route#loadChildren}\n * @publicApi\n */\nexport type LoadChildrenCallback = () =>\n  | Type<any>\n  | NgModuleFactory<any>\n  | Routes\n  | Observable<Type<any> | Routes | DefaultExport<Type<any>> | DefaultExport<Routes>>\n  | Promise<\n      NgModuleFactory<any> | Type<any> | Routes | DefaultExport<Type<any>> | DefaultExport<Routes>\n    >;\n\n/**\n *\n * A function that returns a set of routes to load.\n *\n * @see {@link LoadChildrenCallback}\n * @publicApi\n */\nexport type LoadChildren = LoadChildrenCallback;\n\n/**\n *\n * How to handle query parameters in a router link.\n * One of:\n * - `\"merge\"` : Merge new parameters with current parameters.\n * - `\"preserve\"` : Preserve current parameters.\n * - `\"replace\"` : Replace current parameters with new parameters. This is the default behavior.\n * - `\"\"` : For legacy reasons, the same as `'replace'`.\n *\n * @see {@link UrlCreationOptions#queryParamsHandling}\n * @see {@link RouterLink}\n * @publicApi\n */\nexport type QueryParamsHandling = 'merge' | 'preserve' | 'replace' | '';\n\n/**\n * The type for the function that can be used to handle redirects when the path matches a `Route` config.\n *\n * The `RedirectFunction` does have access to the full\n * `ActivatedRouteSnapshot` interface. Some data are not accurately known\n * at the route matching phase. For example, resolvers are not run until\n * later, so any resolved title would not be populated. The same goes for lazy\n * loaded components. This is also true for all the snapshots up to the\n * root, so properties that include parents (root, parent, pathFromRoot)\n * are also excluded. And naturally, the full route matching hasn't yet\n * happened so firstChild and children are not available either.\n *\n * @see {@link Route#redirectTo}\n * @publicApi\n */\nexport type RedirectFunction = (\n  redirectData: Pick<\n    ActivatedRouteSnapshot,\n    'routeConfig' | 'url' | 'params' | 'queryParams' | 'fragment' | 'data' | 'outlet' | 'title'\n  >,\n) => string | UrlTree;\n\n/**\n * A policy for when to run guards and resolvers on a route.\n *\n * Guards and/or resolvers will always run when a route is activated or deactivated. When a route is\n * unchanged, the default behavior is the same as `paramsChange`.\n *\n * `paramsChange` : Rerun the guards and resolvers when path or\n * path param changes. This does not include query parameters. This option is the default.\n * - `always` : Run on every execution.\n * - `pathParamsChange` : Rerun guards and resolvers when the path params\n * change. This does not compare matrix or query parameters.\n * - `paramsOrQueryParamsChange` : Run when path, matrix, or query parameters change.\n * - `pathParamsOrQueryParamsChange` : Rerun guards and resolvers when the path params\n * change or query params have changed. This does not include matrix parameters.\n *\n * @see {@link Route#runGuardsAndResolvers}\n * @publicApi\n */\nexport type RunGuardsAndResolvers =\n  | 'pathParamsChange'\n  | 'pathParamsOrQueryParamsChange'\n  | 'paramsChange'\n  | 'paramsOrQueryParamsChange'\n  | 'always'\n  | ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) => boolean);\n\n/**\n * A configuration object that defines a single route.\n * A set of routes are collected in a `Routes` array to define a `Router` configuration.\n * The router attempts to match segments of a given URL against each route,\n * using the configuration options defined in this object.\n *\n * Supports static, parameterized, redirect, and wildcard routes, as well as\n * custom route data and resolve methods.\n *\n * For detailed usage information, see the [Routing Guide](guide/routing/common-router-tasks).\n *\n * @usageNotes\n *\n * ### Simple Configuration\n *\n * The following route specifies that when navigating to, for example,\n * `/team/11/user/bob`, the router creates the 'Team' component\n * with the 'User' child component in it.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * ### Multiple Outlets\n *\n * The following route creates sibling components with multiple outlets.\n * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to\n * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * ### Wild Cards\n *\n * The following route uses wild-card notation to specify a component\n * that is always instantiated regardless of where you navigate to.\n *\n * ```ts\n * [{\n *   path: '**',\n *   component: WildcardComponent\n * }]\n * ```\n *\n * ### Redirects\n *\n * The following route uses the `redirectTo` property to ignore a segment of\n * a given URL when looking for a child path.\n *\n * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment\n * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates\n * the Team component with the User child component in it.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * The redirect path can be relative, as shown in this example, or absolute.\n * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',\n * the result URL is also absolute, '/user/jim'.\n\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any URL segments.\n *\n * In the following configuration, when navigating to\n * `/team/11`, the router instantiates the 'AllUsers' component.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * Empty-path routes can have children. In the following example, when navigating\n * to `/team/11/user/jim`, the router instantiates the wrapper component with\n * the user component in it.\n *\n * Note that an empty path route inherits its parent's parameters and data.\n *\n * ```ts\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * ### Matching Strategy\n *\n * The default path-match strategy is 'prefix', which means that the router\n * checks URL elements from the left to see if the URL matches a specified path.\n * For example, '/team/11/user' matches 'team/:id'.\n *\n * ```ts\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * You can specify the path-match strategy 'full' to make sure that the path\n * covers the whole unconsumed URL. It is important to do this when redirecting\n * empty-path routes. Otherwise, because an empty path is a prefix of any URL,\n * the router would apply the redirect even when navigating to the redirect destination,\n * creating an endless loop.\n *\n * In the following example, supplying the 'full' `pathMatch` strategy ensures\n * that the router applies the redirect if and only if navigating to '/'.\n *\n * ```ts\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * You can share parameters between sibling components.\n * For example, suppose that two sibling components should go next to each other,\n * and both of them require an ID parameter. You can accomplish this using a route\n * that does not specify a component at the top level.\n *\n * In the following example, 'MainChild' and 'AuxChild' are siblings.\n * When navigating to 'parent/10/(a//aux:b)', the route instantiates\n * the main child and aux child components next to each other.\n * For this to work, the application component must have the primary and aux outlets defined.\n *\n * ```ts\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * The router merges the parameters, data, and resolve of the componentless\n * parent into the parameters, data, and resolve of the children.\n *\n * This is especially useful when child components are defined\n * with an empty path string, as in the following example.\n * With this configuration, navigating to '/parent/10' creates\n * the main child and aux components.\n *\n * ```ts\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up application load time by splitting the application\n * into multiple bundles and loading them on demand.\n * To use lazy loading, provide the `loadChildren` property in the `Route` object,\n * instead of the `children` property.\n *\n * Given the following example route, the router will lazy load\n * the associated module on demand using the browser native import system.\n *\n * ```ts\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * @publicApi\n */\nexport interface Route {\n  /**\n   * Used to define a page title for the route. This can be a static string or an `Injectable` that\n   * implements `Resolve`.\n   *\n   * @see {@link TitleStrategy}\n   */\n  title?: string | Type<Resolve<string>> | ResolveFn<string>;\n\n  /**\n   * The path to match against. Cannot be used together with a custom `matcher` function.\n   * A URL string that uses router matching notation.\n   * Can be a wild card (`**`) that matches any URL (see Usage Notes below).\n   * Default is \"/\" (the root path).\n   *\n   */\n  path?: string;\n  /**\n   * The path-matching strategy, one of 'prefix' or 'full'.\n   * Default is 'prefix'.\n   *\n   * By default, the router checks URL elements from the left to see if the URL\n   * matches a given path and stops when there is a config match. Importantly there must still be a\n   * config match for each segment of the URL. For example, '/team/11/user' matches the prefix\n   * 'team/:id' if one of the route's children matches the segment 'user'. That is, the URL\n   * '/team/11/user' matches the config\n   * `{path: 'team/:id', children: [{path: ':user', component: User}]}`\n   * but does not match when there are no children as in `{path: 'team/:id', component: Team}`.\n   *\n   * The path-match strategy 'full' matches against the entire URL.\n   * It is important to do this when redirecting empty-path routes.\n   * Otherwise, because an empty path is a prefix of any URL,\n   * the router would apply the redirect even when navigating\n   * to the redirect destination, creating an endless loop.\n   *\n   */\n  pathMatch?: 'prefix' | 'full';\n  /**\n   * A custom URL-matching function. Cannot be used together with `path`.\n   */\n  matcher?: UrlMatcher;\n  /**\n   * The component to instantiate when the path matches.\n   * Can be empty if child routes specify components.\n   */\n  component?: Type<any>;\n\n  /**\n   * An object specifying a lazy-loaded component.\n   */\n  loadComponent?: () =>\n    | Type<unknown>\n    | Observable<Type<unknown> | DefaultExport<Type<unknown>>>\n    | Promise<Type<unknown> | DefaultExport<Type<unknown>>>;\n  /**\n   * Filled for routes `loadComponent` once the component is loaded.\n   * @internal\n   */\n  _loadedComponent?: Type<unknown>;\n\n  /**\n   * A URL or function that returns a URL to redirect to when the path matches.\n   *\n   * Absolute if the URL begins with a slash (/) or the function returns a `UrlTree`, otherwise\n   * relative to the path URL.\n   *\n   * The `RedirectFunction` is run in an injection context so it can call `inject` to get any\n   * required dependencies.\n   *\n   * When not present, router does not redirect.\n   */\n  redirectTo?: string | RedirectFunction;\n  /**\n   * Name of a `RouterOutlet` object where the component can be placed\n   * when the path matches.\n   */\n  outlet?: string;\n  /**\n   * An array of `CanActivateFn` or DI tokens used to look up `CanActivate()`\n   * handlers, in order to determine if the current user is allowed to\n   * activate the component. By default, any user can activate.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   */\n  canActivate?: Array<CanActivateFn | DeprecatedGuard>;\n  /**\n   * An array of `CanMatchFn` or DI tokens used to look up `CanMatch()`\n   * handlers, in order to determine if the current user is allowed to\n   * match the `Route`. By default, any route can match.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   */\n  canMatch?: Array<CanMatchFn | DeprecatedGuard>;\n  /**\n   * An array of `CanActivateChildFn` or DI tokens used to look up `CanActivateChild()` handlers,\n   * in order to determine if the current user is allowed to activate\n   * a child of the component. By default, any user can activate a child.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   */\n  canActivateChild?: Array<CanActivateChildFn | DeprecatedGuard>;\n  /**\n   * An array of `CanDeactivateFn` or DI tokens used to look up `CanDeactivate()`\n   * handlers, in order to determine if the current user is allowed to\n   * deactivate the component. By default, any user can deactivate.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   */\n  canDeactivate?: Array<CanDeactivateFn<any> | DeprecatedGuard>;\n  /**\n   * An array of `CanLoadFn` or DI tokens used to look up `CanLoad()`\n   * handlers, in order to determine if the current user is allowed to\n   * load the component. By default, any user can load.\n   *\n   * When using a function rather than DI tokens, the function can call `inject` to get any required\n   * dependencies. This `inject` call must be done in a synchronous context.\n   * @deprecated Use `canMatch` instead\n   */\n  canLoad?: Array<CanLoadFn | DeprecatedGuard>;\n  /**\n   * Additional developer-defined data provided to the component via\n   * `ActivatedRoute`. By default, no additional data is passed.\n   */\n  data?: Data;\n  /**\n   * A map of DI tokens used to look up data resolvers. See `Resolve`.\n   */\n  resolve?: ResolveData;\n  /**\n   * An array of child `Route` objects that specifies a nested route\n   * configuration.\n   */\n  children?: Routes;\n  /**\n   * An object specifying lazy-loaded child routes.\n   */\n  loadChildren?: LoadChildren;\n\n  /**\n   * A policy for when to run guards and resolvers on a route.\n   *\n   * Guards and/or resolvers will always run when a route is activated or deactivated. When a route\n   * is unchanged, the default behavior is the same as `paramsChange`.\n   *\n   * `paramsChange` : Rerun the guards and resolvers when path or\n   * path param changes. This does not include query parameters. This option is the default.\n   * - `always` : Run on every execution.\n   * - `pathParamsChange` : Rerun guards and resolvers when the path params\n   * change. This does not compare matrix or query parameters.\n   * - `paramsOrQueryParamsChange` : Run when path, matrix, or query parameters change.\n   * - `pathParamsOrQueryParamsChange` : Rerun guards and resolvers when the path params\n   * change or query params have changed. This does not include matrix parameters.\n   *\n   * @see {@link RunGuardsAndResolvers}\n   */\n  runGuardsAndResolvers?: RunGuardsAndResolvers;\n\n  /**\n   * A `Provider` array to use for this `Route` and its `children`.\n   *\n   * The `Router` will create a new `EnvironmentInjector` for this\n   * `Route` and use it for this `Route` and its `children`. If this\n   * route also has a `loadChildren` function which returns an `NgModuleRef`, this injector will be\n   * used as the parent of the lazy loaded module.\n   */\n  providers?: Array<Provider | EnvironmentProviders>;\n\n  /**\n   * Injector created from the static route providers\n   * @internal\n   */\n  _injector?: EnvironmentInjector;\n\n  /**\n   * Filled for routes with `loadChildren` once the routes are loaded.\n   * @internal\n   */\n  _loadedRoutes?: Route[];\n\n  /**\n   * Filled for routes with `loadChildren` once the routes are loaded\n   * @internal\n   */\n  _loadedInjector?: EnvironmentInjector;\n}\n\nexport interface LoadedRouterConfig {\n  routes: Route[];\n  injector: EnvironmentInjector | undefined;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be activated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanActivate` function that checks whether the\n * current user has permission to activate the requested route.\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canActivate(): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivate {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivate(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): MaybeAsync<GuardResult> {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canActivate: [CanActivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport interface CanActivate {\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canActivate` guard on a `Route`.\n *\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements and uses a `CanActivateFn` that checks whether the\n * current user has permission to activate the requested route.\n *\n * ```ts\n * @Injectable()\n * class UserToken {}\n *\n * @Injectable()\n * class PermissionsService {\n *   canActivate(currentUser: UserToken, userId: string): boolean {\n *     return true;\n *   }\n *   canMatch(currentUser: UserToken): boolean {\n *     return true;\n *   }\n * }\n *\n * const canActivateTeam: CanActivateFn = (\n *   route: ActivatedRouteSnapshot,\n *   state: RouterStateSnapshot,\n * ) => {\n *   return inject(PermissionsService).canActivate(inject(UserToken), route.params['id']);\n * };\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * bootstrapApplication(App, {\n *    providers: [\n *      provideRouter([\n *        {\n *          path: 'team/:id',\n *          component: TeamComponent,\n *          canActivate: [canActivateTeam],\n *        },\n *      ]),\n *    ],\n *  });\n * ```\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type CanActivateFn = (\n  route: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot,\n) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a child route can be activated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanActivateChild` function that checks whether the\n * current user has permission to activate the requested child route.\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivateChild {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivateChild(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): MaybeAsync<GuardResult> {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: [CanActivateTeam],\n *         children: [\n *           {\n *              path: 'team/:id',\n *              component: TeamComponent\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport interface CanActivateChild {\n  canActivateChild(\n    childRoute: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot,\n  ): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canActivateChild` guard on a `Route`.\n *\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `canActivate` function that checks whether the\n * current user has permission to activate the requested route.\n *\n * {@example router/route_functional_guards.ts region=\"CanActivateChildFn\"}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type CanActivateChildFn = (\n  childRoute: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot,\n) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be deactivated.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanDeactivate` function that checks whether the\n * current user has permission to deactivate the requested route.\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canDeactivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @Injectable()\n * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canDeactivate(\n *     component: TeamComponent,\n *     currentRoute: ActivatedRouteSnapshot,\n *     currentState: RouterStateSnapshot,\n *     nextState: RouterStateSnapshot\n *   ): MaybeAsync<GuardResult> {\n *     return this.permissions.canDeactivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canDeactivate: [CanDeactivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanDeactivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport interface CanDeactivate<T> {\n  canDeactivate(\n    component: T,\n    currentRoute: ActivatedRouteSnapshot,\n    currentState: RouterStateSnapshot,\n    nextState: RouterStateSnapshot,\n  ): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canDeactivate` guard on a `Route`.\n *\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n *\n * The following example implements and uses a `CanDeactivateFn` that checks whether the\n * user component has unsaved changes before navigating away from the route.\n *\n * {@example router/route_functional_guards.ts region=\"CanDeactivateFn\"}\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type CanDeactivateFn<T> = (\n  component: T,\n  currentRoute: ActivatedRouteSnapshot,\n  currentState: RouterStateSnapshot,\n  nextState: RouterStateSnapshot,\n) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a `Route` can be matched.\n * If all guards return `true`, navigation continues and the `Router` will use the `Route` during\n * activation. If any guard returns `false`, the `Route` is skipped for matching and other `Route`\n * configurations are processed instead.\n *\n * The following example implements a `CanMatch` function that decides whether the\n * current user has permission to access the users page.\n *\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canAccess(user: UserToken, route: Route, segments: UrlSegment[]): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanMatchTeamSection implements CanMatch {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canMatch(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canAccess(this.currentUser, route, segments);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: () => import('./team').then(mod => mod.TeamModule),\n *         canMatch: [CanMatchTeamSection]\n *       },\n *       {\n *         path: '**',\n *         component: NotFoundComponent\n *       }\n *     ])\n *   ],\n *   providers: [CanMatchTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * If the `CanMatchTeamSection` were to return `false`, the router would continue navigating to the\n * `team/:id` URL, but would load the `NotFoundComponent` because the `Route` for `'team/:id'`\n * could not be used for a URL match but the catch-all `**` `Route` did instead.\n *\n * @publicApi\n */\nexport interface CanMatch {\n  canMatch(route: Route, segments: UrlSegment[]): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canMatch` guard on a `Route`.\n *\n * If all guards return `true`, navigation continues and the `Router` will use the `Route` during\n * activation. If any guard returns `false`, the `Route` is skipped for matching and other `Route`\n * configurations are processed instead.\n *\n * The following example implements and uses a `CanMatchFn` that checks whether the\n * current user has permission to access the team page.\n *\n * {@example router/route_functional_guards.ts region=\"CanMatchFn\"}\n *\n * @param route The route configuration.\n * @param segments The URL segments that have not been consumed by previous parent route evaluations.\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type CanMatchFn = (route: Route, segments: UrlSegment[]) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Interface that classes can implement to be a data provider.\n * A data provider class can be used with the router to resolve data during navigation.\n * The interface defines a `resolve()` method that is invoked right after the `ResolveStart`\n * router event. The router waits for the data to be resolved before the route is finally activated.\n *\n * The following example implements a `resolve()` method that retrieves the data\n * needed to activate the requested route.\n *\n * ```ts\n * @Injectable({ providedIn: 'root' })\n * export class HeroResolver implements Resolve<Hero> {\n *   constructor(private service: HeroService) {}\n *\n *   resolve(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<Hero>|Promise<Hero>|Hero {\n *     return this.service.getHero(route.paramMap.get('id'));\n *   }\n * }\n * ```\n *\n * Here, the defined `resolve()` function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'detail/:id',\n *         component: HeroDetailComponent,\n *         resolve: {\n *           hero: HeroResolver\n *         }\n *       }\n *     ])\n *   ],\n *   exports: [RouterModule]\n * })\n * export class AppRoutingModule {}\n * ```\n *\n * And you can access to your resolved data from `HeroComponent`:\n *\n * ```ts\n * @Component({\n *  selector: \"app-hero\",\n *  templateUrl: \"hero.component.html\",\n * })\n * export class HeroComponent {\n *\n *  constructor(private activatedRoute: ActivatedRoute) {}\n *\n *  ngOnInit() {\n *    this.activatedRoute.data.subscribe(({ hero }) => {\n *      // do something with your resolved data ...\n *    })\n *  }\n *\n * }\n * ```\n *\n * @usageNotes\n *\n * When both guard and resolvers are specified, the resolvers are not executed until\n * all guards have run and succeeded.\n * For example, consider the following route configuration:\n *\n * ```ts\n * {\n *  path: 'base'\n *  canActivate: [BaseGuard],\n *  resolve: {data: BaseDataResolver}\n *  children: [\n *   {\n *     path: 'child',\n *     guards: [ChildGuard],\n *     component: ChildComponent,\n *     resolve: {childData: ChildDataResolver}\n *    }\n *  ]\n * }\n * ```\n * The order of execution is: BaseGuard, ChildGuard, BaseDataResolver, ChildDataResolver.\n *\n * @publicApi\n * @see {@link ResolveFn}\n */\nexport interface Resolve<T> {\n  resolve(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot,\n  ): MaybeAsync<T | RedirectCommand>;\n}\n\n/**\n * Function type definition for a data provider.\n *\n * A data provider can be used with the router to resolve data during navigation.\n * The router waits for the data to be resolved before the route is finally activated.\n *\n * A resolver can also redirect a `RedirectCommand` and the Angular router will use\n * it to redirect the current navigation to the new destination.\n *\n * @usageNotes\n *\n * The following example implements a function that retrieves the data\n * needed to activate the requested route.\n *\n * ```ts\n * interface Hero {\n *   name: string;\n * }\n * @Injectable()\n * export class HeroService {\n *   getHero(id: string) {\n *     return {name: `Superman-${id}`};\n *   }\n * }\n *\n * export const heroResolver: ResolveFn<Hero> = (\n *   route: ActivatedRouteSnapshot,\n *   state: RouterStateSnapshot,\n * ) => {\n *   return inject(HeroService).getHero(route.paramMap.get('id')!);\n * };\n *\n * bootstrapApplication(App, {\n *   providers: [\n *     provideRouter([\n *       {\n *         path: 'detail/:id',\n *         component: HeroDetailComponent,\n *         resolve: {hero: heroResolver},\n *       },\n *     ]),\n *   ],\n * });\n * ```\n *\n * And you can access to your resolved data from `HeroComponent`:\n *\n * ```ts\n * @Component({template: ''})\n * export class HeroDetailComponent {\n *   private activatedRoute = inject(ActivatedRoute);\n *\n *   ngOnInit() {\n *     this.activatedRoute.data.subscribe(({hero}) => {\n *       // do something with your resolved data ...\n *     });\n *   }\n * }\n * ```\n *\n * If resolved data cannot be retrieved, you may want to redirect the user\n * to a new page instead:\n *\n * ```ts\n * export const heroResolver: ResolveFn<Hero> = async (\n *   route: ActivatedRouteSnapshot,\n *   state: RouterStateSnapshot,\n * ) => {\n *   const router = inject(Router);\n *   const heroService = inject(HeroService);\n *   try {\n *     return await heroService.getHero(route.paramMap.get('id')!);\n *   } catch {\n *     return new RedirectCommand(router.parseUrl('/404'));\n *   }\n * };\n * ```\n *\n * When both guard and resolvers are specified, the resolvers are not executed until\n * all guards have run and succeeded.\n * For example, consider the following route configuration:\n *\n * ```ts\n * {\n *  path: 'base'\n *  canActivate: [baseGuard],\n *  resolve: {data: baseDataResolver}\n *  children: [\n *   {\n *     path: 'child',\n *     canActivate: [childGuard],\n *     component: ChildComponent,\n *     resolve: {childData: childDataResolver}\n *    }\n *  ]\n * }\n * ```\n * The order of execution is: baseGuard, childGuard, baseDataResolver, childDataResolver.\n *\n * @publicApi\n * @see {@link Route}\n */\nexport type ResolveFn<T> = (\n  route: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot,\n) => MaybeAsync<T | RedirectCommand>;\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if children can be loaded.\n * If all guards return `true`, navigation continues. If any guard returns `false`,\n * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n * is cancelled and a new navigation starts to the `UrlTree` returned from the guard.\n *\n * The following example implements a `CanLoad` function that decides whether the\n * current user has permission to load requested child routes.\n *\n *\n * ```ts\n * class UserToken {}\n * class Permissions {\n *   canLoadChildren(user: UserToken, id: string, segments: UrlSegment[]): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanLoadTeamSection implements CanLoad {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canLoad(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canLoadChildren(this.currentUser, route, segments);\n *   }\n * }\n * ```\n *\n * Here, the defined guard function is provided as part of the `Route` object\n * in the router configuration:\n *\n * ```ts\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: () => import('./team').then(mod => mod.TeamModule),\n *         canLoad: [CanLoadTeamSection]\n *       }\n *     ])\n *   ],\n *   providers: [CanLoadTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n * @deprecated Use {@link CanMatch} instead\n */\nexport interface CanLoad {\n  canLoad(route: Route, segments: UrlSegment[]): MaybeAsync<GuardResult>;\n}\n\n/**\n * The signature of a function used as a `canLoad` guard on a `Route`.\n *\n * @publicApi\n * @see {@link CanLoad}\n * @see {@link Route}\n * @see {@link CanMatch}\n * @deprecated Use `Route.canMatch` and `CanMatchFn` instead\n */\nexport type CanLoadFn = (route: Route, segments: UrlSegment[]) => MaybeAsync<GuardResult>;\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the navigation should be handled.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#navigateByUrl}\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n *\n * @publicApi\n */\nexport interface NavigationBehaviorOptions {\n  /**\n   * How to handle a navigation request to the current URL.\n   *\n   * This value is a subset of the options available in `OnSameUrlNavigation` and\n   * will take precedence over the default value set for the `Router`.\n   *\n   * @see {@link OnSameUrlNavigation}\n   * @see {@link RouterConfigOptions}\n   */\n  onSameUrlNavigation?: OnSameUrlNavigation;\n\n  /**\n   * When true, navigates without pushing a new state into history.\n   *\n   * ```\n   * // Navigate silently to /view\n   * this.router.navigate(['/view'], { skipLocationChange: true });\n   * ```\n   */\n  skipLocationChange?: boolean;\n\n  /**\n   * When true, navigates while replacing the current state in history.\n   *\n   * ```\n   * // Navigate to /view\n   * this.router.navigate(['/view'], { replaceUrl: true });\n   * ```\n   */\n  replaceUrl?: boolean;\n\n  /**\n   * Developer-defined state that can be passed to any navigation.\n   * Access this value through the `Navigation.extras` object\n   * returned from the [Router.getCurrentNavigation()\n   * method](api/router/Router#getcurrentnavigation) while a navigation is executing.\n   *\n   * After a navigation completes, the router writes an object containing this\n   * value together with a `navigationId` to `history.state`.\n   * The value is written when `location.go()` or `location.replaceState()`\n   * is called before activating this route.\n   *\n   * Note that `history.state` does not pass an object equality test because\n   * the router adds the `navigationId` on each navigation.\n   *\n   */\n  state?: {[k: string]: any};\n\n  /**\n   * Use this to convey transient information about this particular navigation, such as how it\n   * happened. In this way, it's different from the persisted value `state` that will be set to\n   * `history.state`. This object is assigned directly to the Router's current `Navigation`\n   * (it is not copied or cloned), so it should be mutated with caution.\n   *\n   * One example of how this might be used is to trigger different single-page navigation animations\n   * depending on how a certain route was reached. For example, consider a photo gallery app, where\n   * you can reach the same photo URL and state via various routes:\n   *\n   * - Clicking on it in a gallery view\n   * - Clicking\n   * - \"next\" or \"previous\" when viewing another photo in the album\n   * - Etc.\n   *\n   * Each of these wants a different animation at navigate time. This information doesn't make sense\n   * to store in the persistent URL or history entry state, but it's still important to communicate\n   * from the rest of the application, into the router.\n   *\n   * This information could be used in coordination with the View Transitions feature and the\n   * `onViewTransitionCreated` callback. The information might be used in the callback to set\n   * classes on the document in order to control the transition animations and remove the classes\n   * when the transition has finished animating.\n   */\n  readonly info?: unknown;\n\n  /**\n   * When set, the Router will update the browser's address bar to match the given `UrlTree` instead\n   * of the one used for route matching.\n   *\n   *\n   * @usageNotes\n   *\n   * This feature is useful for redirects, such as redirecting to an error page, without changing\n   * the value that will be displayed in the browser's address bar.\n   *\n   * ```ts\n   * const canActivate: CanActivateFn = (route: ActivatedRouteSnapshot) => {\n   *   const userService = inject(UserService);\n   *   const router = inject(Router);\n   *   if (!userService.isLoggedIn()) {\n   *     const targetOfCurrentNavigation = router.getCurrentNavigation()?.finalUrl;\n   *     const redirect = router.parseUrl('/404');\n   *     return new RedirectCommand(redirect, {browserUrl: targetOfCurrentNavigation});\n   *   }\n   *   return true;\n   * };\n   * ```\n   *\n   * This value is used directly, without considering any `UrlHandingStrategy`. In this way,\n   * `browserUrl` can also be used to use a different value for the browser URL than what would have\n   * been produced by from the navigation due to `UrlHandlingStrategy.merge`.\n   *\n   * This value only affects the path presented in the browser's address bar. It does not apply to\n   * the internal `Router` state. Information such as `params` and `data` will match the internal\n   * state used to match routes which will be different from the browser URL when using this feature\n   * The same is true when using other APIs that cause the browser URL the differ from the Router\n   * state, such as `skipLocationChange`.\n   */\n  readonly browserUrl?: UrlTree | string;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NavigationCancellationCode} from './events';\nimport {NavigationBehaviorOptions, RedirectCommand} from './models';\nimport {isUrlTree, UrlSerializer, UrlTree} from './url_tree';\n\nexport const NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nexport type NavigationCancelingError = Error & {\n  [NAVIGATION_CANCELING_ERROR]: true;\n  cancellationCode: NavigationCancellationCode;\n};\nexport type RedirectingNavigationCancelingError = NavigationCancelingError & {\n  url: UrlTree;\n  navigationBehaviorOptions?: NavigationBehaviorOptions;\n  cancellationCode: NavigationCancellationCode.Redirect;\n};\n\nexport function redirectingNavigationError(\n  urlSerializer: UrlSerializer,\n  redirect: UrlTree | RedirectCommand,\n): RedirectingNavigationCancelingError {\n  const {redirectTo, navigationBehaviorOptions} = isUrlTree(redirect)\n    ? {redirectTo: redirect, navigationBehaviorOptions: undefined}\n    : redirect;\n  const error = navigationCancelingError(\n    ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`,\n    NavigationCancellationCode.Redirect,\n  ) as RedirectingNavigationCancelingError;\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\n\nexport function navigationCancelingError(\n  message: string | null | false,\n  code: NavigationCancellationCode,\n) {\n  const error = new Error(`NavigationCancelingError: ${message || ''}`) as NavigationCancelingError;\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  return error;\n}\n\nexport function isRedirectingNavigationCancelingError(\n  error: unknown | RedirectingNavigationCancelingError,\n): error is RedirectingNavigationCancelingError {\n  return (\n    isNavigationCancelingError(error) &&\n    isUrlTree((error as RedirectingNavigationCancelingError).url)\n  );\n}\n\nexport function isNavigationCancelingError(error: unknown): error is NavigationCancelingError {\n  return !!error && (error as NavigationCancelingError)[NAVIGATION_CANCELING_ERROR];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {ActivationEnd, ChildActivationEnd, Event} from '../events';\nimport type {NavigationTransition} from '../navigation_transition';\nimport type {DetachedRouteHandleInternal, RouteReuseStrategy} from '../route_reuse_strategy';\nimport type {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute, advanceActivatedRoute, RouterState} from '../router_state';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nlet warnedAboutUnsupportedInputBinding = false;\n\nexport const activateRoutes = (\n  rootContexts: ChildrenOutletContexts,\n  routeReuseStrategy: RouteReuseStrategy,\n  forwardEvent: (evt: Event) => void,\n  inputBindingEnabled: boolean,\n): MonoTypeOperatorFunction<NavigationTransition> =>\n  map((t) => {\n    new ActivateRoutes(\n      routeReuseStrategy,\n      t.targetRouterState!,\n      t.currentRouterState,\n      forwardEvent,\n      inputBindingEnabled,\n    ).activate(rootContexts);\n    return t;\n  });\n\nexport class ActivateRoutes {\n  constructor(\n    private routeReuseStrategy: RouteReuseStrategy,\n    private futureState: RouterState,\n    private currState: RouterState,\n    private forwardEvent: (evt: Event) => void,\n    private inputBindingEnabled: boolean,\n  ) {}\n\n  activate(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n\n  // De-activate the child route that are not re-used for the future state\n  private deactivateChildRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute> | null,\n    contexts: ChildrenOutletContexts,\n  ): void {\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach((futureChild) => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n\n    // De-activate the routes that will not be re-used\n    Object.values(children).forEach((v: TreeNode<ActivatedRoute>) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n\n  private deactivateRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute>,\n    parentContext: ChildrenOutletContexts,\n  ): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    // If there is no component, the Route is never attached to an outlet (because there is no\n    // component to attach).\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n\n  private detachAndStoreRouteSubtree(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});\n    }\n  }\n\n  private deactivateRouteAndOutlet(\n    route: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    // The context could be `null` if we are on a componentless route but there may still be\n    // children that need deactivating.\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n\n    if (context) {\n      if (context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate();\n        // Destroy the contexts for all the outlets that were in the component\n        context.children.onOutletDeactivated();\n      }\n      // Clear the information about the attached component on the context but keep the reference to\n      // the outlet. Clear even if outlet was not yet activated to avoid activating later with old\n      // info\n      context.attachRef = null;\n      context.route = null;\n    }\n  }\n\n  private activateChildRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute> | null,\n    contexts: ChildrenOutletContexts,\n  ): void {\n    const children: {[outlet: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach((c) => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n\n  private activateRoutes(\n    futureNode: TreeNode<ActivatedRoute>,\n    currNode: TreeNode<ActivatedRoute>,\n    parentContexts: ChildrenOutletContexts,\n  ): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    advanceActivatedRoute(future);\n\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored = <DetachedRouteHandleInternal>(\n            this.routeReuseStrategy.retrieve(future.snapshot)\n          );\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context.children);\n        } else {\n          context.attachRef = null;\n          context.route = future;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, context.injector);\n          }\n\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const context = parentContexts.getOrCreateContext(future.outlet);\n      const outlet = context.outlet;\n      if (\n        outlet &&\n        this.inputBindingEnabled &&\n        !outlet.supportsBindingToComponentInputs &&\n        !warnedAboutUnsupportedInputBinding\n      ) {\n        console.warn(\n          `'withComponentInputBinding' feature is enabled but ` +\n            `this application is using an outlet that may not support binding to component inputs.`,\n        );\n        warnedAboutUnsupportedInputBinding = true;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, ProviderToken, isInjectable as isInjectable} from '@angular/core';\n\nimport {RunGuardsAndResolvers} from '../models';\nimport {ChildrenOutletContexts, OutletContext} from '../router_outlet_context';\nimport {\n  ActivatedRouteSnapshot,\n  equalParamsAndUrlSegments,\n  RouterStateSnapshot,\n} from '../router_state';\nimport {equalPath} from '../url_tree';\nimport {shallowEqual} from '../utils/collection';\nimport {nodeChildrenAsMap, TreeNode} from '../utils/tree';\n\nexport class CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nexport class CanDeactivate {\n  constructor(\n    public component: Object | null,\n    public route: ActivatedRouteSnapshot,\n  ) {}\n}\n\nexport declare type Checks = {\n  canDeactivateChecks: CanDeactivate[];\n  canActivateChecks: CanActivate[];\n};\n\nexport function getAllRouteGuards(\n  future: RouterStateSnapshot,\n  curr: RouterStateSnapshot,\n  parentContexts: ChildrenOutletContexts,\n) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n\nexport function getCanActivateChild(\n  p: ActivatedRouteSnapshot,\n): {node: ActivatedRouteSnapshot; guards: any[]} | null {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {node: p, guards: canActivateChild};\n}\n\nexport function getTokenOrFunctionIdentity<T>(\n  tokenOrFunction: Function | ProviderToken<T>,\n  injector: Injector,\n): Function | T {\n  const NOT_FOUND = Symbol();\n  const result = injector.get<T | Symbol>(tokenOrFunction, NOT_FOUND);\n  if (result === NOT_FOUND) {\n    if (typeof tokenOrFunction === 'function' && !isInjectable(tokenOrFunction)) {\n      // We think the token is just a function so return it as-is\n      return tokenOrFunction;\n    } else {\n      // This will throw the not found error\n      return injector.get<T>(tokenOrFunction);\n    }\n  }\n  return result as T;\n}\n\nfunction getChildRouteGuards(\n  futureNode: TreeNode<ActivatedRouteSnapshot>,\n  currNode: TreeNode<ActivatedRouteSnapshot> | null,\n  contexts: ChildrenOutletContexts | null,\n  futurePath: ActivatedRouteSnapshot[],\n  checks: Checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n  },\n): Checks {\n  const prevChildren = nodeChildrenAsMap(currNode);\n\n  // Process the children of the future route\n  futureNode.children.forEach((c) => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n\n  // Process any children left from the current route (not active for the future route)\n  Object.entries(prevChildren).forEach(([k, v]: [string, TreeNode<ActivatedRouteSnapshot>]) =>\n    deactivateRouteAndItsChildren(v, contexts!.getContext(k), checks),\n  );\n\n  return checks;\n}\n\nfunction getRouteGuards(\n  futureNode: TreeNode<ActivatedRouteSnapshot>,\n  currNode: TreeNode<ActivatedRouteSnapshot>,\n  parentContexts: ChildrenOutletContexts | null,\n  futurePath: ActivatedRouteSnapshot[],\n  checks: Checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n  },\n): Checks {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n  // reusing the node\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun = shouldRunGuardsAndResolvers(\n      curr,\n      future,\n      future.routeConfig!.runGuardsAndResolvers,\n    );\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(\n        futureNode,\n        currNode,\n        context ? context.children : null,\n        futurePath,\n        checks,\n      );\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n\nfunction shouldRunGuardsAndResolvers(\n  curr: ActivatedRouteSnapshot,\n  future: ActivatedRouteSnapshot,\n  mode: RunGuardsAndResolvers | undefined,\n): boolean {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n\n    case 'pathParamsOrQueryParamsChange':\n      return (\n        !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams)\n      );\n\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return (\n        !equalParamsAndUrlSegments(curr, future) ||\n        !shallowEqual(curr.queryParams, future.queryParams)\n      );\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n\nfunction deactivateRouteAndItsChildren(\n  route: TreeNode<ActivatedRouteSnapshot>,\n  context: OutletContext | null,\n  checks: Checks,\n): void {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n\n  Object.entries(children).forEach(([childName, node]) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EmptyError} from 'rxjs';\n\nimport {CanActivateChildFn, CanActivateFn, CanDeactivateFn, CanLoadFn, CanMatchFn} from '../models';\nimport {\n  NAVIGATION_CANCELING_ERROR,\n  NavigationCancelingError,\n  RedirectingNavigationCancelingError,\n} from '../navigation_canceling_error';\nimport {isUrlTree} from '../url_tree';\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nexport function isFunction<T>(v: any): v is T {\n  return typeof v === 'function';\n}\n\nexport function isBoolean(v: any): v is boolean {\n  return typeof v === 'boolean';\n}\n\nexport function isCanLoad(guard: any): guard is {canLoad: CanLoadFn} {\n  return guard && isFunction<CanLoadFn>(guard.canLoad);\n}\n\nexport function isCanActivate(guard: any): guard is {canActivate: CanActivateFn} {\n  return guard && isFunction<CanActivateFn>(guard.canActivate);\n}\n\nexport function isCanActivateChild(guard: any): guard is {canActivateChild: CanActivateChildFn} {\n  return guard && isFunction<CanActivateChildFn>(guard.canActivateChild);\n}\n\nexport function isCanDeactivate<T>(guard: any): guard is {canDeactivate: CanDeactivateFn<T>} {\n  return guard && isFunction<CanDeactivateFn<T>>(guard.canDeactivate);\n}\nexport function isCanMatch(guard: any): guard is {canMatch: CanMatchFn} {\n  return guard && isFunction<CanMatchFn>(guard.canMatch);\n}\n\nexport function isEmptyError(e: Error): e is EmptyError {\n  return e instanceof EmptyError || e?.name === 'EmptyError';\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {combineLatest, Observable, OperatorFunction} from 'rxjs';\nimport {filter, map, startWith, switchMap, take} from 'rxjs/operators';\n\nimport {GuardResult, RedirectCommand} from '../models';\nimport {isUrlTree, UrlTree} from '../url_tree';\n\nconst INITIAL_VALUE = /* @__PURE__ */ Symbol('INITIAL_VALUE');\ndeclare type INTERIM_VALUES = typeof INITIAL_VALUE | GuardResult;\n\nexport function prioritizedGuardValue(): OperatorFunction<Observable<GuardResult>[], GuardResult> {\n  return switchMap((obs) => {\n    return combineLatest(\n      obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE as INTERIM_VALUES))),\n    ).pipe(\n      map((results: INTERIM_VALUES[]) => {\n        for (const result of results) {\n          if (result === true) {\n            // If result is true, check the next one\n            continue;\n          } else if (result === INITIAL_VALUE) {\n            // If guard has not finished, we need to stop processing.\n            return INITIAL_VALUE;\n          } else if (result === false || isRedirect(result)) {\n            // Result finished and was not true. Return the result.\n            // Note that we only allow false/UrlTree/RedirectCommand. Other values are considered invalid and\n            // ignored.\n            return result;\n          }\n        }\n        // Everything resolved to true. Return true.\n        return true;\n      }),\n      filter((item): item is GuardResult => item !== INITIAL_VALUE),\n      take(1),\n    );\n  });\n}\n\nfunction isRedirect(val: INTERIM_VALUES): val is UrlTree | RedirectCommand {\n  return isUrlTree(val) || val instanceof RedirectCommand;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, ProviderToken, runInInjectionContext} from '@angular/core';\nimport {\n  concat,\n  defer,\n  from,\n  MonoTypeOperatorFunction,\n  Observable,\n  of,\n  OperatorFunction,\n  pipe,\n} from 'rxjs';\nimport {concatMap, first, map, mergeMap, tap} from 'rxjs/operators';\n\nimport {ActivationStart, ChildActivationStart, Event} from '../events';\nimport {\n  CanActivateChildFn,\n  CanActivateFn,\n  CanDeactivateFn,\n  GuardResult,\n  CanLoadFn,\n  CanMatchFn,\n  Route,\n} from '../models';\nimport {redirectingNavigationError} from '../navigation_canceling_error';\nimport type {NavigationTransition} from '../navigation_transition';\nimport type {ActivatedRouteSnapshot, RouterStateSnapshot} from '../router_state';\nimport {UrlSegment, UrlSerializer} from '../url_tree';\nimport {wrapIntoObservable} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {\n  CanActivate,\n  CanDeactivate,\n  getCanActivateChild,\n  getTokenOrFunctionIdentity,\n} from '../utils/preactivation';\nimport {\n  isBoolean,\n  isCanActivate,\n  isCanActivateChild,\n  isCanDeactivate,\n  isCanLoad,\n  isCanMatch,\n} from '../utils/type_guards';\n\nimport {prioritizedGuardValue} from './prioritized_guard_value';\n\nexport function checkGuards(\n  injector: EnvironmentInjector,\n  forwardEvent?: (evt: Event) => void,\n): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap((t) => {\n    const {\n      targetSnapshot,\n      currentSnapshot,\n      guards: {canActivateChecks, canDeactivateChecks},\n    } = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of({...t, guardsResult: true});\n    }\n\n    return runCanDeactivateChecks(\n      canDeactivateChecks,\n      targetSnapshot!,\n      currentSnapshot,\n      injector,\n    ).pipe(\n      mergeMap((canDeactivate) => {\n        return canDeactivate && isBoolean(canDeactivate)\n          ? runCanActivateChecks(targetSnapshot!, canActivateChecks, injector, forwardEvent)\n          : of(canDeactivate);\n      }),\n      map((guardsResult) => ({...t, guardsResult})),\n    );\n  });\n}\n\nfunction runCanDeactivateChecks(\n  checks: CanDeactivate[],\n  futureRSS: RouterStateSnapshot,\n  currRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n) {\n  return from(checks).pipe(\n    mergeMap((check) =>\n      runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector),\n    ),\n    first((result) => {\n      return result !== true;\n    }, true),\n  );\n}\n\nfunction runCanActivateChecks(\n  futureSnapshot: RouterStateSnapshot,\n  checks: CanActivate[],\n  injector: EnvironmentInjector,\n  forwardEvent?: (evt: Event) => void,\n) {\n  return from(checks).pipe(\n    concatMap((check: CanActivate) => {\n      return concat(\n        fireChildActivationStart(check.route.parent, forwardEvent),\n        fireActivationStart(check.route, forwardEvent),\n        runCanActivateChild(futureSnapshot, check.path, injector),\n        runCanActivate(futureSnapshot, check.route, injector),\n      );\n    }),\n    first((result) => {\n      return result !== true;\n    }, true),\n  );\n}\n\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireActivationStart(\n  snapshot: ActivatedRouteSnapshot | null,\n  forwardEvent?: (evt: Event) => void,\n): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\n\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireChildActivationStart(\n  snapshot: ActivatedRouteSnapshot | null,\n  forwardEvent?: (evt: Event) => void,\n): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\n\nfunction runCanActivate(\n  futureRSS: RouterStateSnapshot,\n  futureARS: ActivatedRouteSnapshot,\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n\n  const canActivateObservables = canActivate.map(\n    (canActivate: CanActivateFn | ProviderToken<unknown>) => {\n      return defer(() => {\n        const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n        const guard = getTokenOrFunctionIdentity<CanActivate>(canActivate, closestInjector);\n        const guardVal = isCanActivate(guard)\n          ? guard.canActivate(futureARS, futureRSS)\n          : runInInjectionContext(closestInjector, () =>\n              (guard as CanActivateFn)(futureARS, futureRSS),\n            );\n        return wrapIntoObservable(guardVal).pipe(first());\n      });\n    },\n  );\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\n\nfunction runCanActivateChild(\n  futureRSS: RouterStateSnapshot,\n  path: ActivatedRouteSnapshot[],\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const futureARS = path[path.length - 1];\n\n  const canActivateChildGuards = path\n    .slice(0, path.length - 1)\n    .reverse()\n    .map((p) => getCanActivateChild(p))\n    .filter((_) => _ !== null);\n\n  const canActivateChildGuardsMapped = canActivateChildGuards.map((d: any) => {\n    return defer(() => {\n      const guardsMapped = d.guards.map(\n        (canActivateChild: CanActivateChildFn | ProviderToken<unknown>) => {\n          const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n          const guard = getTokenOrFunctionIdentity<{canActivateChild: CanActivateChildFn}>(\n            canActivateChild,\n            closestInjector,\n          );\n          const guardVal = isCanActivateChild(guard)\n            ? guard.canActivateChild(futureARS, futureRSS)\n            : runInInjectionContext(closestInjector, () =>\n                (guard as CanActivateChildFn)(futureARS, futureRSS),\n              );\n          return wrapIntoObservable(guardVal).pipe(first());\n        },\n      );\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\n\nfunction runCanDeactivate(\n  component: Object | null,\n  currARS: ActivatedRouteSnapshot,\n  currRSS: RouterStateSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<GuardResult> {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map((c: any) => {\n    const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n    const guard = getTokenOrFunctionIdentity<any>(c, closestInjector);\n    const guardVal = isCanDeactivate(guard)\n      ? guard.canDeactivate(component, currARS, currRSS, futureRSS)\n      : runInInjectionContext(closestInjector, () =>\n          (guard as CanDeactivateFn<any>)(component, currARS, currRSS, futureRSS),\n        );\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\n\nexport function runCanLoadGuards(\n  injector: EnvironmentInjector,\n  route: Route,\n  segments: UrlSegment[],\n  urlSerializer: UrlSerializer,\n): Observable<boolean> {\n  const canLoad = route.canLoad;\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n\n  const canLoadObservables = canLoad.map((injectionToken: any) => {\n    const guard = getTokenOrFunctionIdentity<any>(injectionToken, injector);\n    const guardVal = isCanLoad(guard)\n      ? guard.canLoad(route, segments)\n      : runInInjectionContext(injector, () => (guard as CanLoadFn)(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n\n  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n\nfunction redirectIfUrlTree(urlSerializer: UrlSerializer): OperatorFunction<GuardResult, boolean> {\n  return pipe(\n    tap((result: GuardResult) => {\n      if (typeof result === 'boolean') return;\n\n      throw redirectingNavigationError(urlSerializer, result);\n    }),\n    map((result) => result === true),\n  );\n}\n\nexport function runCanMatchGuards(\n  injector: EnvironmentInjector,\n  route: Route,\n  segments: UrlSegment[],\n  urlSerializer: UrlSerializer,\n): Observable<GuardResult> {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n\n  const canMatchObservables = canMatch.map((injectionToken) => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanMatch(guard)\n      ? guard.canMatch(route, segments)\n      : runInInjectionContext(injector, () => (guard as CanMatchFn)(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n\n  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, runInInjectionContext, RuntimeError as RuntimeError} from '@angular/core';\nimport {Observable, of, throwError} from 'rxjs';\n\nimport {RuntimeErrorCode} from './errors';\nimport {NavigationCancellationCode} from './events';\nimport {LoadedRouterConfig, RedirectFunction, Route} from './models';\nimport {navigationCancelingError} from './navigation_canceling_error';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {Params, PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\n\nexport class NoMatch {\n  public segmentGroup: UrlSegmentGroup | null;\n\n  constructor(segmentGroup?: UrlSegmentGroup) {\n    this.segmentGroup = segmentGroup || null;\n  }\n}\n\nexport class AbsoluteRedirect extends Error {\n  constructor(public urlTree: UrlTree) {\n    super();\n  }\n}\n\nexport function noMatch(segmentGroup: UrlSegmentGroup): Observable<any> {\n  return throwError(new NoMatch(segmentGroup));\n}\n\nexport function absoluteRedirect(newTree: UrlTree): Observable<any> {\n  return throwError(new AbsoluteRedirect(newTree));\n}\n\nexport function namedOutletsRedirect(redirectTo: string): Observable<any> {\n  return throwError(\n    new RuntimeError(\n      RuntimeErrorCode.NAMED_OUTLET_REDIRECT,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`,\n    ),\n  );\n}\n\nexport function canLoadFails(route: Route): Observable<LoadedRouterConfig> {\n  return throwError(\n    navigationCancelingError(\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`,\n      NavigationCancellationCode.GuardRejected,\n    ),\n  );\n}\n\nexport class ApplyRedirects {\n  constructor(\n    private urlSerializer: UrlSerializer,\n    private urlTree: UrlTree,\n  ) {}\n\n  lineralizeSegments(route: Route, urlTree: UrlTree): Observable<UrlSegment[]> {\n    let res: UrlSegment[] = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of(res);\n      }\n\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(`${route.redirectTo!}`);\n      }\n\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n\n  applyRedirectCommands(\n    segments: UrlSegment[],\n    redirectTo: string | RedirectFunction,\n    posParams: {[k: string]: UrlSegment},\n    currentSnapshot: ActivatedRouteSnapshot,\n    injector: Injector,\n  ): UrlTree {\n    if (typeof redirectTo !== 'string') {\n      const redirectToFn = redirectTo;\n      const {queryParams, fragment, routeConfig, url, outlet, params, data, title} =\n        currentSnapshot;\n      const newRedirect = runInInjectionContext(injector, () =>\n        redirectToFn({params, data, queryParams, fragment, routeConfig, url, outlet, title}),\n      );\n      if (newRedirect instanceof UrlTree) {\n        throw new AbsoluteRedirect(newRedirect);\n      }\n\n      redirectTo = newRedirect;\n    }\n\n    const newTree = this.applyRedirectCreateUrlTree(\n      redirectTo,\n      this.urlSerializer.parse(redirectTo),\n      segments,\n      posParams,\n    );\n    if (redirectTo[0] === '/') {\n      throw new AbsoluteRedirect(newTree);\n    }\n    return newTree;\n  }\n\n  applyRedirectCreateUrlTree(\n    redirectTo: string,\n    urlTree: UrlTree,\n    segments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlTree {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(\n      newRoot,\n      this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),\n      urlTree.fragment,\n    );\n  }\n\n  createQueryParams(redirectToParams: Params, actualParams: Params): Params {\n    const res: Params = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v[0] === ':';\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n\n  createSegmentGroup(\n    redirectTo: string,\n    group: UrlSegmentGroup,\n    segments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegmentGroup {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\n    let children: {[n: string]: UrlSegmentGroup} = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n\n  createSegments(\n    redirectTo: string,\n    redirectToSegments: UrlSegment[],\n    actualSegments: UrlSegment[],\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegment[] {\n    return redirectToSegments.map((s) =>\n      s.path[0] === ':'\n        ? this.findPosParam(redirectTo, s, posParams)\n        : this.findOrReturn(s, actualSegments),\n    );\n  }\n\n  findPosParam(\n    redirectTo: string,\n    redirectToUrlSegment: UrlSegment,\n    posParams: {[k: string]: UrlSegment},\n  ): UrlSegment {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos)\n      throw new RuntimeError(\n        RuntimeErrorCode.MISSING_REDIRECT,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`,\n      );\n    return pos;\n  }\n\n  findOrReturn(redirectToUrlSegment: UrlSegment, actualSegments: UrlSegment[]): UrlSegment {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector} from '@angular/core';\nimport {Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Route} from '../models';\nimport {runCanMatchGuards} from '../operators/check_guards';\nimport {defaultUrlMatcher, PRIMARY_OUTLET} from '../shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer} from '../url_tree';\n\nimport {last} from './collection';\nimport {getOrCreateRouteInjectorIfNeeded, getOutlet} from './config';\n\nexport interface MatchResult {\n  matched: boolean;\n  consumedSegments: UrlSegment[];\n  remainingSegments: UrlSegment[];\n  parameters: {[k: string]: string};\n  positionalParamSegments: {[k: string]: UrlSegment};\n}\n\nconst noMatch: MatchResult = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {},\n};\n\nexport function matchWithChecks(\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n  segments: UrlSegment[],\n  injector: EnvironmentInjector,\n  urlSerializer: UrlSerializer,\n): Observable<MatchResult> {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n\n  // Only create the Route's `EnvironmentInjector` if it matches the attempted\n  // navigation\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(\n    map((v) => (v === true ? result : {...noMatch})),\n  );\n}\n\nexport function match(\n  segmentGroup: UrlSegmentGroup,\n  route: Route,\n  segments: UrlSegment[],\n): MatchResult {\n  if (route.path === '**') {\n    return createWildcardMatchResult(segments);\n  }\n\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {...noMatch};\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {},\n    };\n  }\n\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return {...noMatch};\n\n  const posParams: {[n: string]: string} = {};\n  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n    posParams[k] = v.path;\n  });\n  const parameters =\n    res.consumed.length > 0\n      ? {...posParams, ...res.consumed[res.consumed.length - 1].parameters}\n      : posParams;\n\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    // TODO(atscott): investigate combining parameters and positionalParamSegments\n    parameters,\n    positionalParamSegments: res.posParams ?? {},\n  };\n}\n\nfunction createWildcardMatchResult(segments: UrlSegment[]): MatchResult {\n  return {\n    matched: true,\n    parameters: segments.length > 0 ? last(segments)!.parameters : {},\n    consumedSegments: segments,\n    remainingSegments: [],\n    positionalParamSegments: {},\n  };\n}\n\nexport function split(\n  segmentGroup: UrlSegmentGroup,\n  consumedSegments: UrlSegment[],\n  slicedSegments: UrlSegment[],\n  config: Route[],\n) {\n  if (\n    slicedSegments.length > 0 &&\n    containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)\n  ) {\n    const s = new UrlSegmentGroup(\n      consumedSegments,\n      createChildrenForEmptyPaths(\n        config,\n        new UrlSegmentGroup(slicedSegments, segmentGroup.children),\n      ),\n    );\n    return {segmentGroup: s, slicedSegments: []};\n  }\n\n  if (\n    slicedSegments.length === 0 &&\n    containsEmptyPathMatches(segmentGroup, slicedSegments, config)\n  ) {\n    const s = new UrlSegmentGroup(\n      segmentGroup.segments,\n      addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children),\n    );\n    return {segmentGroup: s, slicedSegments};\n  }\n\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  return {segmentGroup: s, slicedSegments};\n}\n\nfunction addEmptyPathsToChildrenIfNeeded(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n  children: {[name: string]: UrlSegmentGroup},\n): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {...children, ...res};\n}\n\nfunction createChildrenForEmptyPaths(\n  routes: Route[],\n  primarySegment: UrlSegmentGroup,\n): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\n\nfunction containsEmptyPathMatchesWithNamedOutlets(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n): boolean {\n  return routes.some(\n    (r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET,\n  );\n}\n\nfunction containsEmptyPathMatches(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  routes: Route[],\n): boolean {\n  return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\n\nexport function emptyPathMatch(\n  segmentGroup: UrlSegmentGroup,\n  slicedSegments: UrlSegment[],\n  r: Route,\n): boolean {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '';\n}\n\nexport function noLeftoversInUrl(\n  segmentGroup: UrlSegmentGroup,\n  segments: UrlSegment[],\n  outlet: string,\n): boolean {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, Type, RuntimeError as RuntimeError} from '@angular/core';\nimport {from, Observable, of} from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  defaultIfEmpty,\n  first,\n  last,\n  map,\n  mergeMap,\n  scan,\n  switchMap,\n  tap,\n} from 'rxjs/operators';\n\nimport {AbsoluteRedirect, ApplyRedirects, canLoadFails, noMatch, NoMatch} from './apply_redirects';\nimport {createUrlTreeFromSnapshot} from './create_url_tree';\nimport {RuntimeErrorCode} from './errors';\nimport {Data, LoadedRouterConfig, ResolveData, Route, Routes} from './models';\nimport {runCanLoadGuards} from './operators/check_guards';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {\n  ActivatedRouteSnapshot,\n  getInherited,\n  ParamsInheritanceStrategy,\n  RouterStateSnapshot,\n} from './router_state';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {getOutlet, sortByMatchingOutlets} from './utils/config';\nimport {\n  emptyPathMatch,\n  match,\n  matchWithChecks,\n  noLeftoversInUrl,\n  split,\n} from './utils/config_matching';\nimport {TreeNode} from './utils/tree';\nimport {isEmptyError} from './utils/type_guards';\n\n/**\n * Class used to indicate there were no additional route config matches but that all segments of\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\n * try to match child configs in case there are empty path children.\n */\nclass NoLeftoversInUrl {}\n\nexport function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Routes,\n  urlTree: UrlTree,\n  urlSerializer: UrlSerializer,\n  paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n): Observable<{state: RouterStateSnapshot; tree: UrlTree}> {\n  return new Recognizer(\n    injector,\n    configLoader,\n    rootComponentType,\n    config,\n    urlTree,\n    paramsInheritanceStrategy,\n    urlSerializer,\n  ).recognize();\n}\n\nconst MAX_ALLOWED_REDIRECTS = 31;\n\nexport class Recognizer {\n  private applyRedirects: ApplyRedirects;\n  private absoluteRedirectCount = 0;\n  allowRedirects = true;\n\n  constructor(\n    private injector: EnvironmentInjector,\n    private configLoader: RouterConfigLoader,\n    private rootComponentType: Type<any> | null,\n    private config: Routes,\n    private urlTree: UrlTree,\n    private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n    private readonly urlSerializer: UrlSerializer,\n  ) {\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n\n  private noMatchError(e: NoMatch): RuntimeError<RuntimeErrorCode.NO_MATCH> {\n    return new RuntimeError(\n      RuntimeErrorCode.NO_MATCH,\n      typeof ngDevMode === 'undefined' || ngDevMode\n        ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'`\n        : `'${e.segmentGroup}'`,\n    );\n  }\n\n  recognize(): Observable<{state: RouterStateSnapshot; tree: UrlTree}> {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n\n    return this.match(rootSegmentGroup).pipe(\n      map(({children, rootSnapshot}) => {\n        const rootNode = new TreeNode(rootSnapshot, children);\n        const routeState = new RouterStateSnapshot('', rootNode);\n        const tree = createUrlTreeFromSnapshot(\n          rootSnapshot,\n          [],\n          this.urlTree.queryParams,\n          this.urlTree.fragment,\n        );\n        // https://github.com/angular/angular/issues/47307\n        // Creating the tree stringifies the query params\n        // We don't want to do this here so reassign them to the original.\n        tree.queryParams = this.urlTree.queryParams;\n        routeState.url = this.urlSerializer.serialize(tree);\n        return {state: routeState, tree};\n      }),\n    );\n  }\n\n  private match(rootSegmentGroup: UrlSegmentGroup): Observable<{\n    children: TreeNode<ActivatedRouteSnapshot>[];\n    rootSnapshot: ActivatedRouteSnapshot;\n  }> {\n    // Use Object.freeze to prevent readers of the Router state from modifying it outside\n    // of a navigation, resulting in the router being out of sync with the browser.\n    const rootSnapshot = new ActivatedRouteSnapshot(\n      [],\n      Object.freeze({}),\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      Object.freeze({}),\n      PRIMARY_OUTLET,\n      this.rootComponentType,\n      null,\n      {},\n    );\n    return this.processSegmentGroup(\n      this.injector,\n      this.config,\n      rootSegmentGroup,\n      PRIMARY_OUTLET,\n      rootSnapshot,\n    ).pipe(\n      map((children) => {\n        return {children, rootSnapshot};\n      }),\n      catchError((e: any) => {\n        if (e instanceof AbsoluteRedirect) {\n          this.urlTree = e.urlTree;\n          return this.match(e.urlTree.root);\n        }\n        if (e instanceof NoMatch) {\n          throw this.noMatchError(e);\n        }\n\n        throw e;\n      }),\n    );\n  }\n\n  processSegmentGroup(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup, parentRoute);\n    }\n\n    return this.processSegment(\n      injector,\n      config,\n      segmentGroup,\n      segmentGroup.segments,\n      outlet,\n      true,\n      parentRoute,\n    ).pipe(map((child) => (child instanceof TreeNode ? [child] : [])));\n  }\n\n  /**\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n   * we cannot find a match for _any_ of the children.\n   *\n   * @param config - The `Routes` to match against\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n   *     config.\n   */\n  processChildren(\n    injector: EnvironmentInjector,\n    config: Route[],\n    segmentGroup: UrlSegmentGroup,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>[]> {\n    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n    // because an absolute redirect from the primary outlet takes precedence.\n    const childOutlets: string[] = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    return from(childOutlets).pipe(\n      concatMap((childOutlet) => {\n        const child = segmentGroup.children[childOutlet];\n        // Sort the config so that routes with outlets that match the one being activated\n        // appear first, followed by routes for other outlets, which might match if they have\n        // an empty path.\n        const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n        return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n      }),\n      scan((children, outletChildren) => {\n        children.push(...outletChildren);\n        return children;\n      }),\n      defaultIfEmpty(null as TreeNode<ActivatedRouteSnapshot>[] | null),\n      last(),\n      mergeMap((children) => {\n        if (children === null) return noMatch(segmentGroup);\n        // Because we may have matched two outlets to the same empty path segment, we can have\n        // multiple activated results for the same outlet. We should merge the children of\n        // these results so the final return value is only one `TreeNode` per outlet.\n        const mergedChildren = mergeEmptyPathMatches(children);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          // This should really never happen - we are only taking the first match for each\n          // outlet and merge the empty path matches.\n          checkOutletNameUniqueness(mergedChildren);\n        }\n        sortActivatedRouteSnapshots(mergedChildren);\n        return of(mergedChildren);\n      }),\n    );\n  }\n\n  processSegment(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    segmentGroup: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    return from(routes).pipe(\n      concatMap((r) => {\n        return this.processSegmentAgainstRoute(\n          r._injector ?? injector,\n          routes,\n          r,\n          segmentGroup,\n          segments,\n          outlet,\n          allowRedirects,\n          parentRoute,\n        ).pipe(\n          catchError((e: any) => {\n            if (e instanceof NoMatch) {\n              return of(null);\n            }\n            throw e;\n          }),\n        );\n      }),\n      first((x): x is TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl => !!x),\n      catchError((e) => {\n        if (isEmptyError(e)) {\n          if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of(new NoLeftoversInUrl());\n          }\n          return noMatch(segmentGroup);\n        }\n        throw e;\n      }),\n    );\n  }\n\n  processSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    routes: Route[],\n    route: Route,\n    rawSegment: UrlSegmentGroup,\n    segments: UrlSegment[],\n    outlet: string,\n    allowRedirects: boolean,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n    // a config like\n    // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n    // or even\n    // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n    //\n    // The exception here is when the segment outlet is for the primary outlet. This would\n    // result in a match inside the named outlet because all children there are written as primary\n    // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n    // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n    // This should only match if the url is `/(x:b)`.\n    if (\n      getOutlet(route) !== outlet &&\n      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))\n    ) {\n      return noMatch(rawSegment);\n    }\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(\n        injector,\n        rawSegment,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n        injector,\n        rawSegment,\n        routes,\n        route,\n        segments,\n        outlet,\n        parentRoute,\n      );\n    }\n\n    return noMatch(rawSegment);\n  }\n\n  private expandSegmentAgainstRouteUsingRedirect(\n    injector: EnvironmentInjector,\n    segmentGroup: UrlSegmentGroup,\n    routes: Route[],\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot> | NoLeftoversInUrl> {\n    const {matched, parameters, consumedSegments, positionalParamSegments, remainingSegments} =\n      match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n\n    // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n    // size exceeded in production\n    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new RuntimeError(\n            RuntimeErrorCode.INFINITE_REDIRECT,\n            `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` +\n              `This is currently a dev mode only error but will become a` +\n              ` call stack size exceeded error in production in a future major version.`,\n          );\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(\n      segments,\n      parameters,\n      Object.freeze({...this.urlTree.queryParams}),\n      this.urlTree.fragment,\n      getData(route),\n      getOutlet(route),\n      route.component ?? route._loadedComponent ?? null,\n      route,\n      getResolve(route),\n    );\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    const newTree = this.applyRedirects.applyRedirectCommands(\n      consumedSegments,\n      route.redirectTo!,\n      positionalParamSegments,\n      currentSnapshot,\n      injector,\n    );\n\n    return this.applyRedirects.lineralizeSegments(route, newTree).pipe(\n      mergeMap((newSegments: UrlSegment[]) => {\n        return this.processSegment(\n          injector,\n          routes,\n          segmentGroup,\n          newSegments.concat(remainingSegments),\n          outlet,\n          false,\n          parentRoute,\n        );\n      }),\n    );\n  }\n\n  matchSegmentAgainstRoute(\n    injector: EnvironmentInjector,\n    rawSegment: UrlSegmentGroup,\n    route: Route,\n    segments: UrlSegment[],\n    outlet: string,\n    parentRoute: ActivatedRouteSnapshot,\n  ): Observable<TreeNode<ActivatedRouteSnapshot>> {\n    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n    if (route.path === '**') {\n      // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n      // We should investigate a better strategy for any existing children. Otherwise, these\n      // child segments are silently dropped from the navigation.\n      // https://github.com/angular/angular/issues/40089\n      rawSegment.children = {};\n    }\n\n    return matchResult.pipe(\n      switchMap((result) => {\n        if (!result.matched) {\n          return noMatch(rawSegment);\n        }\n        // If the route has an injector created from providers, we should start using that.\n        injector = route._injector ?? injector;\n        return this.getChildConfig(injector, route, segments).pipe(\n          switchMap(({routes: childConfig}) => {\n            const childInjector = route._loadedInjector ?? injector;\n\n            const {parameters, consumedSegments, remainingSegments} = result;\n            const snapshot = new ActivatedRouteSnapshot(\n              consumedSegments,\n              parameters,\n              Object.freeze({...this.urlTree.queryParams}),\n              this.urlTree.fragment,\n              getData(route),\n              getOutlet(route),\n              route.component ?? route._loadedComponent ?? null,\n              route,\n              getResolve(route),\n            );\n            const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n            snapshot.params = Object.freeze(inherited.params);\n            snapshot.data = Object.freeze(inherited.data);\n\n            const {segmentGroup, slicedSegments} = split(\n              rawSegment,\n              consumedSegments,\n              remainingSegments,\n              childConfig,\n            );\n\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n              return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(\n                map((children) => {\n                  return new TreeNode(snapshot, children);\n                }),\n              );\n            }\n\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\n              return of(new TreeNode(snapshot, []));\n            }\n\n            const matchedOnOutlet = getOutlet(route) === outlet;\n            // If we matched a config due to empty path match on a different outlet, we need to\n            // continue passing the current outlet for the segment rather than switch to PRIMARY.\n            // Note that we switch to primary when we have a match because outlet configs look like\n            // this: {path: 'a', outlet: 'a', children: [\n            //  {path: 'b', component: B},\n            //  {path: 'c', component: C},\n            // ]}\n            // Notice that the children of the named outlet are configured with the primary outlet\n            return this.processSegment(\n              childInjector,\n              childConfig,\n              segmentGroup,\n              slicedSegments,\n              matchedOnOutlet ? PRIMARY_OUTLET : outlet,\n              true,\n              snapshot,\n            ).pipe(\n              map((child) => {\n                return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n              }),\n            );\n          }),\n        );\n      }),\n    );\n  }\n  private getChildConfig(\n    injector: EnvironmentInjector,\n    route: Route,\n    segments: UrlSegment[],\n  ): Observable<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return of({routes: route.children, injector});\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedRoutes !== undefined) {\n        return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n      }\n\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(\n        mergeMap((shouldLoadResult: boolean) => {\n          if (shouldLoadResult) {\n            return this.configLoader.loadChildren(injector, route).pipe(\n              tap((cfg: LoadedRouterConfig) => {\n                route._loadedRoutes = cfg.routes;\n                route._loadedInjector = cfg.injector;\n              }),\n            );\n          }\n          return canLoadFails(route);\n        }),\n      );\n    }\n\n    return of({routes: [], injector});\n  }\n}\n\nfunction sortActivatedRouteSnapshots(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction hasEmptyPathConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\n\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(\n  nodes: Array<TreeNode<ActivatedRouteSnapshot>>,\n): Array<TreeNode<ActivatedRouteSnapshot>> {\n  const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n  // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n  const mergedNodes: Set<TreeNode<ActivatedRouteSnapshot>> = new Set();\n\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n\n    const duplicateEmptyPathNode = result.find(\n      (resultNode) => node.value.routeConfig === resultNode.value.routeConfig,\n    );\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n  // by also merging those children. This is necessary when there are multiple empty path configs\n  // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n  // if any of those children can be combined into a single node as well.\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter((n) => !mergedNodes.has(n));\n}\n\nfunction checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  const names: {[k: string]: ActivatedRouteSnapshot} = {};\n  nodes.forEach((n) => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');\n      const c = n.value.url.map((s) => s.toString()).join('/');\n      throw new RuntimeError(\n        RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `Two segments cannot have the same outlet name: '${p}' and '${c}'.`,\n      );\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getData(route: Route): Data {\n  return route.data || {};\n}\n\nfunction getResolve(route: Route): ResolveData {\n  return route.resolve || {};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, Type} from '@angular/core';\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map, mergeMap} from 'rxjs/operators';\n\nimport type {Route} from '../models';\nimport type {NavigationTransition} from '../navigation_transition';\nimport {recognize as recognizeFn} from '../recognize';\nimport type {RouterConfigLoader} from '../router_config_loader';\nimport type {UrlSerializer} from '../url_tree';\n\nexport function recognize(\n  injector: EnvironmentInjector,\n  configLoader: RouterConfigLoader,\n  rootComponentType: Type<any> | null,\n  config: Route[],\n  serializer: UrlSerializer,\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap((t) =>\n    recognizeFn(\n      injector,\n      configLoader,\n      rootComponentType,\n      config,\n      t.extractedUrl,\n      serializer,\n      paramsInheritanceStrategy,\n    ).pipe(\n      map(({state: targetSnapshot, tree: urlAfterRedirects}) => {\n        return {...t, targetSnapshot, urlAfterRedirects};\n      }),\n    ),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {EnvironmentInjector, ProviderToken, runInInjectionContext} from '@angular/core';\nimport {EMPTY, from, MonoTypeOperatorFunction, Observable, of, throwError} from 'rxjs';\nimport {catchError, concatMap, first, map, mergeMap, takeLast, tap} from 'rxjs/operators';\n\nimport {RedirectCommand, ResolveData} from '../models';\nimport type {NavigationTransition} from '../navigation_transition';\nimport {\n  ActivatedRouteSnapshot,\n  getInherited,\n  hasStaticTitle,\n  RouterStateSnapshot,\n} from '../router_state';\nimport {RouteTitleKey} from '../shared';\nimport {getDataKeys, wrapIntoObservable} from '../utils/collection';\nimport {getClosestRouteInjector} from '../utils/config';\nimport {getTokenOrFunctionIdentity} from '../utils/preactivation';\nimport {isEmptyError} from '../utils/type_guards';\nimport {redirectingNavigationError} from '../navigation_canceling_error';\nimport {DefaultUrlSerializer} from '../url_tree';\n\nexport function resolveData(\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n  injector: EnvironmentInjector,\n): MonoTypeOperatorFunction<NavigationTransition> {\n  return mergeMap((t) => {\n    const {\n      targetSnapshot,\n      guards: {canActivateChecks},\n    } = t;\n\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    // Iterating a Set in javascript  happens in insertion order so it is safe to use a `Set` to\n    // preserve the correct order that the resolvers should run in.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#description\n    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));\n    const routesNeedingDataUpdates = new Set<ActivatedRouteSnapshot>();\n    for (const route of routesWithResolversToRun) {\n      if (routesNeedingDataUpdates.has(route)) {\n        continue;\n      }\n      // All children under the route with a resolver to run need to recompute inherited data.\n      for (const newRoute of flattenRouteTree(route)) {\n        routesNeedingDataUpdates.add(newRoute);\n      }\n    }\n    let routesProcessed = 0;\n    return from(routesNeedingDataUpdates).pipe(\n      concatMap((route) => {\n        if (routesWithResolversToRun.has(route)) {\n          return runResolve(route, targetSnapshot!, paramsInheritanceStrategy, injector);\n        } else {\n          route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n          return of(void 0);\n        }\n      }),\n      tap(() => routesProcessed++),\n      takeLast(1),\n      mergeMap((_) => (routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY)),\n    );\n  });\n}\n\n/**\n *  Returns the `ActivatedRouteSnapshot` tree as an array, using DFS to traverse the route tree.\n */\nfunction flattenRouteTree(route: ActivatedRouteSnapshot): ActivatedRouteSnapshot[] {\n  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();\n  return [route, ...descendants];\n}\n\nfunction runResolve(\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  paramsInheritanceStrategy: 'emptyOnly' | 'always',\n  injector: EnvironmentInjector,\n) {\n  const config = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config?.title !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitleKey] = config.title;\n  }\n  return resolveNode(resolve, futureARS, futureRSS, injector).pipe(\n    map((resolvedData: any) => {\n      futureARS._resolvedData = resolvedData;\n      futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n      return null;\n    }),\n  );\n}\n\nfunction resolveNode(\n  resolve: ResolveData,\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<any> {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data: {[k: string | symbol]: any} = {};\n  return from(keys).pipe(\n    mergeMap((key) =>\n      getResolver(resolve[key], futureARS, futureRSS, injector).pipe(\n        first(),\n        tap((value: any) => {\n          if (value instanceof RedirectCommand) {\n            throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n          }\n          data[key] = value;\n        }),\n      ),\n    ),\n    takeLast(1),\n    map(() => data),\n    catchError((e: unknown) => (isEmptyError(e as Error) ? EMPTY : throwError(e))),\n  );\n}\n\nfunction getResolver(\n  injectionToken: ProviderToken<any> | Function,\n  futureARS: ActivatedRouteSnapshot,\n  futureRSS: RouterStateSnapshot,\n  injector: EnvironmentInjector,\n): Observable<any> {\n  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  const resolverValue = resolver.resolve\n    ? resolver.resolve(futureARS, futureRSS)\n    : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n  return wrapIntoObservable(resolverValue);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {from, MonoTypeOperatorFunction, ObservableInput, of} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nexport function switchTap<T>(\n  next: (x: T) => void | ObservableInput<any>,\n): MonoTypeOperatorFunction<T> {\n  return switchMap((v) => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable} from '@angular/core';\nimport {Title} from '@angular/platform-browser';\n\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\nimport {PRIMARY_OUTLET, RouteTitleKey} from './shared';\n\n/**\n * Provides a strategy for setting the page title after a router navigation.\n *\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\n * outlet with `title` property. Given the `Routes` below, navigating to\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\n * ```ts\n * [\n *   {path: 'base', title: 'base', children: [\n *     {path: 'child', title: 'child'},\n *   ],\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\n * ]\n * ```\n *\n * This class can be used as a base class for custom title strategies. That is, you can create your\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\n * from the named outlet is never used. However, a custom strategy might be implemented to\n * incorporate titles in named outlets.\n *\n * @publicApi\n * @see [Page title guide](guide/routing/common-router-tasks#setting-the-page-title)\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy)})\nexport abstract class TitleStrategy {\n  /** Performs the application title update. */\n  abstract updateTitle(snapshot: RouterStateSnapshot): void;\n\n  /**\n   * @returns The `title` of the deepest primary route.\n   */\n  buildTitle(snapshot: RouterStateSnapshot): string | undefined {\n    let pageTitle: string | undefined;\n    let route: ActivatedRouteSnapshot | undefined = snapshot.root;\n    while (route !== undefined) {\n      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);\n    }\n    return pageTitle;\n  }\n\n  /**\n   * Given an `ActivatedRouteSnapshot`, returns the final value of the\n   * `Route.title` property, which can either be a static string or a resolved value.\n   */\n  getResolvedTitleForRoute(snapshot: ActivatedRouteSnapshot) {\n    return snapshot.data[RouteTitleKey];\n  }\n}\n\n/**\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\n */\n@Injectable({providedIn: 'root'})\nexport class DefaultTitleStrategy extends TitleStrategy {\n  constructor(readonly title: Title) {\n    super();\n  }\n\n  /**\n   * Sets the title of the browser to the given value.\n   *\n   * @param title The `pageTitle` from the deepest primary route.\n   */\n  override updateTitle(snapshot: RouterStateSnapshot): void {\n    const title = this.buildTitle(snapshot);\n    if (title !== undefined) {\n      this.title.setTitle(title);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\nimport {OnSameUrlNavigation, QueryParamsHandling, RedirectCommand} from './models';\n\n/**\n * Allowed values in an `ExtraOptions` object that configure\n * when the router performs the initial navigation operation.\n *\n * * 'enabledNonBlocking' - (default) The initial navigation starts after the\n * root component has been created. The bootstrap is not blocked on the completion of the initial\n * navigation.\n * * 'enabledBlocking' - The initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete. This value should be set in\n * case you use [server-side rendering](guide/ssr), but do not enable [hydration](guide/hydration)\n * for your application.\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\n * the root component gets created. Use if there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic.\n *\n * @see {@link /api/router/RouterModule#forRoot forRoot}\n *\n * @publicApi\n */\nexport type InitialNavigation = 'disabled' | 'enabledBlocking' | 'enabledNonBlocking';\n\n/**\n * Extra configuration options that can be used with the `withRouterConfig` function.\n *\n * @publicApi\n */\nexport interface RouterConfigOptions {\n  /**\n   * Configures how the Router attempts to restore state when a navigation is cancelled.\n   *\n   * 'replace' - Always uses `location.replaceState` to set the browser state to the state of the\n   * router before the navigation started. This means that if the URL of the browser is updated\n   * _before_ the navigation is canceled, the Router will simply replace the item in history rather\n   * than trying to restore to the previous location in the session history. This happens most\n   * frequently with `urlUpdateStrategy: 'eager'` and navigations with the browser back/forward\n   * buttons.\n   *\n   * 'computed' - Will attempt to return to the same index in the session history that corresponds\n   * to the Angular route when the navigation gets cancelled. For example, if the browser back\n   * button is clicked and the navigation is cancelled, the Router will trigger a forward navigation\n   * and vice versa.\n   *\n   * Note: the 'computed' option is incompatible with any `UrlHandlingStrategy` which only\n   * handles a portion of the URL because the history restoration navigates to the previous place in\n   * the browser history rather than simply resetting a portion of the URL.\n   *\n   * The default value is `replace` when not set.\n   */\n  canceledNavigationResolution?: 'replace' | 'computed';\n\n  /**\n   * Configures the default for handling a navigation request to the current URL.\n   *\n   * If unset, the `Router` will use `'ignore'`.\n   *\n   * @see {@link OnSameUrlNavigation}\n   */\n  onSameUrlNavigation?: OnSameUrlNavigation;\n\n  /**\n   * Defines how the router merges parameters, data, and resolved data from parent to child\n   * routes.\n   *\n   * By default ('emptyOnly'), a route inherits the parent route's parameters when the route itself\n   * has an empty path (meaning its configured with path: '') or when the parent route doesn't have\n   * any component set.\n   *\n   * Set to 'always' to enable unconditional inheritance of parent parameters.\n   *\n   * Note that when dealing with matrix parameters, \"parent\" refers to the parent `Route`\n   * config which does not necessarily mean the \"URL segment to the left\". When the `Route` `path`\n   * contains multiple segments, the matrix parameters must appear on the last segment. For example,\n   * matrix parameters for `{path: 'a/b', component: MyComp}` should appear as `a/b;foo=bar` and not\n   * `a;foo=bar/b`.\n   *\n   */\n  paramsInheritanceStrategy?: 'emptyOnly' | 'always';\n\n  /**\n   * Defines when the router updates the browser URL. By default ('deferred'),\n   * update after successful navigation.\n   * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n   * Updating the URL early allows you to handle a failure of navigation by\n   * showing an error message with the URL that failed.\n   */\n  urlUpdateStrategy?: 'deferred' | 'eager';\n\n  /**\n   * The default strategy to use for handling query params in `Router.createUrlTree` when one is not provided.\n   *\n   * The `createUrlTree` method is used internally by `Router.navigate` and `RouterLink`.\n   * Note that `QueryParamsHandling` does not apply to `Router.navigateByUrl`.\n   *\n   * When neither the default nor the queryParamsHandling option is specified in the call to `createUrlTree`,\n   * the current parameters will be replaced by new parameters.\n   *\n   * @see {@link Router#createUrlTree}\n   * @see {@link QueryParamsHandling}\n   */\n  defaultQueryParamsHandling?: QueryParamsHandling;\n\n  /**\n   * When `true`, the `Promise` will instead resolve with `false`, as it does with other failed\n   * navigations (for example, when guards are rejected).\n\n   * Otherwise the `Promise` returned by the Router's navigation with be rejected\n   * if an error occurs.\n   */\n  resolveNavigationPromiseOnError?: boolean;\n}\n\n/**\n * Configuration options for the scrolling feature which can be used with `withInMemoryScrolling`\n * function.\n *\n * @publicApi\n */\nexport interface InMemoryScrollingOptions {\n  /**\n   * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n   * Anchor scrolling is disabled by default.\n   *\n   * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n   * that we stored or scroll to the top.\n   */\n  anchorScrolling?: 'disabled' | 'enabled';\n\n  /**\n   * Configures if the scroll position needs to be restored when navigating back.\n   *\n   * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n   * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n   * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n   * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n   * navigation). This option will be the default in the future.\n   *\n   * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n   * in the following example.\n   *\n   * ```ts\n   * class AppComponent {\n   *   movieData: any;\n   *\n   *   constructor(private router: Router, private viewportScroller: ViewportScroller,\n   * changeDetectorRef: ChangeDetectorRef) {\n   *   router.events.pipe(filter((event: Event): event is Scroll => event instanceof Scroll)\n   *     ).subscribe(e => {\n   *       fetch('http://example.com/movies.json').then(response => {\n   *         this.movieData = response.json();\n   *         // update the template with the data before restoring scroll\n   *         changeDetectorRef.detectChanges();\n   *\n   *         if (e.position) {\n   *           viewportScroller.scrollToPosition(e.position);\n   *         }\n   *       });\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n}\n\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * @see {@link /api/router/routerModule#forRoot forRoot}\n *\n *\n * @publicApi\n */\nexport interface ExtraOptions extends InMemoryScrollingOptions, RouterConfigOptions {\n  /**\n   * When true, log all internal navigation events to the console.\n   * Use for debugging.\n   */\n  enableTracing?: boolean;\n\n  /**\n   * When true, enable the location strategy that uses the URL fragment\n   * instead of the history API.\n   */\n  useHash?: boolean;\n\n  /**\n   * One of `enabled`, `enabledBlocking`, `enabledNonBlocking` or `disabled`.\n   * When set to `enabled` or `enabledBlocking`, the initial navigation starts before the root\n   * component is created. The bootstrap is blocked until the initial navigation is complete. This\n   * value should be set in case you use [server-side rendering](guide/ssr), but do not enable\n   * [hydration](guide/hydration) for your application. When set to `enabledNonBlocking`,\n   * the initial navigation starts after the root component has been created.\n   * The bootstrap is not blocked on the completion of the initial navigation. When set to\n   * `disabled`, the initial navigation is not performed. The location listener is set up before the\n   * root component gets created. Use if there is a reason to have more control over when the router\n   * starts its initial navigation due to some complex initialization logic.\n   */\n  initialNavigation?: InitialNavigation;\n\n  /**\n   * When true, enables binding information from the `Router` state directly to the inputs of the\n   * component in `Route` configurations.\n   */\n  bindToComponentInputs?: boolean;\n\n  /**\n   * When true, enables view transitions in the Router by running the route activation and\n   * deactivation inside of `document.startViewTransition`.\n   *\n   * @see https://developer.chrome.com/docs/web-platform/view-transitions/\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\n   * @experimental\n   */\n  enableViewTransitions?: boolean;\n\n  /**\n   * A custom error handler for failed navigations.\n   * If the handler returns a value, the navigation Promise is resolved with this value.\n   * If the handler throws an exception, the navigation Promise is rejected with the exception.\n   *\n   * @see RouterConfigOptions\n   */\n  errorHandler?: (error: any) => RedirectCommand | any;\n\n  /**\n   * Configures a preloading strategy.\n   * One of `PreloadAllModules` or `NoPreloading` (the default).\n   */\n  preloadingStrategy?: any;\n\n  /**\n   * Configures the scroll offset the router will use when scrolling to an element.\n   *\n   * When given a tuple with x and y position value,\n   * the router uses that offset each time it scrolls.\n   * When given a function, the router invokes the function every time\n   * it restores scroll position.\n   */\n  scrollOffset?: [number, number] | (() => [number, number]);\n}\n\n/**\n * A DI token for the router service.\n *\n * @publicApi\n */\nexport const ROUTER_CONFIGURATION = new InjectionToken<ExtraOptions>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '',\n  {\n    providedIn: 'root',\n    factory: () => ({}),\n  },\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Component} from '@angular/core';\n\nimport {RouterOutlet} from '../directives/router_outlet';\nimport {PRIMARY_OUTLET} from '../shared';\nimport {Route} from '../models';\nexport {EmptyOutletComponent as EmptyOutletComponent};\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n@Component({\n  template: `<router-outlet/>`,\n  imports: [RouterOutlet],\n  // Used to avoid component ID collisions with user code.\n  exportAs: 'emptyRouterOutlet',\n})\nexport class EmptyOutletComponent {}\n\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nexport function standardizeConfig(r: Route): Route {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {...r, children} : {...r};\n  if (\n    !c.component &&\n    !c.loadComponent &&\n    (children || c.loadChildren) &&\n    c.outlet &&\n    c.outlet !== PRIMARY_OUTLET\n  ) {\n    c.component = EmptyOutletComponent;\n  }\n  return c;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Compiler,\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  NgModuleFactory,\n  Type,\n} from '@angular/core';\nimport {ConnectableObservable, from, Observable, of, Subject} from 'rxjs';\nimport {finalize, map, mergeMap, refCount, tap} from 'rxjs/operators';\n\nimport {DefaultExport, LoadedRouterConfig, Route, Routes} from './models';\nimport {wrapIntoObservable} from './utils/collection';\nimport {assertStandalone, validateConfig} from './utils/config';\nimport {standardizeConfig} from './components/empty_outlet';\n\n/**\n * The DI token for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `provideRouter`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\nexport const ROUTES = new InjectionToken<Route[][]>(ngDevMode ? 'ROUTES' : '');\n\ntype ComponentLoader = Observable<Type<unknown>>;\n\n@Injectable({providedIn: 'root'})\nexport class RouterConfigLoader {\n  private componentLoaders = new WeakMap<Route, ComponentLoader>();\n  private childrenLoaders = new WeakMap<Route, Observable<LoadedRouterConfig>>();\n  onLoadStartListener?: (r: Route) => void;\n  onLoadEndListener?: (r: Route) => void;\n  private readonly compiler = inject(Compiler);\n\n  loadComponent(route: Route): Observable<Type<unknown>> {\n    if (this.componentLoaders.get(route)) {\n      return this.componentLoaders.get(route)!;\n    } else if (route._loadedComponent) {\n      return of(route._loadedComponent);\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const loadRunner = wrapIntoObservable(route.loadComponent!()).pipe(\n      map(maybeUnwrapDefaultExport),\n      tap((component) => {\n        if (this.onLoadEndListener) {\n          this.onLoadEndListener(route);\n        }\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          assertStandalone(route.path ?? '', component);\n        route._loadedComponent = component;\n      }),\n      finalize(() => {\n        this.componentLoaders.delete(route);\n      }),\n    );\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader = new ConnectableObservable(loadRunner, () => new Subject<Type<unknown>>()).pipe(\n      refCount(),\n    );\n    this.componentLoaders.set(route, loader);\n    return loader;\n  }\n\n  loadChildren(parentInjector: Injector, route: Route): Observable<LoadedRouterConfig> {\n    if (this.childrenLoaders.get(route)) {\n      return this.childrenLoaders.get(route)!;\n    } else if (route._loadedRoutes) {\n      return of({routes: route._loadedRoutes, injector: route._loadedInjector});\n    }\n\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const moduleFactoryOrRoutes$ = loadChildren(\n      route,\n      this.compiler,\n      parentInjector,\n      this.onLoadEndListener,\n    );\n    const loadRunner = moduleFactoryOrRoutes$.pipe(\n      finalize(() => {\n        this.childrenLoaders.delete(route);\n      }),\n    );\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader = new ConnectableObservable(\n      loadRunner,\n      () => new Subject<LoadedRouterConfig>(),\n    ).pipe(refCount());\n    this.childrenLoaders.set(route, loader);\n    return loader;\n  }\n}\n\n/**\n * Executes a `route.loadChildren` callback and converts the result to an array of child routes and\n * an injector if that callback returned a module.\n *\n * This function is used for the route discovery during prerendering\n * in @angular-devkit/build-angular. If there are any updates to the contract here, it will require\n * an update to the extractor.\n */\nexport function loadChildren(\n  route: Route,\n  compiler: Compiler,\n  parentInjector: Injector,\n  onLoadEndListener?: (r: Route) => void,\n): Observable<LoadedRouterConfig> {\n  return wrapIntoObservable(route.loadChildren!()).pipe(\n    map(maybeUnwrapDefaultExport),\n    mergeMap((t) => {\n      if (t instanceof NgModuleFactory || Array.isArray(t)) {\n        return of(t);\n      } else {\n        return from(compiler.compileModuleAsync(t));\n      }\n    }),\n    map((factoryOrRoutes: NgModuleFactory<any> | Routes) => {\n      if (onLoadEndListener) {\n        onLoadEndListener(route);\n      }\n      // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is\n      // no injector associated with lazy loading a `Route` array.\n      let injector: EnvironmentInjector | undefined;\n      let rawRoutes: Route[];\n      let requireStandaloneComponents = false;\n      if (Array.isArray(factoryOrRoutes)) {\n        rawRoutes = factoryOrRoutes;\n        requireStandaloneComponents = true;\n      } else {\n        injector = factoryOrRoutes.create(parentInjector).injector;\n        // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n        // will get stuck in an infinite loop. The child module's Injector will look to\n        // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n        // for it's parent module instead.\n        rawRoutes = injector.get(ROUTES, [], {optional: true, self: true}).flat();\n      }\n      const routes = rawRoutes.map(standardizeConfig);\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        validateConfig(routes, route.path, requireStandaloneComponents);\n      return {routes, injector};\n    }),\n  );\n}\n\nfunction isWrappedDefaultExport<T>(value: T | DefaultExport<T>): value is DefaultExport<T> {\n  // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be\n  // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that\n  // `default` will be a renamed property.\n  return value && typeof value === 'object' && 'default' in value;\n}\n\nfunction maybeUnwrapDefaultExport<T>(input: T | DefaultExport<T>): T {\n  // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not\n  // subject to property renaming, so we reference it with bracket access.\n  return isWrappedDefaultExport(input) ? input['default'] : input;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable} from '@angular/core';\n\nimport {UrlTree} from './url_tree';\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy)})\nexport abstract class UrlHandlingStrategy {\n  /**\n   * Tells the router if this URL should be processed.\n   *\n   * When it returns true, the router will execute the regular navigation.\n   * When it returns false, the router will set the router state to an empty state.\n   * As a result, all the active components will be destroyed.\n   *\n   */\n  abstract shouldProcessUrl(url: UrlTree): boolean;\n\n  /**\n   * Extracts the part of the URL that should be handled by the router.\n   * The rest of the URL will remain untouched.\n   */\n  abstract extract(url: UrlTree): UrlTree;\n\n  /**\n   * Merges the URL fragment with the rest of the URL.\n   */\n  abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class DefaultUrlHandlingStrategy implements UrlHandlingStrategy {\n  shouldProcessUrl(url: UrlTree): boolean {\n    return true;\n  }\n  extract(url: UrlTree): UrlTree {\n    return url;\n  }\n  merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree {\n    return newUrlPart;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/// <reference types=\"dom-view-transitions\" />\n\nimport {DOCUMENT} from '@angular/common';\nimport {\n  afterNextRender,\n  InjectionToken,\n  Injector,\n  NgZone,\n  runInInjectionContext,\n} from '@angular/core';\n\nimport {ActivatedRouteSnapshot} from '../router_state';\n\nexport const CREATE_VIEW_TRANSITION = new InjectionToken<typeof createViewTransition>(\n  ngDevMode ? 'view transition helper' : '',\n);\nexport const VIEW_TRANSITION_OPTIONS = new InjectionToken<\n  ViewTransitionsFeatureOptions & {skipNextTransition: boolean}\n>(ngDevMode ? 'view transition options' : '');\n\n/**\n * Options to configure the View Transitions integration in the Router.\n *\n * @experimental\n * @publicApi\n * @see withViewTransitions\n */\nexport interface ViewTransitionsFeatureOptions {\n  /**\n   * Skips the very first call to `startViewTransition`. This can be useful for disabling the\n   * animation during the application's initial loading phase.\n   */\n  skipInitialTransition?: boolean;\n\n  /**\n   * A function to run after the `ViewTransition` is created.\n   *\n   * This function is run in an injection context and can use `inject`.\n   */\n  onViewTransitionCreated?: (transitionInfo: ViewTransitionInfo) => void;\n}\n\n/**\n * The information passed to the `onViewTransitionCreated` function provided in the\n * `withViewTransitions` feature options.\n *\n * @publicApi\n * @experimental\n */\nexport interface ViewTransitionInfo {\n  // TODO(atscott): This type can/should be the built-in `ViewTransition` type\n  // from @types/dom-view-transitions but exporting that type from the public API is currently not\n  // supported by tooling.\n  /**\n   * The `ViewTransition` returned by the call to `startViewTransition`.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition\n   */\n  transition: {\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/finished\n     */\n    finished: Promise<void>;\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/ready\n     */\n    ready: Promise<void>;\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/updateCallbackDone\n     */\n    updateCallbackDone: Promise<void>;\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ViewTransition/skipTransition\n     */\n    skipTransition(): void;\n  };\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning from.\n   */\n  from: ActivatedRouteSnapshot;\n  /**\n   * The `ActivatedRouteSnapshot` that the navigation is transitioning to.\n   */\n  to: ActivatedRouteSnapshot;\n}\n\n/**\n * A helper function for using browser view transitions. This function skips the call to\n * `startViewTransition` if the browser does not support it.\n *\n * @returns A Promise that resolves when the view transition callback begins.\n */\nexport function createViewTransition(\n  injector: Injector,\n  from: ActivatedRouteSnapshot,\n  to: ActivatedRouteSnapshot,\n): Promise<void> {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document = injector.get(DOCUMENT);\n  // Create promises outside the Angular zone to avoid causing extra change detections\n  return injector.get(NgZone).runOutsideAngular(() => {\n    if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n      transitionOptions.skipNextTransition = false;\n      // The timing of `startViewTransition` is closer to a macrotask. It won't be called\n      // until the current event loop exits so we use a promise resolved in a timeout instead\n      // of Promise.resolve().\n      return new Promise((resolve) => setTimeout(resolve));\n    }\n\n    let resolveViewTransitionStarted: () => void;\n    const viewTransitionStarted = new Promise<void>((resolve) => {\n      resolveViewTransitionStarted = resolve;\n    });\n    const transition = document.startViewTransition(() => {\n      resolveViewTransitionStarted();\n      // We don't actually update dom within the transition callback. The resolving of the above\n      // promise unblocks the Router navigation, which synchronously activates and deactivates\n      // routes (the DOM update). This view transition waits for the next change detection to\n      // complete (below), which includes the update phase of the routed components.\n      return createRenderPromise(injector);\n    });\n    const {onViewTransitionCreated} = transitionOptions;\n    if (onViewTransitionCreated) {\n      runInInjectionContext(injector, () => onViewTransitionCreated({transition, from, to}));\n    }\n    return viewTransitionStarted;\n  });\n}\n\n/**\n * Creates a promise that resolves after next render.\n */\nfunction createRenderPromise(injector: Injector) {\n  return new Promise<void>((resolve) => {\n    // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).\n    // This ensures any follow-up renders in the microtask queue are completed before the\n    // view transition starts animating.\n    afterNextRender({read: () => setTimeout(resolve)}, {injector});\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {\n  DestroyRef,\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  InjectionToken,\n  runInInjectionContext,\n  Type,\n} from '@angular/core';\nimport {BehaviorSubject, combineLatest, EMPTY, from, Observable, of, Subject} from 'rxjs';\nimport {\n  catchError,\n  defaultIfEmpty,\n  filter,\n  finalize,\n  map,\n  switchMap,\n  take,\n  takeUntil,\n  tap,\n} from 'rxjs/operators';\n\nimport {createRouterState} from './create_router_state';\nimport {INPUT_BINDER} from './directives/router_outlet';\nimport {\n  BeforeActivateRoutes,\n  Event,\n  GuardsCheckEnd,\n  GuardsCheckStart,\n  IMPERATIVE_NAVIGATION,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n  NavigationSkippedCode,\n  NavigationStart,\n  NavigationTrigger,\n  RedirectRequest,\n  ResolveEnd,\n  ResolveStart,\n  RouteConfigLoadEnd,\n  RouteConfigLoadStart,\n  RoutesRecognized,\n} from './events';\nimport {\n  GuardResult,\n  NavigationBehaviorOptions,\n  QueryParamsHandling,\n  RedirectCommand,\n  Route,\n  Routes,\n} from './models';\nimport {\n  isNavigationCancelingError,\n  isRedirectingNavigationCancelingError,\n  redirectingNavigationError,\n} from './navigation_canceling_error';\nimport {activateRoutes} from './operators/activate_routes';\nimport {checkGuards} from './operators/check_guards';\nimport {recognize} from './operators/recognize';\nimport {resolveData} from './operators/resolve_data';\nimport {switchTap} from './operators/switch_tap';\nimport {TitleStrategy} from './page_title_strategy';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ROUTER_CONFIGURATION} from './router_config';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {\n  ActivatedRoute,\n  ActivatedRouteSnapshot,\n  createEmptyState,\n  RouterState,\n  RouterStateSnapshot,\n} from './router_state';\nimport type {Params} from './shared';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {isUrlTree, UrlSerializer, UrlTree} from './url_tree';\nimport {Checks, getAllRouteGuards} from './utils/preactivation';\nimport {CREATE_VIEW_TRANSITION} from './utils/view_transition';\n\n/**\n * @description\n *\n * Options that modify the `Router` URL.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#createUrlTree}\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n *\n * @publicApi\n */\nexport interface UrlCreationOptions {\n  /**\n   * Specifies a root URI to use for relative navigation.\n   *\n   * For example, consider the following route configuration where the parent route\n   * has two children.\n   *\n   * ```\n   * [{\n   *   path: 'parent',\n   *   component: ParentComponent,\n   *   children: [{\n   *     path: 'list',\n   *     component: ListComponent\n   *   },{\n   *     path: 'child',\n   *     component: ChildComponent\n   *   }]\n   * }]\n   * ```\n   *\n   * The following `go()` function navigates to the `list` route by\n   * interpreting the destination URI as relative to the activated `child`  route\n   *\n   * ```ts\n   *  @Component({...})\n   *  class ChildComponent {\n   *    constructor(private router: Router, private route: ActivatedRoute) {}\n   *\n   *    go() {\n   *      router.navigate(['../list'], { relativeTo: this.route });\n   *    }\n   *  }\n   * ```\n   *\n   * A value of `null` or `undefined` indicates that the navigation commands should be applied\n   * relative to the root.\n   */\n  relativeTo?: ActivatedRoute | null;\n\n  /**\n   * Sets query parameters to the URL.\n   *\n   * ```\n   * // Navigate to /results?page=1\n   * router.navigate(['/results'], { queryParams: { page: 1 } });\n   * ```\n   */\n  queryParams?: Params | null;\n\n  /**\n   * Sets the hash fragment for the URL.\n   *\n   * ```\n   * // Navigate to /results#top\n   * router.navigate(['/results'], { fragment: 'top' });\n   * ```\n   */\n  fragment?: string;\n\n  /**\n   * How to handle query parameters in the router link for the next navigation.\n   * One of:\n   * * `preserve` : Preserve current parameters.\n   * * `merge` : Merge new with current parameters.\n   *\n   * The \"preserve\" option discards any new query params:\n   * ```\n   * // from /view1?page=1 to/view2?page=1\n   * router.navigate(['/view2'], { queryParams: { page: 2 },  queryParamsHandling: \"preserve\"\n   * });\n   * ```\n   * The \"merge\" option appends new query params to the params from the current URL:\n   * ```\n   * // from /view1?page=1 to/view2?page=1&otherKey=2\n   * router.navigate(['/view2'], { queryParams: { otherKey: 2 },  queryParamsHandling: \"merge\"\n   * });\n   * ```\n   * In case of a key collision between current parameters and those in the `queryParams` object,\n   * the new value is used.\n   *\n   */\n  queryParamsHandling?: QueryParamsHandling | null;\n\n  /**\n   * When true, preserves the URL fragment for the next navigation\n   *\n   * ```\n   * // Preserve fragment from /results#top to /view#top\n   * router.navigate(['/view'], { preserveFragment: true });\n   * ```\n   */\n  preserveFragment?: boolean;\n}\n\n/**\n * @description\n *\n * Options that modify the `Router` navigation strategy.\n * Supply an object containing any of these properties to a `Router` navigation function to\n * control how the target URL should be constructed or interpreted.\n *\n * @see {@link Router#navigate}\n * @see {@link Router#navigateByUrl}\n * @see {@link Router#createurltree}\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n * @see {@link UrlCreationOptions}\n * @see {@link NavigationBehaviorOptions}\n *\n * @publicApi\n */\nexport interface NavigationExtras extends UrlCreationOptions, NavigationBehaviorOptions {}\n\nexport type RestoredState = {\n  [k: string]: any;\n  // TODO(#27607): Remove `navigationId` and `routerPageId` and move to `ng` or `` namespace.\n  navigationId: number;\n  // The `` prefix is there to reduce the chance of colliding with any existing user properties on\n  // the history state.\n  routerPageId?: number;\n};\n\n/**\n * Information about a navigation operation.\n * Retrieve the most recent navigation object with the\n * [Router.getCurrentNavigation() method](api/router/Router#getcurrentnavigation) .\n *\n * * *id* : The unique identifier of the current navigation.\n * * *initialUrl* : The target URL passed into the `Router#navigateByUrl()` call before navigation.\n * This is the value before the router has parsed or applied redirects to it.\n * * *extractedUrl* : The initial target URL after being parsed with `UrlSerializer.extract()`.\n * * *finalUrl* : The extracted URL after redirects have been applied.\n * This URL may not be available immediately, therefore this property can be `undefined`.\n * It is guaranteed to be set after the `RoutesRecognized` event fires.\n * * *trigger* : Identifies how this navigation was triggered.\n * -- 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n * -- 'popstate'--Triggered by a popstate event.\n * -- 'hashchange'--Triggered by a hashchange event.\n * * *extras* : A `NavigationExtras` options object that controlled the strategy used for this\n * navigation.\n * * *previousNavigation* : The previously successful `Navigation` object. Only one previous\n * navigation is available, therefore this previous `Navigation` object has a `null` value for its\n * own `previousNavigation`.\n *\n * @publicApi\n */\nexport interface Navigation {\n  /**\n   * The unique identifier of the current navigation.\n   */\n  id: number;\n  /**\n   * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n   * the value before the router has parsed or applied redirects to it.\n   */\n  initialUrl: UrlTree;\n  /**\n   * The initial target URL after being parsed with `UrlHandlingStrategy.extract()`.\n   */\n  extractedUrl: UrlTree;\n  /**\n   * The extracted URL after redirects have been applied.\n   * This URL may not be available immediately, therefore this property can be `undefined`.\n   * It is guaranteed to be set after the `RoutesRecognized` event fires.\n   */\n  finalUrl?: UrlTree;\n  /**\n   * `UrlTree` to use when updating the browser URL for the navigation when `extras.browserUrl` is\n   * defined.\n   * @internal\n   */\n  readonly targetBrowserUrl?: UrlTree | string;\n  /**\n   * TODO(atscott): If we want to make StateManager public, they will need access to this. Note that\n   * it's already eventually exposed through router.routerState.\n   * @internal\n   */\n  targetRouterState?: RouterState;\n  /**\n   * Identifies how this navigation was triggered.\n   *\n   * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n   * * 'popstate'--Triggered by a popstate event.\n   * * 'hashchange'--Triggered by a hashchange event.\n   */\n  trigger: 'imperative' | 'popstate' | 'hashchange';\n  /**\n   * Options that controlled the strategy used for this navigation.\n   * See `NavigationExtras`.\n   */\n  extras: NavigationExtras;\n  /**\n   * The previously successful `Navigation` object. Only one previous navigation\n   * is available, therefore this previous `Navigation` object has a `null` value\n   * for its own `previousNavigation`.\n   */\n  previousNavigation: Navigation | null;\n}\n\nexport interface NavigationTransition {\n  id: number;\n  currentUrlTree: UrlTree;\n  extractedUrl: UrlTree;\n  currentRawUrl: UrlTree;\n  urlAfterRedirects?: UrlTree;\n  rawUrl: UrlTree;\n  extras: NavigationExtras;\n  resolve: (value: boolean | PromiseLike<boolean>) => void;\n  reject: (reason?: any) => void;\n  promise: Promise<boolean>;\n  source: NavigationTrigger;\n  restoredState: RestoredState | null;\n  currentSnapshot: RouterStateSnapshot;\n  targetSnapshot: RouterStateSnapshot | null;\n  currentRouterState: RouterState;\n  targetRouterState: RouterState | null;\n  guards: Checks;\n  guardsResult: GuardResult | null;\n}\n\n/**\n * The interface from the Router needed by the transitions. Used to avoid a circular dependency on\n * Router. This interface should be whittled down with future refactors. For example, we do not need\n * to get `UrlSerializer` from the Router. We can instead inject it in `NavigationTransitions`\n * directly.\n */\ninterface InternalRouterInterface {\n  config: Routes;\n  navigated: boolean;\n  routeReuseStrategy: RouteReuseStrategy;\n  onSameUrlNavigation: 'reload' | 'ignore';\n}\n\nexport const NAVIGATION_ERROR_HANDLER = new InjectionToken<\n  (error: NavigationError) => unknown | RedirectCommand\n>(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\n\n@Injectable({providedIn: 'root'})\nexport class NavigationTransitions {\n  currentNavigation: Navigation | null = null;\n  currentTransition: NavigationTransition | null = null;\n  lastSuccessfulNavigation: Navigation | null = null;\n  /**\n   * These events are used to communicate back to the Router about the state of the transition. The\n   * Router wants to respond to these events in various ways. Because the `NavigationTransition`\n   * class is not public, this event subject is not publicly exposed.\n   */\n  readonly events = new Subject<Event | BeforeActivateRoutes | RedirectRequest>();\n  /**\n   * Used to abort the current transition with an error.\n   */\n  readonly transitionAbortSubject = new Subject<Error>();\n  private readonly configLoader = inject(RouterConfigLoader);\n  private readonly environmentInjector = inject(EnvironmentInjector);\n  private readonly destroyRef = inject(DestroyRef);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly rootContexts = inject(ChildrenOutletContexts);\n  private readonly location = inject(Location);\n  private readonly inputBindingEnabled = inject(INPUT_BINDER, {optional: true}) !== null;\n  private readonly titleStrategy?: TitleStrategy = inject(TitleStrategy);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly paramsInheritanceStrategy =\n    this.options.paramsInheritanceStrategy || 'emptyOnly';\n  private readonly urlHandlingStrategy = inject(UrlHandlingStrategy);\n  private readonly createViewTransition = inject(CREATE_VIEW_TRANSITION, {optional: true});\n  private readonly navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {optional: true});\n\n  navigationId = 0;\n  get hasRequestedNavigation() {\n    return this.navigationId !== 0;\n  }\n  private transitions?: BehaviorSubject<NavigationTransition | null>;\n  /**\n   * Hook that enables you to pause navigation after the preactivation phase.\n   * Used by `RouterModule`.\n   *\n   * @internal\n   */\n  afterPreactivation: () => Observable<void> = () => of(void 0);\n  /** @internal */\n  rootComponentType: Type<any> | null = null;\n\n  private destroyed = false;\n\n  constructor() {\n    const onLoadStart = (r: Route) => this.events.next(new RouteConfigLoadStart(r));\n    const onLoadEnd = (r: Route) => this.events.next(new RouteConfigLoadEnd(r));\n    this.configLoader.onLoadEndListener = onLoadEnd;\n    this.configLoader.onLoadStartListener = onLoadStart;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n\n  complete() {\n    this.transitions?.complete();\n  }\n\n  handleNavigationRequest(\n    request: Pick<\n      NavigationTransition,\n      | 'source'\n      | 'restoredState'\n      | 'currentUrlTree'\n      | 'currentRawUrl'\n      | 'rawUrl'\n      | 'extras'\n      | 'resolve'\n      | 'reject'\n      | 'promise'\n      | 'currentSnapshot'\n      | 'currentRouterState'\n    >,\n  ) {\n    const id = ++this.navigationId;\n    this.transitions?.next({\n      ...request,\n      extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n      targetSnapshot: null,\n      targetRouterState: null,\n      guards: {canActivateChecks: [], canDeactivateChecks: []},\n      guardsResult: null,\n      id,\n    });\n  }\n\n  setupNavigations(router: InternalRouterInterface): Observable<NavigationTransition> {\n    this.transitions = new BehaviorSubject<NavigationTransition | null>(null);\n    return this.transitions.pipe(\n      filter((t): t is NavigationTransition => t !== null),\n\n      // Using switchMap so we cancel executing navigations when a new one comes in\n      switchMap((overallTransitionState) => {\n        let completed = false;\n        let errored = false;\n        return of(overallTransitionState).pipe(\n          switchMap((t) => {\n            // It is possible that `switchMap` fails to cancel previous navigations if a new one happens synchronously while the operator\n            // is processing the `next` notification of that previous navigation. This can happen when a new navigation (say 2) cancels a\n            // previous one (1) and yet another navigation (3) happens synchronously in response to the `NavigationCancel` event for (1).\n            // https://github.com/ReactiveX/rxjs/issues/7455\n            if (this.navigationId > overallTransitionState.id) {\n              const cancellationReason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                  : '';\n              this.cancelNavigationTransition(\n                overallTransitionState,\n                cancellationReason,\n                NavigationCancellationCode.SupersededByNewNavigation,\n              );\n              return EMPTY;\n            }\n            this.currentTransition = overallTransitionState;\n            // Store the Navigation object\n            this.currentNavigation = {\n              id: t.id,\n              initialUrl: t.rawUrl,\n              extractedUrl: t.extractedUrl,\n              targetBrowserUrl:\n                typeof t.extras.browserUrl === 'string'\n                  ? this.urlSerializer.parse(t.extras.browserUrl)\n                  : t.extras.browserUrl,\n              trigger: t.source,\n              extras: t.extras,\n              previousNavigation: !this.lastSuccessfulNavigation\n                ? null\n                : {\n                    ...this.lastSuccessfulNavigation,\n                    previousNavigation: null,\n                  },\n            };\n            const urlTransition =\n              !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n\n            const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n            if (!urlTransition && onSameUrlNavigation !== 'reload') {\n              const reason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.`\n                  : '';\n              this.events.next(\n                new NavigationSkipped(\n                  t.id,\n                  this.urlSerializer.serialize(t.rawUrl),\n                  reason,\n                  NavigationSkippedCode.IgnoredSameUrlNavigation,\n                ),\n              );\n              t.resolve(false);\n              return EMPTY;\n            }\n\n            if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n              return of(t).pipe(\n                // Fire NavigationStart event\n                switchMap((t) => {\n                  this.events.next(\n                    new NavigationStart(\n                      t.id,\n                      this.urlSerializer.serialize(t.extractedUrl),\n                      t.source,\n                      t.restoredState,\n                    ),\n                  );\n                  if (t.id !== this.navigationId) {\n                    return EMPTY;\n                  }\n\n                  // This delay is required to match old behavior that forced\n                  // navigation to always be async\n                  return Promise.resolve(t);\n                }),\n\n                // Recognize\n                recognize(\n                  this.environmentInjector,\n                  this.configLoader,\n                  this.rootComponentType,\n                  router.config,\n                  this.urlSerializer,\n                  this.paramsInheritanceStrategy,\n                ),\n\n                // Update URL if in `eager` update mode\n                tap((t) => {\n                  overallTransitionState.targetSnapshot = t.targetSnapshot;\n                  overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n                  this.currentNavigation = {\n                    ...this.currentNavigation!,\n                    finalUrl: t.urlAfterRedirects,\n                  };\n\n                  // Fire RoutesRecognized\n                  const routesRecognized = new RoutesRecognized(\n                    t.id,\n                    this.urlSerializer.serialize(t.extractedUrl),\n                    this.urlSerializer.serialize(t.urlAfterRedirects!),\n                    t.targetSnapshot!,\n                  );\n                  this.events.next(routesRecognized);\n                }),\n              );\n            } else if (\n              urlTransition &&\n              this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)\n            ) {\n              /* When the current URL shouldn't be processed, but the previous one\n               * was, we handle this \"error condition\" by navigating to the\n               * previously successful URL, but leaving the URL intact.*/\n              const {id, extractedUrl, source, restoredState, extras} = t;\n              const navStart = new NavigationStart(\n                id,\n                this.urlSerializer.serialize(extractedUrl),\n                source,\n                restoredState,\n              );\n              this.events.next(navStart);\n              const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\n\n              this.currentTransition = overallTransitionState = {\n                ...t,\n                targetSnapshot,\n                urlAfterRedirects: extractedUrl,\n                extras: {...extras, skipLocationChange: false, replaceUrl: false},\n              };\n              this.currentNavigation!.finalUrl = extractedUrl;\n              return of(overallTransitionState);\n            } else {\n              /* When neither the current or previous URL can be processed, do\n               * nothing other than update router's internal reference to the\n               * current \"settled\" URL. This way the next navigation will be coming\n               * from the current URL in the browser.\n               */\n              const reason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation was ignored because the UrlHandlingStrategy` +\n                    ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.`\n                  : '';\n              this.events.next(\n                new NavigationSkipped(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  reason,\n                  NavigationSkippedCode.IgnoredByUrlHandlingStrategy,\n                ),\n              );\n              t.resolve(false);\n              return EMPTY;\n            }\n          }),\n\n          // --- GUARDS ---\n          tap((t) => {\n            const guardsStart = new GuardsCheckStart(\n              t.id,\n              this.urlSerializer.serialize(t.extractedUrl),\n              this.urlSerializer.serialize(t.urlAfterRedirects!),\n              t.targetSnapshot!,\n            );\n            this.events.next(guardsStart);\n          }),\n\n          map((t) => {\n            this.currentTransition = overallTransitionState = {\n              ...t,\n              guards: getAllRouteGuards(t.targetSnapshot!, t.currentSnapshot, this.rootContexts),\n            };\n            return overallTransitionState;\n          }),\n\n          checkGuards(this.environmentInjector, (evt: Event) => this.events.next(evt)),\n          tap((t) => {\n            overallTransitionState.guardsResult = t.guardsResult;\n            if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\n              throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n            }\n\n            const guardsEnd = new GuardsCheckEnd(\n              t.id,\n              this.urlSerializer.serialize(t.extractedUrl),\n              this.urlSerializer.serialize(t.urlAfterRedirects!),\n              t.targetSnapshot!,\n              !!t.guardsResult,\n            );\n            this.events.next(guardsEnd);\n          }),\n\n          filter((t) => {\n            if (!t.guardsResult) {\n              this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\n              return false;\n            }\n            return true;\n          }),\n\n          // --- RESOLVE ---\n          switchTap((t) => {\n            if (t.guards.canActivateChecks.length === 0) {\n              return undefined;\n            }\n\n            return of(t).pipe(\n              tap((t) => {\n                const resolveStart = new ResolveStart(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  this.urlSerializer.serialize(t.urlAfterRedirects!),\n                  t.targetSnapshot!,\n                );\n                this.events.next(resolveStart);\n              }),\n              switchMap((t) => {\n                let dataResolved = false;\n                return of(t).pipe(\n                  resolveData(this.paramsInheritanceStrategy, this.environmentInjector),\n                  tap({\n                    next: () => (dataResolved = true),\n                    complete: () => {\n                      if (!dataResolved) {\n                        this.cancelNavigationTransition(\n                          t,\n                          typeof ngDevMode === 'undefined' || ngDevMode\n                            ? `At least one route resolver didn't emit any value.`\n                            : '',\n                          NavigationCancellationCode.NoDataFromResolver,\n                        );\n                      }\n                    },\n                  }),\n                );\n              }),\n              tap((t) => {\n                const resolveEnd = new ResolveEnd(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  this.urlSerializer.serialize(t.urlAfterRedirects!),\n                  t.targetSnapshot!,\n                );\n                this.events.next(resolveEnd);\n              }),\n            );\n          }),\n\n          // --- LOAD COMPONENTS ---\n          switchTap((t: NavigationTransition) => {\n            const loadComponents = (route: ActivatedRouteSnapshot): Array<Observable<void>> => {\n              const loaders: Array<Observable<void>> = [];\n              if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {\n                loaders.push(\n                  this.configLoader.loadComponent(route.routeConfig).pipe(\n                    tap((loadedComponent) => {\n                      route.component = loadedComponent;\n                    }),\n                    map(() => void 0),\n                  ),\n                );\n              }\n              for (const child of route.children) {\n                loaders.push(...loadComponents(child));\n              }\n              return loaders;\n            };\n            return combineLatest(loadComponents(t.targetSnapshot!.root)).pipe(\n              defaultIfEmpty(null),\n              take(1),\n            );\n          }),\n\n          switchTap(() => this.afterPreactivation()),\n\n          switchMap(() => {\n            const {currentSnapshot, targetSnapshot} = overallTransitionState;\n            const viewTransitionStarted = this.createViewTransition?.(\n              this.environmentInjector,\n              currentSnapshot.root,\n              targetSnapshot!.root,\n            );\n\n            // If view transitions are enabled, block the navigation until the view\n            // transition callback starts. Otherwise, continue immediately.\n            return viewTransitionStarted\n              ? from(viewTransitionStarted).pipe(map(() => overallTransitionState))\n              : of(overallTransitionState);\n          }),\n\n          map((t: NavigationTransition) => {\n            const targetRouterState = createRouterState(\n              router.routeReuseStrategy,\n              t.targetSnapshot!,\n              t.currentRouterState,\n            );\n            this.currentTransition = overallTransitionState = {...t, targetRouterState};\n            this.currentNavigation!.targetRouterState = targetRouterState;\n            return overallTransitionState;\n          }),\n\n          tap(() => {\n            this.events.next(new BeforeActivateRoutes());\n          }),\n\n          activateRoutes(\n            this.rootContexts,\n            router.routeReuseStrategy,\n            (evt: Event) => this.events.next(evt),\n            this.inputBindingEnabled,\n          ),\n\n          // Ensure that if some observable used to drive the transition doesn't\n          // complete, the navigation still finalizes This should never happen, but\n          // this is done as a safety measure to avoid surfacing this error (#49567).\n          take(1),\n\n          tap({\n            next: (t: NavigationTransition) => {\n              completed = true;\n              this.lastSuccessfulNavigation = this.currentNavigation;\n              this.events.next(\n                new NavigationEnd(\n                  t.id,\n                  this.urlSerializer.serialize(t.extractedUrl),\n                  this.urlSerializer.serialize(t.urlAfterRedirects!),\n                ),\n              );\n              this.titleStrategy?.updateTitle(t.targetRouterState!.snapshot);\n              t.resolve(true);\n            },\n            complete: () => {\n              completed = true;\n            },\n          }),\n\n          // There used to be a lot more logic happening directly within the\n          // transition Observable. Some of this logic has been refactored out to\n          // other places but there may still be errors that happen there. This gives\n          // us a way to cancel the transition from the outside. This may also be\n          // required in the future to support something like the abort signal of the\n          // Navigation API where the navigation gets aborted from outside the\n          // transition.\n          takeUntil(\n            this.transitionAbortSubject.pipe(\n              tap((err) => {\n                throw err;\n              }),\n            ),\n          ),\n\n          finalize(() => {\n            /* When the navigation stream finishes either through error or success,\n             * we set the `completed` or `errored` flag. However, there are some\n             * situations where we could get here without either of those being set.\n             * For instance, a redirect during NavigationStart. Therefore, this is a\n             * catch-all to make sure the NavigationCancel event is fired when a\n             * navigation gets cancelled but not caught by other means. */\n            if (!completed && !errored) {\n              const cancelationReason =\n                typeof ngDevMode === 'undefined' || ngDevMode\n                  ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                  : '';\n              this.cancelNavigationTransition(\n                overallTransitionState,\n                cancelationReason,\n                NavigationCancellationCode.SupersededByNewNavigation,\n              );\n            }\n            // Only clear current navigation if it is still set to the one that\n            // finalized.\n            if (this.currentTransition?.id === overallTransitionState.id) {\n              this.currentNavigation = null;\n              this.currentTransition = null;\n            }\n          }),\n          catchError((e) => {\n            // If the application is already destroyed, the catch block should not\n            // execute anything in practice because other resources have already\n            // been released and destroyed.\n            if (this.destroyed) {\n              overallTransitionState.resolve(false);\n              return EMPTY;\n            }\n\n            errored = true;\n            /* This error type is issued during Redirect, and is handled as a\n             * cancellation rather than an error. */\n            if (isNavigationCancelingError(e)) {\n              this.events.next(\n                new NavigationCancel(\n                  overallTransitionState.id,\n                  this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                  e.message,\n                  e.cancellationCode,\n                ),\n              );\n\n              // When redirecting, we need to delay resolving the navigation\n              // promise and push it to the redirect navigation\n              if (!isRedirectingNavigationCancelingError(e)) {\n                overallTransitionState.resolve(false);\n              } else {\n                this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n              }\n\n              /* All other errors should reset to the router's internal URL reference\n               * to the pre-error state. */\n            } else {\n              const navigationError = new NavigationError(\n                overallTransitionState.id,\n                this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                e,\n                overallTransitionState.targetSnapshot ?? undefined,\n              );\n\n              try {\n                const navigationErrorHandlerResult = runInInjectionContext(\n                  this.environmentInjector,\n                  () => this.navigationErrorHandler?.(navigationError),\n                );\n\n                if (navigationErrorHandlerResult instanceof RedirectCommand) {\n                  const {message, cancellationCode} = redirectingNavigationError(\n                    this.urlSerializer,\n                    navigationErrorHandlerResult,\n                  );\n                  this.events.next(\n                    new NavigationCancel(\n                      overallTransitionState.id,\n                      this.urlSerializer.serialize(overallTransitionState.extractedUrl),\n                      message,\n                      cancellationCode,\n                    ),\n                  );\n                  this.events.next(\n                    new RedirectRequest(\n                      navigationErrorHandlerResult.redirectTo,\n                      navigationErrorHandlerResult.navigationBehaviorOptions,\n                    ),\n                  );\n                } else {\n                  this.events.next(navigationError);\n                  throw e;\n                }\n              } catch (ee) {\n                // TODO(atscott): consider flipping the default behavior of\n                // resolveNavigationPromiseOnError to be `resolve(false)` when\n                // undefined. This is the most sane thing to do given that\n                // applications very rarely handle the promise rejection and, as a\n                // result, would get \"unhandled promise rejection\" console logs.\n                // The vast majority of applications would not be affected by this\n                // change so omitting a migration seems reasonable. Instead,\n                // applications that rely on rejection can specifically opt-in to the\n                // old behavior.\n                if (this.options.resolveNavigationPromiseOnError) {\n                  overallTransitionState.resolve(false);\n                } else {\n                  overallTransitionState.reject(ee);\n                }\n              }\n            }\n\n            return EMPTY;\n          }),\n        );\n        // casting because `pipe` returns observable({}) when called with 8+ arguments\n      }),\n    ) as Observable<NavigationTransition>;\n  }\n\n  private cancelNavigationTransition(\n    t: NavigationTransition,\n    reason: string,\n    code: NavigationCancellationCode,\n  ) {\n    const navCancel = new NavigationCancel(\n      t.id,\n      this.urlSerializer.serialize(t.extractedUrl),\n      reason,\n      code,\n    );\n    this.events.next(navCancel);\n    t.resolve(false);\n  }\n\n  /**\n   * @returns Whether we're navigating to somewhere that is not what the Router is\n   * currently set to.\n   */\n  private isUpdatingInternalState() {\n    // TODO(atscott): The serializer should likely be used instead of\n    // `UrlTree.toString()`. Custom serializers are often written to handle\n    // things better than the default one (objects, for example will be\n    // [Object object] with the custom serializer and be \"the same\" when they\n    // aren't).\n    // (Same for isUpdatedBrowserUrl)\n    return (\n      this.currentTransition?.extractedUrl.toString() !==\n      this.currentTransition?.currentUrlTree.toString()\n    );\n  }\n\n  /**\n   * @returns Whether we're updating the browser URL to something new (navigation is going\n   * to somewhere not displayed in the URL bar and we will update the URL\n   * bar if navigation succeeds).\n   */\n  private isUpdatedBrowserUrl() {\n    // The extracted URL is the part of the URL that this application cares about. `extract` may\n    // return only part of the browser URL and that part may have not changed even if some other\n    // portion of the URL did.\n    const currentBrowserUrl = this.urlHandlingStrategy.extract(\n      this.urlSerializer.parse(this.location.path(true)),\n    );\n    const targetBrowserUrl =\n      this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;\n    return (\n      currentBrowserUrl.toString() !== targetBrowserUrl?.toString() &&\n      !this.currentNavigation?.extras.skipLocationChange\n    );\n  }\n}\n\nexport function isBrowserTriggeredNavigation(source: NavigationTrigger) {\n  return source !== IMPERATIVE_NAVIGATION;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentRef, inject, Injectable} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>;\n  componentRef: ComponentRef<any>;\n  route: TreeNode<ActivatedRoute>;\n};\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy)})\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nexport abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n  /**\n   * Whether the given route should detach for later reuse.\n   * Always returns false for `BaseRouteReuseStrategy`.\n   * */\n  shouldDetach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /**\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n   */\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n\n  /** Returns `false`, meaning the route (and its subtree) is never reattached */\n  shouldAttach(route: ActivatedRouteSnapshot): boolean {\n    return false;\n  }\n\n  /** Returns `null` because this strategy does not store routes for later re-use. */\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null {\n    return null;\n  }\n\n  /**\n   * Determines if a route should be reused.\n   * This strategy returns `true` when the future route config and current route config are\n   * identical.\n   */\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n\n@Injectable({providedIn: 'root'})\nexport class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {inject, Injectable} from '@angular/core';\nimport {SubscriptionLike} from 'rxjs';\n\nimport {\n  BeforeActivateRoutes,\n  Event,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n  NavigationStart,\n  PrivateRouterEvents,\n  RoutesRecognized,\n} from '../events';\nimport {Navigation, RestoredState} from '../navigation_transition';\nimport {ROUTER_CONFIGURATION} from '../router_config';\nimport {createEmptyState, RouterState} from '../router_state';\nimport {UrlHandlingStrategy} from '../url_handling_strategy';\nimport {UrlSerializer, UrlTree} from '../url_tree';\n\n@Injectable({providedIn: 'root', useFactory: () => inject(HistoryStateManager)})\nexport abstract class StateManager {\n  /**\n   * Returns the currently activated `UrlTree`.\n   *\n   * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\n   * `UrlHandlingStrategy`).\n   *\n   * The value is set after finding the route config tree to activate but before activating the\n   * route.\n   */\n  abstract getCurrentUrlTree(): UrlTree;\n\n  /**\n   * Returns a `UrlTree` that is represents what the browser is actually showing.\n   *\n   * In the life of a navigation transition:\n   * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\n   * navigated to.\n   * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\n   * to `UrlHandlingStrategy`).\n   * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\n   * original raw URL.\n   *\n   * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\n   * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\n   * deviated from the raw `UrlTree`.\n   *\n   * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\n   * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\n   * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\n   * occurs, it needs to know the _whole_ browser URL, not just the part handled by\n   * `UrlHandlingStrategy`.\n   * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\n   * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\n   * location change listener due to a URL update by the AngularJS router. In this case, the router\n   * still need to know what the browser's URL is for future navigations.\n   */\n  abstract getRawUrlTree(): UrlTree;\n\n  /** Returns the current state stored by the browser for the current history entry. */\n  abstract restoredState(): RestoredState | null | undefined;\n\n  /** Returns the current RouterState. */\n  abstract getRouterState(): RouterState;\n\n  /**\n   * Registers a listener that is called whenever the current history entry changes by some API\n   * outside the Router. This includes user-activated changes like back buttons and link clicks, but\n   * also includes programmatic APIs called by non-Router JavaScript.\n   */\n  abstract registerNonRouterCurrentEntryChangeListener(\n    listener: (url: string, state: RestoredState | null | undefined) => void,\n  ): SubscriptionLike;\n\n  /**\n   * Handles a navigation event sent from the Router. These are typically events that indicate a\n   * navigation has started, progressed, been cancelled, or finished.\n   */\n  abstract handleRouterEvent(e: Event | PrivateRouterEvents, currentTransition: Navigation): void;\n}\n\n@Injectable({providedIn: 'root'})\nexport class HistoryStateManager extends StateManager {\n  private readonly location = inject(Location);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly canceledNavigationResolution =\n    this.options.canceledNavigationResolution || 'replace';\n\n  private urlHandlingStrategy = inject(UrlHandlingStrategy);\n  private urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n\n  private currentUrlTree = new UrlTree();\n\n  override getCurrentUrlTree() {\n    return this.currentUrlTree;\n  }\n\n  private rawUrlTree = this.currentUrlTree;\n\n  override getRawUrlTree() {\n    return this.rawUrlTree;\n  }\n\n  /**\n   * The id of the currently active page in the router.\n   * Updated to the transition's target id on a successful navigation.\n   *\n   * This is used to track what page the router last activated. When an attempted navigation fails,\n   * the router can then use this to compute how to restore the state back to the previously active\n   * page.\n   */\n  private currentPageId: number = 0;\n  private lastSuccessfulId: number = -1;\n\n  override restoredState(): RestoredState | null | undefined {\n    return this.location.getState() as RestoredState | null | undefined;\n  }\n\n  /**\n   * The routerPageId of whatever page is currently active in the browser history. This is\n   * important for computing the target page id for new navigations because we need to ensure each\n   * page id in the browser history is 1 more than the previous entry.\n   */\n  private get browserPageId(): number {\n    if (this.canceledNavigationResolution !== 'computed') {\n      return this.currentPageId;\n    }\n    return this.restoredState()?.routerPageId ?? this.currentPageId;\n  }\n\n  private routerState = createEmptyState(null);\n\n  override getRouterState() {\n    return this.routerState;\n  }\n\n  private stateMemento = this.createStateMemento();\n\n  private createStateMemento() {\n    return {\n      rawUrlTree: this.rawUrlTree,\n      currentUrlTree: this.currentUrlTree,\n      routerState: this.routerState,\n    };\n  }\n\n  override registerNonRouterCurrentEntryChangeListener(\n    listener: (url: string, state: RestoredState | null | undefined) => void,\n  ): SubscriptionLike {\n    return this.location.subscribe((event) => {\n      if (event['type'] === 'popstate') {\n        listener(event['url']!, event.state as RestoredState | null | undefined);\n      }\n    });\n  }\n\n  override handleRouterEvent(e: Event | PrivateRouterEvents, currentTransition: Navigation) {\n    if (e instanceof NavigationStart) {\n      this.stateMemento = this.createStateMemento();\n    } else if (e instanceof NavigationSkipped) {\n      this.rawUrlTree = currentTransition.initialUrl;\n    } else if (e instanceof RoutesRecognized) {\n      if (this.urlUpdateStrategy === 'eager') {\n        if (!currentTransition.extras.skipLocationChange) {\n          const rawUrl = this.urlHandlingStrategy.merge(\n            currentTransition.finalUrl!,\n            currentTransition.initialUrl,\n          );\n          this.setBrowserUrl(currentTransition.targetBrowserUrl ?? rawUrl, currentTransition);\n        }\n      }\n    } else if (e instanceof BeforeActivateRoutes) {\n      this.currentUrlTree = currentTransition.finalUrl!;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(\n        currentTransition.finalUrl!,\n        currentTransition.initialUrl,\n      );\n      this.routerState = currentTransition.targetRouterState!;\n      if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n        this.setBrowserUrl(\n          currentTransition.targetBrowserUrl ?? this.rawUrlTree,\n          currentTransition,\n        );\n      }\n    } else if (\n      e instanceof NavigationCancel &&\n      (e.code === NavigationCancellationCode.GuardRejected ||\n        e.code === NavigationCancellationCode.NoDataFromResolver)\n    ) {\n      this.restoreHistory(currentTransition);\n    } else if (e instanceof NavigationError) {\n      this.restoreHistory(currentTransition, true);\n    } else if (e instanceof NavigationEnd) {\n      this.lastSuccessfulId = e.id;\n      this.currentPageId = this.browserPageId;\n    }\n  }\n\n  private setBrowserUrl(url: UrlTree | string, transition: Navigation) {\n    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n    if (this.location.isCurrentPathEqualTo(path) || !!transition.extras.replaceUrl) {\n      // replacements do not update the target page\n      const currentBrowserPageId = this.browserPageId;\n      const state = {\n        ...transition.extras.state,\n        ...this.generateNgRouterState(transition.id, currentBrowserPageId),\n      };\n      this.location.replaceState(path, '', state);\n    } else {\n      const state = {\n        ...transition.extras.state,\n        ...this.generateNgRouterState(transition.id, this.browserPageId + 1),\n      };\n      this.location.go(path, '', state);\n    }\n  }\n\n  /**\n   * Performs the necessary rollback action to restore the browser URL to the\n   * state before the transition.\n   */\n  private restoreHistory(navigation: Navigation, restoringFromCaughtError = false) {\n    if (this.canceledNavigationResolution === 'computed') {\n      const currentBrowserPageId = this.browserPageId;\n      const targetPagePosition = this.currentPageId - currentBrowserPageId;\n      if (targetPagePosition !== 0) {\n        this.location.historyGo(targetPagePosition);\n      } else if (this.currentUrlTree === navigation.finalUrl && targetPagePosition === 0) {\n        // We got to the activation stage (where currentUrlTree is set to the navigation's\n        // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n        // We still need to reset the router state back to what it was when the navigation started.\n        this.resetState(navigation);\n        this.resetUrlToCurrentUrlTree();\n      } else {\n        // The browser URL and router state was not updated before the navigation cancelled so\n        // there's no restoration needed.\n      }\n    } else if (this.canceledNavigationResolution === 'replace') {\n      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n      // for `deferred` navigations that haven't change the internal state yet because guards\n      // reject. For 'eager' navigations, it seems like we also really should reset the state\n      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n      if (restoringFromCaughtError) {\n        this.resetState(navigation);\n      }\n      this.resetUrlToCurrentUrlTree();\n    }\n  }\n\n  private resetState(navigation: Navigation): void {\n    this.routerState = this.stateMemento.routerState;\n    this.currentUrlTree = this.stateMemento.currentUrlTree;\n    // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n    // configured to handle only part of the navigation URL. This means we would only want to reset\n    // the part of the navigation handled by the Angular router rather than the whole URL. In\n    // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n    // when merging, such as the query params so they are not lost on a refresh.\n    this.rawUrlTree = this.urlHandlingStrategy.merge(\n      this.currentUrlTree,\n      navigation.finalUrl ?? this.rawUrlTree,\n    );\n  }\n\n  private resetUrlToCurrentUrlTree(): void {\n    this.location.replaceState(\n      this.urlSerializer.serialize(this.rawUrlTree),\n      '',\n      this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId),\n    );\n  }\n\n  private generateNgRouterState(navigationId: number, routerPageId: number) {\n    if (this.canceledNavigationResolution === 'computed') {\n      return {navigationId, routerPageId: routerPageId};\n    }\n    return {navigationId};\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Observable} from 'rxjs';\nimport {filter, map, take} from 'rxjs/operators';\n\nimport {\n  Event,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationError,\n  NavigationSkipped,\n} from '../events';\n\nconst enum NavigationResult {\n  COMPLETE,\n  FAILED,\n  REDIRECTING,\n}\n\n/**\n * Performs the given action once the router finishes its next/current navigation.\n *\n * The navigation is considered complete under the following conditions:\n * - `NavigationCancel` event emits and the code is not `NavigationCancellationCode.Redirect` or\n * `NavigationCancellationCode.SupersededByNewNavigation`. In these cases, the\n * redirecting/superseding navigation must finish.\n * - `NavigationError`, `NavigationEnd`, or `NavigationSkipped` event emits\n */\nexport function afterNextNavigation(router: {events: Observable<Event>}, action: () => void) {\n  router.events\n    .pipe(\n      filter(\n        (e): e is NavigationEnd | NavigationCancel | NavigationError | NavigationSkipped =>\n          e instanceof NavigationEnd ||\n          e instanceof NavigationCancel ||\n          e instanceof NavigationError ||\n          e instanceof NavigationSkipped,\n      ),\n      map((e) => {\n        if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n          return NavigationResult.COMPLETE;\n        }\n        const redirecting =\n          e instanceof NavigationCancel\n            ? e.code === NavigationCancellationCode.Redirect ||\n              e.code === NavigationCancellationCode.SupersededByNewNavigation\n            : false;\n        return redirecting ? NavigationResult.REDIRECTING : NavigationResult.FAILED;\n      }),\n      filter(\n        (result): result is NavigationResult.COMPLETE | NavigationResult.FAILED =>\n          result !== NavigationResult.REDIRECTING,\n      ),\n      take(1),\n    )\n    .subscribe(() => {\n      action();\n    });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Location} from '@angular/common';\nimport {\n  inject,\n  Injectable,\n  Type,\n  Console as Console,\n  PendingTasksInternal as PendingTasks,\n  RuntimeError as RuntimeError,\n} from '@angular/core';\nimport {Observable, Subject, Subscription, SubscriptionLike} from 'rxjs';\n\nimport {createSegmentGroupFromRoute, createUrlTreeFromSegmentGroup} from './create_url_tree';\nimport {INPUT_BINDER} from './directives/router_outlet';\nimport {RuntimeErrorCode} from './errors';\nimport {\n  BeforeActivateRoutes,\n  Event,\n  IMPERATIVE_NAVIGATION,\n  NavigationCancel,\n  NavigationCancellationCode,\n  NavigationEnd,\n  NavigationTrigger,\n  PrivateRouterEvents,\n  RedirectRequest,\n} from './events';\nimport {NavigationBehaviorOptions, OnSameUrlNavigation, Routes} from './models';\nimport {\n  isBrowserTriggeredNavigation,\n  Navigation,\n  NavigationExtras,\n  NavigationTransitions,\n  RestoredState,\n  UrlCreationOptions,\n} from './navigation_transition';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ROUTER_CONFIGURATION} from './router_config';\nimport {ROUTES} from './router_config_loader';\nimport {Params} from './shared';\nimport {StateManager} from './statemanager/state_manager';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {\n  containsTree,\n  IsActiveMatchOptions,\n  isUrlTree,\n  UrlSegmentGroup,\n  UrlSerializer,\n  UrlTree,\n} from './url_tree';\nimport {validateConfig} from './utils/config';\nimport {afterNextNavigation} from './utils/navigations';\nimport {standardizeConfig} from './components/empty_outlet';\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\n * (exact = true).\n */\nexport const exactMatchOptions: IsActiveMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact',\n};\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\n * (exact = false).\n */\nexport const subsetMatchOptions: IsActiveMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset',\n};\n\n/**\n * @description\n *\n * A service that facilitates navigation among views and URL manipulation capabilities.\n * This service is provided in the root scope and configured with [provideRouter](api/router/provideRouter).\n *\n * @see {@link Route}\n * @see {@link provideRouter}\n * @see [Routing and Navigation Guide](guide/routing/common-router-tasks).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Injectable({providedIn: 'root'})\nexport class Router {\n  private get currentUrlTree() {\n    return this.stateManager.getCurrentUrlTree();\n  }\n  private get rawUrlTree() {\n    return this.stateManager.getRawUrlTree();\n  }\n  private disposed = false;\n  private nonRouterCurrentEntryChangeSubscription?: SubscriptionLike;\n\n  private readonly console = inject(Console);\n  private readonly stateManager = inject(StateManager);\n  private readonly options = inject(ROUTER_CONFIGURATION, {optional: true}) || {};\n  private readonly pendingTasks = inject(PendingTasks);\n  private readonly urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n  private readonly navigationTransitions = inject(NavigationTransitions);\n  private readonly urlSerializer = inject(UrlSerializer);\n  private readonly location = inject(Location);\n  private readonly urlHandlingStrategy = inject(UrlHandlingStrategy);\n\n  /**\n   * The private `Subject` type for the public events exposed in the getter. This is used internally\n   * to push events to. The separate field allows us to expose separate types in the public API\n   * (i.e., an Observable rather than the Subject).\n   */\n  private _events = new Subject<Event>();\n  /**\n   * An event stream for routing events.\n   */\n  public get events(): Observable<Event> {\n    // TODO(atscott): This _should_ be events.asObservable(). However, this change requires internal\n    // cleanup: tests are doing `(route.events as Subject<Event>).next(...)`. This isn't\n    // allowed/supported but we still have to fix these or file bugs against the teams before making\n    // the change.\n    return this._events;\n  }\n  /**\n   * The current state of routing in this NgModule.\n   */\n  get routerState() {\n    return this.stateManager.getRouterState();\n  }\n\n  /**\n   * True if at least one navigation event has occurred,\n   * false otherwise.\n   */\n  navigated: boolean = false;\n\n  /**\n   * A strategy for re-using routes.\n   *\n   * @deprecated Configure using `providers` instead:\n   *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\n   */\n  routeReuseStrategy: RouteReuseStrategy = inject(RouteReuseStrategy);\n\n  /**\n   * How to handle a navigation request to the current URL.\n   *\n   *\n   * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\n   * @see {@link withRouterConfig}\n   * @see {@link provideRouter}\n   * @see {@link RouterModule}\n   */\n  onSameUrlNavigation: OnSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n\n  config: Routes = inject(ROUTES, {optional: true})?.flat() ?? [];\n\n  /**\n   * Indicates whether the application has opted in to binding Router data to component inputs.\n   *\n   * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\n   * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\n   */\n  readonly componentInputBindingEnabled: boolean = !!inject(INPUT_BINDER, {optional: true});\n\n  constructor() {\n    this.resetConfig(this.config);\n\n    this.navigationTransitions.setupNavigations(this).subscribe({\n      error: (e) => {\n        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n      },\n    });\n    this.subscribeToNavigationEvents();\n  }\n\n  private eventsSubscription = new Subscription();\n  private subscribeToNavigationEvents() {\n    const subscription = this.navigationTransitions.events.subscribe((e) => {\n      try {\n        const currentTransition = this.navigationTransitions.currentTransition;\n        const currentNavigation = this.navigationTransitions.currentNavigation;\n        if (currentTransition !== null && currentNavigation !== null) {\n          this.stateManager.handleRouterEvent(e, currentNavigation);\n          if (\n            e instanceof NavigationCancel &&\n            e.code !== NavigationCancellationCode.Redirect &&\n            e.code !== NavigationCancellationCode.SupersededByNewNavigation\n          ) {\n            // It seems weird that `navigated` is set to `true` when the navigation is rejected,\n            // however it's how things were written initially. Investigation would need to be done\n            // to determine if this can be removed.\n            this.navigated = true;\n          } else if (e instanceof NavigationEnd) {\n            this.navigated = true;\n          } else if (e instanceof RedirectRequest) {\n            const opts = e.navigationBehaviorOptions;\n            const mergedTree = this.urlHandlingStrategy.merge(\n              e.url,\n              currentTransition.currentRawUrl,\n            );\n            const extras = {\n              browserUrl: currentTransition.extras.browserUrl,\n              info: currentTransition.extras.info,\n              skipLocationChange: currentTransition.extras.skipLocationChange,\n              // The URL is already updated at this point if we have 'eager' URL\n              // updates or if the navigation was triggered by the browser (back\n              // button, URL bar, etc). We want to replace that item in history\n              // if the navigation is rejected.\n              replaceUrl:\n                currentTransition.extras.replaceUrl ||\n                this.urlUpdateStrategy === 'eager' ||\n                isBrowserTriggeredNavigation(currentTransition.source),\n              // allow developer to override default options with RedirectCommand\n              ...opts,\n            };\n\n            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n              resolve: currentTransition.resolve,\n              reject: currentTransition.reject,\n              promise: currentTransition.promise,\n            });\n          }\n        }\n        // Note that it's important to have the Router process the events _before_ the event is\n        // pushed through the public observable. This ensures the correct router state is in place\n        // before applications observe the events.\n        if (isPublicRouterEvent(e)) {\n          this._events.next(e);\n        }\n      } catch (e: unknown) {\n        this.navigationTransitions.transitionAbortSubject.next(e as Error);\n      }\n    });\n    this.eventsSubscription.add(subscription);\n  }\n\n  /** @internal */\n  resetRootComponentType(rootComponentType: Type<any>): void {\n    // TODO: vsavkin router 4.0 should make the root component set to null\n    // this will simplify the lifecycle of the router.\n    this.routerState.root.component = rootComponentType;\n    this.navigationTransitions.rootComponentType = rootComponentType;\n  }\n\n  /**\n   * Sets up the location change listener and performs the initial navigation.\n   */\n  initialNavigation(): void {\n    this.setUpLocationChangeListener();\n    if (!this.navigationTransitions.hasRequestedNavigation) {\n      this.navigateToSyncWithBrowser(\n        this.location.path(true),\n        IMPERATIVE_NAVIGATION,\n        this.stateManager.restoredState(),\n      );\n    }\n  }\n\n  /**\n   * Sets up the location change listener. This listener detects navigations triggered from outside\n   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n   * navigation so that the correct events, guards, etc. are triggered.\n   */\n  setUpLocationChangeListener(): void {\n    // Don't need to use Zone.wrap any more, because zone.js\n    // already patch onPopState, so location change callback will\n    // run into ngZone\n    this.nonRouterCurrentEntryChangeSubscription ??=\n      this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state) => {\n        // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n        // hybrid apps.\n        setTimeout(() => {\n          this.navigateToSyncWithBrowser(url, 'popstate', state);\n        }, 0);\n      });\n  }\n\n  /**\n   * Schedules a router navigation to synchronize Router state with the browser state.\n   *\n   * This is done as a response to a popstate event and the initial navigation. These\n   * two scenarios represent times when the browser URL/state has been updated and\n   * the Router needs to respond to ensure its internal state matches.\n   */\n  private navigateToSyncWithBrowser(\n    url: string,\n    source: NavigationTrigger,\n    state: RestoredState | null | undefined,\n  ) {\n    const extras: NavigationExtras = {replaceUrl: true};\n\n    // TODO: restoredState should always include the entire state, regardless\n    // of navigationId. This requires a breaking change to update the type on\n    // NavigationStarts restoredState, which currently requires navigationId\n    // to always be present. The Router used to only restore history state if\n    // a navigationId was present.\n\n    // The stored navigationId is used by the RouterScroller to retrieve the scroll\n    // position for the page.\n    const restoredState = state?.navigationId ? state : null;\n\n    // Separate to NavigationStart.restoredState, we must also restore the state to\n    // history.state and generate a new navigationId, since it will be overwritten\n    if (state) {\n      const stateCopy = {...state} as Partial<RestoredState>;\n      delete stateCopy.navigationId;\n      delete stateCopy.routerPageId;\n      if (Object.keys(stateCopy).length !== 0) {\n        extras.state = stateCopy;\n      }\n    }\n\n    const urlTree = this.parseUrl(url);\n    this.scheduleNavigation(urlTree, source, restoredState, extras);\n  }\n\n  /** The current URL. */\n  get url(): string {\n    return this.serializeUrl(this.currentUrlTree);\n  }\n\n  /**\n   * Returns the current `Navigation` object when the router is navigating,\n   * and `null` when idle.\n   */\n  getCurrentNavigation(): Navigation | null {\n    return this.navigationTransitions.currentNavigation;\n  }\n\n  /**\n   * The `Navigation` object of the most recent navigation to succeed and `null` if there\n   *     has not been a successful navigation yet.\n   */\n  get lastSuccessfulNavigation(): Navigation | null {\n    return this.navigationTransitions.lastSuccessfulNavigation;\n  }\n\n  /**\n   * Resets the route configuration used for navigation and generating links.\n   *\n   * @param config The route array for the new configuration.\n   *\n   * @usageNotes\n   *\n   * ```ts\n   * router.resetConfig([\n   *  { path: 'team/:id', component: TeamCmp, children: [\n   *    { path: 'simple', component: SimpleCmp },\n   *    { path: 'user/:name', component: UserCmp }\n   *  ]}\n   * ]);\n   * ```\n   */\n  resetConfig(config: Routes): void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n    this.config = config.map(standardizeConfig);\n    this.navigated = false;\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this.dispose();\n  }\n\n  /** Disposes of the router. */\n  dispose(): void {\n    // We call `unsubscribe()` to release observers, as users may forget to\n    // unsubscribe manually when subscribing to `router.events`. We do not call\n    // `complete()` because it is unsafe; if someone subscribes using the `first`\n    // operator and the observable completes before emitting a value,\n    // RxJS will throw an error.\n    this._events.unsubscribe();\n    this.navigationTransitions.complete();\n    if (this.nonRouterCurrentEntryChangeSubscription) {\n      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n      this.nonRouterCurrentEntryChangeSubscription = undefined;\n    }\n    this.disposed = true;\n    this.eventsSubscription.unsubscribe();\n  }\n\n  /**\n   * Appends URL segments to the current URL tree to create a new URL tree.\n   *\n   * @param commands An array of URL fragments with which to construct the new URL tree.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n   * property of the options object, if supplied.\n   * @param navigationExtras Options that control the navigation strategy.\n   * @returns The new URL tree.\n   *\n   * @usageNotes\n   *\n   * ```\n   * // create /team/33/user/11\n   * router.createUrlTree(['/team', 33, 'user', 11]);\n   *\n   * // create /team/33;expand=true/user/11\n   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n   *\n   * // you can collapse static segments like this (this works only with the first passed-in value):\n   * router.createUrlTree(['/team/33/user', userId]);\n   *\n   * // If the first segment can contain slashes, and you do not want the router to split it,\n   * // you can do the following:\n   * router.createUrlTree([{segmentPath: '/one/two'}]);\n   *\n   * // create /team/33/(user/11//right:chat)\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n   *\n   * // remove the right secondary node\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n   *\n   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n   *\n   * // navigate to /team/33/user/11/details\n   * router.createUrlTree(['details'], {relativeTo: route});\n   *\n   * // navigate to /team/33/user/22\n   * router.createUrlTree(['../22'], {relativeTo: route});\n   *\n   * // navigate to /team/44/user/22\n   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n   *\n   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n   * tree should be created relative to the root.\n   * ```\n   */\n  createUrlTree(commands: any[], navigationExtras: UrlCreationOptions = {}): UrlTree {\n    const {relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment} =\n      navigationExtras;\n    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n    let q: Params | null = null;\n    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n      case 'merge':\n        q = {...this.currentUrlTree.queryParams, ...queryParams};\n        break;\n      case 'preserve':\n        q = this.currentUrlTree.queryParams;\n        break;\n      default:\n        q = queryParams || null;\n    }\n    if (q !== null) {\n      q = this.removeEmptyProps(q);\n    }\n\n    let relativeToUrlSegmentGroup: UrlSegmentGroup | undefined;\n    try {\n      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n    } catch (e: unknown) {\n      // This is strictly for backwards compatibility with tests that create\n      // invalid `ActivatedRoute` mocks.\n      // Note: the difference between having this fallback for invalid `ActivatedRoute` setups and\n      // just throwing is ~500 test failures. Fixing all of those tests by hand is not feasible at\n      // the moment.\n      if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\n        // Navigations that were absolute in the old way of creating UrlTrees\n        // would still work because they wouldn't attempt to match the\n        // segments in the `ActivatedRoute` to the `currentUrlTree` but\n        // instead just replace the root segment with the navigation result.\n        // Non-absolute navigations would fail to apply the commands because\n        // the logic could not find the segment to replace (so they'd act like there were no\n        // commands).\n        commands = [];\n      }\n      relativeToUrlSegmentGroup = this.currentUrlTree.root;\n    }\n    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);\n  }\n\n  /**\n   * Navigates to a view using an absolute route path.\n   *\n   * @param url An absolute path for a defined route. The function does not apply any delta to the\n   *     current URL.\n   * @param extras An object containing properties that modify the navigation strategy.\n   *\n   * @returns A Promise that resolves to 'true' when navigation succeeds,\n   * to 'false' when navigation fails, or is rejected on error.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to an absolute path.\n   *\n   * ```ts\n   * router.navigateByUrl(\"/team/33/user/11\");\n   *\n   * // Navigate without updating the URL\n   * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n   *\n   */\n  navigateByUrl(\n    url: string | UrlTree,\n    extras: NavigationBehaviorOptions = {\n      skipLocationChange: false,\n    },\n  ): Promise<boolean> {\n    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n\n    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n  }\n\n  /**\n   * Navigate based on the provided array of commands and a starting point.\n   * If no starting route is provided, the navigation is absolute.\n   *\n   * @param commands An array of URL fragments with which to construct the target URL.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n   * of the options object, if supplied.\n   * @param extras An options object that determines how the URL should be constructed or\n   *     interpreted.\n   *\n   * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation\n   *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is\n   * not `true`.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to a dynamic route path relative to the current URL.\n   *\n   * ```ts\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n   *\n   * // Navigate without updating the URL, overriding the default behavior\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n   *\n   */\n  navigate(\n    commands: any[],\n    extras: NavigationExtras = {skipLocationChange: false},\n  ): Promise<boolean> {\n    validateCommands(commands);\n    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n  }\n\n  /** Serializes a `UrlTree` into a string */\n  serializeUrl(url: UrlTree): string {\n    return this.urlSerializer.serialize(url);\n  }\n\n  /** Parses a string into a `UrlTree` */\n  parseUrl(url: string): UrlTree {\n    try {\n      return this.urlSerializer.parse(url);\n    } catch {\n      return this.urlSerializer.parse('/');\n    }\n  }\n\n  /**\n   * Returns whether the url is activated.\n   *\n   * @deprecated\n   * Use `IsActiveMatchOptions` instead.\n   *\n   * - The equivalent `IsActiveMatchOptions` for `true` is\n   * `{paths: 'exact', queryParams: 'exact', fragment: 'ignored', matrixParams: 'ignored'}`.\n   * - The equivalent for `false` is\n   * `{paths: 'subset', queryParams: 'subset', fragment: 'ignored', matrixParams: 'ignored'}`.\n   */\n  isActive(url: string | UrlTree, exact: boolean): boolean;\n  /**\n   * Returns whether the url is activated.\n   */\n  isActive(url: string | UrlTree, matchOptions: IsActiveMatchOptions): boolean;\n  /** @internal */\n  isActive(url: string | UrlTree, matchOptions: boolean | IsActiveMatchOptions): boolean;\n  isActive(url: string | UrlTree, matchOptions: boolean | IsActiveMatchOptions): boolean {\n    let options: IsActiveMatchOptions;\n    if (matchOptions === true) {\n      options = {...exactMatchOptions};\n    } else if (matchOptions === false) {\n      options = {...subsetMatchOptions};\n    } else {\n      options = matchOptions;\n    }\n    if (isUrlTree(url)) {\n      return containsTree(this.currentUrlTree, url, options);\n    }\n\n    const urlTree = this.parseUrl(url);\n    return containsTree(this.currentUrlTree, urlTree, options);\n  }\n\n  private removeEmptyProps(params: Params): Params {\n    return Object.entries(params).reduce((result: Params, [key, value]: [string, any]) => {\n      if (value !== null && value !== undefined) {\n        result[key] = value;\n      }\n      return result;\n    }, {});\n  }\n\n  private scheduleNavigation(\n    rawUrl: UrlTree,\n    source: NavigationTrigger,\n    restoredState: RestoredState | null,\n    extras: NavigationExtras,\n    priorPromise?: {\n      resolve: (result: boolean | PromiseLike<boolean>) => void;\n      reject: (reason?: any) => void;\n      promise: Promise<boolean>;\n    },\n  ): Promise<boolean> {\n    if (this.disposed) {\n      return Promise.resolve(false);\n    }\n\n    let resolve: (result: boolean | PromiseLike<boolean>) => void;\n    let reject: (reason?: any) => void;\n    let promise: Promise<boolean>;\n    if (priorPromise) {\n      resolve = priorPromise.resolve;\n      reject = priorPromise.reject;\n      promise = priorPromise.promise;\n    } else {\n      promise = new Promise<boolean>((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n    }\n\n    // Indicate that the navigation is happening.\n    const taskId = this.pendingTasks.add();\n    afterNextNavigation(this, () => {\n      // Remove pending task in a microtask to allow for cancelled\n      // initial navigations and redirects within the same task.\n      queueMicrotask(() => this.pendingTasks.remove(taskId));\n    });\n\n    this.navigationTransitions.handleNavigationRequest({\n      source,\n      restoredState,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.currentUrlTree,\n      rawUrl,\n      extras,\n      resolve: resolve!,\n      reject: reject!,\n      promise,\n      currentSnapshot: this.routerState.snapshot,\n      currentRouterState: this.routerState,\n    });\n\n    // Make sure that the error is propagated even though `processNavigations` catch\n    // handler does not rethrow\n    return promise.catch((e: any) => {\n      return Promise.reject(e);\n    });\n  }\n}\n\nfunction validateCommands(commands: string[]): void {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new RuntimeError(\n        RuntimeErrorCode.NULLISH_COMMAND,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `The requested path contains ${cmd} segment at index ${i}`,\n      );\n    }\n  }\n}\n\nfunction isPublicRouterEvent(e: Event | PrivateRouterEvents): e is Event {\n  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LocationStrategy} from '@angular/common';\nimport {\n  Attribute,\n  booleanAttribute,\n  Directive,\n  ElementRef,\n  HostBinding,\n  HostListener,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Renderer2,\n  RuntimeError as RuntimeError,\n  SimpleChanges,\n  sanitizeUrlOrResourceUrl,\n} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\n\nimport {Event, NavigationEnd} from '../events';\nimport {QueryParamsHandling} from '../models';\nimport {Router} from '../router';\nimport {ActivatedRoute} from '../router_state';\nimport {Params} from '../shared';\nimport {isUrlTree, UrlTree} from '../url_tree';\nimport {RuntimeErrorCode} from '../errors';\n\n/**\n * @description\n *\n * When applied to an element in a template, makes that element a link\n * that initiates navigation to a route. Navigation opens one or more routed components\n * in one or more `<router-outlet>` locations on the page.\n *\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\n * the following creates a static link to the route:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * You can use dynamic values to generate the link.\n * For a dynamic link, pass an array of path segments,\n * followed by the params for each segment.\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\n * generates a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one term and combined with dynamic segments.\n * For example, `['/team/11/user', userName, {details: true}]`\n *\n * The input that you provide to the link is treated as a delta to the current URL.\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\n * `/user/(jim//aux:team)`.\n * See {@link Router#createUrlTree} for more information.\n *\n * @usageNotes\n *\n * You can use absolute or relative paths in a link, set query parameters,\n * control how parameters are handled, and keep a history of navigation states.\n *\n * ### Relative link paths\n *\n * The first segment name can be prepended with `/`, `./`, or `../`.\n * * If the first segment begins with `/`, the router looks up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\n *   looks in the children of the current activated route.\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\n *\n * ### Setting and handling query params and fragments\n *\n * The following link adds a query parameter and a fragment to the generated URL:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * By default, the directive constructs the new URL using the given query parameters.\n * The example generates the link: `/user/bob?debug=true#education`.\n *\n * You can instruct the directive to handle query parameters differently\n * by specifying the `queryParamsHandling` option in the link.\n * Allowed values are:\n *\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\n *  - `'preserve'`: Preserve the current query params.\n *\n * For example:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * `queryParams`, `fragment`, `queryParamsHandling`, `preserveFragment`, and `relativeTo`\n * cannot be used when the `routerLink` input is a `UrlTree`.\n *\n * See {@link UrlCreationOptions#queryParamsHandling}.\n *\n * ### Preserving navigation history\n *\n * You can provide a `state` value to be persisted to the browser's\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\n * For example:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * Use {@link Router#getCurrentNavigation} to retrieve a saved\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\n * event:\n *\n * ```ts\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: '[routerLink]',\n})\nexport class RouterLink implements OnChanges, OnDestroy {\n  /**\n   * Represents an `href` attribute value applied to a host element,\n   * when a host element is `<a>`. For other tags, the value is `null`.\n   */\n  href: string | null = null;\n\n  /**\n   * Represents the `target` attribute on a host element.\n   * This is only used when the host element is an `<a>` tag.\n   */\n  @HostBinding('attr.target') @Input() target?: string;\n\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#queryParams}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() queryParams?: Params | null;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#fragment}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() fragment?: string;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#queryParamsHandling}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() queryParamsHandling?: QueryParamsHandling | null;\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#state}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input() state?: {[k: string]: any};\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#info}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input() info?: unknown;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * Specify a value here when you do not want to use the default value\n   * for `routerLink`, which is the current activated route.\n   * Note that a value of `undefined` here will use the `routerLink` default.\n   * @see {@link UrlCreationOptions#relativeTo}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input() relativeTo?: ActivatedRoute | null;\n\n  /** Whether a host element is an `<a>` tag. */\n  private isAnchorElement: boolean;\n\n  private subscription?: Subscription;\n\n  /** @internal */\n  onChanges = new Subject<RouterLink>();\n\n  constructor(\n    private router: Router,\n    private route: ActivatedRoute,\n    @Attribute('tabindex') private readonly tabIndexAttribute: string | null | undefined,\n    private readonly renderer: Renderer2,\n    private readonly el: ElementRef,\n    private locationStrategy?: LocationStrategy,\n  ) {\n    const tagName = el.nativeElement.tagName?.toLowerCase();\n    this.isAnchorElement = tagName === 'a' || tagName === 'area';\n\n    if (this.isAnchorElement) {\n      this.subscription = router.events.subscribe((s: Event) => {\n        if (s instanceof NavigationEnd) {\n          this.updateHref();\n        }\n      });\n    } else {\n      this.setTabIndexIfNotOnNativeEl('0');\n    }\n  }\n\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#preserveFragment}\n   * @see {@link Router#createUrlTree}\n   */\n  @Input({transform: booleanAttribute}) preserveFragment: boolean = false;\n\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#skipLocationChange}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input({transform: booleanAttribute}) skipLocationChange: boolean = false;\n\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#replaceUrl}\n   * @see {@link Router#navigateByUrl}\n   */\n  @Input({transform: booleanAttribute}) replaceUrl: boolean = false;\n\n  /**\n   * Modifies the tab index if there was not a tabindex attribute on the element during\n   * instantiation.\n   */\n  private setTabIndexIfNotOnNativeEl(newTabIndex: string | null) {\n    if (this.tabIndexAttribute != null /* both `null` and `undefined` */ || this.isAnchorElement) {\n      return;\n    }\n    this.applyAttributeValue('tabindex', newTabIndex);\n  }\n\n  /** @nodoc */\n  // TODO(atscott): Remove changes parameter in major version as a breaking change.\n  ngOnChanges(changes?: SimpleChanges) {\n    if (\n      ngDevMode &&\n      isUrlTree(this.routerLinkInput) &&\n      (this.fragment !== undefined ||\n        this.queryParams ||\n        this.queryParamsHandling ||\n        this.preserveFragment ||\n        this.relativeTo)\n    ) {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_ROUTER_LINK_INPUTS,\n        'Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.',\n      );\n    }\n    if (this.isAnchorElement) {\n      this.updateHref();\n    }\n    // This is subscribed to by `RouterLinkActive` so that it knows to update when there are changes\n    // to the RouterLinks it's tracking.\n    this.onChanges.next(this);\n  }\n\n  private routerLinkInput: any[] | UrlTree | null = null;\n\n  /**\n   * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.\n   *   - **array**: commands to pass to {@link Router#createUrlTree}.\n   *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n   *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands\n   *     and other inputs that correspond to properties of `UrlCreationOptions`.\n   *   - **null|undefined**: effectively disables the `routerLink`\n   * @see {@link Router#createUrlTree}\n   */\n  @Input()\n  set routerLink(commandsOrUrlTree: any[] | string | UrlTree | null | undefined) {\n    if (commandsOrUrlTree == null) {\n      this.routerLinkInput = null;\n      this.setTabIndexIfNotOnNativeEl(null);\n    } else {\n      if (isUrlTree(commandsOrUrlTree)) {\n        this.routerLinkInput = commandsOrUrlTree;\n      } else {\n        this.routerLinkInput = Array.isArray(commandsOrUrlTree)\n          ? commandsOrUrlTree\n          : [commandsOrUrlTree];\n      }\n      this.setTabIndexIfNotOnNativeEl('0');\n    }\n  }\n\n  /** @nodoc */\n  @HostListener('click', [\n    '$event.button',\n    '$event.ctrlKey',\n    '$event.shiftKey',\n    '$event.altKey',\n    '$event.metaKey',\n  ])\n  onClick(\n    button: number,\n    ctrlKey: boolean,\n    shiftKey: boolean,\n    altKey: boolean,\n    metaKey: boolean,\n  ): boolean {\n    const urlTree = this.urlTree;\n\n    if (urlTree === null) {\n      return true;\n    }\n\n    if (this.isAnchorElement) {\n      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {\n        return true;\n      }\n\n      if (typeof this.target === 'string' && this.target != '_self') {\n        return true;\n      }\n    }\n\n    const extras = {\n      skipLocationChange: this.skipLocationChange,\n      replaceUrl: this.replaceUrl,\n      state: this.state,\n      info: this.info,\n    };\n    this.router.navigateByUrl(urlTree, extras);\n\n    // Return `false` for `<a>` elements to prevent default action\n    // and cancel the native behavior, since the navigation is handled\n    // by the Router.\n    return !this.isAnchorElement;\n  }\n\n  /** @nodoc */\n  ngOnDestroy(): any {\n    this.subscription?.unsubscribe();\n  }\n\n  private updateHref(): void {\n    const urlTree = this.urlTree;\n    this.href =\n      urlTree !== null && this.locationStrategy\n        ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree))\n        : null;\n\n    const sanitizedValue =\n      this.href === null\n        ? null\n        : // This class represents a directive that can be added to both `<a>` elements,\n          // as well as other elements. As a result, we can't define security context at\n          // compile time. So the security context is deferred to runtime.\n          // The `sanitizeUrlOrResourceUrl` selects the necessary sanitizer function\n          // based on the tag and property names. The logic mimics the one from\n          // `packages/compiler/src/schema/dom_security_schema.ts`, which is used at compile time.\n          //\n          // Note: we should investigate whether we can switch to using `@HostBinding('attr.href')`\n          // instead of applying a value via a renderer, after a final merge of the\n          // `RouterLinkWithHref` directive.\n          sanitizeUrlOrResourceUrl(\n            this.href,\n            this.el.nativeElement.tagName.toLowerCase(),\n            'href',\n          );\n    this.applyAttributeValue('href', sanitizedValue);\n  }\n\n  private applyAttributeValue(attrName: string, attrValue: string | null) {\n    const renderer = this.renderer;\n    const nativeElement = this.el.nativeElement;\n    if (attrValue !== null) {\n      renderer.setAttribute(nativeElement, attrName, attrValue);\n    } else {\n      renderer.removeAttribute(nativeElement, attrName);\n    }\n  }\n\n  get urlTree(): UrlTree | null {\n    if (this.routerLinkInput === null) {\n      return null;\n    } else if (isUrlTree(this.routerLinkInput)) {\n      return this.routerLinkInput;\n    }\n    return this.router.createUrlTree(this.routerLinkInput, {\n      // If the `relativeTo` input is not defined, we want to use `this.route` by default.\n      // Otherwise, we should use the value provided by the user in the input.\n      relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,\n      queryParams: this.queryParams,\n      fragment: this.fragment,\n      queryParamsHandling: this.queryParamsHandling,\n      preserveFragment: this.preserveFragment,\n    });\n  }\n}\n\n/**\n * @description\n * An alias for the `RouterLink` directive.\n * Deprecated since v15, use `RouterLink` directive instead.\n *\n * @deprecated use `RouterLink` directive instead.\n * @publicApi\n */\nexport {RouterLink as RouterLinkWithHref};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterContentInit,\n  ChangeDetectorRef,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Output,\n  QueryList,\n  Renderer2,\n  SimpleChanges,\n} from '@angular/core';\nimport {from, of, Subscription} from 'rxjs';\nimport {mergeAll} from 'rxjs/operators';\n\nimport {Event, NavigationEnd} from '../events';\nimport {Router} from '../router';\nimport {IsActiveMatchOptions} from '../url_tree';\n\nimport {RouterLink} from './router_link';\n\n/**\n *\n * @description\n *\n * Tracks whether the linked route of an element is currently active, and allows you\n * to specify one or more CSS classes to add to the element when the linked route\n * is active.\n *\n * Use this directive to create a visual distinction for elements associated with an active route.\n * For example, the following code highlights the word \"Bob\" when the router\n * activates the associated route:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\n * added to the anchor tag. If the URL changes, the class is removed.\n *\n * You can set more than one class using a space-separated string or an array.\n * For example:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\n * instance to a template variable.\n * For example, the following checks the status without assigning any CSS classes:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\n * For example, the following sets the active-link class on the `<div>`  parent tag\n * when the URL is either '/user/jim' or '/user/bob'.\n *\n * ```html\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * The `RouterLinkActive` directive can also be used to set the aria-current attribute\n * to provide an alternative distinction for active elements to visually impaired users.\n *\n * For example, the following code adds the 'active' class to the Home Page link when it is\n * indeed active and in such case also sets its aria-current attribute to 'page':\n *\n * ```html\n * <a routerLink=\"/\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Home Page</a>\n * ```\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: '[routerLinkActive]',\n  exportAs: 'routerLinkActive',\n})\nexport class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {\n  @ContentChildren(RouterLink, {descendants: true}) links!: QueryList<RouterLink>;\n\n  private classes: string[] = [];\n  private routerEventsSubscription: Subscription;\n  private linkInputChangesSubscription?: Subscription;\n  private _isActive = false;\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  /**\n   * Options to configure how to determine if the router link is active.\n   *\n   * These options are passed to the `Router.isActive()` function.\n   *\n   * @see {@link Router#isActive}\n   */\n  @Input() routerLinkActiveOptions: {exact: boolean} | IsActiveMatchOptions = {exact: false};\n\n  /**\n   * Aria-current attribute to apply when the router link is active.\n   *\n   * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}\n   */\n  @Input() ariaCurrentWhenActive?: 'page' | 'step' | 'location' | 'date' | 'time' | true | false;\n\n  /**\n   *\n   * You can use the output `isActiveChange` to get notified each time the link becomes\n   * active or inactive.\n   *\n   * Emits:\n   * true  -> Route is active\n   * false -> Route is inactive\n   *\n   * ```html\n   * <a\n   *  routerLink=\"/user/bob\"\n   *  routerLinkActive=\"active-link\"\n   *  (isActiveChange)=\"this.onRouterLinkActive($event)\">Bob</a>\n   * ```\n   */\n  @Output() readonly isActiveChange: EventEmitter<boolean> = new EventEmitter();\n\n  constructor(\n    private router: Router,\n    private element: ElementRef,\n    private renderer: Renderer2,\n    private readonly cdr: ChangeDetectorRef,\n    @Optional() private link?: RouterLink,\n  ) {\n    this.routerEventsSubscription = router.events.subscribe((s: Event) => {\n      if (s instanceof NavigationEnd) {\n        this.update();\n      }\n    });\n  }\n\n  /** @nodoc */\n  ngAfterContentInit(): void {\n    // `of(null)` is used to force subscribe body to execute once immediately (like `startWith`).\n    of(this.links.changes, of(null))\n      .pipe(mergeAll())\n      .subscribe((_) => {\n        this.update();\n        this.subscribeToEachLinkOnChanges();\n      });\n  }\n\n  private subscribeToEachLinkOnChanges() {\n    this.linkInputChangesSubscription?.unsubscribe();\n    const allLinkChanges = [...this.links.toArray(), this.link]\n      .filter((link): link is RouterLink => !!link)\n      .map((link) => link.onChanges);\n    this.linkInputChangesSubscription = from(allLinkChanges)\n      .pipe(mergeAll())\n      .subscribe((link) => {\n        if (this._isActive !== this.isLinkActive(this.router)(link)) {\n          this.update();\n        }\n      });\n  }\n\n  @Input()\n  set routerLinkActive(data: string[] | string) {\n    const classes = Array.isArray(data) ? data : data.split(' ');\n    this.classes = classes.filter((c) => !!c);\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges): void {\n    this.update();\n  }\n  /** @nodoc */\n  ngOnDestroy(): void {\n    this.routerEventsSubscription.unsubscribe();\n    this.linkInputChangesSubscription?.unsubscribe();\n  }\n\n  private update(): void {\n    if (!this.links || !this.router.navigated) return;\n\n    queueMicrotask(() => {\n      const hasActiveLinks = this.hasActiveLinks();\n      this.classes.forEach((c) => {\n        if (hasActiveLinks) {\n          this.renderer.addClass(this.element.nativeElement, c);\n        } else {\n          this.renderer.removeClass(this.element.nativeElement, c);\n        }\n      });\n      if (hasActiveLinks && this.ariaCurrentWhenActive !== undefined) {\n        this.renderer.setAttribute(\n          this.element.nativeElement,\n          'aria-current',\n          this.ariaCurrentWhenActive.toString(),\n        );\n      } else {\n        this.renderer.removeAttribute(this.element.nativeElement, 'aria-current');\n      }\n\n      // Only emit change if the active state changed.\n      if (this._isActive !== hasActiveLinks) {\n        this._isActive = hasActiveLinks;\n        this.cdr.markForCheck();\n        // Emit on isActiveChange after classes are updated\n        this.isActiveChange.emit(hasActiveLinks);\n      }\n    });\n  }\n\n  private isLinkActive(router: Router): (link: RouterLink) => boolean {\n    const options: boolean | IsActiveMatchOptions = isActiveMatchOptions(\n      this.routerLinkActiveOptions,\n    )\n      ? this.routerLinkActiveOptions\n      : // While the types should disallow `undefined` here, it's possible without strict inputs\n        this.routerLinkActiveOptions.exact || false;\n    return (link: RouterLink) => {\n      const urlTree = link.urlTree;\n      return urlTree ? router.isActive(urlTree, options) : false;\n    };\n  }\n\n  private hasActiveLinks(): boolean {\n    const isActiveCheckFn = this.isLinkActive(this.router);\n    return (this.link && isActiveCheckFn(this.link)) || this.links.some(isActiveCheckFn);\n  }\n}\n\n/**\n * Use instead of `'paths' in options` to be compatible with property renaming\n */\nfunction isActiveMatchOptions(\n  options: {exact: boolean} | IsActiveMatchOptions,\n): options is IsActiveMatchOptions {\n  return !!(options as IsActiveMatchOptions).paths;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ViewportScroller} from '@angular/common';\nimport {Injectable, InjectionToken, NgZone, OnDestroy} from '@angular/core';\nimport {Unsubscribable} from 'rxjs';\n\nimport {\n  NavigationEnd,\n  NavigationSkipped,\n  NavigationSkippedCode,\n  NavigationStart,\n  Scroll,\n} from './events';\nimport {NavigationTransitions} from './navigation_transition';\nimport {UrlSerializer} from './url_tree';\n\nexport const ROUTER_SCROLLER = new InjectionToken<RouterScroller>('');\n\n@Injectable()\nexport class RouterScroller implements OnDestroy {\n  private routerEventsSubscription?: Unsubscribable;\n  private scrollEventsSubscription?: Unsubscribable;\n\n  private lastId = 0;\n  private lastSource: 'imperative' | 'popstate' | 'hashchange' | undefined = 'imperative';\n  private restoredId = 0;\n  private store: {[key: string]: [number, number]} = {};\n\n  /** @nodoc */\n  constructor(\n    readonly urlSerializer: UrlSerializer,\n    private transitions: NavigationTransitions,\n    public readonly viewportScroller: ViewportScroller,\n    private readonly zone: NgZone,\n    private options: {\n      scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n      anchorScrolling?: 'disabled' | 'enabled';\n    } = {},\n  ) {\n    // Default both options to 'disabled'\n    options.scrollPositionRestoration ||= 'disabled';\n    options.anchorScrolling ||= 'disabled';\n  }\n\n  init(): void {\n    // we want to disable the automatic scrolling because having two places\n    // responsible for scrolling results race conditions, especially given\n    // that browser don't implement this behavior consistently\n    if (this.options.scrollPositionRestoration !== 'disabled') {\n      this.viewportScroller.setHistoryScrollRestoration('manual');\n    }\n    this.routerEventsSubscription = this.createScrollEvents();\n    this.scrollEventsSubscription = this.consumeScrollEvents();\n  }\n\n  private createScrollEvents() {\n    return this.transitions.events.subscribe((e) => {\n      if (e instanceof NavigationStart) {\n        // store the scroll position of the current stable navigations.\n        this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n        this.lastSource = e.navigationTrigger;\n        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n      } else if (e instanceof NavigationEnd) {\n        this.lastId = e.id;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);\n      } else if (\n        e instanceof NavigationSkipped &&\n        e.code === NavigationSkippedCode.IgnoredSameUrlNavigation\n      ) {\n        this.lastSource = undefined;\n        this.restoredId = 0;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);\n      }\n    });\n  }\n\n  private consumeScrollEvents() {\n    return this.transitions.events.subscribe((e) => {\n      if (!(e instanceof Scroll)) return;\n      // a popstate event. The pop state event will always ignore anchor scrolling.\n      if (e.position) {\n        if (this.options.scrollPositionRestoration === 'top') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        } else if (this.options.scrollPositionRestoration === 'enabled') {\n          this.viewportScroller.scrollToPosition(e.position);\n        }\n        // imperative navigation \"forward\"\n      } else {\n        if (e.anchor && this.options.anchorScrolling === 'enabled') {\n          this.viewportScroller.scrollToAnchor(e.anchor);\n        } else if (this.options.scrollPositionRestoration !== 'disabled') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        }\n      }\n    });\n  }\n\n  private scheduleScrollEvent(\n    routerEvent: NavigationEnd | NavigationSkipped,\n    anchor: string | null,\n  ): void {\n    this.zone.runOutsideAngular(() => {\n      // The scroll event needs to be delayed until after change detection. Otherwise, we may\n      // attempt to restore the scroll position before the router outlet has fully rendered the\n      // component by executing its update block of the template function.\n      setTimeout(() => {\n        this.zone.run(() => {\n          this.transitions.events.next(\n            new Scroll(\n              routerEvent,\n              this.lastSource === 'popstate' ? this.store[this.restoredId] : null,\n              anchor,\n            ),\n          );\n        });\n      }, 0);\n    });\n  }\n\n  /** @nodoc */\n  ngOnDestroy() {\n    this.routerEventsSubscription?.unsubscribe();\n    this.scrollEventsSubscription?.unsubscribe();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  HashLocationStrategy,\n  LOCATION_INITIALIZED,\n  LocationStrategy,\n  ViewportScroller,\n} from '@angular/common';\nimport {\n  APP_BOOTSTRAP_LISTENER,\n  APP_INITIALIZER,\n  ApplicationRef,\n  ComponentRef,\n  ENVIRONMENT_INITIALIZER,\n  EnvironmentProviders,\n  inject,\n  InjectFlags,\n  InjectionToken,\n  Injector,\n  makeEnvironmentProviders,\n  NgZone,\n  Provider,\n  runInInjectionContext,\n  Type,\n} from '@angular/core';\nimport {of, Subject} from 'rxjs';\n\nimport {INPUT_BINDER, RoutedComponentInputBinder} from './directives/router_outlet';\nimport {Event, NavigationError, stringifyEvent} from './events';\nimport {RedirectCommand, Routes} from './models';\nimport {NAVIGATION_ERROR_HANDLER, NavigationTransitions} from './navigation_transition';\nimport {Router} from './router';\nimport {InMemoryScrollingOptions, ROUTER_CONFIGURATION, RouterConfigOptions} from './router_config';\nimport {ROUTES} from './router_config_loader';\nimport {PreloadingStrategy, RouterPreloader} from './router_preloader';\nimport {ROUTER_SCROLLER, RouterScroller} from './router_scroller';\nimport {ActivatedRoute} from './router_state';\nimport {UrlSerializer} from './url_tree';\nimport {afterNextNavigation} from './utils/navigations';\nimport {\n  CREATE_VIEW_TRANSITION,\n  createViewTransition,\n  VIEW_TRANSITION_OPTIONS,\n  ViewTransitionsFeatureOptions,\n} from './utils/view_transition';\n\n/**\n * Sets up providers necessary to enable `Router` functionality for the application.\n * Allows to configure a set of routes as well as extra features that should be enabled.\n *\n * @usageNotes\n *\n * Basic example of how you can add a Router to your application:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent, {\n *   providers: [provideRouter(appRoutes)]\n * });\n * ```\n *\n * You can also enable optional features in the Router by adding functions from the `RouterFeatures`\n * type:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes,\n *         withDebugTracing(),\n *         withRouterConfig({paramsInheritanceStrategy: 'always'}))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link RouterFeatures}\n *\n * @publicApi\n * @param routes A set of `Route`s to use for the application routing table.\n * @param features Optional features to configure additional router behaviors.\n * @returns A set of providers to setup a Router.\n */\nexport function provideRouter(routes: Routes, ...features: RouterFeatures[]): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    {provide: ROUTES, multi: true, useValue: routes},\n    typeof ngDevMode === 'undefined' || ngDevMode\n      ? {provide: ROUTER_IS_PROVIDED, useValue: true}\n      : [],\n    {provide: ActivatedRoute, useFactory: rootRoute, deps: [Router]},\n    {provide: APP_BOOTSTRAP_LISTENER, multi: true, useFactory: getBootstrapListener},\n    features.map((feature) => feature.providers),\n  ]);\n}\n\nexport function rootRoute(router: Router): ActivatedRoute {\n  return router.routerState.root;\n}\n\n/**\n * Helper type to represent a Router feature.\n *\n * @publicApi\n */\nexport interface RouterFeature<FeatureKind extends RouterFeatureKind> {\n  kind: FeatureKind;\n  providers: Provider[];\n}\n\n/**\n * Helper function to create an object that represents a Router feature.\n */\nfunction routerFeature<FeatureKind extends RouterFeatureKind>(\n  kind: FeatureKind,\n  providers: Provider[],\n): RouterFeature<FeatureKind> {\n  return {kind: kind, providers: providers};\n}\n\n/**\n * An Injection token used to indicate whether `provideRouter` or `RouterModule.forRoot` was ever\n * called.\n */\nexport const ROUTER_IS_PROVIDED = new InjectionToken<boolean>('', {\n  providedIn: 'root',\n  factory: () => false,\n});\n\nconst routerIsProvidedDevModeCheck = {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => {\n      if (!inject(ROUTER_IS_PROVIDED)) {\n        console.warn(\n          '`provideRoutes` was called without `provideRouter` or `RouterModule.forRoot`. ' +\n            'This is likely a mistake.',\n        );\n      }\n    };\n  },\n};\n\n/**\n * Registers a DI provider for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```ts\n * @NgModule({\n *   providers: [provideRoutes(ROUTES)]\n * })\n * class LazyLoadedChildModule {}\n * ```\n *\n * @deprecated If necessary, provide routes using the `ROUTES` `InjectionToken`.\n * @see {@link ROUTES}\n * @publicApi\n */\nexport function provideRoutes(routes: Routes): Provider[] {\n  return [\n    {provide: ROUTES, multi: true, useValue: routes},\n    typeof ngDevMode === 'undefined' || ngDevMode ? routerIsProvidedDevModeCheck : [],\n  ];\n}\n\n/**\n * A type alias for providers returned by `withInMemoryScrolling` for use with `provideRouter`.\n *\n * @see {@link withInMemoryScrolling}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type InMemoryScrollingFeature = RouterFeature<RouterFeatureKind.InMemoryScrollingFeature>;\n\n/**\n * Enables customizable scrolling behavior for router navigations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable scrolling feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withInMemoryScrolling())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n * @see {@link ViewportScroller}\n *\n * @publicApi\n * @param options Set of configuration parameters to customize scrolling behavior, see\n *     `InMemoryScrollingOptions` for additional information.\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withInMemoryScrolling(\n  options: InMemoryScrollingOptions = {},\n): InMemoryScrollingFeature {\n  const providers = [\n    {\n      provide: ROUTER_SCROLLER,\n      useFactory: () => {\n        const viewportScroller = inject(ViewportScroller);\n        const zone = inject(NgZone);\n        const transitions = inject(NavigationTransitions);\n        const urlSerializer = inject(UrlSerializer);\n        return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, options);\n      },\n    },\n  ];\n  return routerFeature(RouterFeatureKind.InMemoryScrollingFeature, providers);\n}\n\nexport function getBootstrapListener() {\n  const injector = inject(Injector);\n  return (bootstrappedComponentRef: ComponentRef<unknown>) => {\n    const ref = injector.get(ApplicationRef);\n\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n\n    const router = injector.get(Router);\n    const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n\n    if (injector.get(INITIAL_NAVIGATION) === InitialNavigation.EnabledNonBlocking) {\n      router.initialNavigation();\n    }\n\n    injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)?.setUpPreloading();\n    injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)?.init();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    if (!bootstrapDone.closed) {\n      bootstrapDone.next();\n      bootstrapDone.complete();\n      bootstrapDone.unsubscribe();\n    }\n  };\n}\n\n/**\n * A subject used to indicate that the bootstrapping phase is done. When initial navigation is\n * `enabledBlocking`, the first navigation waits until bootstrapping is finished before continuing\n * to the activation phase.\n */\nconst BOOTSTRAP_DONE = new InjectionToken<Subject<void>>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'bootstrap done indicator' : '',\n  {\n    factory: () => {\n      return new Subject<void>();\n    },\n  },\n);\n\n/**\n * This and the INITIAL_NAVIGATION token are used internally only. The public API side of this is\n * configured through the `ExtraOptions`.\n *\n * When set to `EnabledBlocking`, the initial navigation starts before the root\n * component is created. The bootstrap is blocked until the initial navigation is complete. This\n * value should be set in case you use [server-side rendering](guide/ssr), but do not enable\n * [hydration](guide/hydration) for your application.\n *\n * When set to `EnabledNonBlocking`, the initial navigation starts after the root component has been\n * created. The bootstrap is not blocked on the completion of the initial navigation.\n *\n * When set to `Disabled`, the initial navigation is not performed. The location listener is set up\n * before the root component gets created. Use if there is a reason to have more control over when\n * the router starts its initial navigation due to some complex initialization logic.\n *\n * @see {@link ExtraOptions}\n */\nconst enum InitialNavigation {\n  EnabledBlocking,\n  EnabledNonBlocking,\n  Disabled,\n}\n\nconst INITIAL_NAVIGATION = new InjectionToken<InitialNavigation>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'initial navigation' : '',\n  {providedIn: 'root', factory: () => InitialNavigation.EnabledNonBlocking},\n);\n\n/**\n * A type alias for providers returned by `withEnabledBlockingInitialNavigation` for use with\n * `provideRouter`.\n *\n * @see {@link withEnabledBlockingInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type EnabledBlockingInitialNavigationFeature =\n  RouterFeature<RouterFeatureKind.EnabledBlockingInitialNavigationFeature>;\n\n/**\n * A type alias for providers returned by `withEnabledBlockingInitialNavigation` or\n * `withDisabledInitialNavigation` functions for use with `provideRouter`.\n *\n * @see {@link withEnabledBlockingInitialNavigation}\n * @see {@link withDisabledInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type InitialNavigationFeature =\n  | EnabledBlockingInitialNavigationFeature\n  | DisabledInitialNavigationFeature;\n\n/**\n * Configures initial navigation to start before the root component is created.\n *\n * The bootstrap is blocked until the initial navigation is complete. This should be set in case\n * you use [server-side rendering](guide/ssr), but do not enable [hydration](guide/hydration) for\n * your application.\n *\n * @usageNotes\n *\n * Basic example of how you can enable this navigation behavior:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withEnabledBlockingInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @publicApi\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withEnabledBlockingInitialNavigation(): EnabledBlockingInitialNavigationFeature {\n  const providers = [\n    {provide: INITIAL_NAVIGATION, useValue: InitialNavigation.EnabledBlocking},\n    {\n      provide: APP_INITIALIZER,\n      multi: true,\n      deps: [Injector],\n      useFactory: (injector: Injector) => {\n        const locationInitialized: Promise<any> = injector.get(\n          LOCATION_INITIALIZED,\n          Promise.resolve(),\n        );\n\n        return () => {\n          return locationInitialized.then(() => {\n            return new Promise((resolve) => {\n              const router = injector.get(Router);\n              const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n              afterNextNavigation(router, () => {\n                // Unblock APP_INITIALIZER in case the initial navigation was canceled or errored\n                // without a redirect.\n                resolve(true);\n              });\n\n              injector.get(NavigationTransitions).afterPreactivation = () => {\n                // Unblock APP_INITIALIZER once we get to `afterPreactivation`. At this point, we\n                // assume activation will complete successfully (even though this is not\n                // guaranteed).\n                resolve(true);\n                return bootstrapDone.closed ? of(void 0) : bootstrapDone;\n              };\n              router.initialNavigation();\n            });\n          });\n        };\n      },\n    },\n  ];\n  return routerFeature(RouterFeatureKind.EnabledBlockingInitialNavigationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withDisabledInitialNavigation` for use with\n * `provideRouter`.\n *\n * @see {@link withDisabledInitialNavigation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type DisabledInitialNavigationFeature =\n  RouterFeature<RouterFeatureKind.DisabledInitialNavigationFeature>;\n\n/**\n * Disables initial navigation.\n *\n * Use if there is a reason to have more control over when the router starts its initial navigation\n * due to some complex initialization logic.\n *\n * @usageNotes\n *\n * Basic example of how you can disable initial navigation:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDisabledInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withDisabledInitialNavigation(): DisabledInitialNavigationFeature {\n  const providers = [\n    {\n      provide: APP_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const router = inject(Router);\n        return () => {\n          router.setUpLocationChangeListener();\n        };\n      },\n    },\n    {provide: INITIAL_NAVIGATION, useValue: InitialNavigation.Disabled},\n  ];\n  return routerFeature(RouterFeatureKind.DisabledInitialNavigationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withDebugTracing` for use with `provideRouter`.\n *\n * @see {@link withDebugTracing}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type DebugTracingFeature = RouterFeature<RouterFeatureKind.DebugTracingFeature>;\n\n/**\n * Enables logging of all internal navigation events to the console.\n * Extra logging might be useful for debugging purposes to inspect Router event sequence.\n *\n * @usageNotes\n *\n * Basic example of how you can enable debug tracing:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDebugTracing())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withDebugTracing(): DebugTracingFeature {\n  let providers: Provider[] = [];\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    providers = [\n      {\n        provide: ENVIRONMENT_INITIALIZER,\n        multi: true,\n        useFactory: () => {\n          const router = inject(Router);\n          return () =>\n            router.events.subscribe((e: Event) => {\n              // tslint:disable:no-console\n              console.group?.(`Router Event: ${(<any>e.constructor).name}`);\n              console.log(stringifyEvent(e));\n              console.log(e);\n              console.groupEnd?.();\n              // tslint:enable:no-console\n            });\n        },\n      },\n    ];\n  } else {\n    providers = [];\n  }\n  return routerFeature(RouterFeatureKind.DebugTracingFeature, providers);\n}\n\nconst ROUTER_PRELOADER = new InjectionToken<RouterPreloader>(\n  typeof ngDevMode === 'undefined' || ngDevMode ? 'router preloader' : '',\n);\n\n/**\n * A type alias that represents a feature which enables preloading in Router.\n * The type is used to describe the return value of the `withPreloading` function.\n *\n * @see {@link withPreloading}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type PreloadingFeature = RouterFeature<RouterFeatureKind.PreloadingFeature>;\n\n/**\n * Allows to configure a preloading strategy to use. The strategy is configured by providing a\n * reference to a class that implements a `PreloadingStrategy`.\n *\n * @usageNotes\n *\n * Basic example of how you can configure preloading:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withPreloading(PreloadAllModules))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @param preloadingStrategy A reference to a class that implements a `PreloadingStrategy` that\n *     should be used.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withPreloading(preloadingStrategy: Type<PreloadingStrategy>): PreloadingFeature {\n  const providers = [\n    {provide: ROUTER_PRELOADER, useExisting: RouterPreloader},\n    {provide: PreloadingStrategy, useExisting: preloadingStrategy},\n  ];\n  return routerFeature(RouterFeatureKind.PreloadingFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withRouterConfig` for use with `provideRouter`.\n *\n * @see {@link withRouterConfig}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterConfigurationFeature =\n  RouterFeature<RouterFeatureKind.RouterConfigurationFeature>;\n\n/**\n * Allows to provide extra parameters to configure Router.\n *\n * @usageNotes\n *\n * Basic example of how you can provide extra configuration options:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withRouterConfig({\n *          onSameUrlNavigation: 'reload'\n *       }))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @param options A set of parameters to configure Router, see `RouterConfigOptions` for\n *     additional information.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withRouterConfig(options: RouterConfigOptions): RouterConfigurationFeature {\n  const providers = [{provide: ROUTER_CONFIGURATION, useValue: options}];\n  return routerFeature(RouterFeatureKind.RouterConfigurationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withHashLocation` for use with `provideRouter`.\n *\n * @see {@link withHashLocation}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterHashLocationFeature = RouterFeature<RouterFeatureKind.RouterHashLocationFeature>;\n\n/**\n * Provides the location strategy that uses the URL fragment instead of the history API.\n *\n * @usageNotes\n *\n * Basic example of how you can use the hash location option:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withHashLocation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n * @see {@link /api/common/HashLocationStrategy HashLocationStrategy}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withHashLocation(): RouterHashLocationFeature {\n  const providers = [{provide: LocationStrategy, useClass: HashLocationStrategy}];\n  return routerFeature(RouterFeatureKind.RouterHashLocationFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withNavigationErrorHandler` for use with `provideRouter`.\n *\n * @see {@link withNavigationErrorHandler}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type NavigationErrorHandlerFeature =\n  RouterFeature<RouterFeatureKind.NavigationErrorHandlerFeature>;\n\n/**\n * Provides a function which is called when a navigation error occurs.\n *\n * This function is run inside application's [injection context](guide/di/dependency-injection-context)\n * so you can use the [`inject`](api/core/inject) function.\n *\n * This function can return a `RedirectCommand` to convert the error to a redirect, similar to returning\n * a `UrlTree` or `RedirectCommand` from a guard. This will also prevent the `Router` from emitting\n * `NavigationError`; it will instead emit `NavigationCancel` with code NavigationCancellationCode.Redirect.\n * Return values other than `RedirectCommand` are ignored and do not change any behavior with respect to\n * how the `Router` handles the error.\n *\n * @usageNotes\n *\n * Basic example of how you can use the error handler option:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withNavigationErrorHandler((e: NavigationError) =>\n * inject(MyErrorTracker).trackError(e)))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link NavigationError}\n * @see {@link /api/core/inject inject}\n * @see {@link runInInjectionContext}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nexport function withNavigationErrorHandler(\n  handler: (error: NavigationError) => unknown | RedirectCommand,\n): NavigationErrorHandlerFeature {\n  const providers = [\n    {\n      provide: NAVIGATION_ERROR_HANDLER,\n      useValue: handler,\n    },\n  ];\n  return routerFeature(RouterFeatureKind.NavigationErrorHandlerFeature, providers);\n}\n\n/**\n * A type alias for providers returned by `withComponentInputBinding` for use with `provideRouter`.\n *\n * @see {@link withComponentInputBinding}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type ComponentInputBindingFeature =\n  RouterFeature<RouterFeatureKind.ComponentInputBindingFeature>;\n\n/**\n * A type alias for providers returned by `withViewTransitions` for use with `provideRouter`.\n *\n * @see {@link withViewTransitions}\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type ViewTransitionsFeature = RouterFeature<RouterFeatureKind.ViewTransitionsFeature>;\n\n/**\n * Enables binding information from the `Router` state directly to the inputs of the component in\n * `Route` configurations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable the feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withComponentInputBinding())\n *     ]\n *   }\n * );\n * ```\n *\n * The router bindings information from any of the following sources:\n *\n *  - query parameters\n *  - path and matrix parameters\n *  - static route data\n *  - data from resolvers\n *\n * Duplicate keys are resolved in the same order from above, from least to greatest,\n * meaning that resolvers have the highest precedence and override any of the other information\n * from the route.\n *\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. This prevents previous information from being\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n * Default values can be provided with a resolver on the route to ensure the value is always present\n * or an input and use an input transform in the component.\n *\n * @see {@link /guide/components/inputs#input-transforms Input Transforms}\n * @returns A set of providers for use with `provideRouter`.\n */\nexport function withComponentInputBinding(): ComponentInputBindingFeature {\n  const providers = [\n    RoutedComponentInputBinder,\n    {provide: INPUT_BINDER, useExisting: RoutedComponentInputBinder},\n  ];\n\n  return routerFeature(RouterFeatureKind.ComponentInputBindingFeature, providers);\n}\n\n/**\n * Enables view transitions in the Router by running the route activation and deactivation inside of\n * `document.startViewTransition`.\n *\n * Note: The View Transitions API is not available in all browsers. If the browser does not support\n * view transitions, the Router will not attempt to start a view transition and continue processing\n * the navigation as usual.\n *\n * @usageNotes\n *\n * Basic example of how you can enable the feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withViewTransitions())\n *     ]\n *   }\n * );\n * ```\n *\n * @returns A set of providers for use with `provideRouter`.\n * @see https://developer.chrome.com/docs/web-platform/view-transitions/\n * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\n * @developerPreview\n */\nexport function withViewTransitions(\n  options?: ViewTransitionsFeatureOptions,\n): ViewTransitionsFeature {\n  const providers = [\n    {provide: CREATE_VIEW_TRANSITION, useValue: createViewTransition},\n    {\n      provide: VIEW_TRANSITION_OPTIONS,\n      useValue: {skipNextTransition: !!options?.skipInitialTransition, ...options},\n    },\n  ];\n  return routerFeature(RouterFeatureKind.ViewTransitionsFeature, providers);\n}\n\n/**\n * A type alias that represents all Router features available for use with `provideRouter`.\n * Features can be enabled by adding special functions to the `provideRouter` call.\n * See documentation for each symbol to find corresponding function name. See also `provideRouter`\n * documentation on how to use those functions.\n *\n * @see {@link provideRouter}\n *\n * @publicApi\n */\nexport type RouterFeatures =\n  | PreloadingFeature\n  | DebugTracingFeature\n  | InitialNavigationFeature\n  | InMemoryScrollingFeature\n  | RouterConfigurationFeature\n  | NavigationErrorHandlerFeature\n  | ComponentInputBindingFeature\n  | ViewTransitionsFeature\n  | RouterHashLocationFeature;\n\n/**\n * The list of features as an enum to uniquely type each feature.\n */\nexport const enum RouterFeatureKind {\n  PreloadingFeature,\n  DebugTracingFeature,\n  EnabledBlockingInitialNavigationFeature,\n  DisabledInitialNavigationFeature,\n  InMemoryScrollingFeature,\n  RouterConfigurationFeature,\n  RouterHashLocationFeature,\n  NavigationErrorHandlerFeature,\n  ComponentInputBindingFeature,\n  ViewTransitionsFeature,\n}\n","export const environment = {\n  production: true,\n  // TEMPORARY DISABLED WHILE WORKING WITH LOCAL DB PHYSIO-APP BUILD\n  // apiURL: 'https://physioapp.onrender.com/api/v1/',\n  apiURL: 'https://physioapp-backend-716326002606.us-central1.run.app/api/v1/'\n  // temp local db build\n  // apiURL: 'http://localhost:3000/api/v1/',\n};\n","import { HttpClient } from '@angular/common/http';\nimport { Injectable, inject } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { AuthCredentials } from '../models/authCredentials';\nimport { LocalstorageService } from './localstorage.service';\nimport { Router } from '@angular/router';\nimport { environment } from '@env/environment';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  private http = inject(HttpClient);\n  private tokenService = inject(LocalstorageService);\n  private router = inject(Router);\n\n  apiURLUsers = environment.apiURL + 'users';\n\n  login(email: string, password: string): Observable<AuthCredentials> {\n    return this.http.post<AuthCredentials>(`${this.apiURLUsers}/login`, {\n      email,\n      password,\n    });\n  }\n\n  logout() {\n    this.tokenService.removeToken();\n    this.router.navigate(['/login']);\n  }\n}\n","import { Injectable, inject } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { LocalstorageService } from './localstorage.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard {\n  private router = inject(Router);\n  private localStorageToken = inject(LocalstorageService);\n\n\n  canActivate() {\n    const token = this.localStorageToken.getToken('jwtToken');\n\n    if (token) {\n      const tokenDecode = JSON.parse(atob(token.split('.')[1]));\n      if(tokenDecode.userId && !this._tokenExpired(tokenDecode.exp)) {\n          // On login, check if there's 'admin' in path and if user is admin\n          const isAdminPath = window.location.pathname.includes('/admin');\n          if(isAdminPath) {\n            return tokenDecode.isAdmin ? true : false;\n          }\n\n        return true;\n      }\n    }\n    this.router.navigate(['/login']);\n    return false;\n  }\n\n  private _tokenExpired(expiration: number): boolean{\n    return Math.floor(new Date().getTime() / 1000) >= expiration;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ChangeDetectionStrategy, Component, ViewEncapsulation} from '@angular/core';\n\n/** Component used to load the structural styles of the text field. */\n@Component({\n  template: '',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  styleUrl: 'text-field-prebuilt.css',\n  host: {'cdk-text-field-style-loader': ''},\n})\nexport class _CdkTextFieldStyleLoader {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Platform, _bindEventWithOptions} from '../platform';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  inject,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Output,\n  RendererFactory2,\n} from '@angular/core';\nimport {_CdkPrivateStyleLoader} from '../private';\nimport {coerceElement} from '../coercion';\nimport {EMPTY, Observable, Subject} from 'rxjs';\nimport {_CdkTextFieldStyleLoader} from './text-field-style-loader';\n\n/** An event that is emitted when the autofill state of an input changes. */\nexport type AutofillEvent = {\n  /** The element whose autofill state changes. */\n  target: Element;\n  /** Whether the element is currently autofilled. */\n  isAutofilled: boolean;\n};\n\n/** Used to track info about currently monitored elements. */\ntype MonitoredElementInfo = {\n  readonly subject: Subject<AutofillEvent>;\n  unlisten: () => void;\n};\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = {passive: true};\n\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\n@Injectable({providedIn: 'root'})\nexport class AutofillMonitor implements OnDestroy {\n  private _platform = inject(Platform);\n  private _ngZone = inject(NgZone);\n  private _renderer = inject(RendererFactory2).createRenderer(null, null);\n\n  private _styleLoader = inject(_CdkPrivateStyleLoader);\n  private _monitoredElements = new Map<Element, MonitoredElementInfo>();\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: Element): Observable<AutofillEvent>;\n\n  /**\n   * Monitor for changes in the autofill state of the given input element.\n   * @param element The element to monitor.\n   * @return A stream of autofill state changes.\n   */\n  monitor(element: ElementRef<Element>): Observable<AutofillEvent>;\n\n  monitor(elementOrRef: Element | ElementRef<Element>): Observable<AutofillEvent> {\n    if (!this._platform.isBrowser) {\n      return EMPTY;\n    }\n\n    this._styleLoader.load(_CdkTextFieldStyleLoader);\n\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      return info.subject;\n    }\n\n    const subject = new Subject<AutofillEvent>();\n    const cssClass = 'cdk-text-field-autofilled';\n    const listener = (event: AnimationEvent) => {\n      // Animation events fire on initial element render, we check for the presence of the autofill\n      // CSS class to make sure this is a real change in state, not just the initial render before\n      // we fire off events.\n      if (\n        event.animationName === 'cdk-text-field-autofill-start' &&\n        !element.classList.contains(cssClass)\n      ) {\n        element.classList.add(cssClass);\n        this._ngZone.run(() => subject.next({target: event.target as Element, isAutofilled: true}));\n      } else if (\n        event.animationName === 'cdk-text-field-autofill-end' &&\n        element.classList.contains(cssClass)\n      ) {\n        element.classList.remove(cssClass);\n        this._ngZone.run(() =>\n          subject.next({target: event.target as Element, isAutofilled: false}),\n        );\n      }\n    };\n\n    const unlisten = this._ngZone.runOutsideAngular(() => {\n      element.classList.add('cdk-text-field-autofill-monitored');\n      return _bindEventWithOptions(\n        this._renderer,\n        element,\n        'animationstart',\n        listener,\n        listenerOptions,\n      );\n    });\n\n    this._monitoredElements.set(element, {subject, unlisten});\n    return subject;\n  }\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: Element): void;\n\n  /**\n   * Stop monitoring the autofill state of the given input element.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: ElementRef<Element>): void;\n\n  stopMonitoring(elementOrRef: Element | ElementRef<Element>): void {\n    const element = coerceElement(elementOrRef);\n    const info = this._monitoredElements.get(element);\n\n    if (info) {\n      info.unlisten();\n      info.subject.complete();\n      element.classList.remove('cdk-text-field-autofill-monitored');\n      element.classList.remove('cdk-text-field-autofilled');\n      this._monitoredElements.delete(element);\n    }\n  }\n\n  ngOnDestroy() {\n    this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n  }\n}\n\n/** A directive that can be used to monitor the autofill state of an input. */\n@Directive({\n  selector: '[cdkAutofill]',\n})\nexport class CdkAutofill implements OnDestroy, OnInit {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _autofillMonitor = inject(AutofillMonitor);\n\n  /** Emits when the autofill state of the element changes. */\n  @Output() readonly cdkAutofill = new EventEmitter<AutofillEvent>();\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngOnInit() {\n    this._autofillMonitor\n      .monitor(this._elementRef)\n      .subscribe(event => this.cdkAutofill.emit(event));\n  }\n\n  ngOnDestroy() {\n    this._autofillMonitor.stopMonitoring(this._elementRef);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NumberInput, coerceNumberProperty} from '../coercion';\nimport {\n  Directive,\n  ElementRef,\n  Input,\n  AfterViewInit,\n  DoCheck,\n  OnDestroy,\n  NgZone,\n  booleanAttribute,\n  inject,\n  Renderer2,\n} from '@angular/core';\nimport {DOCUMENT} from '@angular/common';\nimport {Platform} from '../platform';\nimport {_CdkPrivateStyleLoader} from '../private';\nimport {auditTime} from 'rxjs/operators';\nimport {Subject} from 'rxjs';\nimport {_CdkTextFieldStyleLoader} from './text-field-style-loader';\n\n/** Directive to automatically resize a textarea to fit its content. */\n@Directive({\n  selector: 'textarea[cdkTextareaAutosize]',\n  exportAs: 'cdkTextareaAutosize',\n  host: {\n    'class': 'cdk-textarea-autosize',\n    // Textarea elements that have the directive applied should have a single row by default.\n    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n    'rows': '1',\n    '(input)': '_noopInputHandler()',\n  },\n})\nexport class CdkTextareaAutosize implements AfterViewInit, DoCheck, OnDestroy {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _platform = inject(Platform);\n  private _ngZone = inject(NgZone);\n  private _renderer = inject(Renderer2);\n  private _resizeEvents = new Subject<void>();\n\n  /** Keep track of the previous textarea value to avoid resizing when the value hasn't changed. */\n  private _previousValue?: string;\n  private _initialHeight: string | undefined;\n  private readonly _destroyed = new Subject<void>();\n  private _listenerCleanups: (() => void)[] | undefined;\n\n  private _minRows: number;\n  private _maxRows: number;\n  private _enabled: boolean = true;\n\n  /**\n   * Value of minRows as of last resize. If the minRows has decreased, the\n   * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n   * does not have the same problem because it does not affect the textarea's scrollHeight.\n   */\n  private _previousMinRows: number = -1;\n\n  private _textareaElement: HTMLTextAreaElement;\n\n  /** Minimum amount of rows in the textarea. */\n  @Input('cdkAutosizeMinRows')\n  get minRows(): number {\n    return this._minRows;\n  }\n  set minRows(value: NumberInput) {\n    this._minRows = coerceNumberProperty(value);\n    this._setMinHeight();\n  }\n\n  /** Maximum amount of rows in the textarea. */\n  @Input('cdkAutosizeMaxRows')\n  get maxRows(): number {\n    return this._maxRows;\n  }\n  set maxRows(value: NumberInput) {\n    this._maxRows = coerceNumberProperty(value);\n    this._setMaxHeight();\n  }\n\n  /** Whether autosizing is enabled or not */\n  @Input({alias: 'cdkTextareaAutosize', transform: booleanAttribute})\n  get enabled(): boolean {\n    return this._enabled;\n  }\n  set enabled(value: boolean) {\n    // Only act if the actual value changed. This specifically helps to not run\n    // resizeToFitContent too early (i.e. before ngAfterViewInit)\n    if (this._enabled !== value) {\n      (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n    }\n  }\n\n  @Input()\n  get placeholder(): string {\n    return this._textareaElement.placeholder;\n  }\n  set placeholder(value: string) {\n    this._cachedPlaceholderHeight = undefined;\n\n    if (value) {\n      this._textareaElement.setAttribute('placeholder', value);\n    } else {\n      this._textareaElement.removeAttribute('placeholder');\n    }\n\n    this._cacheTextareaPlaceholderHeight();\n  }\n\n  /** Cached height of a textarea with a single row. */\n  private _cachedLineHeight?: number;\n  /** Cached height of a textarea with only the placeholder. */\n  private _cachedPlaceholderHeight?: number;\n  /** Cached scroll top of a textarea */\n  private _cachedScrollTop: number;\n\n  /** Used to reference correct document/window */\n  protected _document? = inject(DOCUMENT, {optional: true});\n\n  private _hasFocus: boolean;\n\n  private _isViewInited = false;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const styleLoader = inject(_CdkPrivateStyleLoader);\n    styleLoader.load(_CdkTextFieldStyleLoader);\n    this._textareaElement = this._elementRef.nativeElement as HTMLTextAreaElement;\n  }\n\n  /** Sets the minimum height of the textarea as determined by minRows. */\n  _setMinHeight(): void {\n    const minHeight =\n      this.minRows && this._cachedLineHeight ? `${this.minRows * this._cachedLineHeight}px` : null;\n\n    if (minHeight) {\n      this._textareaElement.style.minHeight = minHeight;\n    }\n  }\n\n  /** Sets the maximum height of the textarea as determined by maxRows. */\n  _setMaxHeight(): void {\n    const maxHeight =\n      this.maxRows && this._cachedLineHeight ? `${this.maxRows * this._cachedLineHeight}px` : null;\n\n    if (maxHeight) {\n      this._textareaElement.style.maxHeight = maxHeight;\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      // Remember the height which we started with in case autosizing is disabled\n      this._initialHeight = this._textareaElement.style.height;\n      this.resizeToFitContent();\n\n      this._ngZone.runOutsideAngular(() => {\n        this._listenerCleanups = [\n          this._renderer.listen('window', 'resize', () => this._resizeEvents.next()),\n          this._renderer.listen(this._textareaElement, 'focus', this._handleFocusEvent),\n          this._renderer.listen(this._textareaElement, 'blur', this._handleFocusEvent),\n        ];\n        this._resizeEvents.pipe(auditTime(16)).subscribe(() => {\n          // Clear the cached heights since the styles can change\n          // when the window is resized (e.g. by media queries).\n          this._cachedLineHeight = this._cachedPlaceholderHeight = undefined;\n          this.resizeToFitContent(true);\n        });\n      });\n\n      this._isViewInited = true;\n      this.resizeToFitContent(true);\n    }\n  }\n\n  ngOnDestroy() {\n    this._listenerCleanups?.forEach(cleanup => cleanup());\n    this._resizeEvents.complete();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /**\n   * Cache the height of a single-row textarea if it has not already been cached.\n   *\n   * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n   * maxRows. For the initial version, we will assume that the height of a single line in the\n   * textarea does not ever change.\n   */\n  private _cacheTextareaLineHeight(): void {\n    if (this._cachedLineHeight) {\n      return;\n    }\n\n    // Use a clone element because we have to override some styles.\n    const textareaClone = this._textareaElement.cloneNode(false) as HTMLTextAreaElement;\n    const cloneStyles = textareaClone.style;\n    textareaClone.rows = 1;\n\n    // Use `position: absolute` so that this doesn't cause a browser layout and use\n    // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n    // would affect the height.\n    cloneStyles.position = 'absolute';\n    cloneStyles.visibility = 'hidden';\n    cloneStyles.border = 'none';\n    cloneStyles.padding = '0';\n    cloneStyles.height = '';\n    cloneStyles.minHeight = '';\n    cloneStyles.maxHeight = '';\n\n    // App styles might be messing with the height through the positioning properties.\n    cloneStyles.top = cloneStyles.bottom = cloneStyles.left = cloneStyles.right = 'auto';\n\n    // In Firefox it happens that textarea elements are always bigger than the specified amount\n    // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n    // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n    // to hidden. This ensures that there is no invalid calculation of the line height.\n    // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n    cloneStyles.overflow = 'hidden';\n\n    this._textareaElement.parentNode!.appendChild(textareaClone);\n    this._cachedLineHeight = textareaClone.clientHeight;\n    textareaClone.remove();\n\n    // Min and max heights have to be re-calculated if the cached line height changes\n    this._setMinHeight();\n    this._setMaxHeight();\n  }\n\n  private _measureScrollHeight(): number {\n    const element = this._textareaElement;\n    const previousMargin = element.style.marginBottom || '';\n    const isFirefox = this._platform.FIREFOX;\n    const needsMarginFiller = isFirefox && this._hasFocus;\n    const measuringClass = isFirefox\n      ? 'cdk-textarea-autosize-measuring-firefox'\n      : 'cdk-textarea-autosize-measuring';\n\n    // In some cases the page might move around while we're measuring the `textarea` on Firefox. We\n    // work around it by assigning a temporary margin with the same height as the `textarea` so that\n    // it occupies the same amount of space. See #23233.\n    if (needsMarginFiller) {\n      element.style.marginBottom = `${element.clientHeight}px`;\n    }\n\n    // Reset the textarea height to auto in order to shrink back to its default size.\n    // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n    element.classList.add(measuringClass);\n    // The measuring class includes a 2px padding to workaround an issue with Chrome,\n    // so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n    const scrollHeight = element.scrollHeight - 4;\n    element.classList.remove(measuringClass);\n\n    if (needsMarginFiller) {\n      element.style.marginBottom = previousMargin;\n    }\n\n    return scrollHeight;\n  }\n\n  private _cacheTextareaPlaceholderHeight(): void {\n    if (!this._isViewInited || this._cachedPlaceholderHeight != undefined) {\n      return;\n    }\n    if (!this.placeholder) {\n      this._cachedPlaceholderHeight = 0;\n      return;\n    }\n\n    const value = this._textareaElement.value;\n\n    this._textareaElement.value = this._textareaElement.placeholder;\n    this._cachedPlaceholderHeight = this._measureScrollHeight();\n    this._textareaElement.value = value;\n  }\n\n  /** Handles `focus` and `blur` events. */\n  private _handleFocusEvent = (event: FocusEvent) => {\n    this._hasFocus = event.type === 'focus';\n  };\n\n  ngDoCheck() {\n    if (this._platform.isBrowser) {\n      this.resizeToFitContent();\n    }\n  }\n\n  /**\n   * Resize the textarea to fit its content.\n   * @param force Whether to force a height recalculation. By default the height will be\n   *    recalculated only if the value changed since the last call.\n   */\n  resizeToFitContent(force: boolean = false) {\n    // If autosizing is disabled, just skip everything else\n    if (!this._enabled) {\n      return;\n    }\n\n    this._cacheTextareaLineHeight();\n    this._cacheTextareaPlaceholderHeight();\n    this._cachedScrollTop = this._textareaElement.scrollTop;\n\n    // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n    // in checking the height of the textarea.\n    if (!this._cachedLineHeight) {\n      return;\n    }\n\n    const textarea = this._elementRef.nativeElement as HTMLTextAreaElement;\n    const value = textarea.value;\n\n    // Only resize if the value or minRows have changed since these calculations can be expensive.\n    if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n      return;\n    }\n\n    const scrollHeight = this._measureScrollHeight();\n    const height = Math.max(scrollHeight, this._cachedPlaceholderHeight || 0);\n\n    // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n    textarea.style.height = `${height}px`;\n\n    this._ngZone.runOutsideAngular(() => {\n      if (typeof requestAnimationFrame !== 'undefined') {\n        requestAnimationFrame(() => this._scrollToCaretPosition(textarea));\n      } else {\n        setTimeout(() => this._scrollToCaretPosition(textarea));\n      }\n    });\n\n    this._previousValue = value;\n    this._previousMinRows = this._minRows;\n  }\n\n  /**\n   * Resets the textarea to its original size\n   */\n  reset() {\n    // Do not try to change the textarea, if the initialHeight has not been determined yet\n    // This might potentially remove styles when reset() is called before ngAfterViewInit\n    if (this._initialHeight !== undefined) {\n      this._textareaElement.style.height = this._initialHeight;\n    }\n  }\n\n  _noopInputHandler() {\n    // no-op handler that ensures we're running change detection on input events.\n  }\n\n  /**\n   * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n   * prevent it from scrolling to the caret position. We need to re-set the selection\n   * in order for it to scroll to the proper position.\n   */\n  private _scrollToCaretPosition(textarea: HTMLTextAreaElement) {\n    const {selectionStart, selectionEnd} = textarea;\n\n    // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n    // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n    // between the time we requested the animation frame and when it was executed.\n    // Also note that we have to assert that the textarea is focused before we set the\n    // selection range. Setting the selection range on a non-focused textarea will cause\n    // it to receive focus on IE and Edge.\n    if (!this._destroyed.isStopped && this._hasFocus) {\n      textarea.setSelectionRange(selectionStart, selectionEnd);\n      textarea.scrollTop = this._cachedScrollTop;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkAutofill} from './autofill';\nimport {CdkTextareaAutosize} from './autosize';\n\n@NgModule({\n  imports: [CdkAutofill, CdkTextareaAutosize],\n  exports: [CdkAutofill, CdkTextareaAutosize],\n})\nexport class TextFieldModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken, WritableSignal} from '@angular/core';\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport const MAT_INPUT_VALUE_ACCESSOR = new InjectionToken<{value: any | WritableSignal<any>}>(\n  'MAT_INPUT_VALUE_ACCESSOR',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {inject, Injectable, NgZone, OnDestroy, RendererFactory2} from '@angular/core';\nimport {Observable, Subject} from 'rxjs';\nimport {filter, shareReplay, takeUntil} from 'rxjs/operators';\n\n/**\n * Handler that logs \"ResizeObserver loop limit exceeded\" errors.\n * These errors are not shown in the Chrome console, so we log them to ensure developers are aware.\n * @param e The error\n */\nconst loopLimitExceededErrorHandler = (e: unknown) => {\n  if (e instanceof ErrorEvent && e.message === 'ResizeObserver loop limit exceeded') {\n    console.error(\n      `${e.message}. This could indicate a performance issue with your app. See https://github.com/WICG/resize-observer/blob/master/explainer.md#error-handling`,\n    );\n  }\n};\n\n/**\n * A shared ResizeObserver to be used for a particular box type (content-box, border-box, or\n * device-pixel-content-box)\n */\nclass SingleBoxSharedResizeObserver {\n  /** Stream that emits when the shared observer is destroyed. */\n  private _destroyed = new Subject<void>();\n  /** Stream of all events from the ResizeObserver. */\n  private _resizeSubject = new Subject<ResizeObserverEntry[]>();\n  /** ResizeObserver used to observe element resize events. */\n  private _resizeObserver?: ResizeObserver;\n  /** A map of elements to streams of their resize events. */\n  private _elementObservables = new Map<Element, Observable<ResizeObserverEntry[]>>();\n\n  constructor(\n    /** The box type to observe for resizes. */\n    private _box: ResizeObserverBoxOptions,\n  ) {\n    if (typeof ResizeObserver !== 'undefined') {\n      this._resizeObserver = new ResizeObserver(entries => this._resizeSubject.next(entries));\n    }\n  }\n\n  /**\n   * Gets a stream of resize events for the given element.\n   * @param target The element to observe.\n   * @return The stream of resize events for the element.\n   */\n  observe(target: Element): Observable<ResizeObserverEntry[]> {\n    if (!this._elementObservables.has(target)) {\n      this._elementObservables.set(\n        target,\n        new Observable<ResizeObserverEntry[]>(observer => {\n          const subscription = this._resizeSubject.subscribe(observer);\n          this._resizeObserver?.observe(target, {box: this._box});\n          return () => {\n            this._resizeObserver?.unobserve(target);\n            subscription.unsubscribe();\n            this._elementObservables.delete(target);\n          };\n        }).pipe(\n          filter(entries => entries.some(entry => entry.target === target)),\n          // Share a replay of the last event so that subsequent calls to observe the same element\n          // receive initial sizing info like the first one. Also enable ref counting so the\n          // element will be automatically unobserved when there are no more subscriptions.\n          shareReplay({bufferSize: 1, refCount: true}),\n          takeUntil(this._destroyed),\n        ),\n      );\n    }\n    return this._elementObservables.get(target)!;\n  }\n\n  /** Destroys this instance. */\n  destroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n    this._resizeSubject.complete();\n    this._elementObservables.clear();\n  }\n}\n\n/**\n * Allows observing resize events on multiple elements using a shared set of ResizeObserver.\n * Sharing a ResizeObserver instance is recommended for better performance (see\n * https://github.com/WICG/resize-observer/issues/59).\n *\n * Rather than share a single `ResizeObserver`, this class creates one `ResizeObserver` per type\n * of observed box ('content-box', 'border-box', and 'device-pixel-content-box'). This avoids\n * later calls to `observe` with a different box type from influencing the events dispatched to\n * earlier calls.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class SharedResizeObserver implements OnDestroy {\n  private _cleanupErrorListener: (() => void) | undefined;\n\n  /** Map of box type to shared resize observer. */\n  private _observers = new Map<ResizeObserverBoxOptions, SingleBoxSharedResizeObserver>();\n\n  /** The Angular zone. */\n  private _ngZone = inject(NgZone);\n\n  constructor() {\n    if (typeof ResizeObserver !== 'undefined' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      this._ngZone.runOutsideAngular(() => {\n        const renderer = inject(RendererFactory2).createRenderer(null, null);\n        this._cleanupErrorListener = renderer.listen(\n          'window',\n          'error',\n          loopLimitExceededErrorHandler,\n        );\n      });\n    }\n  }\n\n  ngOnDestroy() {\n    for (const [, observer] of this._observers) {\n      observer.destroy();\n    }\n    this._observers.clear();\n    this._cleanupErrorListener?.();\n  }\n\n  /**\n   * Gets a stream of resize events for the given target element and box type.\n   * @param target The element to observe for resizes.\n   * @param options Options to pass to the `ResizeObserver`\n   * @return The stream of resize events for the element.\n   */\n  observe(target: Element, options?: ResizeObserverOptions): Observable<ResizeObserverEntry[]> {\n    const box = options?.box || 'content-box';\n    if (!this._observers.has(box)) {\n      this._observers.set(box, new SingleBoxSharedResizeObserver(box));\n    }\n    return this._observers.get(box)!.observe(target);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive} from '@angular/core';\n\n/** The floating label for a `mat-form-field`. */\n@Directive({\n  selector: 'mat-label',\n})\nexport class MatLabel {}\n","<ng-template #labelTemplate>\n  <!--\n    MDC recommends that the text-field is a `<label>` element. This rather complicates the\n    setup because it would require every form-field control to explicitly set `aria-labelledby`.\n    This is because the `<label>` itself contains more than the actual label (e.g. prefix, suffix\n    or other projected content), and screen readers could potentially read out undesired content.\n    Excluding elements from being printed out requires them to be marked with `aria-hidden`, or\n    the form control is set to a scoped element for the label (using `aria-labelledby`). Both of\n    these options seem to complicate the setup because we know exactly what content is rendered\n    as part of the label, and we don't want to spend resources on walking through projected content\n    to set `aria-hidden`. Nor do we want to set `aria-labelledby` on every form control if we could\n    simply link the label to the control using the label `for` attribute.\n  -->\n  @if (_hasFloatingLabel()) {\n    <label\n      matFormFieldFloatingLabel\n      [floating]=\"_shouldLabelFloat()\"\n      [monitorResize]=\"_hasOutline()\"\n      [id]=\"_labelId\"\n      [attr.for]=\"_control.disableAutomaticLabeling ? null : _control.id\"\n    >\n      <ng-content select=\"mat-label\"></ng-content>\n      <!--\n        We set the required marker as a separate element, in order to make it easier to target if\n        apps want to override it and to be able to set `aria-hidden` so that screen readers don't\n        pick it up.\n       -->\n      @if (!hideRequiredMarker && _control.required) {\n        <span\n          aria-hidden=\"true\"\n          class=\"mat-mdc-form-field-required-marker mdc-floating-label--required\"\n        ></span>\n      }\n    </label>\n  }\n</ng-template>\n\n<div\n  class=\"mat-mdc-text-field-wrapper mdc-text-field\"\n  #textField\n  [class.mdc-text-field--filled]=\"!_hasOutline()\"\n  [class.mdc-text-field--outlined]=\"_hasOutline()\"\n  [class.mdc-text-field--no-label]=\"!_hasFloatingLabel()\"\n  [class.mdc-text-field--disabled]=\"_control.disabled\"\n  [class.mdc-text-field--invalid]=\"_control.errorState\"\n  (click)=\"_control.onContainerClick($event)\"\n>\n  @if (!_hasOutline() && !_control.disabled) {\n    <div class=\"mat-mdc-form-field-focus-overlay\"></div>\n  }\n  <div class=\"mat-mdc-form-field-flex\">\n    @if (_hasOutline()) {\n      <div matFormFieldNotchedOutline [matFormFieldNotchedOutlineOpen]=\"_shouldLabelFloat()\">\n        @if (!_forceDisplayInfixLabel()) {\n          <ng-template [ngTemplateOutlet]=\"labelTemplate\"></ng-template>\n        }\n      </div>\n    }\n\n    @if (_hasIconPrefix) {\n      <div class=\"mat-mdc-form-field-icon-prefix\" #iconPrefixContainer>\n        <ng-content select=\"[matPrefix], [matIconPrefix]\"></ng-content>\n      </div>\n    }\n\n    @if (_hasTextPrefix) {\n      <div class=\"mat-mdc-form-field-text-prefix\" #textPrefixContainer>\n        <ng-content select=\"[matTextPrefix]\"></ng-content>\n      </div>\n    }\n\n    <div class=\"mat-mdc-form-field-infix\">\n      @if (!_hasOutline() || _forceDisplayInfixLabel()) {\n        <ng-template [ngTemplateOutlet]=\"labelTemplate\"></ng-template>\n      }\n\n      <ng-content></ng-content>\n    </div>\n\n    @if (_hasTextSuffix) {\n      <div class=\"mat-mdc-form-field-text-suffix\" #textSuffixContainer>\n        <ng-content select=\"[matTextSuffix]\"></ng-content>\n      </div>\n    }\n\n    @if (_hasIconSuffix) {\n      <div class=\"mat-mdc-form-field-icon-suffix\" #iconSuffixContainer>\n        <ng-content select=\"[matSuffix], [matIconSuffix]\"></ng-content>\n      </div>\n    }\n  </div>\n\n  @if (!_hasOutline()) {\n    <div matFormFieldLineRipple></div>\n  }\n</div>\n\n<div\n  class=\"mat-mdc-form-field-subscript-wrapper mat-mdc-form-field-bottom-align\"\n  [class.mat-mdc-form-field-subscript-dynamic-size]=\"subscriptSizing === 'dynamic'\"\n>\n  @switch (_getDisplayedMessages()) {\n    @case ('error') {\n      <div class=\"mat-mdc-form-field-error-wrapper\">\n        <ng-content select=\"mat-error, [matError]\"></ng-content>\n      </div>\n    }\n\n    @case ('hint') {\n      <div class=\"mat-mdc-form-field-hint-wrapper\">\n        @if (hintLabel) {\n          <mat-hint [id]=\"_hintLabelId\">{{hintLabel}}</mat-hint>\n        }\n        <ng-content select=\"mat-hint:not([align='end'])\"></ng-content>\n        <div class=\"mat-mdc-form-field-hint-spacer\"></div>\n        <ng-content select=\"mat-hint[align='end']\"></ng-content>\n      </div>\n    }\n  }\n</div>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Directive,\n  ElementRef,\n  InjectionToken,\n  Input,\n  HostAttributeToken,\n  inject,\n} from '@angular/core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\n\n/**\n * Injection token that can be used to reference instances of `MatError`. It serves as\n * alternative token to the actual `MatError` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_ERROR = new InjectionToken<MatError>('MatError');\n\n/** Single error message to be shown underneath the form-field. */\n@Directive({\n  selector: 'mat-error, [matError]',\n  host: {\n    'class': 'mat-mdc-form-field-error mat-mdc-form-field-bottom-align',\n    'aria-atomic': 'true',\n    '[id]': 'id',\n  },\n  providers: [{provide: MAT_ERROR, useExisting: MatError}],\n})\nexport class MatError {\n  @Input() id: string = inject(_IdGenerator).getId('mat-mdc-error-');\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const ariaLive = inject(new HostAttributeToken('aria-live'), {optional: true});\n\n    // If no aria-live value is set add 'polite' as a default. This is preferred over setting\n    // role='alert' so that screen readers do not interrupt the current task to read this aloud.\n    if (!ariaLive) {\n      const elementRef = inject(ElementRef);\n      elementRef.nativeElement.setAttribute('aria-live', 'polite');\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, inject, Input} from '@angular/core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\n\n/** Hint text to be shown underneath the form field control. */\n@Directive({\n  selector: 'mat-hint',\n  host: {\n    'class': 'mat-mdc-form-field-hint mat-mdc-form-field-bottom-align',\n    '[class.mat-mdc-form-field-hint-end]': 'align === \"end\"',\n    '[id]': 'id',\n    // Remove align attribute to prevent it from interfering with layout.\n    '[attr.align]': 'null',\n  },\n})\nexport class MatHint {\n  /** Whether to align the hint label at the start or end of the line. */\n  @Input() align: 'start' | 'end' = 'start';\n\n  /** Unique ID for the hint. Used for the aria-describedby on the form field control. */\n  @Input() id: string = inject(_IdGenerator).getId('mat-mdc-hint-');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, InjectionToken, Input} from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `MatPrefix`. It serves as\n * alternative token to the actual `MatPrefix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_PREFIX = new InjectionToken<MatPrefix>('MatPrefix');\n\n/** Prefix to be placed in front of the form field. */\n@Directive({\n  selector: '[matPrefix], [matIconPrefix], [matTextPrefix]',\n  providers: [{provide: MAT_PREFIX, useExisting: MatPrefix}],\n})\nexport class MatPrefix {\n  @Input('matTextPrefix')\n  set _isTextSelector(value: '') {\n    this._isText = true;\n  }\n\n  _isText = false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, InjectionToken, Input} from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `MatSuffix`. It serves as\n * alternative token to the actual `MatSuffix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_SUFFIX = new InjectionToken<MatSuffix>('MatSuffix');\n\n/** Suffix to be placed at the end of the form field. */\n@Directive({\n  selector: '[matSuffix], [matIconSuffix], [matTextSuffix]',\n  providers: [{provide: MAT_SUFFIX, useExisting: MatSuffix}],\n})\nexport class MatSuffix {\n  @Input('matTextSuffix')\n  set _isTextSelector(value: '') {\n    this._isText = true;\n  }\n\n  _isText = false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Directive,\n  ElementRef,\n  inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  InjectionToken,\n} from '@angular/core';\nimport {SharedResizeObserver} from '@angular/cdk/observers/private';\nimport {Subscription} from 'rxjs';\n\n/** An interface that the parent form-field should implement to receive resize events. */\nexport interface FloatingLabelParent {\n  _handleLabelResized(): void;\n}\n\n/** An injion token for the parent form-field. */\nexport const FLOATING_LABEL_PARENT = new InjectionToken<FloatingLabelParent>('FloatingLabelParent');\n\n/**\n * Internal directive that maintains a MDC floating label. This directive does not\n * use the `MDCFloatingLabelFoundation` class, as it is not worth the size cost of\n * including it just to measure the label width and toggle some classes.\n *\n * The use of a directive allows us to conditionally render a floating label in the\n * template without having to manually manage instantiation and destruction of the\n * floating label component based on.\n *\n * The component is responsible for setting up the floating label styles, measuring label\n * width for the outline notch, and providing inputs that can be used to toggle the\n * label's floating or required state.\n */\n@Directive({\n  selector: 'label[matFormFieldFloatingLabel]',\n  host: {\n    'class': 'mdc-floating-label mat-mdc-floating-label',\n    '[class.mdc-floating-label--float-above]': 'floating',\n  },\n})\nexport class MatFormFieldFloatingLabel implements OnDestroy {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n\n  /** Whether the label is floating. */\n  @Input()\n  get floating() {\n    return this._floating;\n  }\n  set floating(value: boolean) {\n    this._floating = value;\n    if (this.monitorResize) {\n      this._handleResize();\n    }\n  }\n  private _floating = false;\n\n  /** Whether to monitor for resize events on the floating label. */\n  @Input()\n  get monitorResize() {\n    return this._monitorResize;\n  }\n  set monitorResize(value: boolean) {\n    this._monitorResize = value;\n    if (this._monitorResize) {\n      this._subscribeToResize();\n    } else {\n      this._resizeSubscription.unsubscribe();\n    }\n  }\n  private _monitorResize = false;\n\n  /** The shared ResizeObserver. */\n  private _resizeObserver = inject(SharedResizeObserver);\n\n  /** The Angular zone. */\n  private _ngZone = inject(NgZone);\n\n  /** The parent form-field. */\n  private _parent = inject(FLOATING_LABEL_PARENT);\n\n  /** The current resize event subscription. */\n  private _resizeSubscription = new Subscription();\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngOnDestroy() {\n    this._resizeSubscription.unsubscribe();\n  }\n\n  /** Gets the width of the label. Used for the outline notch. */\n  getWidth(): number {\n    return estimateScrollWidth(this._elementRef.nativeElement);\n  }\n\n  /** Gets the HTML element for the floating label. */\n  get element(): HTMLElement {\n    return this._elementRef.nativeElement;\n  }\n\n  /** Handles resize events from the ResizeObserver. */\n  private _handleResize() {\n    // In the case where the label grows in size, the following sequence of events occurs:\n    // 1. The label grows by 1px triggering the ResizeObserver\n    // 2. The notch is expanded to accommodate the entire label\n    // 3. The label expands to its full width, triggering the ResizeObserver again\n    //\n    // This is expected, but If we allow this to all happen within the same macro task it causes an\n    // error: `ResizeObserver loop limit exceeded`. Therefore we push the notch resize out until\n    // the next macro task.\n    setTimeout(() => this._parent._handleLabelResized());\n  }\n\n  /** Subscribes to resize events. */\n  private _subscribeToResize() {\n    this._resizeSubscription.unsubscribe();\n    this._ngZone.runOutsideAngular(() => {\n      this._resizeSubscription = this._resizeObserver\n        .observe(this._elementRef.nativeElement, {box: 'border-box'})\n        .subscribe(() => this._handleResize());\n    });\n  }\n}\n\n/**\n * Estimates the scroll width of an element.\n * via https://github.com/material-components/material-components-web/blob/c0a11ef0d000a098fd0c372be8f12d6a99302855/packages/mdc-dom/ponyfill.ts\n */\nfunction estimateScrollWidth(element: HTMLElement): number {\n  // Check the offsetParent. If the element inherits display: none from any\n  // parent, the offsetParent property will be null (see\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).\n  // This check ensures we only clone the node when necessary.\n  const htmlEl = element as HTMLElement;\n  if (htmlEl.offsetParent !== null) {\n    return htmlEl.scrollWidth;\n  }\n\n  const clone = htmlEl.cloneNode(true) as HTMLElement;\n  clone.style.setProperty('position', 'absolute');\n  clone.style.setProperty('transform', 'translate(-9999px, -9999px)');\n  document.documentElement.appendChild(clone);\n  const scrollWidth = clone.scrollWidth;\n  clone.remove();\n  return scrollWidth;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, ElementRef, NgZone, OnDestroy, Renderer2, inject} from '@angular/core';\n\n/** Class added when the line ripple is active. */\nconst ACTIVATE_CLASS = 'mdc-line-ripple--active';\n\n/** Class added when the line ripple is being deactivated. */\nconst DEACTIVATING_CLASS = 'mdc-line-ripple--deactivating';\n\n/**\n * Internal directive that creates an instance of the MDC line-ripple component. Using a\n * directive allows us to conditionally render a line-ripple in the template without having\n * to manually create and destroy the `MDCLineRipple` component whenever the condition changes.\n *\n * The directive sets up the styles for the line-ripple and provides an API for activating\n * and deactivating the line-ripple.\n */\n@Directive({\n  selector: 'div[matFormFieldLineRipple]',\n  host: {\n    'class': 'mdc-line-ripple',\n  },\n})\nexport class MatFormFieldLineRipple implements OnDestroy {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _cleanupTransitionEnd: () => void;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const ngZone = inject(NgZone);\n    const renderer = inject(Renderer2);\n\n    ngZone.runOutsideAngular(() => {\n      this._cleanupTransitionEnd = renderer.listen(\n        this._elementRef.nativeElement,\n        'transitionend',\n        this._handleTransitionEnd,\n      );\n    });\n  }\n\n  activate() {\n    const classList = this._elementRef.nativeElement.classList;\n    classList.remove(DEACTIVATING_CLASS);\n    classList.add(ACTIVATE_CLASS);\n  }\n\n  deactivate() {\n    this._elementRef.nativeElement.classList.add(DEACTIVATING_CLASS);\n  }\n\n  private _handleTransitionEnd = (event: TransitionEvent) => {\n    const classList = this._elementRef.nativeElement.classList;\n    const isDeactivating = classList.contains(DEACTIVATING_CLASS);\n\n    if (event.propertyName === 'opacity' && isDeactivating) {\n      classList.remove(ACTIVATE_CLASS, DEACTIVATING_CLASS);\n    }\n  };\n\n  ngOnDestroy() {\n    this._cleanupTransitionEnd();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  Input,\n  NgZone,\n  ViewChild,\n  ViewEncapsulation,\n  inject,\n} from '@angular/core';\n\n/**\n * Internal component that creates an instance of the MDC notched-outline component.\n *\n * The component sets up the HTML structure and styles for the notched-outline. It provides\n * inputs to toggle the notch state and width.\n */\n@Component({\n  selector: 'div[matFormFieldNotchedOutline]',\n  templateUrl: './notched-outline.html',\n  host: {\n    'class': 'mdc-notched-outline',\n    // Besides updating the notch state through the MDC component, we toggle this class through\n    // a host binding in order to ensure that the notched-outline renders correctly on the server.\n    '[class.mdc-notched-outline--notched]': 'open',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class MatFormFieldNotchedOutline implements AfterViewInit {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _ngZone = inject(NgZone);\n\n  /** Whether the notch should be opened. */\n  @Input('matFormFieldNotchedOutlineOpen') open: boolean = false;\n\n  @ViewChild('notch') _notch: ElementRef;\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngAfterViewInit(): void {\n    const label = this._elementRef.nativeElement.querySelector<HTMLElement>('.mdc-floating-label');\n    if (label) {\n      this._elementRef.nativeElement.classList.add('mdc-notched-outline--upgraded');\n\n      if (typeof requestAnimationFrame === 'function') {\n        label.style.transitionDuration = '0s';\n        this._ngZone.runOutsideAngular(() => {\n          requestAnimationFrame(() => (label.style.transitionDuration = ''));\n        });\n      }\n    } else {\n      this._elementRef.nativeElement.classList.add('mdc-notched-outline--no-label');\n    }\n  }\n\n  _setNotchWidth(labelWidth: number) {\n    if (!this.open || !labelWidth) {\n      this._notch.nativeElement.style.width = '';\n    } else {\n      const NOTCH_ELEMENT_PADDING = 8;\n      const NOTCH_ELEMENT_BORDER = 1;\n      this._notch.nativeElement.style.width = `calc(${labelWidth}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + ${\n        NOTCH_ELEMENT_PADDING + NOTCH_ELEMENT_BORDER\n      }px)`;\n    }\n  }\n}\n","<div class=\"mat-mdc-notch-piece mdc-notched-outline__leading\"></div>\n<div class=\"mat-mdc-notch-piece mdc-notched-outline__notch\" #notch>\n  <ng-content></ng-content>\n</div>\n<div class=\"mat-mdc-notch-piece mdc-notched-outline__trailing\"></div>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Observable} from 'rxjs';\nimport {AbstractControlDirective, NgControl} from '@angular/forms';\nimport {Directive} from '@angular/core';\n\n/** An interface which allows a control to work inside of a `MatFormField`. */\n@Directive()\nexport abstract class MatFormFieldControl<T> {\n  /** The value of the control. */\n  value: T | null;\n\n  /**\n   * Stream that emits whenever the state of the control changes such that the parent `MatFormField`\n   * needs to run change detection.\n   */\n  readonly stateChanges: Observable<void>;\n\n  /** The element ID for this control. */\n  readonly id: string;\n\n  /** The placeholder for this control. */\n  readonly placeholder: string;\n\n  /** Gets the AbstractControlDirective for this control. */\n  readonly ngControl: NgControl | AbstractControlDirective | null;\n\n  /** Whether the control is focused. */\n  readonly focused: boolean;\n\n  /** Whether the control is empty. */\n  readonly empty: boolean;\n\n  /** Whether the `MatFormField` label should try to float. */\n  readonly shouldLabelFloat: boolean;\n\n  /** Whether the control is required. */\n  readonly required: boolean;\n\n  /** Whether the control is disabled. */\n  readonly disabled: boolean;\n\n  /** Whether the control is in an error state. */\n  readonly errorState: boolean;\n\n  /**\n   * An optional name for the control type that can be used to distinguish `mat-form-field` elements\n   * based on their control type. The form field will add a class,\n   * `mat-form-field-type-{{controlType}}` to its root element.\n   */\n  readonly controlType?: string;\n\n  /**\n   * Whether the input is currently in an autofilled state. If property is not present on the\n   * control it is assumed to be false.\n   */\n  readonly autofilled?: boolean;\n\n  /**\n   * Value of `aria-describedby` that should be merged with the described-by ids\n   * which are set by the form-field.\n   */\n  readonly userAriaDescribedBy?: string;\n\n  /**\n   * Whether to automatically assign the ID of the form field as the `for` attribute\n   * on the `<label>` inside the form field. Set this to true to prevent the form\n   * field from associating the label with non-native elements.\n   */\n  readonly disableAutomaticLabeling?: boolean;\n\n  /** Sets the list of element IDs that currently describe this control. */\n  abstract setDescribedByIds(ids: string[]): void;\n\n  /** Handles a click on the control's container. */\n  abstract onContainerClick(event: MouseEvent): void;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {Directionality} from '@angular/cdk/bidi';\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {Platform} from '@angular/cdk/platform';\nimport {NgTemplateOutlet} from '@angular/common';\nimport {\n  ANIMATION_MODULE_TYPE,\n  AfterContentChecked,\n  AfterContentInit,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  ElementRef,\n  InjectionToken,\n  Injector,\n  Input,\n  NgZone,\n  OnDestroy,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n  afterRender,\n  computed,\n  contentChild,\n  inject,\n} from '@angular/core';\nimport {AbstractControlDirective, ValidatorFn} from '@angular/forms';\nimport {ThemePalette} from '../core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\nimport {Subject, Subscription, merge} from 'rxjs';\nimport {map, pairwise, takeUntil, filter, startWith} from 'rxjs/operators';\nimport {MAT_ERROR, MatError} from './directives/error';\nimport {\n  FLOATING_LABEL_PARENT,\n  FloatingLabelParent,\n  MatFormFieldFloatingLabel,\n} from './directives/floating-label';\nimport {MatHint} from './directives/hint';\nimport {MatLabel} from './directives/label';\nimport {MatFormFieldLineRipple} from './directives/line-ripple';\nimport {MatFormFieldNotchedOutline} from './directives/notched-outline';\nimport {MAT_PREFIX, MatPrefix} from './directives/prefix';\nimport {MAT_SUFFIX, MatSuffix} from './directives/suffix';\nimport {MatFormFieldControl as _MatFormFieldControl} from './form-field-control';\nimport {\n  getMatFormFieldDuplicatedHintError,\n  getMatFormFieldMissingControlError,\n} from './form-field-errors';\n\n/** Type for the available floatLabel values. */\nexport type FloatLabelType = 'always' | 'auto';\n\n/** Possible appearance styles for the form field. */\nexport type MatFormFieldAppearance = 'fill' | 'outline';\n\n/** Behaviors for how the subscript height is set. */\nexport type SubscriptSizing = 'fixed' | 'dynamic';\n\n/**\n * Represents the default options for the form field that can be configured\n * using the `MAT_FORM_FIELD_DEFAULT_OPTIONS` injection token.\n */\nexport interface MatFormFieldDefaultOptions {\n  /** Default form field appearance style. */\n  appearance?: MatFormFieldAppearance;\n  /**\n   * Default theme color of the form field. This API is supported in M2 themes only, it has no\n   * effect in M3 themes. For color customization in M3, see https://material.angular.io/components/form-field/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  color?: ThemePalette;\n  /** Whether the required marker should be hidden by default. */\n  hideRequiredMarker?: boolean;\n  /**\n   * Whether the label for form fields should by default float `always`,\n   * `never`, or `auto` (only when necessary).\n   */\n  floatLabel?: FloatLabelType;\n  /** Whether the form field should reserve space for one line by default. */\n  subscriptSizing?: SubscriptSizing;\n}\n\n/**\n * Injection token that can be used to inject an instances of `MatFormField`. It serves\n * as alternative token to the actual `MatFormField` class which would cause unnecessary\n * retention of the `MatFormField` class and its component metadata.\n */\nexport const MAT_FORM_FIELD = new InjectionToken<MatFormField>('MatFormField');\n\n/**\n * Injection token that can be used to configure the\n * default options for all form field within an app.\n */\nexport const MAT_FORM_FIELD_DEFAULT_OPTIONS = new InjectionToken<MatFormFieldDefaultOptions>(\n  'MAT_FORM_FIELD_DEFAULT_OPTIONS',\n);\n\n/** Default appearance used by the form field. */\nconst DEFAULT_APPEARANCE: MatFormFieldAppearance = 'fill';\n\n/**\n * Whether the label for form fields should by default float `always`,\n * `never`, or `auto`.\n */\nconst DEFAULT_FLOAT_LABEL: FloatLabelType = 'auto';\n\n/** Default way that the subscript element height is set. */\nconst DEFAULT_SUBSCRIPT_SIZING: SubscriptSizing = 'fixed';\n\n/**\n * Default transform for docked floating labels in a MDC text-field. This value has been\n * extracted from the MDC text-field styles because we programmatically modify the docked\n * label transform, but do not want to accidentally discard the default label transform.\n */\nconst FLOATING_LABEL_DEFAULT_DOCKED_TRANSFORM = `translateY(-50%)`;\n\n/**\n * Despite `MatFormFieldControl` being an abstract class, most of our usages enforce its shape\n * using `implements` instead of `extends`. This appears to be problematic when Closure compiler\n * is configured to use type information to rename properties, because it can't figure out which\n * class properties are coming from. This interface seems to work around the issue while preserving\n * our type safety (alternative being using `any` everywhere).\n * @docs-private\n */\ninterface MatFormFieldControl<T> extends _MatFormFieldControl<T> {}\n\n/** Container for form controls that applies Material Design styling and behavior. */\n@Component({\n  selector: 'mat-form-field',\n  exportAs: 'matFormField',\n  templateUrl: './form-field.html',\n  styleUrl: './form-field.css',\n  host: {\n    'class': 'mat-mdc-form-field',\n    '[class.mat-mdc-form-field-label-always-float]': '_shouldAlwaysFloat()',\n    '[class.mat-mdc-form-field-has-icon-prefix]': '_hasIconPrefix',\n    '[class.mat-mdc-form-field-has-icon-suffix]': '_hasIconSuffix',\n    // Note that these classes reuse the same names as the non-MDC version, because they can be\n    // considered a public API since custom form controls may use them to style themselves.\n    // See https://github.com/angular/components/pull/20502#discussion_r486124901.\n    '[class.mat-form-field-invalid]': '_control.errorState',\n    '[class.mat-form-field-disabled]': '_control.disabled',\n    '[class.mat-form-field-autofilled]': '_control.autofilled',\n    '[class.mat-form-field-appearance-fill]': 'appearance == \"fill\"',\n    '[class.mat-form-field-appearance-outline]': 'appearance == \"outline\"',\n    '[class.mat-form-field-hide-placeholder]': '_hasFloatingLabel() && !_shouldLabelFloat()',\n    '[class.mat-focused]': '_control.focused',\n    '[class.mat-primary]': 'color !== \"accent\" && color !== \"warn\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    '[class.ng-untouched]': '_shouldForward(\"untouched\")',\n    '[class.ng-touched]': '_shouldForward(\"touched\")',\n    '[class.ng-pristine]': '_shouldForward(\"pristine\")',\n    '[class.ng-dirty]': '_shouldForward(\"dirty\")',\n    '[class.ng-valid]': '_shouldForward(\"valid\")',\n    '[class.ng-invalid]': '_shouldForward(\"invalid\")',\n    '[class.ng-pending]': '_shouldForward(\"pending\")',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [\n    {provide: MAT_FORM_FIELD, useExisting: MatFormField},\n    {provide: FLOATING_LABEL_PARENT, useExisting: MatFormField},\n  ],\n  imports: [\n    MatFormFieldFloatingLabel,\n    MatFormFieldNotchedOutline,\n    NgTemplateOutlet,\n    MatFormFieldLineRipple,\n    MatHint,\n  ],\n})\nexport class MatFormField\n  implements FloatingLabelParent, AfterContentInit, AfterContentChecked, AfterViewInit, OnDestroy\n{\n  _elementRef = inject(ElementRef);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _dir = inject(Directionality);\n  private _platform = inject(Platform);\n  private _idGenerator = inject(_IdGenerator);\n  private _ngZone = inject(NgZone);\n  private _injector = inject(Injector);\n  private _defaults = inject<MatFormFieldDefaultOptions>(MAT_FORM_FIELD_DEFAULT_OPTIONS, {\n    optional: true,\n  });\n\n  @ViewChild('textField') _textField: ElementRef<HTMLElement>;\n  @ViewChild('iconPrefixContainer') _iconPrefixContainer: ElementRef<HTMLElement>;\n  @ViewChild('textPrefixContainer') _textPrefixContainer: ElementRef<HTMLElement>;\n  @ViewChild('iconSuffixContainer') _iconSuffixContainer: ElementRef<HTMLElement>;\n  @ViewChild('textSuffixContainer') _textSuffixContainer: ElementRef<HTMLElement>;\n  @ViewChild(MatFormFieldFloatingLabel) _floatingLabel: MatFormFieldFloatingLabel | undefined;\n  @ViewChild(MatFormFieldNotchedOutline) _notchedOutline: MatFormFieldNotchedOutline | undefined;\n  @ViewChild(MatFormFieldLineRipple) _lineRipple: MatFormFieldLineRipple | undefined;\n\n  @ContentChild(_MatFormFieldControl) _formFieldControl: MatFormFieldControl<any>;\n  @ContentChildren(MAT_PREFIX, {descendants: true}) _prefixChildren: QueryList<MatPrefix>;\n  @ContentChildren(MAT_SUFFIX, {descendants: true}) _suffixChildren: QueryList<MatSuffix>;\n  @ContentChildren(MAT_ERROR, {descendants: true}) _errorChildren: QueryList<MatError>;\n  @ContentChildren(MatHint, {descendants: true}) _hintChildren: QueryList<MatHint>;\n\n  private readonly _labelChild = contentChild(MatLabel);\n\n  /** Whether the required marker should be hidden. */\n  @Input()\n  get hideRequiredMarker(): boolean {\n    return this._hideRequiredMarker;\n  }\n  set hideRequiredMarker(value: BooleanInput) {\n    this._hideRequiredMarker = coerceBooleanProperty(value);\n  }\n  private _hideRequiredMarker = false;\n\n  /**\n   * Theme color of the form field. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/form-field/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  @Input() color: ThemePalette = 'primary';\n\n  /** Whether the label should always float or float as the user types. */\n  @Input()\n  get floatLabel(): FloatLabelType {\n    return this._floatLabel || this._defaults?.floatLabel || DEFAULT_FLOAT_LABEL;\n  }\n  set floatLabel(value: FloatLabelType) {\n    if (value !== this._floatLabel) {\n      this._floatLabel = value;\n      // For backwards compatibility. Custom form field controls or directives might set\n      // the \"floatLabel\" input and expect the form field view to be updated automatically.\n      // e.g. autocomplete trigger. Ideally we'd get rid of this and the consumers would just\n      // emit the \"stateChanges\" observable. TODO(devversion): consider removing.\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _floatLabel: FloatLabelType;\n\n  /** The form field appearance style. */\n  @Input()\n  get appearance(): MatFormFieldAppearance {\n    return this._appearance;\n  }\n  set appearance(value: MatFormFieldAppearance) {\n    const oldValue = this._appearance;\n    const newAppearance = value || this._defaults?.appearance || DEFAULT_APPEARANCE;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (newAppearance !== 'fill' && newAppearance !== 'outline') {\n        throw new Error(\n          `MatFormField: Invalid appearance \"${newAppearance}\", valid values are \"fill\" or \"outline\".`,\n        );\n      }\n    }\n    this._appearance = newAppearance;\n    if (this._appearance === 'outline' && this._appearance !== oldValue) {\n      // If the appearance has been switched to `outline`, the label offset needs to be updated.\n      // The update can happen once the view has been re-checked, but not immediately because\n      // the view has not been updated and the notched-outline floating label is not present.\n      this._needsOutlineLabelOffsetUpdate = true;\n    }\n  }\n  private _appearance: MatFormFieldAppearance = DEFAULT_APPEARANCE;\n\n  /**\n   * Whether the form field should reserve space for one line of hint/error text (default)\n   * or to have the spacing grow from 0px as needed based on the size of the hint/error content.\n   * Note that when using dynamic sizing, layout shifts will occur when hint/error text changes.\n   */\n  @Input()\n  get subscriptSizing(): SubscriptSizing {\n    return this._subscriptSizing || this._defaults?.subscriptSizing || DEFAULT_SUBSCRIPT_SIZING;\n  }\n  set subscriptSizing(value: SubscriptSizing) {\n    this._subscriptSizing = value || this._defaults?.subscriptSizing || DEFAULT_SUBSCRIPT_SIZING;\n  }\n  private _subscriptSizing: SubscriptSizing | null = null;\n\n  /** Text for the form field hint. */\n  @Input()\n  get hintLabel(): string {\n    return this._hintLabel;\n  }\n  set hintLabel(value: string) {\n    this._hintLabel = value;\n    this._processHints();\n  }\n  private _hintLabel = '';\n\n  _hasIconPrefix = false;\n  _hasTextPrefix = false;\n  _hasIconSuffix = false;\n  _hasTextSuffix = false;\n\n  // Unique id for the internal form field label.\n  readonly _labelId = this._idGenerator.getId('mat-mdc-form-field-label-');\n\n  // Unique id for the hint label.\n  readonly _hintLabelId = this._idGenerator.getId('mat-mdc-hint-');\n\n  /** Gets the current form field control */\n  get _control(): MatFormFieldControl<any> {\n    return this._explicitFormFieldControl || this._formFieldControl;\n  }\n  set _control(value) {\n    this._explicitFormFieldControl = value;\n  }\n\n  private _destroyed = new Subject<void>();\n  private _isFocused: boolean | null = null;\n  private _explicitFormFieldControl: MatFormFieldControl<any>;\n  private _needsOutlineLabelOffsetUpdate = false;\n  private _previousControl: MatFormFieldControl<unknown> | null = null;\n  private _previousControlValidatorFn: ValidatorFn | null = null;\n  private _stateChanges: Subscription | undefined;\n  private _valueChanges: Subscription | undefined;\n  private _describedByChanges: Subscription | undefined;\n  protected readonly _animationsDisabled: boolean;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const defaults = this._defaults;\n\n    if (defaults) {\n      if (defaults.appearance) {\n        this.appearance = defaults.appearance;\n      }\n      this._hideRequiredMarker = Boolean(defaults?.hideRequiredMarker);\n      if (defaults.color) {\n        this.color = defaults.color;\n      }\n    }\n\n    this._animationsDisabled = inject(ANIMATION_MODULE_TYPE, {optional: true}) === 'NoopAnimations';\n  }\n\n  ngAfterViewInit() {\n    // Initial focus state sync. This happens rarely, but we want to account for\n    // it in case the form field control has \"focused\" set to true on init.\n    this._updateFocusState();\n\n    if (!this._animationsDisabled) {\n      this._ngZone.runOutsideAngular(() => {\n        // Enable animations after a certain amount of time so that they don't run on init.\n        setTimeout(() => {\n          this._elementRef.nativeElement.classList.add('mat-form-field-animations-enabled');\n        }, 300);\n      });\n    }\n\n    // Because the above changes a value used in the template after it was checked, we need\n    // to trigger CD or the change might not be reflected if there is no other CD scheduled.\n    this._changeDetectorRef.detectChanges();\n  }\n\n  ngAfterContentInit() {\n    this._assertFormFieldControl();\n    this._initializeSubscript();\n    this._initializePrefixAndSuffix();\n    this._initializeOutlineLabelOffsetSubscriptions();\n  }\n\n  ngAfterContentChecked() {\n    this._assertFormFieldControl();\n\n    // if form field was being used with an input in first place and then replaced by other\n    // component such as select.\n    if (this._control !== this._previousControl) {\n      this._initializeControl(this._previousControl);\n\n      // keep a reference for last validator we had.\n      if (this._control.ngControl && this._control.ngControl.control) {\n        this._previousControlValidatorFn = this._control.ngControl.control.validator;\n      }\n\n      this._previousControl = this._control;\n    }\n\n    // make sure the the control has been initialized.\n    if (this._control.ngControl && this._control.ngControl.control) {\n      // get the validators for current control.\n      const validatorFn = this._control.ngControl.control.validator;\n\n      // if our current validatorFn isn't equal to it might be we are CD behind, marking the\n      // component will allow us to catch up.\n      if (validatorFn !== this._previousControlValidatorFn) {\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._stateChanges?.unsubscribe();\n    this._valueChanges?.unsubscribe();\n    this._describedByChanges?.unsubscribe();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /**\n   * Gets the id of the label element. If no label is present, returns `null`.\n   */\n  getLabelId = computed(() => (this._hasFloatingLabel() ? this._labelId : null));\n\n  /**\n   * Gets an ElementRef for the element that a overlay attached to the form field\n   * should be positioned relative to.\n   */\n  getConnectedOverlayOrigin(): ElementRef {\n    return this._textField || this._elementRef;\n  }\n\n  /** Animates the placeholder up and locks it in position. */\n  _animateAndLockLabel(): void {\n    // This is for backwards compatibility only. Consumers of the form field might use\n    // this method. e.g. the autocomplete trigger. This method has been added to the non-MDC\n    // form field because setting \"floatLabel\" to \"always\" caused the label to float without\n    // animation. This is different in MDC where the label always animates, so this method\n    // is no longer necessary. There doesn't seem any benefit in adding logic to allow changing\n    // the floating label state without animations. The non-MDC implementation was inconsistent\n    // because it always animates if \"floatLabel\" is set away from \"always\".\n    // TODO(devversion): consider removing this method when releasing the MDC form field.\n    if (this._hasFloatingLabel()) {\n      this.floatLabel = 'always';\n    }\n  }\n\n  /** Initializes the registered form field control. */\n  private _initializeControl(previousControl: MatFormFieldControl<unknown> | null) {\n    const control = this._control;\n    const classPrefix = 'mat-mdc-form-field-type-';\n\n    if (previousControl) {\n      this._elementRef.nativeElement.classList.remove(classPrefix + previousControl.controlType);\n    }\n\n    if (control.controlType) {\n      this._elementRef.nativeElement.classList.add(classPrefix + control.controlType);\n    }\n\n    // Subscribe to changes in the child control state in order to update the form field UI.\n    this._stateChanges?.unsubscribe();\n    this._stateChanges = control.stateChanges.subscribe(() => {\n      this._updateFocusState();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Updating the `aria-describedby` touches the DOM. Only do it if it actually needs to change.\n    this._describedByChanges?.unsubscribe();\n    this._describedByChanges = control.stateChanges\n      .pipe(\n        startWith([undefined, undefined] as const),\n        map(() => [control.errorState, control.userAriaDescribedBy] as const),\n        pairwise(),\n        filter(([[prevErrorState, prevDescribedBy], [currentErrorState, currentDescribedBy]]) => {\n          return prevErrorState !== currentErrorState || prevDescribedBy !== currentDescribedBy;\n        }),\n      )\n      .subscribe(() => this._syncDescribedByIds());\n\n    this._valueChanges?.unsubscribe();\n\n    // Run change detection if the value changes.\n    if (control.ngControl && control.ngControl.valueChanges) {\n      this._valueChanges = control.ngControl.valueChanges\n        .pipe(takeUntil(this._destroyed))\n        .subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n  }\n\n  private _checkPrefixAndSuffixTypes() {\n    this._hasIconPrefix = !!this._prefixChildren.find(p => !p._isText);\n    this._hasTextPrefix = !!this._prefixChildren.find(p => p._isText);\n    this._hasIconSuffix = !!this._suffixChildren.find(s => !s._isText);\n    this._hasTextSuffix = !!this._suffixChildren.find(s => s._isText);\n  }\n\n  /** Initializes the prefix and suffix containers. */\n  private _initializePrefixAndSuffix() {\n    this._checkPrefixAndSuffixTypes();\n    // Mark the form field as dirty whenever the prefix or suffix children change. This\n    // is necessary because we conditionally display the prefix/suffix containers based\n    // on whether there is projected content.\n    merge(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => {\n      this._checkPrefixAndSuffixTypes();\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n\n  /**\n   * Initializes the subscript by validating hints and synchronizing \"aria-describedby\" ids\n   * with the custom form field control. Also subscribes to hint and error changes in order\n   * to be able to validate and synchronize ids on change.\n   */\n  private _initializeSubscript() {\n    // Re-validate when the number of hints changes.\n    this._hintChildren.changes.subscribe(() => {\n      this._processHints();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Update the aria-described by when the number of errors changes.\n    this._errorChildren.changes.subscribe(() => {\n      this._syncDescribedByIds();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Initial mat-hint validation and subscript describedByIds sync.\n    this._validateHints();\n    this._syncDescribedByIds();\n  }\n\n  /** Throws an error if the form field's control is missing. */\n  private _assertFormFieldControl() {\n    if (!this._control && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatFormFieldMissingControlError();\n    }\n  }\n\n  private _updateFocusState() {\n    // Usually the MDC foundation would call \"activateFocus\" and \"deactivateFocus\" whenever\n    // certain DOM events are emitted. This is not possible in our implementation of the\n    // form field because we support abstract form field controls which are not necessarily\n    // of type input, nor do we have a reference to a native form field control element. Instead\n    // we handle the focus by checking if the abstract form field control focused state changes.\n    if (this._control.focused && !this._isFocused) {\n      this._isFocused = true;\n      this._lineRipple?.activate();\n    } else if (!this._control.focused && (this._isFocused || this._isFocused === null)) {\n      this._isFocused = false;\n      this._lineRipple?.deactivate();\n    }\n\n    this._textField?.nativeElement.classList.toggle(\n      'mdc-text-field--focused',\n      this._control.focused,\n    );\n  }\n\n  /**\n   * The floating label in the docked state needs to account for prefixes. The horizontal offset\n   * is calculated whenever the appearance changes to `outline`, the prefixes change, or when the\n   * form field is added to the DOM. This method sets up all subscriptions which are needed to\n   * trigger the label offset update.\n   */\n  private _initializeOutlineLabelOffsetSubscriptions() {\n    // Whenever the prefix changes, schedule an update of the label offset.\n    // TODO(mmalerba): Use ResizeObserver to better support dynamically changing prefix content.\n    this._prefixChildren.changes.subscribe(() => (this._needsOutlineLabelOffsetUpdate = true));\n\n    // TODO(mmalerba): Split this into separate `afterRender` calls using the `EarlyRead` and\n    //  `Write` phases.\n    afterRender(\n      () => {\n        if (this._needsOutlineLabelOffsetUpdate) {\n          this._needsOutlineLabelOffsetUpdate = false;\n          this._updateOutlineLabelOffset();\n        }\n      },\n      {\n        injector: this._injector,\n      },\n    );\n\n    this._dir.change\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => (this._needsOutlineLabelOffsetUpdate = true));\n  }\n\n  /** Whether the floating label should always float or not. */\n  _shouldAlwaysFloat() {\n    return this.floatLabel === 'always';\n  }\n\n  _hasOutline() {\n    return this.appearance === 'outline';\n  }\n\n  /**\n   * Whether the label should display in the infix. Labels in the outline appearance are\n   * displayed as part of the notched-outline and are horizontally offset to account for\n   * form field prefix content. This won't work in server side rendering since we cannot\n   * measure the width of the prefix container. To make the docked label appear as if the\n   * right offset has been calculated, we forcibly render the label inside the infix. Since\n   * the label is part of the infix, the label cannot overflow the prefix content.\n   */\n  _forceDisplayInfixLabel() {\n    return !this._platform.isBrowser && this._prefixChildren.length && !this._shouldLabelFloat();\n  }\n\n  _hasFloatingLabel = computed(() => !!this._labelChild());\n\n  _shouldLabelFloat(): boolean {\n    if (!this._hasFloatingLabel()) {\n      return false;\n    }\n    return this._control.shouldLabelFloat || this._shouldAlwaysFloat();\n  }\n\n  /**\n   * Determines whether a class from the AbstractControlDirective\n   * should be forwarded to the host element.\n   */\n  _shouldForward(prop: keyof AbstractControlDirective): boolean {\n    const control = this._control ? this._control.ngControl : null;\n    return control && control[prop];\n  }\n\n  /** Determines whether to display hints or errors. */\n  _getDisplayedMessages(): 'error' | 'hint' {\n    return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState\n      ? 'error'\n      : 'hint';\n  }\n\n  /** Handle label resize events. */\n  _handleLabelResized() {\n    this._refreshOutlineNotchWidth();\n  }\n\n  /** Refreshes the width of the outline-notch, if present. */\n  _refreshOutlineNotchWidth() {\n    if (!this._hasOutline() || !this._floatingLabel || !this._shouldLabelFloat()) {\n      this._notchedOutline?._setNotchWidth(0);\n    } else {\n      this._notchedOutline?._setNotchWidth(this._floatingLabel.getWidth());\n    }\n  }\n\n  /** Does any extra processing that is required when handling the hints. */\n  private _processHints() {\n    this._validateHints();\n    this._syncDescribedByIds();\n  }\n\n  /**\n   * Ensure that there is a maximum of one of each \"mat-hint\" alignment specified. The hint\n   * label specified set through the input is being considered as \"start\" aligned.\n   *\n   * This method is a noop if Angular runs in production mode.\n   */\n  private _validateHints() {\n    if (this._hintChildren && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      let startHint: MatHint;\n      let endHint: MatHint;\n      this._hintChildren.forEach((hint: MatHint) => {\n        if (hint.align === 'start') {\n          if (startHint || this.hintLabel) {\n            throw getMatFormFieldDuplicatedHintError('start');\n          }\n          startHint = hint;\n        } else if (hint.align === 'end') {\n          if (endHint) {\n            throw getMatFormFieldDuplicatedHintError('end');\n          }\n          endHint = hint;\n        }\n      });\n    }\n  }\n\n  /**\n   * Sets the list of element IDs that describe the child control. This allows the control to update\n   * its `aria-describedby` attribute accordingly.\n   */\n  private _syncDescribedByIds() {\n    if (this._control) {\n      let ids: string[] = [];\n\n      // TODO(wagnermaciel): Remove the type check when we find the root cause of this bug.\n      if (\n        this._control.userAriaDescribedBy &&\n        typeof this._control.userAriaDescribedBy === 'string'\n      ) {\n        ids.push(...this._control.userAriaDescribedBy.split(' '));\n      }\n\n      if (this._getDisplayedMessages() === 'hint') {\n        const startHint = this._hintChildren\n          ? this._hintChildren.find(hint => hint.align === 'start')\n          : null;\n        const endHint = this._hintChildren\n          ? this._hintChildren.find(hint => hint.align === 'end')\n          : null;\n\n        if (startHint) {\n          ids.push(startHint.id);\n        } else if (this._hintLabel) {\n          ids.push(this._hintLabelId);\n        }\n\n        if (endHint) {\n          ids.push(endHint.id);\n        }\n      } else if (this._errorChildren) {\n        ids.push(...this._errorChildren.map(error => error.id));\n      }\n\n      this._control.setDescribedByIds(ids);\n    }\n  }\n\n  /**\n   * Updates the horizontal offset of the label in the outline appearance. In the outline\n   * appearance, the notched-outline and label are not relative to the infix container because\n   * the outline intends to surround prefixes, suffixes and the infix. This means that the\n   * floating label by default overlaps prefixes in the docked state. To avoid this, we need to\n   * horizontally offset the label by the width of the prefix container. The MDC text-field does\n   * not need to do this because they use a fixed width for prefixes. Hence, they can simply\n   * incorporate the horizontal offset into their default text-field styles.\n   */\n  private _updateOutlineLabelOffset() {\n    if (!this._hasOutline() || !this._floatingLabel) {\n      return;\n    }\n    const floatingLabel = this._floatingLabel.element;\n    // If no prefix is displayed, reset the outline label offset from potential\n    // previous label offset updates.\n    if (!(this._iconPrefixContainer || this._textPrefixContainer)) {\n      floatingLabel.style.transform = '';\n      return;\n    }\n    // If the form field is not attached to the DOM yet (e.g. in a tab), we defer\n    // the label offset update until the zone stabilizes.\n    if (!this._isAttachedToDom()) {\n      this._needsOutlineLabelOffsetUpdate = true;\n      return;\n    }\n    const iconPrefixContainer = this._iconPrefixContainer?.nativeElement;\n    const textPrefixContainer = this._textPrefixContainer?.nativeElement;\n    const iconSuffixContainer = this._iconSuffixContainer?.nativeElement;\n    const textSuffixContainer = this._textSuffixContainer?.nativeElement;\n    const iconPrefixContainerWidth = iconPrefixContainer?.getBoundingClientRect().width ?? 0;\n    const textPrefixContainerWidth = textPrefixContainer?.getBoundingClientRect().width ?? 0;\n    const iconSuffixContainerWidth = iconSuffixContainer?.getBoundingClientRect().width ?? 0;\n    const textSuffixContainerWidth = textSuffixContainer?.getBoundingClientRect().width ?? 0;\n    // If the directionality is RTL, the x-axis transform needs to be inverted. This\n    // is because `transformX` does not change based on the page directionality.\n    const negate = this._dir.value === 'rtl' ? '-1' : '1';\n    const prefixWidth = `${iconPrefixContainerWidth + textPrefixContainerWidth}px`;\n    const labelOffset = `var(--mat-mdc-form-field-label-offset-x, 0px)`;\n    const labelHorizontalOffset = `calc(${negate} * (${prefixWidth} + ${labelOffset}))`;\n\n    // Update the translateX of the floating label to account for the prefix container,\n    // but allow the CSS to override this setting via a CSS variable when the label is\n    // floating.\n    floatingLabel.style.transform = `var(\n        --mat-mdc-form-field-label-transform,\n        ${FLOATING_LABEL_DEFAULT_DOCKED_TRANSFORM} translateX(${labelHorizontalOffset})\n    )`;\n\n    // Prevent the label from overlapping the suffix when in resting position.\n    const prefixAndSuffixWidth =\n      iconPrefixContainerWidth +\n      textPrefixContainerWidth +\n      iconSuffixContainerWidth +\n      textSuffixContainerWidth;\n    this._elementRef.nativeElement.style.setProperty(\n      '--mat-form-field-notch-max-width',\n      `calc(100% - ${prefixAndSuffixWidth}px)`,\n    );\n  }\n\n  /** Checks whether the form field is attached to the DOM. */\n  private _isAttachedToDom(): boolean {\n    const element: HTMLElement = this._elementRef.nativeElement;\n    if (element.getRootNode) {\n      const rootNode = element.getRootNode();\n      // If the element is inside the DOM the root node will be either the document\n      // or the closest shadow root, otherwise it'll be the element itself.\n      return rootNode && rootNode !== element;\n    }\n    // Otherwise fall back to checking if it's in the document. This doesn't account for\n    // shadow DOM, however browser that support shadow DOM should support `getRootNode` as well.\n    return document.documentElement!.contains(element);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {FormGroupDirective, NgForm, AbstractControl} from '@angular/forms';\n\n/** Error state matcher that matches when a control is invalid and dirty. */\n@Injectable()\nexport class ShowOnDirtyErrorStateMatcher implements ErrorStateMatcher {\n  isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid && (control.dirty || (form && form.submitted)));\n  }\n}\n\n/** Provider that defines how form controls behave with regards to displaying error messages. */\n@Injectable({providedIn: 'root'})\nexport class ErrorStateMatcher {\n  isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid && (control.touched || (form && form.submitted)));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AbstractControl, FormGroupDirective, NgControl, NgForm} from '@angular/forms';\nimport {Subject} from 'rxjs';\nimport {ErrorStateMatcher as _ErrorStateMatcher} from '../error/error-options';\n\n// Declare ErrorStateMatcher as an interface to have compatibility with Closure Compiler.\ninterface ErrorStateMatcher extends _ErrorStateMatcher {}\n\n/**\n * Class that tracks the error state of a component.\n * @docs-private\n */\nexport class _ErrorStateTracker {\n  /** Whether the tracker is currently in an error state. */\n  errorState = false;\n\n  /** User-defined matcher for the error state. */\n  matcher: ErrorStateMatcher;\n\n  constructor(\n    private _defaultMatcher: ErrorStateMatcher | null,\n    public ngControl: NgControl | null,\n    private _parentFormGroup: FormGroupDirective | null,\n    private _parentForm: NgForm | null,\n    private _stateChanges: Subject<void>,\n  ) {}\n\n  /** Updates the error state based on the provided error state matcher. */\n  updateErrorState() {\n    const oldState = this.errorState;\n    const parent = this._parentFormGroup || this._parentForm;\n    const matcher = this.matcher || this._defaultMatcher;\n    const control = this.ngControl ? (this.ngControl.control as AbstractControl) : null;\n    const newState = matcher?.isErrorState(control, parent) ?? false;\n\n    if (newState !== oldState) {\n      this.errorState = newState;\n      this._stateChanges.next();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ObserversModule} from '@angular/cdk/observers';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '../core';\nimport {MatError} from './directives/error';\nimport {MatHint} from './directives/hint';\nimport {MatLabel} from './directives/label';\nimport {MatPrefix} from './directives/prefix';\nimport {MatSuffix} from './directives/suffix';\nimport {MatFormField} from './form-field';\n\n@NgModule({\n  imports: [\n    MatCommonModule,\n    ObserversModule,\n    MatFormField,\n    MatLabel,\n    MatError,\n    MatHint,\n    MatPrefix,\n    MatSuffix,\n  ],\n  exports: [MatFormField, MatLabel, MatHint, MatError, MatPrefix, MatSuffix, MatCommonModule],\n})\nexport class MatFormFieldModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  AfterViewInit,\n  booleanAttribute,\n  Directive,\n  DoCheck,\n  effect,\n  ElementRef,\n  inject,\n  InjectionToken,\n  Input,\n  isSignal,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Renderer2,\n  WritableSignal,\n} from '@angular/core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\nimport {FormGroupDirective, NgControl, NgForm, Validators} from '@angular/forms';\nimport {ErrorStateMatcher, _ErrorStateTracker} from '../core';\nimport {MatFormFieldControl, MatFormField, MAT_FORM_FIELD} from '../form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit',\n];\n\n/** Object that can be used to configure the default options for the input. */\nexport interface MatInputConfig {\n  /** Whether disabled inputs should be interactive. */\n  disabledInteractive?: boolean;\n}\n\n/** Injection token that can be used to provide the default options for the input. */\nexport const MAT_INPUT_CONFIG = new InjectionToken<MatInputConfig>('MAT_INPUT_CONFIG');\n\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    'class': 'mat-mdc-input-element',\n    // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n    // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n    // this MDC equivalent input.\n    '[class.mat-input-server]': '_isServer',\n    '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n    '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n    '[class.mat-mdc-input-disabled-interactive]': 'disabledInteractive',\n    '[class.mdc-text-field__input]': '_isInFormField',\n    '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[id]': 'id',\n    '[disabled]': 'disabled && !disabledInteractive',\n    '[required]': 'required',\n    '[attr.name]': 'name || null',\n    '[attr.readonly]': '_getReadonlyAttribute()',\n    '[attr.aria-disabled]': 'disabled && disabledInteractive ? \"true\" : null',\n    // Only mark the input as invalid for assistive technology if it has a value since the\n    // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n    '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n    '[attr.aria-required]': 'required',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    '(focus)': '_focusChanged(true)',\n    '(blur)': '_focusChanged(false)',\n    '(input)': '_onInput()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput\n  implements MatFormFieldControl<any>, OnChanges, OnDestroy, AfterViewInit, DoCheck\n{\n  protected _elementRef =\n    inject<ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>>(ElementRef);\n  protected _platform = inject(Platform);\n  ngControl = inject(NgControl, {optional: true, self: true})!;\n  private _autofillMonitor = inject(AutofillMonitor);\n  private _ngZone = inject(NgZone);\n  protected _formField? = inject<MatFormField>(MAT_FORM_FIELD, {optional: true});\n  private _renderer = inject(Renderer2);\n\n  protected _uid = inject(_IdGenerator).getId('mat-input-');\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  private _signalBasedValueAccessor?: {value: WritableSignal<any>};\n  private _previousPlaceholder: string | null;\n  private _errorStateTracker: _ErrorStateTracker;\n  private _config = inject(MAT_INPUT_CONFIG, {optional: true});\n  private _cleanupIosKeyup: (() => void) | undefined;\n  private _cleanupWebkitWheel: (() => void) | undefined;\n\n  /** `aria-describedby` IDs assigned by the form field. */\n  private _formFieldDescribedBy: string[] | undefined;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /** Whether the input is inside of a form field. */\n  readonly _isInFormField: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n  }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Name of the input.\n   * @docs-private\n   */\n  @Input() name: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  protected _required: boolean | undefined;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string {\n    return this._type;\n  }\n  set type(value: string) {\n    const prevType = this._type;\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n\n    if (this._type !== prevType) {\n      this._ensureWheelDefaultBehavior();\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input()\n  get errorStateMatcher() {\n    return this._errorStateTracker.matcher;\n  }\n  set errorStateMatcher(value: ErrorStateMatcher) {\n    this._errorStateTracker.matcher = value;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string {\n    return this._signalBasedValueAccessor\n      ? this._signalBasedValueAccessor.value()\n      : this._inputValueAccessor.value;\n  }\n  set value(value: any) {\n    if (value !== this.value) {\n      if (this._signalBasedValueAccessor) {\n        this._signalBasedValueAccessor.value.set(value);\n      } else {\n        this._inputValueAccessor.value = value;\n      }\n\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean {\n    return this._readonly;\n  }\n  set readonly(value: BooleanInput) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  private _readonly = false;\n\n  /** Whether the input should remain interactive when it is disabled. */\n  @Input({transform: booleanAttribute})\n  disabledInteractive: boolean;\n\n  /** Whether the input is in an error state. */\n  get errorState() {\n    return this._errorStateTracker.errorState;\n  }\n  set errorState(value: boolean) {\n    this._errorStateTracker.errorState = value;\n  }\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week',\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const parentForm = inject(NgForm, {optional: true});\n    const parentFormGroup = inject(FormGroupDirective, {optional: true});\n    const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n    const accessor = inject(MAT_INPUT_VALUE_ACCESSOR, {optional: true, self: true});\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    if (accessor) {\n      if (isSignal(accessor.value)) {\n        this._signalBasedValueAccessor = accessor;\n      } else {\n        this._inputValueAccessor = accessor;\n      }\n    } else {\n      // If no input value accessor was explicitly specified, use the element as the input value\n      // accessor.\n      this._inputValueAccessor = element;\n    }\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (this._platform.IOS) {\n      this._ngZone.runOutsideAngular(() => {\n        this._cleanupIosKeyup = this._renderer.listen(element, 'keyup', this._iOSKeyupListener);\n      });\n    }\n\n    this._errorStateTracker = new _ErrorStateTracker(\n      defaultErrorStateMatcher,\n      this.ngControl,\n      parentFormGroup,\n      parentForm,\n      this.stateChanges,\n    );\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n    this._isInFormField = !!this._formField;\n    this.disabledInteractive = this._config?.disabledInteractive || false;\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple\n        ? 'mat-native-select-multiple'\n        : 'mat-native-select';\n    }\n\n    if (this._signalBasedValueAccessor) {\n      effect(() => {\n        // Read the value so the effect can register the dependency.\n        this._signalBasedValueAccessor!.value();\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n\n    this._cleanupIosKeyup?.();\n    this._cleanupWebkitWheel?.();\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n\n      // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n      // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n      // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n      // disabled.\n      if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n        this.disabled = this.ngControl.disabled;\n        this.stateChanges.next();\n      }\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Refreshes the error state of the input. */\n  updateErrorState() {\n    this._errorStateTracker.updateErrorState();\n  }\n\n  /** Callback for the cases where the focused state of the input changes. */\n  _focusChanged(isFocused: boolean) {\n    if (isFocused === this.focused) {\n      return;\n    }\n\n    if (!this._isNativeSelect && isFocused && this.disabled && this.disabledInteractive) {\n      const element = this._elementRef.nativeElement as HTMLInputElement;\n\n      // Focusing an input that has text will cause all the text to be selected. Clear it since\n      // the user won't be able to change it. This is based on the internal implementation.\n      if (element.type === 'number') {\n        // setSelectionRange doesn't work on number inputs so it needs to be set briefly to text.\n        element.type = 'text';\n        element.setSelectionRange(0, 0);\n        element.type = 'number';\n      } else {\n        element.setSelectionRange(0, 0);\n      }\n    }\n\n    this.focused = isFocused;\n    this.stateChanges.next();\n  }\n\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  private _dirtyCheckPlaceholder() {\n    const placeholder = this._getPlaceholder();\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder\n        ? element.setAttribute('placeholder', placeholder)\n        : element.removeAttribute('placeholder');\n    }\n  }\n\n  /** Gets the current placeholder of the form field. */\n  protected _getPlaceholder(): string | null {\n    return this.placeholder || null;\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (\n      MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return (\n      !this._isNeverEmpty() &&\n      !this._elementRef.nativeElement.value &&\n      !this._isBadInput() &&\n      !this.autofilled\n    );\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return (\n        this.focused ||\n        selectElement.multiple ||\n        !this.empty ||\n        !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label)\n      );\n    } else {\n      return (this.focused && !this.disabled) || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    const element = this._elementRef.nativeElement;\n    const existingDescribedBy = element.getAttribute('aria-describedby');\n    let toAssign: string[];\n\n    // In some cases there might be some `aria-describedby` IDs that were assigned directly,\n    // like by the `AriaDescriber` (see #30011). Attempt to preserve them by taking the previous\n    // attribute value and filtering out the IDs that came from the previous `setDescribedByIds`\n    // call. Note the `|| ids` here allows us to avoid duplicating IDs on the first render.\n    if (existingDescribedBy) {\n      const exclude = this._formFieldDescribedBy || ids;\n      toAssign = ids.concat(\n        existingDescribedBy.split(' ').filter(id => id && !exclude.includes(id)),\n      );\n    } else {\n      toAssign = ids;\n    }\n\n    this._formFieldDescribedBy = ids;\n\n    if (toAssign.length) {\n      element.setAttribute('aria-describedby', toAssign.join(' '));\n    } else {\n      element.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  /** Whether the form control is a native select that is displayed inline. */\n  _isInlineSelect(): boolean {\n    const element = this._elementRef.nativeElement as HTMLSelectElement;\n    return this._isNativeSelect && (element.multiple || element.size > 1);\n  }\n\n  private _iOSKeyupListener = (event: Event): void => {\n    const el = event.target as HTMLInputElement;\n\n    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n    // indicate different things. If the value is 0, it means that the caret is at the start\n    // of the input, whereas a value of `null` means that the input doesn't support\n    // manipulating the selection range. Inputs that don't support setting the selection range\n    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n      // Note: Just setting `0, 0` doesn't fix the issue. Setting\n      // `1, 1` fixes it for the first time that you type text and\n      // then hold delete. Toggling to `1, 1` and then back to\n      // `0, 0` seems to completely fix it.\n      el.setSelectionRange(1, 1);\n      el.setSelectionRange(0, 0);\n    }\n  };\n\n  private _webkitBlinkWheelListener = (): void => {\n    // This is a noop function and is used to enable mouse wheel input\n    // on number inputs\n    // on blink and webkit browsers.\n  };\n\n  /**\n   * In blink and webkit browsers a focused number input does not increment or decrement its value\n   * on mouse wheel interaction unless a wheel event listener is attached to it or one of its\n   * ancestors or a passive wheel listener is attached somewhere in the DOM. For example: Hitting\n   * a tooltip once enables the mouse wheel input for all number inputs as long as it exists. In\n   * order to get reliable and intuitive behavior we apply a wheel event on our own thus making\n   * sure increment and decrement by mouse wheel works every time.\n   * @docs-private\n   */\n  private _ensureWheelDefaultBehavior(): void {\n    this._cleanupWebkitWheel?.();\n\n    if (this._type === 'number' && (this._platform.BLINK || this._platform.WEBKIT)) {\n      this._cleanupWebkitWheel = this._renderer.listen(\n        this._elementRef.nativeElement,\n        'wheel',\n        this._webkitBlinkWheelListener,\n      );\n    }\n  }\n\n  /** Gets the value to set on the `readonly` attribute. */\n  protected _getReadonlyAttribute(): string | null {\n    if (this._isNativeSelect) {\n      return null;\n    }\n\n    if (this.readonly || (this.disabled && this.disabledInteractive)) {\n      return 'true';\n    }\n\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '../core';\nimport {MatFormFieldModule} from '../form-field';\nimport {MatInput} from './input';\n\n@NgModule({\n  imports: [MatCommonModule, MatFormFieldModule, MatInput],\n  exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule],\n})\nexport class MatInputModule {}\n","import { HttpClient } from '@angular/common/http';\nimport { Injectable, signal, inject } from '@angular/core';\nimport { Observable, map } from 'rxjs';\nimport { Favorites, User, UserLanguage } from '../models/user';\nimport { environment } from '@env/environment';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class UsersService {\n  private http = inject(HttpClient);\n\n  apiURLUsers = environment.apiURL + 'users';\n\n  getUsers(): Observable<User[]> {\n    return this.http.get<User[]>(this.apiURLUsers);\n  }\n\n  getUser(userId: string): Observable<any> {\n    return this.http.get<any>(`${this.apiURLUsers}/${userId}`);\n  }\n\n  createUser(user: FormData): Observable<User> {\n    return this.http.post<User>(this.apiURLUsers, user);\n  }\n\n  updateUser(user: FormData, userId: string): Observable<User> {\n    return this.http.put<User>(`${this.apiURLUsers}/${userId}`, user);\n  }\n\n  deleteUser(userId: string): Observable<User> {\n    return this.http.delete<User>(`${this.apiURLUsers}/${userId}`);\n  }\n\n  getFavorites(userId: string): Observable<Favorites> {\n    return this.http.get<any>(`${this.apiURLUsers}/favorites/${userId}`).pipe(\n      map(favoritesData => {\n        this.userName.set(favoritesData.firstName + ' ' + favoritesData.lastName)\n        return favoritesData.favorites as Favorites;\n      }),\n    );\n  }\n\n  updateFavorites(userId: string, favorites: Favorites): Observable<Favorites> {\n    return this.http.patch<Favorites>(\n      `${this.apiURLUsers}/favorites/${userId}`,\n      favorites,\n    );\n  }\n\n  getUserLanguage(userId: string): Observable<UserLanguage> {\n    return this.http.get<UserLanguage>(\n      `${this.apiURLUsers}/user-language/${userId}`,\n    );\n    // .pipe(\n    //   map(userLanguage => {\n    //     return userLanguage.userLanguage;\n    //   }),\n    // );\n  }\n\n  updateUserLanguage(\n    userId: string,\n    userLanguageCode: UserLanguage,\n  ): Observable<string> {\n    return this.http.patch<string>(\n      `${this.apiURLUsers}/user-language/${userId}`,\n      userLanguageCode,\n    );\n  }\n\n  loginAsGuest(): Observable<{ username: string; token: string }> {\n    return this.http.get<{ username: string; token: string }>(\n      `${this.apiURLUsers}/guest/login`,\n    );\n  }\n\n  userId = signal<string>('');\n\n  isAdmin = signal<boolean>(false);\n\n  userName = signal<string>('');\n\n\n  userFavorites = signal<Favorites>({ favExercises: [], favPrograms: [] });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n// PascalCase is being used as Breakpoints is used like an enum.\n// tslint:disable-next-line:variable-name\nexport const Breakpoints = {\n  XSmall: '(max-width: 599.98px)',\n  Small: '(min-width: 600px) and (max-width: 959.98px)',\n  Medium: '(min-width: 960px) and (max-width: 1279.98px)',\n  Large: '(min-width: 1280px) and (max-width: 1919.98px)',\n  XLarge: '(min-width: 1920px)',\n\n  Handset:\n    '(max-width: 599.98px) and (orientation: portrait), ' +\n    '(max-width: 959.98px) and (orientation: landscape)',\n  Tablet:\n    '(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), ' +\n    '(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)',\n  Web:\n    '(min-width: 840px) and (orientation: portrait), ' +\n    '(min-width: 1280px) and (orientation: landscape)',\n\n  HandsetPortrait: '(max-width: 599.98px) and (orientation: portrait)',\n  TabletPortrait: '(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)',\n  WebPortrait: '(min-width: 840px) and (orientation: portrait)',\n\n  HandsetLandscape: '(max-width: 959.98px) and (orientation: landscape)',\n  TabletLandscape: '(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)',\n  WebLandscape: '(min-width: 1280px) and (orientation: landscape)',\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OverlayRef} from '@angular/cdk/overlay';\nimport {Observable, Subject} from 'rxjs';\nimport {MatSnackBarContainer} from './snack-bar-container';\n\n/** Event that is emitted when a snack bar is dismissed. */\nexport interface MatSnackBarDismiss {\n  /** Whether the snack bar was dismissed using the action button. */\n  dismissedByAction: boolean;\n}\n\n/** Maximum amount of milliseconds that can be passed into setTimeout. */\nconst MAX_TIMEOUT = Math.pow(2, 31) - 1;\n\n/**\n * Reference to a snack bar dispatched from the snack bar service.\n */\nexport class MatSnackBarRef<T> {\n  /** The instance of the component making up the content of the snack bar. */\n  instance: T;\n\n  /**\n   * The instance of the component making up the content of the snack bar.\n   * @docs-private\n   */\n  containerInstance: MatSnackBarContainer;\n\n  /** Subject for notifying the user that the snack bar has been dismissed. */\n  private readonly _afterDismissed = new Subject<MatSnackBarDismiss>();\n\n  /** Subject for notifying the user that the snack bar has opened and appeared. */\n  private readonly _afterOpened = new Subject<void>();\n\n  /** Subject for notifying the user that the snack bar action was called. */\n  private readonly _onAction = new Subject<void>();\n\n  /**\n   * Timeout ID for the duration setTimeout call. Used to clear the timeout if the snackbar is\n   * dismissed before the duration passes.\n   */\n  private _durationTimeoutId: ReturnType<typeof setTimeout>;\n\n  /** Whether the snack bar was dismissed using the action button. */\n  private _dismissedByAction = false;\n\n  constructor(\n    containerInstance: MatSnackBarContainer,\n    private _overlayRef: OverlayRef,\n  ) {\n    this.containerInstance = containerInstance;\n    containerInstance._onExit.subscribe(() => this._finishDismiss());\n  }\n\n  /** Dismisses the snack bar. */\n  dismiss(): void {\n    if (!this._afterDismissed.closed) {\n      this.containerInstance.exit();\n    }\n    clearTimeout(this._durationTimeoutId);\n  }\n\n  /** Marks the snackbar action clicked. */\n  dismissWithAction(): void {\n    if (!this._onAction.closed) {\n      this._dismissedByAction = true;\n      this._onAction.next();\n      this._onAction.complete();\n      this.dismiss();\n    }\n    clearTimeout(this._durationTimeoutId);\n  }\n\n  /**\n   * Marks the snackbar action clicked.\n   * @deprecated Use `dismissWithAction` instead.\n   * @breaking-change 8.0.0\n   */\n  closeWithAction(): void {\n    this.dismissWithAction();\n  }\n\n  /** Dismisses the snack bar after some duration */\n  _dismissAfter(duration: number): void {\n    // Note that we need to cap the duration to the maximum value for setTimeout, because\n    // it'll revert to 1 if somebody passes in something greater (e.g. `Infinity`). See #17234.\n    this._durationTimeoutId = setTimeout(() => this.dismiss(), Math.min(duration, MAX_TIMEOUT));\n  }\n\n  /** Marks the snackbar as opened */\n  _open(): void {\n    if (!this._afterOpened.closed) {\n      this._afterOpened.next();\n      this._afterOpened.complete();\n    }\n  }\n\n  /** Cleans up the DOM after closing. */\n  private _finishDismiss(): void {\n    this._overlayRef.dispose();\n\n    if (!this._onAction.closed) {\n      this._onAction.complete();\n    }\n\n    this._afterDismissed.next({dismissedByAction: this._dismissedByAction});\n    this._afterDismissed.complete();\n    this._dismissedByAction = false;\n  }\n\n  /** Gets an observable that is notified when the snack bar is finished closing. */\n  afterDismissed(): Observable<MatSnackBarDismiss> {\n    return this._afterDismissed;\n  }\n\n  /** Gets an observable that is notified when the snack bar has opened and appeared. */\n  afterOpened(): Observable<void> {\n    return this.containerInstance._onEnter;\n  }\n\n  /** Gets an observable that is notified when the snack bar action is called. */\n  onAction(): Observable<void> {\n    return this._onAction;\n  }\n}\n","<div matSnackBarLabel>\n  {{data.message}}\n</div>\n\n@if (hasAction) {\n  <div matSnackBarActions>\n    <button mat-button matSnackBarAction (click)=\"action()\">\n      {{data.action}}\n    </button>\n  </div>\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ViewContainerRef, InjectionToken} from '@angular/core';\nimport {AriaLivePoliteness} from '@angular/cdk/a11y';\nimport {Direction} from '@angular/cdk/bidi';\n\n/** Injection token that can be used to access the data that was passed in to a snack bar. */\nexport const MAT_SNACK_BAR_DATA = new InjectionToken<any>('MatSnackBarData');\n\n/** Possible values for horizontalPosition on MatSnackBarConfig. */\nexport type MatSnackBarHorizontalPosition = 'start' | 'center' | 'end' | 'left' | 'right';\n\n/** Possible values for verticalPosition on MatSnackBarConfig. */\nexport type MatSnackBarVerticalPosition = 'top' | 'bottom';\n\n/**\n * Configuration used when opening a snack-bar.\n */\nexport class MatSnackBarConfig<D = any> {\n  /** The politeness level for the MatAriaLiveAnnouncer announcement. */\n  politeness?: AriaLivePoliteness = 'assertive';\n\n  /**\n   * Message to be announced by the LiveAnnouncer. When opening a snackbar without a custom\n   * component or template, the announcement message will default to the specified message.\n   */\n  announcementMessage?: string = '';\n\n  /**\n   * The view container that serves as the parent for the snackbar for the purposes of dependency\n   * injection. Note: this does not affect where the snackbar is inserted in the DOM.\n   */\n  viewContainerRef?: ViewContainerRef;\n\n  /** The length of time in milliseconds to wait before automatically dismissing the snack bar. */\n  duration?: number = 0;\n\n  /** Extra CSS classes to be added to the snack bar container. */\n  panelClass?: string | string[];\n\n  /** Text layout direction for the snack bar. */\n  direction?: Direction;\n\n  /** Data being injected into the child component. */\n  data?: D | null = null;\n\n  /** The horizontal position to place the snack bar. */\n  horizontalPosition?: MatSnackBarHorizontalPosition = 'center';\n\n  /** The vertical position to place the snack bar. */\n  verticalPosition?: MatSnackBarVerticalPosition = 'bottom';\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive} from '@angular/core';\n\n/** Directive that should be applied to the text element to be rendered in the snack bar. */\n@Directive({\n  selector: `[matSnackBarLabel]`,\n  host: {\n    'class': 'mat-mdc-snack-bar-label mdc-snackbar__label',\n  },\n})\nexport class MatSnackBarLabel {}\n\n/** Directive that should be applied to the element containing the snack bar's action buttons. */\n@Directive({\n  selector: `[matSnackBarActions]`,\n  host: {\n    'class': 'mat-mdc-snack-bar-actions mdc-snackbar__actions',\n  },\n})\nexport class MatSnackBarActions {}\n\n/** Directive that should be applied to each of the snack bar's action buttons. */\n@Directive({\n  selector: `[matSnackBarAction]`,\n  host: {\n    'class': 'mat-mdc-snack-bar-action mdc-snackbar__action',\n  },\n})\nexport class MatSnackBarAction {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ChangeDetectionStrategy, Component, ViewEncapsulation, inject} from '@angular/core';\nimport {MatButton} from '../button';\nimport {MatSnackBarRef} from './snack-bar-ref';\nimport {MAT_SNACK_BAR_DATA} from './snack-bar-config';\nimport {MatSnackBarAction, MatSnackBarActions, MatSnackBarLabel} from './snack-bar-content';\n\n/**\n * Interface for a simple snack bar component that has a message and a single action.\n */\nexport interface TextOnlySnackBar {\n  data: {message: string; action: string};\n  snackBarRef: MatSnackBarRef<TextOnlySnackBar>;\n  action: () => void;\n  hasAction: boolean;\n}\n\n@Component({\n  selector: 'simple-snack-bar',\n  templateUrl: 'simple-snack-bar.html',\n  styleUrl: 'simple-snack-bar.css',\n  exportAs: 'matSnackBar',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatButton, MatSnackBarLabel, MatSnackBarActions, MatSnackBarAction],\n  host: {\n    'class': 'mat-mdc-simple-snack-bar',\n  },\n})\nexport class SimpleSnackBar implements TextOnlySnackBar {\n  snackBarRef = inject<MatSnackBarRef<SimpleSnackBar>>(MatSnackBarRef);\n  data = inject(MAT_SNACK_BAR_DATA);\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /** Performs the action on the snack bar. */\n  action(): void {\n    this.snackBarRef.dismissWithAction();\n  }\n\n  /** If the action button should be shown. */\n  get hasAction(): boolean {\n    return !!this.data.action;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  afterRender,\n  AfterRenderRef,\n  ANIMATION_MODULE_TYPE,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ComponentRef,\n  ElementRef,\n  EmbeddedViewRef,\n  inject,\n  NgZone,\n  OnDestroy,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {DOCUMENT} from '@angular/common';\nimport {\n  BasePortalOutlet,\n  CdkPortalOutlet,\n  ComponentPortal,\n  DomPortal,\n  TemplatePortal,\n} from '@angular/cdk/portal';\nimport {Observable, Subject, of} from 'rxjs';\nimport {_IdGenerator, AriaLivePoliteness} from '@angular/cdk/a11y';\nimport {Platform} from '@angular/cdk/platform';\nimport {MatSnackBarConfig} from './snack-bar-config';\nimport {take} from 'rxjs/operators';\n\nconst ENTER_ANIMATION = '_mat-snack-bar-enter';\nconst EXIT_ANIMATION = '_mat-snack-bar-exit';\n\n/**\n * Internal component that wraps user-provided snack bar content.\n * @docs-private\n */\n@Component({\n  selector: 'mat-snack-bar-container',\n  templateUrl: 'snack-bar-container.html',\n  styleUrl: 'snack-bar-container.css',\n  // In Ivy embedded views will be change detected from their declaration place, rather than\n  // where they were stamped out. This means that we can't have the snack bar container be OnPush,\n  // because it might cause snack bars that were opened from a template not to be out of date.\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  encapsulation: ViewEncapsulation.None,\n  imports: [CdkPortalOutlet],\n  host: {\n    'class': 'mdc-snackbar mat-mdc-snack-bar-container',\n    '[class.mat-snack-bar-container-enter]': '_animationState === \"visible\"',\n    '[class.mat-snack-bar-container-exit]': '_animationState === \"hidden\"',\n    '[class.mat-snack-bar-container-animations-enabled]': '!_animationsDisabled',\n    '(animationend)': 'onAnimationEnd($event.animationName)',\n    '(animationcancel)': 'onAnimationEnd($event.animationName)',\n  },\n})\nexport class MatSnackBarContainer extends BasePortalOutlet implements OnDestroy {\n  private _ngZone = inject(NgZone);\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _platform = inject(Platform);\n  private _rendersRef: AfterRenderRef;\n  protected _animationsDisabled =\n    inject(ANIMATION_MODULE_TYPE, {optional: true}) === 'NoopAnimations';\n  snackBarConfig = inject(MatSnackBarConfig);\n\n  private _document = inject(DOCUMENT);\n  private _trackedModals = new Set<Element>();\n  private _enterFallback: ReturnType<typeof setTimeout> | undefined;\n  private _exitFallback: ReturnType<typeof setTimeout> | undefined;\n  private _renders = new Subject<void>();\n\n  /** The number of milliseconds to wait before announcing the snack bar's content. */\n  private readonly _announceDelay: number = 150;\n\n  /** The timeout for announcing the snack bar's content. */\n  private _announceTimeoutId: ReturnType<typeof setTimeout>;\n\n  /** Whether the component has been destroyed. */\n  private _destroyed = false;\n\n  /** The portal outlet inside of this container into which the snack bar content will be loaded. */\n  @ViewChild(CdkPortalOutlet, {static: true}) _portalOutlet: CdkPortalOutlet;\n\n  /** Subject for notifying that the snack bar has announced to screen readers. */\n  readonly _onAnnounce: Subject<void> = new Subject();\n\n  /** Subject for notifying that the snack bar has exited from view. */\n  readonly _onExit: Subject<void> = new Subject();\n\n  /** Subject for notifying that the snack bar has finished entering the view. */\n  readonly _onEnter: Subject<void> = new Subject();\n\n  /** The state of the snack bar animations. */\n  _animationState = 'void';\n\n  /** aria-live value for the live region. */\n  _live: AriaLivePoliteness;\n\n  /**\n   * Element that will have the `mdc-snackbar__label` class applied if the attached component\n   * or template does not have it. This ensures that the appropriate structure, typography, and\n   * color is applied to the attached view.\n   */\n  @ViewChild('label', {static: true}) _label: ElementRef;\n\n  /**\n   * Role of the live region. This is only for Firefox as there is a known issue where Firefox +\n   * JAWS does not read out aria-live message.\n   */\n  _role?: 'status' | 'alert';\n\n  /** Unique ID of the aria-live element. */\n  readonly _liveElementId = inject(_IdGenerator).getId('mat-snack-bar-container-live-');\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    super();\n    const config = this.snackBarConfig;\n\n    // Use aria-live rather than a live role like 'alert' or 'status'\n    // because NVDA and JAWS have show inconsistent behavior with live roles.\n    if (config.politeness === 'assertive' && !config.announcementMessage) {\n      this._live = 'assertive';\n    } else if (config.politeness === 'off') {\n      this._live = 'off';\n    } else {\n      this._live = 'polite';\n    }\n\n    // Only set role for Firefox. Set role based on aria-live because setting role=\"alert\" implies\n    // aria-live=\"assertive\" which may cause issues if aria-live is set to \"polite\" above.\n    if (this._platform.FIREFOX) {\n      if (this._live === 'polite') {\n        this._role = 'status';\n      }\n      if (this._live === 'assertive') {\n        this._role = 'alert';\n      }\n    }\n\n    // Note: ideally we'd just do an `afterNextRender` in the places where we need to delay\n    // something, however in some cases (TestBed teardown) the injector can be destroyed at an\n    // unexpected time, causing the `afterRender` to fail.\n    this._rendersRef = afterRender(() => this._renders.next(), {manualCleanup: true});\n  }\n\n  /** Attach a component portal as content to this snack bar container. */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    this._assertNotAttached();\n    const result = this._portalOutlet.attachComponentPortal(portal);\n    this._afterPortalAttached();\n    return result;\n  }\n\n  /** Attach a template portal as content to this snack bar container. */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    this._assertNotAttached();\n    const result = this._portalOutlet.attachTemplatePortal(portal);\n    this._afterPortalAttached();\n    return result;\n  }\n\n  /**\n   * Attaches a DOM portal to the snack bar container.\n   * @deprecated To be turned into a method.\n   * @breaking-change 10.0.0\n   */\n  override attachDomPortal = (portal: DomPortal) => {\n    this._assertNotAttached();\n    const result = this._portalOutlet.attachDomPortal(portal);\n    this._afterPortalAttached();\n    return result;\n  };\n\n  /** Handle end of animations, updating the state of the snackbar. */\n  onAnimationEnd(animationName: string) {\n    if (animationName === EXIT_ANIMATION) {\n      this._completeExit();\n    } else if (animationName === ENTER_ANIMATION) {\n      clearTimeout(this._enterFallback);\n      this._ngZone.run(() => {\n        this._onEnter.next();\n        this._onEnter.complete();\n      });\n    }\n  }\n\n  /** Begin animation of snack bar entrance into view. */\n  enter(): void {\n    if (!this._destroyed) {\n      this._animationState = 'visible';\n      // _animationState lives in host bindings and `detectChanges` does not refresh host bindings\n      // so we have to call `markForCheck` to ensure the host view is refreshed eventually.\n      this._changeDetectorRef.markForCheck();\n      this._changeDetectorRef.detectChanges();\n      this._screenReaderAnnounce();\n\n      if (this._animationsDisabled) {\n        this._renders.pipe(take(1)).subscribe(() => {\n          this._ngZone.run(() => queueMicrotask(() => this.onAnimationEnd(ENTER_ANIMATION)));\n        });\n      } else {\n        clearTimeout(this._enterFallback);\n        this._enterFallback = setTimeout(() => {\n          // The snack bar will stay invisible if it fails to animate. Add a fallback class so it\n          // becomes visible. This can happen in some apps that do `* {animation: none !important}`.\n          this._elementRef.nativeElement.classList.add('mat-snack-bar-fallback-visible');\n          this.onAnimationEnd(ENTER_ANIMATION);\n        }, 200);\n      }\n    }\n  }\n\n  /** Begin animation of the snack bar exiting from view. */\n  exit(): Observable<void> {\n    if (this._destroyed) {\n      return of(undefined);\n    }\n\n    // It's common for snack bars to be opened by random outside calls like HTTP requests or\n    // errors. Run inside the NgZone to ensure that it functions correctly.\n    this._ngZone.run(() => {\n      // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case\n      // where multiple snack bars are opened in quick succession (e.g. two consecutive calls to\n      // `MatSnackBar.open`).\n      this._animationState = 'hidden';\n      this._changeDetectorRef.markForCheck();\n\n      // Mark this element with an 'exit' attribute to indicate that the snackbar has\n      // been dismissed and will soon be removed from the DOM. This is used by the snackbar\n      // test harness.\n      this._elementRef.nativeElement.setAttribute('mat-exit', '');\n\n      // If the snack bar hasn't been announced by the time it exits it wouldn't have been open\n      // long enough to visually read it either, so clear the timeout for announcing.\n      clearTimeout(this._announceTimeoutId);\n\n      if (this._animationsDisabled) {\n        this._renders.pipe(take(1)).subscribe(() => {\n          this._ngZone.run(() => queueMicrotask(() => this.onAnimationEnd(EXIT_ANIMATION)));\n        });\n      } else {\n        clearTimeout(this._exitFallback);\n        this._exitFallback = setTimeout(() => this.onAnimationEnd(EXIT_ANIMATION), 200);\n      }\n    });\n\n    return this._onExit;\n  }\n\n  /** Makes sure the exit callbacks have been invoked when the element is destroyed. */\n  ngOnDestroy() {\n    this._destroyed = true;\n    this._clearFromModals();\n    this._completeExit();\n    this._renders.complete();\n    this._rendersRef.destroy();\n  }\n\n  private _completeExit() {\n    clearTimeout(this._exitFallback);\n    queueMicrotask(() => {\n      this._onExit.next();\n      this._onExit.complete();\n    });\n  }\n\n  /**\n   * Called after the portal contents have been attached. Can be\n   * used to modify the DOM once it's guaranteed to be in place.\n   */\n  private _afterPortalAttached() {\n    const element: HTMLElement = this._elementRef.nativeElement;\n    const panelClasses = this.snackBarConfig.panelClass;\n\n    if (panelClasses) {\n      if (Array.isArray(panelClasses)) {\n        // Note that we can't use a spread here, because IE doesn't support multiple arguments.\n        panelClasses.forEach(cssClass => element.classList.add(cssClass));\n      } else {\n        element.classList.add(panelClasses);\n      }\n    }\n\n    this._exposeToModals();\n\n    // Check to see if the attached component or template uses the MDC template structure,\n    // specifically the MDC label. If not, the container should apply the MDC label class to this\n    // component's label container, which will apply MDC's label styles to the attached view.\n    const label = this._label.nativeElement;\n    const labelClass = 'mdc-snackbar__label';\n    label.classList.toggle(labelClass, !label.querySelector(`.${labelClass}`));\n  }\n\n  /**\n   * Some browsers won't expose the accessibility node of the live element if there is an\n   * `aria-modal` and the live element is outside of it. This method works around the issue by\n   * pointing the `aria-owns` of all modals to the live element.\n   */\n  private _exposeToModals() {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with the\n    // `LiveAnnouncer` and any other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const id = this._liveElementId;\n    const modals = this._document.querySelectorAll(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    for (let i = 0; i < modals.length; i++) {\n      const modal = modals[i];\n      const ariaOwns = modal.getAttribute('aria-owns');\n      this._trackedModals.add(modal);\n\n      if (!ariaOwns) {\n        modal.setAttribute('aria-owns', id);\n      } else if (ariaOwns.indexOf(id) === -1) {\n        modal.setAttribute('aria-owns', ariaOwns + ' ' + id);\n      }\n    }\n  }\n\n  /** Clears the references to the live element from any modals it was added to. */\n  private _clearFromModals() {\n    this._trackedModals.forEach(modal => {\n      const ariaOwns = modal.getAttribute('aria-owns');\n\n      if (ariaOwns) {\n        const newValue = ariaOwns.replace(this._liveElementId, '').trim();\n\n        if (newValue.length > 0) {\n          modal.setAttribute('aria-owns', newValue);\n        } else {\n          modal.removeAttribute('aria-owns');\n        }\n      }\n    });\n    this._trackedModals.clear();\n  }\n\n  /** Asserts that no content is already attached to the container. */\n  private _assertNotAttached() {\n    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Attempting to attach snack bar content after content is already attached');\n    }\n  }\n\n  /**\n   * Starts a timeout to move the snack bar content to the live region so screen readers will\n   * announce it.\n   */\n  private _screenReaderAnnounce() {\n    if (this._announceTimeoutId) {\n      return;\n    }\n\n    this._ngZone.runOutsideAngular(() => {\n      this._announceTimeoutId = setTimeout(() => {\n        if (this._destroyed) {\n          return;\n        }\n\n        const element = this._elementRef.nativeElement;\n        const inertElement = element.querySelector('[aria-hidden]');\n        const liveElement = element.querySelector('[aria-live]');\n\n        if (inertElement && liveElement) {\n          // If an element in the snack bar content is focused before being moved\n          // track it and restore focus after moving to the live region.\n          let focusedElement: HTMLElement | null = null;\n          if (\n            this._platform.isBrowser &&\n            document.activeElement instanceof HTMLElement &&\n            inertElement.contains(document.activeElement)\n          ) {\n            focusedElement = document.activeElement;\n          }\n\n          inertElement.removeAttribute('aria-hidden');\n          liveElement.appendChild(inertElement);\n          focusedElement?.focus();\n\n          this._onAnnounce.next();\n          this._onAnnounce.complete();\n        }\n      }, this._announceDelay);\n    });\n  }\n}\n","<div class=\"mdc-snackbar__surface mat-mdc-snackbar-surface\">\n  <!--\n    This outer label wrapper will have the class `mdc-snackbar__label` applied if\n    the attached template/component does not contain it.\n  -->\n  <div class=\"mat-mdc-snack-bar-label\" #label>\n    <!-- Initialy holds the snack bar content, will be empty after announcing to screen readers. -->\n    <div aria-hidden=\"true\">\n      <ng-template cdkPortalOutlet />\n    </div>\n\n    <!-- Will receive the snack bar content from the non-live div, move will happen a short delay after opening -->\n    <div [attr.aria-live]=\"_live\" [attr.role]=\"_role\" [attr.id]=\"_liveElementId\"></div>\n  </div>\n</div>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LiveAnnouncer} from '@angular/cdk/a11y';\nimport {BreakpointObserver, Breakpoints} from '@angular/cdk/layout';\nimport {ComponentType, Overlay, OverlayConfig, OverlayRef} from '@angular/cdk/overlay';\nimport {\n  ComponentRef,\n  EmbeddedViewRef,\n  Injectable,\n  InjectionToken,\n  Injector,\n  OnDestroy,\n  TemplateRef,\n  inject,\n} from '@angular/core';\nimport {SimpleSnackBar, TextOnlySnackBar} from './simple-snack-bar';\nimport {MatSnackBarContainer} from './snack-bar-container';\nimport {MAT_SNACK_BAR_DATA, MatSnackBarConfig} from './snack-bar-config';\nimport {MatSnackBarRef} from './snack-bar-ref';\nimport {ComponentPortal, TemplatePortal} from '@angular/cdk/portal';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nexport function MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY(): MatSnackBarConfig {\n  return new MatSnackBarConfig();\n}\n\n/** Injection token that can be used to specify default snack bar. */\nexport const MAT_SNACK_BAR_DEFAULT_OPTIONS = new InjectionToken<MatSnackBarConfig>(\n  'mat-snack-bar-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\n/**\n * Service to dispatch Material Design snack bar messages.\n */\n@Injectable({providedIn: 'root'})\nexport class MatSnackBar implements OnDestroy {\n  private _overlay = inject(Overlay);\n  private _live = inject(LiveAnnouncer);\n  private _injector = inject(Injector);\n  private _breakpointObserver = inject(BreakpointObserver);\n  private _parentSnackBar = inject(MatSnackBar, {optional: true, skipSelf: true});\n  private _defaultConfig = inject<MatSnackBarConfig>(MAT_SNACK_BAR_DEFAULT_OPTIONS);\n\n  /**\n   * Reference to the current snack bar in the view *at this level* (in the Angular injector tree).\n   * If there is a parent snack-bar service, all operations should delegate to that parent\n   * via `_openedSnackBarRef`.\n   */\n  private _snackBarRefAtThisLevel: MatSnackBarRef<any> | null = null;\n\n  /** The component that should be rendered as the snack bar's simple component. */\n  simpleSnackBarComponent = SimpleSnackBar;\n\n  /** The container component that attaches the provided template or component. */\n  snackBarContainerComponent = MatSnackBarContainer;\n\n  /** The CSS class to apply for handset mode. */\n  handsetCssClass = 'mat-mdc-snack-bar-handset';\n\n  /** Reference to the currently opened snackbar at *any* level. */\n  get _openedSnackBarRef(): MatSnackBarRef<any> | null {\n    const parent = this._parentSnackBar;\n    return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;\n  }\n\n  set _openedSnackBarRef(value: MatSnackBarRef<any> | null) {\n    if (this._parentSnackBar) {\n      this._parentSnackBar._openedSnackBarRef = value;\n    } else {\n      this._snackBarRefAtThisLevel = value;\n    }\n  }\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /**\n   * Creates and dispatches a snack bar with a custom component for the content, removing any\n   * currently opened snack bars.\n   *\n   * @param component Component to be instantiated.\n   * @param config Extra configuration for the snack bar.\n   */\n  openFromComponent<T, D = any>(\n    component: ComponentType<T>,\n    config?: MatSnackBarConfig<D>,\n  ): MatSnackBarRef<T> {\n    return this._attach(component, config) as MatSnackBarRef<T>;\n  }\n\n  /**\n   * Creates and dispatches a snack bar with a custom template for the content, removing any\n   * currently opened snack bars.\n   *\n   * @param template Template to be instantiated.\n   * @param config Extra configuration for the snack bar.\n   */\n  openFromTemplate(\n    template: TemplateRef<any>,\n    config?: MatSnackBarConfig,\n  ): MatSnackBarRef<EmbeddedViewRef<any>> {\n    return this._attach(template, config);\n  }\n\n  /**\n   * Opens a snackbar with a message and an optional action.\n   * @param message The message to show in the snackbar.\n   * @param action The label for the snackbar action.\n   * @param config Additional configuration options for the snackbar.\n   */\n  open(\n    message: string,\n    action: string = '',\n    config?: MatSnackBarConfig,\n  ): MatSnackBarRef<TextOnlySnackBar> {\n    const _config = {...this._defaultConfig, ...config};\n\n    // Since the user doesn't have access to the component, we can\n    // override the data to pass in our own message and action.\n    _config.data = {message, action};\n\n    // Since the snack bar has `role=\"alert\"`, we don't\n    // want to announce the same message twice.\n    if (_config.announcementMessage === message) {\n      _config.announcementMessage = undefined;\n    }\n\n    return this.openFromComponent(this.simpleSnackBarComponent, _config);\n  }\n\n  /**\n   * Dismisses the currently-visible snack bar.\n   */\n  dismiss(): void {\n    if (this._openedSnackBarRef) {\n      this._openedSnackBarRef.dismiss();\n    }\n  }\n\n  ngOnDestroy() {\n    // Only dismiss the snack bar at the current level on destroy.\n    if (this._snackBarRefAtThisLevel) {\n      this._snackBarRefAtThisLevel.dismiss();\n    }\n  }\n\n  /**\n   * Attaches the snack bar container component to the overlay.\n   */\n  private _attachSnackBarContainer(\n    overlayRef: OverlayRef,\n    config: MatSnackBarConfig,\n  ): MatSnackBarContainer {\n    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n    const injector = Injector.create({\n      parent: userInjector || this._injector,\n      providers: [{provide: MatSnackBarConfig, useValue: config}],\n    });\n\n    const containerPortal = new ComponentPortal(\n      this.snackBarContainerComponent,\n      config.viewContainerRef,\n      injector,\n    );\n    const containerRef: ComponentRef<MatSnackBarContainer> = overlayRef.attach(containerPortal);\n    containerRef.instance.snackBarConfig = config;\n    return containerRef.instance;\n  }\n\n  /**\n   * Places a new component or a template as the content of the snack bar container.\n   */\n  private _attach<T>(\n    content: ComponentType<T> | TemplateRef<T>,\n    userConfig?: MatSnackBarConfig,\n  ): MatSnackBarRef<T | EmbeddedViewRef<any>> {\n    const config = {...new MatSnackBarConfig(), ...this._defaultConfig, ...userConfig};\n    const overlayRef = this._createOverlay(config);\n    const container = this._attachSnackBarContainer(overlayRef, config);\n    const snackBarRef = new MatSnackBarRef<T | EmbeddedViewRef<any>>(container, overlayRef);\n\n    if (content instanceof TemplateRef) {\n      const portal = new TemplatePortal(content, null!, {\n        $implicit: config.data,\n        snackBarRef,\n      } as any);\n\n      snackBarRef.instance = container.attachTemplatePortal(portal);\n    } else {\n      const injector = this._createInjector(config, snackBarRef);\n      const portal = new ComponentPortal(content, undefined, injector);\n      const contentRef = container.attachComponentPortal<T>(portal);\n\n      // We can't pass this via the injector, because the injector is created earlier.\n      snackBarRef.instance = contentRef.instance;\n    }\n\n    // Subscribe to the breakpoint observer and attach the mat-snack-bar-handset class as\n    // appropriate. This class is applied to the overlay element because the overlay must expand to\n    // fill the width of the screen for full width snackbars.\n    this._breakpointObserver\n      .observe(Breakpoints.HandsetPortrait)\n      .pipe(takeUntil(overlayRef.detachments()))\n      .subscribe(state => {\n        overlayRef.overlayElement.classList.toggle(this.handsetCssClass, state.matches);\n      });\n\n    if (config.announcementMessage) {\n      // Wait until the snack bar contents have been announced then deliver this message.\n      container._onAnnounce.subscribe(() => {\n        this._live.announce(config.announcementMessage!, config.politeness);\n      });\n    }\n\n    this._animateSnackBar(snackBarRef, config);\n    this._openedSnackBarRef = snackBarRef;\n    return this._openedSnackBarRef;\n  }\n\n  /** Animates the old snack bar out and the new one in. */\n  private _animateSnackBar(snackBarRef: MatSnackBarRef<any>, config: MatSnackBarConfig) {\n    // When the snackbar is dismissed, clear the reference to it.\n    snackBarRef.afterDismissed().subscribe(() => {\n      // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.\n      if (this._openedSnackBarRef == snackBarRef) {\n        this._openedSnackBarRef = null;\n      }\n\n      if (config.announcementMessage) {\n        this._live.clear();\n      }\n    });\n\n    // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.\n    if (config.duration && config.duration > 0) {\n      snackBarRef.afterOpened().subscribe(() => snackBarRef._dismissAfter(config.duration!));\n    }\n\n    if (this._openedSnackBarRef) {\n      // If a snack bar is already in view, dismiss it and enter the\n      // new snack bar after exit animation is complete.\n      this._openedSnackBarRef.afterDismissed().subscribe(() => {\n        snackBarRef.containerInstance.enter();\n      });\n      this._openedSnackBarRef.dismiss();\n    } else {\n      // If no snack bar is in view, enter the new snack bar.\n      snackBarRef.containerInstance.enter();\n    }\n  }\n\n  /**\n   * Creates a new overlay and places it in the correct location.\n   * @param config The user-specified snack bar config.\n   */\n  private _createOverlay(config: MatSnackBarConfig): OverlayRef {\n    const overlayConfig = new OverlayConfig();\n    overlayConfig.direction = config.direction;\n\n    let positionStrategy = this._overlay.position().global();\n    // Set horizontal position.\n    const isRtl = config.direction === 'rtl';\n    const isLeft =\n      config.horizontalPosition === 'left' ||\n      (config.horizontalPosition === 'start' && !isRtl) ||\n      (config.horizontalPosition === 'end' && isRtl);\n    const isRight = !isLeft && config.horizontalPosition !== 'center';\n    if (isLeft) {\n      positionStrategy.left('0');\n    } else if (isRight) {\n      positionStrategy.right('0');\n    } else {\n      positionStrategy.centerHorizontally();\n    }\n    // Set horizontal position.\n    if (config.verticalPosition === 'top') {\n      positionStrategy.top('0');\n    } else {\n      positionStrategy.bottom('0');\n    }\n\n    overlayConfig.positionStrategy = positionStrategy;\n    return this._overlay.create(overlayConfig);\n  }\n\n  /**\n   * Creates an injector to be used inside of a snack bar component.\n   * @param config Config that was used to create the snack bar.\n   * @param snackBarRef Reference to the snack bar.\n   */\n  private _createInjector<T>(config: MatSnackBarConfig, snackBarRef: MatSnackBarRef<T>): Injector {\n    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n\n    return Injector.create({\n      parent: userInjector || this._injector,\n      providers: [\n        {provide: MatSnackBarRef, useValue: snackBarRef},\n        {provide: MAT_SNACK_BAR_DATA, useValue: config.data},\n      ],\n    });\n  }\n}\n","<div class=\"login-register\">\n  <div class=\"login-panel\">\n    <div class=\"flex-item1 flex-item\">\n      <div class=\"logo\">\n        <img src=\"assets/images/leaf-img.svg\" alt=\"SanareApp logo\" />\n      </div>\n      <div class=\"sign-in\">\n        <h1 class=\"mat-display-medium\" i18n=\"@@Login.signIn\">Sign in</h1>\n        <span i18n=\"@@Login.continueToSanare\">to continue to Sanare</span>\n      </div>\n    </div>\n    <div class=\"flex-item2 flex-item\">\n      <div class=\"login-form\">\n        <form [formGroup]=\"loginFormGroup\">\n          <mat-form-field appearance=\"outline\" class=\"form-field-full-width\">\n            <mat-label i18n=\"@@ClientsList.tableEmailColumn\">Email</mat-label>\n            <input\n              type=\"email\"\n              matInput\n              formControlName=\"email\"\n              placeholder=\"Enter username/email\"\n              i18n-placeholder=\"@@Login.emailPlaceholder\"\n            />\n            <!-- @if (truehrehr) {\n              <mat-error\n                >Username and/or password are\n                <strong>incorect</strong></mat-error\n              >\n            } -->\n            @if (\n              loginForm['email'].hasError('email') &&\n              !loginForm['email'].hasError('required')\n            ) {\n              <mat-error i18n=\"@@Login.enterEmailError\"\n                >Please enter a valid email address</mat-error\n              >\n            }\n            @if (loginForm['email'].hasError('required')) {\n              <mat-error i18n=\"@@Login.emailRequiredError\"\n                >Email is required</mat-error\n              >\n            }\n          </mat-form-field>\n          <mat-form-field appearance=\"outline\" class=\"form-field-full-width\">\n            <mat-label i18n=\"@@Login.password\">Password</mat-label>\n            <input\n              type=\"password\"\n              matInput\n              formControlName=\"password\"\n              placeholder=\"Enter password\"\n              i18n-placeholder=\"@@Login.passwordPlaceholder\"\n            />\n            @if (loginForm['password'].hasError('required')) {\n              <mat-error i18n=\"@@Login.passwordRequiredError\"\n                >Password is required</mat-error\n              >\n            }\n            @if (authError) {\n              <mat-hint class=\"error\" 18n=\"@@Login.emailOrPasswordIncorrect\"\n                >Email and/or password are incorrect</mat-hint\n              >\n            }\n          </mat-form-field>\n        </form>\n      </div>\n    </div>\n\n    <!-- <div class=\"all-buttons-flex\"> -->\n    <div class=\"buttons flex-item3 flex-item\">\n      <div class=\"create-submit-flex\">\n        <button mat-stroked-button disabled i18n=\"@@Login.createBtn\">\n          Create account\n        </button>\n        <button\n          mat-flat-button\n          (click)=\"onSubmit()\"\n          [class.spinner]=\"isSubmitted\"\n          [disabled]=\"isSubmitted\"\n          i18n=\"@@Login.submitBtn\"\n        >\n          Submit\n        </button>\n      </div>\n      <!-- <div class=\"guest-login-button\"> -->\n      <button\n        class=\"guest-login-button\"\n        mat-flat-button\n        (click)=\"onSubmitGuest()\"\n        [class.spinner]=\"isGuestSubmitted\"\n        [disabled]=\"isGuestSubmitted\"\n        i18n=\"@@Login.tryAppBtn\"\n      >\n        Try App as Guest\n      </button>\n      <!-- </div> -->\n    </div>\n    <!-- </div> -->\n  </div>\n</div>\n\n<!-- <div class=\"login-register\">\n  <div class=\"login-register-panel\">\n    <div class=\"grid\">\n      <div class=\"col-6\">\n        <img\n          src=\"assets/images/turqoise-test-render-diffuase-blue3.png\"\n          alt=\"\"\n        />\n      </div>\n      <div class=\"col-6 p-5\">\n        <h3>Welcome!</h3>\n        <h2>Login Page</h2>\n        <form [formGroup]=\"loginFormGroup\">\n          <div class=\"grid mt-6\">\n            <div class=\"col-12\">\n              <div class=\"p-inputgroup\">\n                <span class=\"p-inputgroup-addon\">\n                  <i class=\"pi pi-user\"></i>\n                </span>\n                <input formControlName=\"email\" pInputText placeholder=\"Email\" />\n              </div>\n              @if (loginForm['email'].invalid && isSubmitted) {\n                <small class=\"p-error\">\n                  @if (loginForm['email'].errors?.['required']) {\n                    <span>Email is required</span>\n                  }\n                  @if (loginForm['email'].errors?.['email']) {\n                    <span>Email is invalid</span>\n                  }\n                </small>\n              }\n            </div>\n            <div class=\"col-12\">\n              <div class=\"p-inputgroup\">\n                <span class=\"p-inputgroup-addon\">\n                  <i class=\"pi pi-lock\"></i>\n                </span>\n                <input\n                  formControlName=\"password\"\n                  pInputText\n                  type=\"password\"\n                  placeholder=\"Password\"\n                />\n              </div>\n              @if (loginForm['password'].invalid && isSubmitted) {\n                <small class=\"p-error\">Password is required</small>\n              }\n            </div>\n            <div class=\"col-12\">\n              <p-button\n                label=\"Submit\"\n                [icon]=\"isSubmitted ? 'pi pi-spin pi-spinner' : ''\"\n                styleClass=\"full-btn\"\n                (onClick)=\"onSubmit()\"\n              ></p-button>\n            </div>\n            @if (isSubmitted && authError) {\n              <div class=\"col-12\">\n                <small class=\"p-error\">{{ authMessage }}</small>\n              </div>\n            }\n          </div>\n        </form>\n      </div>\n    </div>\n  </div>\n</div> -->\n","/// <reference types=\"@angular/localize\" />\n\nimport { Component, OnDestroy, OnInit, inject } from '@angular/core';\nimport {\n  FormBuilder,\n  FormGroup,\n  Validators,\n  FormsModule,\n  ReactiveFormsModule,\n} from '@angular/forms';\nimport { AuthService } from '../../services/auth.service';\nimport { LocalstorageService } from '../../services/localstorage.service';\nimport { Router } from '@angular/router';\nimport { Subscription } from 'rxjs';\n// import { InputTextModule } from 'primeng/inputtext';\n// import { Button } from 'primeng/button';\nimport { AuthGuard } from '../../services/auth-guard.service';\n// import { ErrorStateMatcher } from '@angular/material/core';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatButtonModule } from '@angular/material/button';\nimport { UsersService } from '../../services/users.service';\nimport { MatSnackBar } from '@angular/material/snack-bar';\n\n@Component({\n  selector: 'users-login',\n  templateUrl: './login.component.html',\n  styleUrl: './login.component.scss',\n  imports: [\n    FormsModule,\n    ReactiveFormsModule,\n    MatInputModule,\n    MatFormFieldModule,\n    MatButtonModule,\n  ],\n})\nexport class LoginComponent implements OnInit, OnDestroy {\n  private formBuilder = inject(FormBuilder);\n  private auth = inject(AuthService);\n  private localstorageService = inject(LocalstorageService);\n  private router = inject(Router);\n  private authGuard = inject(AuthGuard);\n  private usersService = inject(UsersService);\n  private _snackBar = inject(MatSnackBar);\n\n  loginFormGroup!: FormGroup;\n  isSubmitted = false;\n  isGuestSubmitted = false;\n  authError = false;\n  authMessage = 'Email or Password are wrong';\n  subscriptions = new Subscription();\n\n  ngOnInit(): void {\n    if (this.authGuard.canActivate()) {\n      this.router.navigateByUrl('/');\n    }\n\n    this._initLoginForm();\n\n    const subscription = this.loginFormGroup.valueChanges.subscribe(change => {\n      if (change) this.authError = false;\n    });\n    this.subscriptions.add(subscription);\n  }\n\n  private _initLoginForm() {\n    this.loginFormGroup = this.formBuilder.group({\n      email: ['', [Validators.required, Validators.email]],\n      password: ['', Validators.required],\n    });\n  }\n\n  onSubmit() {\n    if (this.loginFormGroup.invalid) return;\n    this.isSubmitted = true;\n\n    const subscription = this.auth\n      .login(this.loginForm['email'].value, this.loginForm['password'].value)\n      .subscribe({\n        next: user => {\n          this.authError = false;\n          const token = user.token;\n          let tokenDecode: any;\n\n          this.localstorageService.setToken('jwtToken', token);\n          console.log(token);\n\n          // On login, check if there's 'admin' in path and redirect root path or language specific path\n          const isAdminPath = window.location.pathname.includes('/admin');\n          console.log('Is Admin Path:', isAdminPath);\n\n          // Set user language\n          if (token) {\n            tokenDecode = JSON.parse(atob(token.split('.')[1]));\n            console.log(tokenDecode.userLanguage);\n            if (tokenDecode.userLanguage) {\n              this.localstorageService.setToken(\n                'userLanguage',\n                tokenDecode.userLanguage,\n              );\n            }\n            if (isAdminPath) {\n              this.router.navigate(['/']);\n            } else {\n              console.log('navigate to lang build');\n              location.replace(\n                `${window.location.origin}/${tokenDecode.userLanguage}/`,\n              );\n            }\n            // this.router.navigate([`/${tokenDecode.userLanguage}`]);\n            console.log('navigzte here');\n          } else {\n            this.router.navigate(['/']);\n          }\n        },\n        error: error => {\n          this.isSubmitted = false;\n          this.authError = true;\n\n          if (error.status !== 400) {\n            this.authMessage = 'Error in the server, please try again later';\n          }\n        },\n      });\n\n    this.subscriptions.add(subscription);\n  }\n\n  onSubmitGuest() {\n    this.usersService.loginAsGuest().subscribe({\n      next: data => {\n        console.log(data);\n        const token = data.token;\n\n        this.localstorageService.setToken('jwtToken', token);\n        this.localstorageService.setToken(\n          'userLanguage',\n          'en-US',\n        );\n        this.router.navigate(['/']); // Redirect to app\n      },\n      error: err => {\n        this._snackBar.open(\n          $localize`:@@Snackbar.loginError:Too many login attempts. Try again in 15 minutes.`,\n          '',\n          {\n            duration: 2000,\n            panelClass: ['custom-snackbar-style'],\n          },\n        );\n      },\n    });\n  }\n\n  get loginForm() {\n    return this.loginFormGroup?.controls;\n  }\n\n  ngOnDestroy(): void {\n    this.subscriptions.unsubscribe();\n  }\n}\n","import { Route } from '@angular/router';\nimport { LoginComponent } from './pages/login/login.component';\n\nexport const usersRoutes: Route[] = [\n  {\n    path: '',\n    title: 'Login  Sanare',\n    component: LoginComponent,\n  },\n];\n"]}