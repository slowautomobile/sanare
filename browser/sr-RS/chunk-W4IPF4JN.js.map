{
  "version": 3,
  "sources": ["../../src/material/icon/trusted-types.ts", "../../src/material/icon/icon-registry.ts", "../../src/material/icon/icon.ts", "../../src/material/icon/icon-module.ts", "../../src/material/tooltip/tooltip.ts", "../../src/material/tooltip/tooltip.html", "../../src/material/tooltip/module.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular Material. It lazily constructs the Trusted Types policy, providing\n * helper utilities for promoting strings to Trusted Types. When Trusted Types\n * are not available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nexport declare interface TrustedHTML {\n  __brand__: 'TrustedHTML';\n}\n\nexport declare interface TrustedTypePolicyFactory {\n  createPolicy(\n    policyName: string,\n    policyOptions: {\n      createHTML?: (input: string) => string;\n    },\n  ): TrustedTypePolicy;\n}\n\nexport declare interface TrustedTypePolicy {\n  createHTML(input: string): TrustedHTML;\n}\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy | null | undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy | null {\n  if (policy === undefined) {\n    policy = null;\n    if (typeof window !== 'undefined') {\n      const ttWindow = window as unknown as {trustedTypes?: TrustedTypePolicyFactory};\n      if (ttWindow.trustedTypes !== undefined) {\n        policy = ttWindow.trustedTypes.createPolicy('angular#components', {\n          createHTML: (s: string) => s,\n        });\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nexport function trustedHTMLFromString(html: string): TrustedHTML {\n  return getPolicy()?.createHTML(html) || (html as unknown as TrustedHTML);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {HttpClient, HttpErrorResponse} from '@angular/common/http';\nimport {\n  ErrorHandler,\n  Inject,\n  Injectable,\n  InjectionToken,\n  OnDestroy,\n  Optional,\n  SecurityContext,\n  SkipSelf,\n} from '@angular/core';\nimport {DomSanitizer, SafeHtml, SafeResourceUrl} from '@angular/platform-browser';\nimport {forkJoin, Observable, of as observableOf, throwError as observableThrow} from 'rxjs';\nimport {catchError, finalize, map, share, tap} from 'rxjs/operators';\nimport {TrustedHTML, trustedHTMLFromString} from './trusted-types';\n\n/**\n * Returns an exception to be thrown in the case when attempting to\n * load an icon with a name that cannot be found.\n * @docs-private\n */\nexport function getMatIconNameNotFoundError(iconName: string): Error {\n  return Error(`Unable to find icon with the name \"${iconName}\"`);\n}\n\n/**\n * Returns an exception to be thrown when the consumer attempts to use\n * `<mat-icon>` without including @angular/common/http.\n * @docs-private\n */\nexport function getMatIconNoHttpProviderError(): Error {\n  return Error(\n    'Could not find HttpClient for use with Angular Material icons. ' +\n      'Please add provideHttpClient() to your providers.',\n  );\n}\n\n/**\n * Returns an exception to be thrown when a URL couldn't be sanitized.\n * @param url URL that was attempted to be sanitized.\n * @docs-private\n */\nexport function getMatIconFailedToSanitizeUrlError(url: SafeResourceUrl): Error {\n  return Error(\n    `The URL provided to MatIconRegistry was not trusted as a resource URL ` +\n      `via Angular's DomSanitizer. Attempted URL was \"${url}\".`,\n  );\n}\n\n/**\n * Returns an exception to be thrown when a HTML string couldn't be sanitized.\n * @param literal HTML that was attempted to be sanitized.\n * @docs-private\n */\nexport function getMatIconFailedToSanitizeLiteralError(literal: SafeHtml): Error {\n  return Error(\n    `The literal provided to MatIconRegistry was not trusted as safe HTML by ` +\n      `Angular's DomSanitizer. Attempted literal was \"${literal}\".`,\n  );\n}\n\n/** Options that can be used to configure how an icon or the icons in an icon set are presented. */\nexport interface IconOptions {\n  /** View box to set on the icon. */\n  viewBox?: string;\n\n  /** Whether or not to fetch the icon or icon set using HTTP credentials. */\n  withCredentials?: boolean;\n}\n\n/**\n * Function that will be invoked by the icon registry when trying to resolve the\n * URL from which to fetch an icon. The returned URL will be used to make a request for the icon.\n */\nexport type IconResolver = (\n  name: string,\n  namespace: string,\n) => SafeResourceUrl | SafeResourceUrlWithIconOptions | null;\n\n/** Object that specifies a URL from which to fetch an icon and the options to use for it. */\nexport interface SafeResourceUrlWithIconOptions {\n  url: SafeResourceUrl;\n  options: IconOptions;\n}\n\n/**\n * Configuration for an icon, including the URL and possibly the cached SVG element.\n * @docs-private\n */\nclass SvgIconConfig {\n  svgElement: SVGElement | null;\n\n  constructor(\n    public url: SafeResourceUrl,\n    public svgText: TrustedHTML | null,\n    public options?: IconOptions,\n  ) {}\n}\n\n/** Icon configuration whose content has already been loaded. */\ntype LoadedSvgIconConfig = SvgIconConfig & {svgText: TrustedHTML};\n\n/**\n * Service to register and display icons used by the `<mat-icon>` component.\n * - Registers icon URLs by namespace and name.\n * - Registers icon set URLs by namespace.\n * - Registers aliases for CSS classes, for use with icon fonts.\n * - Loads icons from URLs and extracts individual icons from icon sets.\n */\n@Injectable({providedIn: 'root'})\nexport class MatIconRegistry implements OnDestroy {\n  private _document: Document;\n\n  /**\n   * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\n   */\n  private _svgIconConfigs = new Map<string, SvgIconConfig>();\n\n  /**\n   * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\n   * Multiple icon sets can be registered under the same namespace.\n   */\n  private _iconSetConfigs = new Map<string, SvgIconConfig[]>();\n\n  /** Cache for icons loaded by direct URLs. */\n  private _cachedIconsByUrl = new Map<string, SVGElement>();\n\n  /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */\n  private _inProgressUrlFetches = new Map<string, Observable<TrustedHTML>>();\n\n  /** Map from font identifiers to their CSS class names. Used for icon fonts. */\n  private _fontCssClassesByAlias = new Map<string, string>();\n\n  /** Registered icon resolver functions. */\n  private _resolvers: IconResolver[] = [];\n\n  /**\n   * The CSS classes to apply when an `<mat-icon>` component has no icon name, url, or font\n   * specified. The default 'material-icons' value assumes that the material icon font has been\n   * loaded as described at https://google.github.io/material-design-icons/#icon-font-for-the-web\n   */\n  private _defaultFontSetClass = ['material-icons', 'mat-ligature-font'];\n\n  constructor(\n    @Optional() private _httpClient: HttpClient,\n    private _sanitizer: DomSanitizer,\n    @Optional() @Inject(DOCUMENT) document: any,\n    private readonly _errorHandler: ErrorHandler,\n  ) {\n    this._document = document;\n  }\n\n  /**\n   * Registers an icon by URL in the default namespace.\n   * @param iconName Name under which the icon should be registered.\n   * @param url\n   */\n  addSvgIcon(iconName: string, url: SafeResourceUrl, options?: IconOptions): this {\n    return this.addSvgIconInNamespace('', iconName, url, options);\n  }\n\n  /**\n   * Registers an icon using an HTML string in the default namespace.\n   * @param iconName Name under which the icon should be registered.\n   * @param literal SVG source of the icon.\n   */\n  addSvgIconLiteral(iconName: string, literal: SafeHtml, options?: IconOptions): this {\n    return this.addSvgIconLiteralInNamespace('', iconName, literal, options);\n  }\n\n  /**\n   * Registers an icon by URL in the specified namespace.\n   * @param namespace Namespace in which the icon should be registered.\n   * @param iconName Name under which the icon should be registered.\n   * @param url\n   */\n  addSvgIconInNamespace(\n    namespace: string,\n    iconName: string,\n    url: SafeResourceUrl,\n    options?: IconOptions,\n  ): this {\n    return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url, null, options));\n  }\n\n  /**\n   * Registers an icon resolver function with the registry. The function will be invoked with the\n   * name and namespace of an icon when the registry tries to resolve the URL from which to fetch\n   * the icon. The resolver is expected to return a `SafeResourceUrl` that points to the icon,\n   * an object with the icon URL and icon options, or `null` if the icon is not supported. Resolvers\n   * will be invoked in the order in which they have been registered.\n   * @param resolver Resolver function to be registered.\n   */\n  addSvgIconResolver(resolver: IconResolver): this {\n    this._resolvers.push(resolver);\n    return this;\n  }\n\n  /**\n   * Registers an icon using an HTML string in the specified namespace.\n   * @param namespace Namespace in which the icon should be registered.\n   * @param iconName Name under which the icon should be registered.\n   * @param literal SVG source of the icon.\n   */\n  addSvgIconLiteralInNamespace(\n    namespace: string,\n    iconName: string,\n    literal: SafeHtml,\n    options?: IconOptions,\n  ): this {\n    const cleanLiteral = this._sanitizer.sanitize(SecurityContext.HTML, literal);\n\n    // TODO: add an ngDevMode check\n    if (!cleanLiteral) {\n      throw getMatIconFailedToSanitizeLiteralError(literal);\n    }\n\n    // Security: The literal is passed in as SafeHtml, and is thus trusted.\n    const trustedLiteral = trustedHTMLFromString(cleanLiteral);\n    return this._addSvgIconConfig(\n      namespace,\n      iconName,\n      new SvgIconConfig('', trustedLiteral, options),\n    );\n  }\n\n  /**\n   * Registers an icon set by URL in the default namespace.\n   * @param url\n   */\n  addSvgIconSet(url: SafeResourceUrl, options?: IconOptions): this {\n    return this.addSvgIconSetInNamespace('', url, options);\n  }\n\n  /**\n   * Registers an icon set using an HTML string in the default namespace.\n   * @param literal SVG source of the icon set.\n   */\n  addSvgIconSetLiteral(literal: SafeHtml, options?: IconOptions): this {\n    return this.addSvgIconSetLiteralInNamespace('', literal, options);\n  }\n\n  /**\n   * Registers an icon set by URL in the specified namespace.\n   * @param namespace Namespace in which to register the icon set.\n   * @param url\n   */\n  addSvgIconSetInNamespace(namespace: string, url: SafeResourceUrl, options?: IconOptions): this {\n    return this._addSvgIconSetConfig(namespace, new SvgIconConfig(url, null, options));\n  }\n\n  /**\n   * Registers an icon set using an HTML string in the specified namespace.\n   * @param namespace Namespace in which to register the icon set.\n   * @param literal SVG source of the icon set.\n   */\n  addSvgIconSetLiteralInNamespace(\n    namespace: string,\n    literal: SafeHtml,\n    options?: IconOptions,\n  ): this {\n    const cleanLiteral = this._sanitizer.sanitize(SecurityContext.HTML, literal);\n\n    if (!cleanLiteral) {\n      throw getMatIconFailedToSanitizeLiteralError(literal);\n    }\n\n    // Security: The literal is passed in as SafeHtml, and is thus trusted.\n    const trustedLiteral = trustedHTMLFromString(cleanLiteral);\n    return this._addSvgIconSetConfig(namespace, new SvgIconConfig('', trustedLiteral, options));\n  }\n\n  /**\n   * Defines an alias for CSS class names to be used for icon fonts. Creating an matIcon\n   * component with the alias as the fontSet input will cause the class name to be applied\n   * to the `<mat-icon>` element.\n   *\n   * If the registered font is a ligature font, then don't forget to also include the special\n   * class `mat-ligature-font` to allow the usage via attribute. So register like this:\n   *\n   * ```ts\n   * iconRegistry.registerFontClassAlias('f1', 'font1 mat-ligature-font');\n   * ```\n   *\n   * And use like this:\n   *\n   * ```html\n   * <mat-icon fontSet=\"f1\" fontIcon=\"home\"></mat-icon>\n   * ```\n   *\n   * @param alias Alias for the font.\n   * @param classNames Class names override to be used instead of the alias.\n   */\n  registerFontClassAlias(alias: string, classNames: string = alias): this {\n    this._fontCssClassesByAlias.set(alias, classNames);\n    return this;\n  }\n\n  /**\n   * Returns the CSS class name associated with the alias by a previous call to\n   * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\n   */\n  classNameForFontAlias(alias: string): string {\n    return this._fontCssClassesByAlias.get(alias) || alias;\n  }\n\n  /**\n   * Sets the CSS classes to be used for icon fonts when an `<mat-icon>` component does not\n   * have a fontSet input value, and is not loading an icon by name or URL.\n   */\n  setDefaultFontSetClass(...classNames: string[]): this {\n    this._defaultFontSetClass = classNames;\n    return this;\n  }\n\n  /**\n   * Returns the CSS classes to be used for icon fonts when an `<mat-icon>` component does not\n   * have a fontSet input value, and is not loading an icon by name or URL.\n   */\n  getDefaultFontSetClass(): string[] {\n    return this._defaultFontSetClass;\n  }\n\n  /**\n   * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.\n   * The response from the URL may be cached so this will not always cause an HTTP request, but\n   * the produced element will always be a new copy of the originally fetched icon. (That is,\n   * it will not contain any modifications made to elements previously returned).\n   *\n   * @param safeUrl URL from which to fetch the SVG icon.\n   */\n  getSvgIconFromUrl(safeUrl: SafeResourceUrl): Observable<SVGElement> {\n    const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n\n    if (!url) {\n      throw getMatIconFailedToSanitizeUrlError(safeUrl);\n    }\n\n    const cachedIcon = this._cachedIconsByUrl.get(url);\n\n    if (cachedIcon) {\n      return observableOf(cloneSvg(cachedIcon));\n    }\n\n    return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl, null)).pipe(\n      tap(svg => this._cachedIconsByUrl.set(url!, svg)),\n      map(svg => cloneSvg(svg)),\n    );\n  }\n\n  /**\n   * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name\n   * and namespace. The icon must have been previously registered with addIcon or addIconSet;\n   * if not, the Observable will throw an error.\n   *\n   * @param name Name of the icon to be retrieved.\n   * @param namespace Namespace in which to look for the icon.\n   */\n  getNamedSvgIcon(name: string, namespace: string = ''): Observable<SVGElement> {\n    const key = iconKey(namespace, name);\n    let config = this._svgIconConfigs.get(key);\n\n    // Return (copy of) cached icon if possible.\n    if (config) {\n      return this._getSvgFromConfig(config);\n    }\n\n    // Otherwise try to resolve the config from one of the resolver functions.\n    config = this._getIconConfigFromResolvers(namespace, name);\n\n    if (config) {\n      this._svgIconConfigs.set(key, config);\n      return this._getSvgFromConfig(config);\n    }\n\n    // See if we have any icon sets registered for the namespace.\n    const iconSetConfigs = this._iconSetConfigs.get(namespace);\n\n    if (iconSetConfigs) {\n      return this._getSvgFromIconSetConfigs(name, iconSetConfigs);\n    }\n\n    return observableThrow(getMatIconNameNotFoundError(key));\n  }\n\n  ngOnDestroy() {\n    this._resolvers = [];\n    this._svgIconConfigs.clear();\n    this._iconSetConfigs.clear();\n    this._cachedIconsByUrl.clear();\n  }\n\n  /**\n   * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\n   */\n  private _getSvgFromConfig(config: SvgIconConfig): Observable<SVGElement> {\n    if (config.svgText) {\n      // We already have the SVG element for this icon, return a copy.\n      return observableOf(cloneSvg(this._svgElementFromConfig(config as LoadedSvgIconConfig)));\n    } else {\n      // Fetch the icon from the config's URL, cache it, and return a copy.\n      return this._loadSvgIconFromConfig(config).pipe(map(svg => cloneSvg(svg)));\n    }\n  }\n\n  /**\n   * Attempts to find an icon with the specified name in any of the SVG icon sets.\n   * First searches the available cached icons for a nested element with a matching name, and\n   * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets\n   * that have not been cached, and searches again after all fetches are completed.\n   * The returned Observable produces the SVG element if possible, and throws\n   * an error if no icon with the specified name can be found.\n   */\n  private _getSvgFromIconSetConfigs(\n    name: string,\n    iconSetConfigs: SvgIconConfig[],\n  ): Observable<SVGElement> {\n    // For all the icon set SVG elements we've fetched, see if any contain an icon with the\n    // requested name.\n    const namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n\n    if (namedIcon) {\n      // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every\n      // time anyway, there's probably not much advantage compared to just always extracting\n      // it from the icon set.\n      return observableOf(namedIcon);\n    }\n\n    // Not found in any cached icon sets. If there are icon sets with URLs that we haven't\n    // fetched, fetch them now and look for iconName in the results.\n    const iconSetFetchRequests: Observable<TrustedHTML | null>[] = iconSetConfigs\n      .filter(iconSetConfig => !iconSetConfig.svgText)\n      .map(iconSetConfig => {\n        return this._loadSvgIconSetFromConfig(iconSetConfig).pipe(\n          catchError((err: HttpErrorResponse) => {\n            const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);\n\n            // Swallow errors fetching individual URLs so the\n            // combined Observable won't necessarily fail.\n            const errorMessage = `Loading icon set URL: ${url} failed: ${err.message}`;\n            this._errorHandler.handleError(new Error(errorMessage));\n            return observableOf(null);\n          }),\n        );\n      });\n\n    // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\n    // cached SVG element (unless the request failed), and we can check again for the icon.\n    return forkJoin(iconSetFetchRequests).pipe(\n      map(() => {\n        const foundIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n\n        // TODO: add an ngDevMode check\n        if (!foundIcon) {\n          throw getMatIconNameNotFoundError(name);\n        }\n\n        return foundIcon;\n      }),\n    );\n  }\n\n  /**\n   * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\n   * tag matches the specified name. If found, copies the nested element to a new SVG element and\n   * returns it. Returns null if no matching element is found.\n   */\n  private _extractIconWithNameFromAnySet(\n    iconName: string,\n    iconSetConfigs: SvgIconConfig[],\n  ): SVGElement | null {\n    // Iterate backwards, so icon sets added later have precedence.\n    for (let i = iconSetConfigs.length - 1; i >= 0; i--) {\n      const config = iconSetConfigs[i];\n\n      // Parsing the icon set's text into an SVG element can be expensive. We can avoid some of\n      // the parsing by doing a quick check using `indexOf` to see if there's any chance for the\n      // icon to be in the set. This won't be 100% accurate, but it should help us avoid at least\n      // some of the parsing.\n      if (config.svgText && config.svgText.toString().indexOf(iconName) > -1) {\n        const svg = this._svgElementFromConfig(config as LoadedSvgIconConfig);\n        const foundIcon = this._extractSvgIconFromSet(svg, iconName, config.options);\n        if (foundIcon) {\n          return foundIcon;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\n   * from it.\n   */\n  private _loadSvgIconFromConfig(config: SvgIconConfig): Observable<SVGElement> {\n    return this._fetchIcon(config).pipe(\n      tap(svgText => (config.svgText = svgText)),\n      map(() => this._svgElementFromConfig(config as LoadedSvgIconConfig)),\n    );\n  }\n\n  /**\n   * Loads the content of the icon set URL specified in the\n   * SvgIconConfig and attaches it to the config.\n   */\n  private _loadSvgIconSetFromConfig(config: SvgIconConfig): Observable<TrustedHTML | null> {\n    if (config.svgText) {\n      return observableOf(null);\n    }\n\n    return this._fetchIcon(config).pipe(tap(svgText => (config.svgText = svgText)));\n  }\n\n  /**\n   * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\n   * tag matches the specified name. If found, copies the nested element to a new SVG element and\n   * returns it. Returns null if no matching element is found.\n   */\n  private _extractSvgIconFromSet(\n    iconSet: SVGElement,\n    iconName: string,\n    options?: IconOptions,\n  ): SVGElement | null {\n    // Use the `id=\"iconName\"` syntax in order to escape special\n    // characters in the ID (versus using the #iconName syntax).\n    const iconSource = iconSet.querySelector(`[id=\"${iconName}\"]`);\n\n    if (!iconSource) {\n      return null;\n    }\n\n    // Clone the element and remove the ID to prevent multiple elements from being added\n    // to the page with the same ID.\n    const iconElement = iconSource.cloneNode(true) as Element;\n    iconElement.removeAttribute('id');\n\n    // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\n    // the content of a new <svg> node.\n    if (iconElement.nodeName.toLowerCase() === 'svg') {\n      return this._setSvgAttributes(iconElement as SVGElement, options);\n    }\n\n    // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note\n    // that the same could be achieved by referring to it via <use href=\"#id\">, however the <use>\n    // tag is problematic on Firefox, because it needs to include the current page path.\n    if (iconElement.nodeName.toLowerCase() === 'symbol') {\n      return this._setSvgAttributes(this._toSvgElement(iconElement), options);\n    }\n\n    // createElement('SVG') doesn't work as expected; the DOM ends up with\n    // the correct nodes, but the SVG content doesn't render. Instead we\n    // have to create an empty SVG node using innerHTML and append its content.\n    // Elements created using DOMParser.parseFromString have the same problem.\n    // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\n    const svg = this._svgElementFromString(trustedHTMLFromString('<svg></svg>'));\n    // Clone the node so we don't remove it from the parent icon set element.\n    svg.appendChild(iconElement);\n\n    return this._setSvgAttributes(svg, options);\n  }\n\n  /**\n   * Creates a DOM element from the given SVG string.\n   */\n  private _svgElementFromString(str: TrustedHTML): SVGElement {\n    const div = this._document.createElement('DIV');\n    div.innerHTML = str as unknown as string;\n    const svg = div.querySelector('svg') as SVGElement;\n\n    // TODO: add an ngDevMode check\n    if (!svg) {\n      throw Error('<svg> tag not found');\n    }\n\n    return svg;\n  }\n\n  /**\n   * Converts an element into an SVG node by cloning all of its children.\n   */\n  private _toSvgElement(element: Element): SVGElement {\n    const svg = this._svgElementFromString(trustedHTMLFromString('<svg></svg>'));\n    const attributes = element.attributes;\n\n    // Copy over all the attributes from the `symbol` to the new SVG, except the id.\n    for (let i = 0; i < attributes.length; i++) {\n      const {name, value} = attributes[i];\n\n      if (name !== 'id') {\n        svg.setAttribute(name, value);\n      }\n    }\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      if (element.childNodes[i].nodeType === this._document.ELEMENT_NODE) {\n        svg.appendChild(element.childNodes[i].cloneNode(true));\n      }\n    }\n\n    return svg;\n  }\n\n  /**\n   * Sets the default attributes for an SVG element to be used as an icon.\n   */\n  private _setSvgAttributes(svg: SVGElement, options?: IconOptions): SVGElement {\n    svg.setAttribute('fit', '');\n    svg.setAttribute('height', '100%');\n    svg.setAttribute('width', '100%');\n    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n    svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.\n\n    if (options && options.viewBox) {\n      svg.setAttribute('viewBox', options.viewBox);\n    }\n\n    return svg;\n  }\n\n  /**\n   * Returns an Observable which produces the string contents of the given icon. Results may be\n   * cached, so future calls with the same URL may not cause another HTTP request.\n   */\n  private _fetchIcon(iconConfig: SvgIconConfig): Observable<TrustedHTML> {\n    const {url: safeUrl, options} = iconConfig;\n    const withCredentials = options?.withCredentials ?? false;\n\n    if (!this._httpClient) {\n      throw getMatIconNoHttpProviderError();\n    }\n\n    // TODO: add an ngDevMode check\n    if (safeUrl == null) {\n      throw Error(`Cannot fetch icon from URL \"${safeUrl}\".`);\n    }\n\n    const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n\n    // TODO: add an ngDevMode check\n    if (!url) {\n      throw getMatIconFailedToSanitizeUrlError(safeUrl);\n    }\n\n    // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\n    // already a request in progress for that URL. It's necessary to call share() on the\n    // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.\n    const inProgressFetch = this._inProgressUrlFetches.get(url);\n\n    if (inProgressFetch) {\n      return inProgressFetch;\n    }\n\n    const req = this._httpClient.get(url, {responseType: 'text', withCredentials}).pipe(\n      map(svg => {\n        // Security: This SVG is fetched from a SafeResourceUrl, and is thus\n        // trusted HTML.\n        return trustedHTMLFromString(svg);\n      }),\n      finalize(() => this._inProgressUrlFetches.delete(url)),\n      share(),\n    );\n\n    this._inProgressUrlFetches.set(url, req);\n    return req;\n  }\n\n  /**\n   * Registers an icon config by name in the specified namespace.\n   * @param namespace Namespace in which to register the icon config.\n   * @param iconName Name under which to register the config.\n   * @param config Config to be registered.\n   */\n  private _addSvgIconConfig(namespace: string, iconName: string, config: SvgIconConfig): this {\n    this._svgIconConfigs.set(iconKey(namespace, iconName), config);\n    return this;\n  }\n\n  /**\n   * Registers an icon set config in the specified namespace.\n   * @param namespace Namespace in which to register the icon config.\n   * @param config Config to be registered.\n   */\n  private _addSvgIconSetConfig(namespace: string, config: SvgIconConfig): this {\n    const configNamespace = this._iconSetConfigs.get(namespace);\n\n    if (configNamespace) {\n      configNamespace.push(config);\n    } else {\n      this._iconSetConfigs.set(namespace, [config]);\n    }\n\n    return this;\n  }\n\n  /** Parses a config's text into an SVG element. */\n  private _svgElementFromConfig(config: LoadedSvgIconConfig): SVGElement {\n    if (!config.svgElement) {\n      const svg = this._svgElementFromString(config.svgText);\n      this._setSvgAttributes(svg, config.options);\n      config.svgElement = svg;\n    }\n\n    return config.svgElement;\n  }\n\n  /** Tries to create an icon config through the registered resolver functions. */\n  private _getIconConfigFromResolvers(namespace: string, name: string): SvgIconConfig | undefined {\n    for (let i = 0; i < this._resolvers.length; i++) {\n      const result = this._resolvers[i](name, namespace);\n\n      if (result) {\n        return isSafeUrlWithOptions(result)\n          ? new SvgIconConfig(result.url, null, result.options)\n          : new SvgIconConfig(result, null);\n      }\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nexport function ICON_REGISTRY_PROVIDER_FACTORY(\n  parentRegistry: MatIconRegistry,\n  httpClient: HttpClient,\n  sanitizer: DomSanitizer,\n  errorHandler: ErrorHandler,\n  document?: any,\n) {\n  return parentRegistry || new MatIconRegistry(httpClient, sanitizer, document, errorHandler);\n}\n\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nexport const ICON_REGISTRY_PROVIDER = {\n  // If there is already an MatIconRegistry available, use that. Otherwise, provide a new one.\n  provide: MatIconRegistry,\n  deps: [\n    [new Optional(), new SkipSelf(), MatIconRegistry],\n    [new Optional(), HttpClient],\n    DomSanitizer,\n    ErrorHandler,\n    [new Optional(), DOCUMENT as InjectionToken<any>],\n  ],\n  useFactory: ICON_REGISTRY_PROVIDER_FACTORY,\n};\n\n/** Clones an SVGElement while preserving type information. */\nfunction cloneSvg(svg: SVGElement): SVGElement {\n  return svg.cloneNode(true) as SVGElement;\n}\n\n/** Returns the cache key to use for an icon namespace and name. */\nfunction iconKey(namespace: string, name: string) {\n  return namespace + ':' + name;\n}\n\nfunction isSafeUrlWithOptions(value: any): value is SafeResourceUrlWithIconOptions {\n  return !!(value.url && value.options);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {\n  AfterViewChecked,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  ErrorHandler,\n  inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  ViewEncapsulation,\n  HostAttributeToken,\n} from '@angular/core';\nimport {ThemePalette} from '../core';\nimport {Subscription} from 'rxjs';\nimport {take} from 'rxjs/operators';\n\nimport {MatIconRegistry} from './icon-registry';\n\n/** Default options for `mat-icon`.  */\nexport interface MatIconDefaultOptions {\n  /**\n   * Theme color of the icon. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/icon/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  color?: ThemePalette;\n  /** Font set that the icon is a part of. */\n  fontSet?: string;\n}\n\n/** Injection token to be used to override the default options for `mat-icon`. */\nexport const MAT_ICON_DEFAULT_OPTIONS = new InjectionToken<MatIconDefaultOptions>(\n  'MAT_ICON_DEFAULT_OPTIONS',\n);\n\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * @docs-private\n */\nexport const MAT_ICON_LOCATION = new InjectionToken<MatIconLocation>('mat-icon-location', {\n  providedIn: 'root',\n  factory: MAT_ICON_LOCATION_FACTORY,\n});\n\n/**\n * Stubbed out location for `MatIcon`.\n * @docs-private\n */\nexport interface MatIconLocation {\n  getPathname: () => string;\n}\n\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nexport function MAT_ICON_LOCATION_FACTORY(): MatIconLocation {\n  const _document = inject(DOCUMENT);\n  const _location = _document ? _document.location : null;\n\n  return {\n    // Note that this needs to be a function, rather than a property, because Angular\n    // will only resolve it once, but we want the current path on each call.\n    getPathname: () => (_location ? _location.pathname + _location.search : ''),\n  };\n}\n\n/** SVG attributes that accept a FuncIRI (e.g. `url(<something>)`). */\nconst funcIriAttributes = [\n  'clip-path',\n  'color-profile',\n  'src',\n  'cursor',\n  'fill',\n  'filter',\n  'marker',\n  'marker-start',\n  'marker-mid',\n  'marker-end',\n  'mask',\n  'stroke',\n];\n\n/** Selector that can be used to find all elements that are using a `FuncIRI`. */\nconst funcIriAttributeSelector = funcIriAttributes.map(attr => `[${attr}]`).join(', ');\n\n/** Regex that can be used to extract the id out of a FuncIRI. */\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the `fontIcon` attribute or the\n *   content of the `<mat-icon>` component. If you register a custom font class, don't forget to also\n *   include the special class `mat-ligature-font`. It is recommended to use the attribute alternative\n *   to prevent the ligature text to be selectable and to appear in search engine results.\n *   By default, the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon fontIcon=\"home\"></mat-icon>\n *     <mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\" fontIcon=\"sun\"></mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fontawesome-v4.github.io/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\n@Component({\n  template: '<ng-content></ng-content>',\n  selector: 'mat-icon',\n  exportAs: 'matIcon',\n  styleUrl: 'icon.css',\n  host: {\n    'role': 'img',\n    'class': 'mat-icon notranslate',\n    '[class]': 'color ? \"mat-\" + color : \"\"',\n    '[attr.data-mat-icon-type]': '_usingFontIcon() ? \"font\" : \"svg\"',\n    '[attr.data-mat-icon-name]': '_svgName || fontIcon',\n    '[attr.data-mat-icon-namespace]': '_svgNamespace || fontSet',\n    '[attr.fontIcon]': '_usingFontIcon() ? fontIcon : null',\n    '[class.mat-icon-inline]': 'inline',\n    '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatIcon implements OnInit, AfterViewChecked, OnDestroy {\n  readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _iconRegistry = inject(MatIconRegistry);\n  private _location = inject<MatIconLocation>(MAT_ICON_LOCATION);\n  private readonly _errorHandler = inject(ErrorHandler);\n  private _defaultColor: ThemePalette;\n\n  /**\n   * Theme color of the icon. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.io/components/icon/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.io/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  @Input()\n  get color() {\n    return this._color || this._defaultColor;\n  }\n  set color(value: string | null | undefined) {\n    this._color = value;\n  }\n  private _color: string | null | undefined;\n\n  /**\n   * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n   * the element the icon is contained in.\n   */\n  @Input({transform: booleanAttribute})\n  inline: boolean = false;\n\n  /** Name of the icon in the SVG icon set. */\n  @Input()\n  get svgIcon(): string {\n    return this._svgIcon;\n  }\n  set svgIcon(value: string) {\n    if (value !== this._svgIcon) {\n      if (value) {\n        this._updateSvgIcon(value);\n      } else if (this._svgIcon) {\n        this._clearSvgElement();\n      }\n      this._svgIcon = value;\n    }\n  }\n  private _svgIcon: string;\n\n  /** Font set that the icon is a part of. */\n  @Input()\n  get fontSet(): string {\n    return this._fontSet;\n  }\n  set fontSet(value: string) {\n    const newValue = this._cleanupFontValue(value);\n\n    if (newValue !== this._fontSet) {\n      this._fontSet = newValue;\n      this._updateFontIconClasses();\n    }\n  }\n  private _fontSet: string;\n\n  /** Name of an icon within a font set. */\n  @Input()\n  get fontIcon(): string {\n    return this._fontIcon;\n  }\n  set fontIcon(value: string) {\n    const newValue = this._cleanupFontValue(value);\n\n    if (newValue !== this._fontIcon) {\n      this._fontIcon = newValue;\n      this._updateFontIconClasses();\n    }\n  }\n  private _fontIcon: string;\n\n  private _previousFontSetClass: string[] = [];\n  private _previousFontIconClass: string;\n\n  _svgName: string | null;\n  _svgNamespace: string | null;\n\n  /** Keeps track of the current page path. */\n  private _previousPath?: string;\n\n  /** Keeps track of the elements and attributes that we've prefixed with the current path. */\n  private _elementsWithExternalReferences?: Map<Element, {name: string; value: string}[]>;\n\n  /** Subscription to the current in-progress SVG icon request. */\n  private _currentIconFetch = Subscription.EMPTY;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const ariaHidden = inject(new HostAttributeToken('aria-hidden'), {optional: true});\n    const defaults = inject<MatIconDefaultOptions>(MAT_ICON_DEFAULT_OPTIONS, {optional: true});\n\n    if (defaults) {\n      if (defaults.color) {\n        this.color = this._defaultColor = defaults.color;\n      }\n\n      if (defaults.fontSet) {\n        this.fontSet = defaults.fontSet;\n      }\n    }\n\n    // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n    // the right thing to do for the majority of icon use-cases.\n    if (!ariaHidden) {\n      this._elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n    }\n  }\n\n  /**\n   * Splits an svgIcon binding value into its icon set and icon name components.\n   * Returns a 2-element array of [(icon set), (icon name)].\n   * The separator for the two fields is ':'. If there is no separator, an empty\n   * string is returned for the icon set and the entire value is returned for\n   * the icon name. If the argument is falsy, returns an array of two empty strings.\n   * Throws an error if the name contains two or more ':' separators.\n   * Examples:\n   *   `'social:cake' -> ['social', 'cake']\n   *   'penguin' -> ['', 'penguin']\n   *   null -> ['', '']\n   *   'a:b:c' -> (throws Error)`\n   */\n  private _splitIconName(iconName: string): [string, string] {\n    if (!iconName) {\n      return ['', ''];\n    }\n    const parts = iconName.split(':');\n    switch (parts.length) {\n      case 1:\n        return ['', parts[0]]; // Use default namespace.\n      case 2:\n        return <[string, string]>parts;\n      default:\n        throw Error(`Invalid icon name: \"${iconName}\"`); // TODO: add an ngDevMode check\n    }\n  }\n\n  ngOnInit() {\n    // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n    // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n    this._updateFontIconClasses();\n  }\n\n  ngAfterViewChecked() {\n    const cachedElements = this._elementsWithExternalReferences;\n\n    if (cachedElements && cachedElements.size) {\n      const newPath = this._location.getPathname();\n\n      // We need to check whether the URL has changed on each change detection since\n      // the browser doesn't have an API that will let us react on link clicks and\n      // we can't depend on the Angular router. The references need to be updated,\n      // because while most browsers don't care whether the URL is correct after\n      // the first render, Safari will break if the user navigates to a different\n      // page and the SVG isn't re-rendered.\n      if (newPath !== this._previousPath) {\n        this._previousPath = newPath;\n        this._prependPathToReferences(newPath);\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._currentIconFetch.unsubscribe();\n\n    if (this._elementsWithExternalReferences) {\n      this._elementsWithExternalReferences.clear();\n    }\n  }\n\n  _usingFontIcon(): boolean {\n    return !this.svgIcon;\n  }\n\n  private _setSvgElement(svg: SVGElement) {\n    this._clearSvgElement();\n\n    // Note: we do this fix here, rather than the icon registry, because the\n    // references have to point to the URL at the time that the icon was created.\n    const path = this._location.getPathname();\n    this._previousPath = path;\n    this._cacheChildrenWithExternalReferences(svg);\n    this._prependPathToReferences(path);\n    this._elementRef.nativeElement.appendChild(svg);\n  }\n\n  private _clearSvgElement() {\n    const layoutElement: HTMLElement = this._elementRef.nativeElement;\n    let childCount = layoutElement.childNodes.length;\n\n    if (this._elementsWithExternalReferences) {\n      this._elementsWithExternalReferences.clear();\n    }\n\n    // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n    // we can't use innerHTML, because IE will throw if the element has a data binding.\n    while (childCount--) {\n      const child = layoutElement.childNodes[childCount];\n\n      // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n      // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n      if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n        child.remove();\n      }\n    }\n  }\n\n  private _updateFontIconClasses() {\n    if (!this._usingFontIcon()) {\n      return;\n    }\n\n    const elem: HTMLElement = this._elementRef.nativeElement;\n    const fontSetClasses = (\n      this.fontSet\n        ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/)\n        : this._iconRegistry.getDefaultFontSetClass()\n    ).filter(className => className.length > 0);\n\n    this._previousFontSetClass.forEach(className => elem.classList.remove(className));\n    fontSetClasses.forEach(className => elem.classList.add(className));\n    this._previousFontSetClass = fontSetClasses;\n\n    if (\n      this.fontIcon !== this._previousFontIconClass &&\n      !fontSetClasses.includes('mat-ligature-font')\n    ) {\n      if (this._previousFontIconClass) {\n        elem.classList.remove(this._previousFontIconClass);\n      }\n      if (this.fontIcon) {\n        elem.classList.add(this.fontIcon);\n      }\n      this._previousFontIconClass = this.fontIcon;\n    }\n  }\n\n  /**\n   * Cleans up a value to be used as a fontIcon or fontSet.\n   * Since the value ends up being assigned as a CSS class, we\n   * have to trim the value and omit space-separated values.\n   */\n  private _cleanupFontValue(value: string) {\n    return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n  }\n\n  /**\n   * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n   * reference. This is required because WebKit browsers require references to be prefixed with\n   * the current path, if the page has a `base` tag.\n   */\n  private _prependPathToReferences(path: string) {\n    const elements = this._elementsWithExternalReferences;\n\n    if (elements) {\n      elements.forEach((attrs, element) => {\n        attrs.forEach(attr => {\n          element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n        });\n      });\n    }\n  }\n\n  /**\n   * Caches the children of an SVG element that have `url()`\n   * references that we need to prefix with the current path.\n   */\n  private _cacheChildrenWithExternalReferences(element: SVGElement) {\n    const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n    const elements = (this._elementsWithExternalReferences =\n      this._elementsWithExternalReferences || new Map());\n\n    for (let i = 0; i < elementsWithFuncIri.length; i++) {\n      funcIriAttributes.forEach(attr => {\n        const elementWithReference = elementsWithFuncIri[i];\n        const value = elementWithReference.getAttribute(attr);\n        const match = value ? value.match(funcIriPattern) : null;\n\n        if (match) {\n          let attributes = elements.get(elementWithReference);\n\n          if (!attributes) {\n            attributes = [];\n            elements.set(elementWithReference, attributes);\n          }\n\n          attributes!.push({name: attr, value: match[1]});\n        }\n      });\n    }\n  }\n\n  /** Sets a new SVG icon with a particular name. */\n  private _updateSvgIcon(rawName: string | undefined) {\n    this._svgNamespace = null;\n    this._svgName = null;\n    this._currentIconFetch.unsubscribe();\n\n    if (rawName) {\n      const [namespace, iconName] = this._splitIconName(rawName);\n\n      if (namespace) {\n        this._svgNamespace = namespace;\n      }\n\n      if (iconName) {\n        this._svgName = iconName;\n      }\n\n      this._currentIconFetch = this._iconRegistry\n        .getNamedSvgIcon(iconName, namespace)\n        .pipe(take(1))\n        .subscribe(\n          svg => this._setSvgElement(svg),\n          (err: Error) => {\n            const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n            this._errorHandler.handleError(new Error(errorMessage));\n          },\n        );\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatCommonModule} from '../core';\nimport {MatIcon} from './icon';\n\n@NgModule({\n  imports: [MatCommonModule, MatIcon],\n  exports: [MatIcon, MatCommonModule],\n})\nexport class MatIconModule {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {takeUntil} from 'rxjs/operators';\nimport {\n  BooleanInput,\n  coerceBooleanProperty,\n  coerceNumberProperty,\n  NumberInput,\n} from '@angular/cdk/coercion';\nimport {ESCAPE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  Directive,\n  ElementRef,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnDestroy,\n  ViewChild,\n  ViewContainerRef,\n  ViewEncapsulation,\n  inject,\n  ANIMATION_MODULE_TYPE,\n  afterNextRender,\n  Injector,\n} from '@angular/core';\nimport {DOCUMENT, NgClass} from '@angular/common';\nimport {normalizePassiveListenerOptions, Platform} from '@angular/cdk/platform';\nimport {AriaDescriber, FocusMonitor} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  ConnectedPosition,\n  ConnectionPositionPair,\n  FlexibleConnectedPositionStrategy,\n  HorizontalConnectionPos,\n  OriginConnectionPosition,\n  Overlay,\n  OverlayConnectionPosition,\n  OverlayRef,\n  ScrollDispatcher,\n  ScrollStrategy,\n  VerticalConnectionPos,\n} from '@angular/cdk/overlay';\nimport {ComponentPortal} from '@angular/cdk/portal';\nimport {Observable, Subject} from 'rxjs';\n\n/** Possible positions for a tooltip. */\nexport type TooltipPosition = 'left' | 'right' | 'above' | 'below' | 'before' | 'after';\n\n/**\n * Options for how the tooltip trigger should handle touch gestures.\n * See `MatTooltip.touchGestures` for more information.\n */\nexport type TooltipTouchGestures = 'auto' | 'on' | 'off';\n\n/** Possible visibility states of a tooltip. */\nexport type TooltipVisibility = 'initial' | 'visible' | 'hidden';\n\n/** Time in ms to throttle repositioning after scroll events. */\nexport const SCROLL_THROTTLE_MS = 20;\n\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * @docs-private\n */\nexport function getMatTooltipInvalidPositionError(position: string) {\n  return Error(`Tooltip position \"${position}\" is invalid.`);\n}\n\n/** Injection token that determines the scroll handling while a tooltip is visible. */\nexport const MAT_TOOLTIP_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-tooltip-scroll-strategy',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const overlay = inject(Overlay);\n      return () => overlay.scrollStrategies.reposition({scrollThrottle: SCROLL_THROTTLE_MS});\n    },\n  },\n);\n\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nexport function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy {\n  return () => overlay.scrollStrategies.reposition({scrollThrottle: SCROLL_THROTTLE_MS});\n}\n\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nexport const MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_TOOLTIP_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,\n};\n\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nexport function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY(): MatTooltipDefaultOptions {\n  return {\n    showDelay: 0,\n    hideDelay: 0,\n    touchendHideDelay: 1500,\n  };\n}\n\n/** Injection token to be used to override the default options for `matTooltip`. */\nexport const MAT_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken<MatTooltipDefaultOptions>(\n  'mat-tooltip-default-options',\n  {\n    providedIn: 'root',\n    factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY,\n  },\n);\n\n/** Default `matTooltip` options that can be overridden. */\nexport interface MatTooltipDefaultOptions {\n  /** Default delay when the tooltip is shown. */\n  showDelay: number;\n\n  /** Default delay when the tooltip is hidden. */\n  hideDelay: number;\n\n  /** Default delay when hiding the tooltip on a touch device. */\n  touchendHideDelay: number;\n\n  /** Time between the user putting the pointer on a tooltip trigger and the long press event being fired on a touch device. */\n  touchLongPressShowDelay?: number;\n\n  /** Default touch gesture handling for tooltips. */\n  touchGestures?: TooltipTouchGestures;\n\n  /** Default position for tooltips. */\n  position?: TooltipPosition;\n\n  /**\n   * Default value for whether tooltips should be positioned near the click or touch origin\n   * instead of outside the element bounding box.\n   */\n  positionAtOrigin?: boolean;\n\n  /** Disables the ability for the user to interact with the tooltip element. */\n  disableTooltipInteractivity?: boolean;\n\n  /**\n   * Default classes to be applied to the tooltip. These default classes will not be applied if\n   * `tooltipClass` is defined directly on the tooltip element, as it will override the default.\n   */\n  tooltipClass?: string | string[];\n}\n\n/**\n * CSS class that will be attached to the overlay panel.\n * @deprecated\n * @breaking-change 13.0.0 remove this variable\n */\nexport const TOOLTIP_PANEL_CLASS = 'mat-mdc-tooltip-panel';\n\nconst PANEL_CLASS = 'tooltip-panel';\n\n/** Options used to bind passive event listeners. */\nconst passiveListenerOptions = normalizePassiveListenerOptions({passive: true});\n\n// These constants were taken from MDC's `numbers` object. We can't import them from MDC,\n// because they have some top-level references to `window` which break during SSR.\nconst MIN_VIEWPORT_TOOLTIP_THRESHOLD = 8;\nconst UNBOUNDED_ANCHOR_GAP = 8;\nconst MIN_HEIGHT = 24;\nconst MAX_WIDTH = 200;\n\n/**\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\n * hiding of a tooltip provided position (defaults to below the element).\n *\n * https://material.io/design/components/tooltips.html\n */\n@Directive({\n  selector: '[matTooltip]',\n  exportAs: 'matTooltip',\n  host: {\n    'class': 'mat-mdc-tooltip-trigger',\n    '[class.mat-mdc-tooltip-disabled]': 'disabled',\n  },\n})\nexport class MatTooltip implements OnDestroy, AfterViewInit {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _ngZone = inject(NgZone);\n  private _platform = inject(Platform);\n  private _ariaDescriber = inject(AriaDescriber);\n  private _focusMonitor = inject(FocusMonitor);\n  protected _dir = inject(Directionality);\n  private _injector = inject(Injector);\n  private _viewContainerRef = inject(ViewContainerRef);\n  private _defaultOptions = inject<MatTooltipDefaultOptions>(MAT_TOOLTIP_DEFAULT_OPTIONS, {\n    optional: true,\n  });\n\n  _overlayRef: OverlayRef | null;\n  _tooltipInstance: TooltipComponent | null;\n\n  private _portal: ComponentPortal<TooltipComponent>;\n  private _position: TooltipPosition = 'below';\n  private _positionAtOrigin: boolean = false;\n  private _disabled: boolean = false;\n  private _tooltipClass: string | string[] | Set<string> | {[key: string]: any};\n  private _viewInitialized = false;\n  private _pointerExitEventsInitialized = false;\n  private readonly _tooltipComponent = TooltipComponent;\n  private _viewportMargin = 8;\n  private _currentPosition: TooltipPosition;\n  private readonly _cssClassPrefix: string = 'mat-mdc';\n  private _ariaDescriptionPending: boolean;\n  private _dirSubscribed = false;\n\n  /** Allows the user to define the position of the tooltip relative to the parent element */\n  @Input('matTooltipPosition')\n  get position(): TooltipPosition {\n    return this._position;\n  }\n\n  set position(value: TooltipPosition) {\n    if (value !== this._position) {\n      this._position = value;\n\n      if (this._overlayRef) {\n        this._updatePosition(this._overlayRef);\n        this._tooltipInstance?.show(0);\n        this._overlayRef.updatePosition();\n      }\n    }\n  }\n\n  /**\n   * Whether tooltip should be relative to the click or touch origin\n   * instead of outside the element bounding box.\n   */\n  @Input('matTooltipPositionAtOrigin')\n  get positionAtOrigin(): boolean {\n    return this._positionAtOrigin;\n  }\n\n  set positionAtOrigin(value: BooleanInput) {\n    this._positionAtOrigin = coerceBooleanProperty(value);\n    this._detach();\n    this._overlayRef = null;\n  }\n\n  /** Disables the display of the tooltip. */\n  @Input('matTooltipDisabled')\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  set disabled(value: BooleanInput) {\n    const isDisabled = coerceBooleanProperty(value);\n\n    if (this._disabled !== isDisabled) {\n      this._disabled = isDisabled;\n\n      // If tooltip is disabled, hide immediately.\n      if (isDisabled) {\n        this.hide(0);\n      } else {\n        this._setupPointerEnterEventsIfNeeded();\n      }\n\n      this._syncAriaDescription(this.message);\n    }\n  }\n\n  /** The default delay in ms before showing the tooltip after show is called */\n  @Input('matTooltipShowDelay')\n  get showDelay(): number {\n    return this._showDelay;\n  }\n\n  set showDelay(value: NumberInput) {\n    this._showDelay = coerceNumberProperty(value);\n  }\n\n  private _showDelay: number;\n\n  /** The default delay in ms before hiding the tooltip after hide is called */\n  @Input('matTooltipHideDelay')\n  get hideDelay(): number {\n    return this._hideDelay;\n  }\n\n  set hideDelay(value: NumberInput) {\n    this._hideDelay = coerceNumberProperty(value);\n\n    if (this._tooltipInstance) {\n      this._tooltipInstance._mouseLeaveHideDelay = this._hideDelay;\n    }\n  }\n\n  private _hideDelay: number;\n\n  /**\n   * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive\n   * uses a long press gesture to show and hide, however it can conflict with the native browser\n   * gestures. To work around the conflict, Angular Material disables native gestures on the\n   * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable\n   * elements). The different values for this option configure the touch event handling as follows:\n   * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native\n   *   browser gestures on particular elements. In particular, it allows text selection on inputs\n   *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.\n   * - `on` - Enables touch gestures for all elements and disables native\n   *   browser gestures with no exceptions.\n   * - `off` - Disables touch gestures. Note that this will prevent the tooltip from\n   *   showing on touch devices.\n   */\n  @Input('matTooltipTouchGestures') touchGestures: TooltipTouchGestures = 'auto';\n\n  /** The message to be displayed in the tooltip */\n  @Input('matTooltip')\n  get message(): string {\n    return this._message;\n  }\n\n  set message(value: string | null | undefined) {\n    const oldMessage = this._message;\n\n    // If the message is not a string (e.g. number), convert it to a string and trim it.\n    // Must convert with `String(value)`, not `${value}`, otherwise Closure Compiler optimises\n    // away the string-conversion: https://github.com/angular/components/issues/20684\n    this._message = value != null ? String(value).trim() : '';\n\n    if (!this._message && this._isTooltipVisible()) {\n      this.hide(0);\n    } else {\n      this._setupPointerEnterEventsIfNeeded();\n      this._updateTooltipMessage();\n    }\n\n    this._syncAriaDescription(oldMessage);\n  }\n\n  private _message = '';\n\n  /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */\n  @Input('matTooltipClass')\n  get tooltipClass() {\n    return this._tooltipClass;\n  }\n\n  set tooltipClass(value: string | string[] | Set<string> | {[key: string]: any}) {\n    this._tooltipClass = value;\n    if (this._tooltipInstance) {\n      this._setTooltipClass(this._tooltipClass);\n    }\n  }\n\n  /** Manually-bound passive event listeners. */\n  private readonly _passiveListeners: (readonly [string, EventListenerOrEventListenerObject])[] =\n    [];\n\n  /** Timer started at the last `touchstart` event. */\n  private _touchstartTimeout: null | ReturnType<typeof setTimeout> = null;\n\n  /** Emits when the component is destroyed. */\n  private readonly _destroyed = new Subject<void>();\n\n  /** Whether ngOnDestroyed has been called. */\n  private _isDestroyed = false;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const defaultOptions = this._defaultOptions;\n\n    if (defaultOptions) {\n      this._showDelay = defaultOptions.showDelay;\n      this._hideDelay = defaultOptions.hideDelay;\n\n      if (defaultOptions.position) {\n        this.position = defaultOptions.position;\n      }\n\n      if (defaultOptions.positionAtOrigin) {\n        this.positionAtOrigin = defaultOptions.positionAtOrigin;\n      }\n\n      if (defaultOptions.touchGestures) {\n        this.touchGestures = defaultOptions.touchGestures;\n      }\n\n      if (defaultOptions.tooltipClass) {\n        this.tooltipClass = defaultOptions.tooltipClass;\n      }\n    }\n\n    this._viewportMargin = MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n  }\n\n  ngAfterViewInit() {\n    // This needs to happen after view init so the initial values for all inputs have been set.\n    this._viewInitialized = true;\n    this._setupPointerEnterEventsIfNeeded();\n\n    this._focusMonitor\n      .monitor(this._elementRef)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(origin => {\n        // Note that the focus monitor runs outside the Angular zone.\n        if (!origin) {\n          this._ngZone.run(() => this.hide(0));\n        } else if (origin === 'keyboard') {\n          this._ngZone.run(() => this.show());\n        }\n      });\n  }\n\n  /**\n   * Dispose the tooltip when destroyed.\n   */\n  ngOnDestroy() {\n    const nativeElement = this._elementRef.nativeElement;\n\n    // Optimization: Do not call clearTimeout unless there is an active timer.\n    if (this._touchstartTimeout) {\n      clearTimeout(this._touchstartTimeout);\n    }\n\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._tooltipInstance = null;\n    }\n\n    // Clean up the event listeners set in the constructor\n    this._passiveListeners.forEach(([event, listener]) => {\n      nativeElement.removeEventListener(event, listener, passiveListenerOptions);\n    });\n    this._passiveListeners.length = 0;\n\n    this._destroyed.next();\n    this._destroyed.complete();\n\n    this._isDestroyed = true;\n\n    this._ariaDescriber.removeDescription(nativeElement, this.message, 'tooltip');\n    this._focusMonitor.stopMonitoring(nativeElement);\n  }\n\n  /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\n  show(delay: number = this.showDelay, origin?: {x: number; y: number}): void {\n    if (this.disabled || !this.message || this._isTooltipVisible()) {\n      this._tooltipInstance?._cancelPendingAnimations();\n      return;\n    }\n\n    const overlayRef = this._createOverlay(origin);\n    this._detach();\n    this._portal =\n      this._portal || new ComponentPortal(this._tooltipComponent, this._viewContainerRef);\n    const instance = (this._tooltipInstance = overlayRef.attach(this._portal).instance);\n    instance._triggerElement = this._elementRef.nativeElement;\n    instance._mouseLeaveHideDelay = this._hideDelay;\n    instance\n      .afterHidden()\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => this._detach());\n    this._setTooltipClass(this._tooltipClass);\n    this._updateTooltipMessage();\n    instance.show(delay);\n  }\n\n  /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\n  hide(delay: number = this.hideDelay): void {\n    const instance = this._tooltipInstance;\n\n    if (instance) {\n      if (instance.isVisible()) {\n        instance.hide(delay);\n      } else {\n        instance._cancelPendingAnimations();\n        this._detach();\n      }\n    }\n  }\n\n  /** Shows/hides the tooltip */\n  toggle(origin?: {x: number; y: number}): void {\n    this._isTooltipVisible() ? this.hide() : this.show(undefined, origin);\n  }\n\n  /** Returns true if the tooltip is currently visible to the user */\n  _isTooltipVisible(): boolean {\n    return !!this._tooltipInstance && this._tooltipInstance.isVisible();\n  }\n\n  /** Create the overlay config and position strategy */\n  private _createOverlay(origin?: {x: number; y: number}): OverlayRef {\n    if (this._overlayRef) {\n      const existingStrategy = this._overlayRef.getConfig()\n        .positionStrategy as FlexibleConnectedPositionStrategy;\n\n      if ((!this.positionAtOrigin || !origin) && existingStrategy._origin instanceof ElementRef) {\n        return this._overlayRef;\n      }\n\n      this._detach();\n    }\n\n    const scrollableAncestors = this._injector\n      .get(ScrollDispatcher)\n      .getAncestorScrollContainers(this._elementRef);\n\n    const overlay = this._injector.get(Overlay);\n\n    // Create connected position strategy that listens for scroll events to reposition.\n    const strategy = overlay\n      .position()\n      .flexibleConnectedTo(this.positionAtOrigin ? origin || this._elementRef : this._elementRef)\n      .withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`)\n      .withFlexibleDimensions(false)\n      .withViewportMargin(this._viewportMargin)\n      .withScrollableContainers(scrollableAncestors);\n\n    strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe(change => {\n      this._updateCurrentPositionClass(change.connectionPair);\n\n      if (this._tooltipInstance) {\n        if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {\n          // After position changes occur and the overlay is clipped by\n          // a parent scrollable then close the tooltip.\n          this._ngZone.run(() => this.hide(0));\n        }\n      }\n    });\n\n    this._overlayRef = overlay.create({\n      direction: this._dir,\n      positionStrategy: strategy,\n      panelClass: `${this._cssClassPrefix}-${PANEL_CLASS}`,\n      scrollStrategy: this._injector.get(MAT_TOOLTIP_SCROLL_STRATEGY)(),\n    });\n\n    this._updatePosition(this._overlayRef);\n\n    this._overlayRef\n      .detachments()\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => this._detach());\n\n    this._overlayRef\n      .outsidePointerEvents()\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => this._tooltipInstance?._handleBodyInteraction());\n\n    this._overlayRef\n      .keydownEvents()\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(event => {\n        if (this._isTooltipVisible() && event.keyCode === ESCAPE && !hasModifierKey(event)) {\n          event.preventDefault();\n          event.stopPropagation();\n          this._ngZone.run(() => this.hide(0));\n        }\n      });\n\n    if (this._defaultOptions?.disableTooltipInteractivity) {\n      this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`);\n    }\n\n    if (!this._dirSubscribed) {\n      this._dirSubscribed = true;\n      this._dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\n        if (this._overlayRef) {\n          this._updatePosition(this._overlayRef);\n        }\n      });\n    }\n\n    return this._overlayRef;\n  }\n\n  /** Detaches the currently-attached tooltip. */\n  private _detach() {\n    if (this._overlayRef && this._overlayRef.hasAttached()) {\n      this._overlayRef.detach();\n    }\n\n    this._tooltipInstance = null;\n  }\n\n  /** Updates the position of the current tooltip. */\n  private _updatePosition(overlayRef: OverlayRef) {\n    const position = overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy;\n    const origin = this._getOrigin();\n    const overlay = this._getOverlayPosition();\n\n    position.withPositions([\n      this._addOffset({...origin.main, ...overlay.main}),\n      this._addOffset({...origin.fallback, ...overlay.fallback}),\n    ]);\n  }\n\n  /** Adds the configured offset to a position. Used as a hook for child classes. */\n  protected _addOffset(position: ConnectedPosition): ConnectedPosition {\n    const offset = UNBOUNDED_ANCHOR_GAP;\n    const isLtr = !this._dir || this._dir.value == 'ltr';\n\n    if (position.originY === 'top') {\n      position.offsetY = -offset;\n    } else if (position.originY === 'bottom') {\n      position.offsetY = offset;\n    } else if (position.originX === 'start') {\n      position.offsetX = isLtr ? -offset : offset;\n    } else if (position.originX === 'end') {\n      position.offsetX = isLtr ? offset : -offset;\n    }\n\n    return position;\n  }\n\n  /**\n   * Returns the origin position and a fallback position based on the user's position preference.\n   * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n   */\n  _getOrigin(): {main: OriginConnectionPosition; fallback: OriginConnectionPosition} {\n    const isLtr = !this._dir || this._dir.value == 'ltr';\n    const position = this.position;\n    let originPosition: OriginConnectionPosition;\n\n    if (position == 'above' || position == 'below') {\n      originPosition = {originX: 'center', originY: position == 'above' ? 'top' : 'bottom'};\n    } else if (\n      position == 'before' ||\n      (position == 'left' && isLtr) ||\n      (position == 'right' && !isLtr)\n    ) {\n      originPosition = {originX: 'start', originY: 'center'};\n    } else if (\n      position == 'after' ||\n      (position == 'right' && isLtr) ||\n      (position == 'left' && !isLtr)\n    ) {\n      originPosition = {originX: 'end', originY: 'center'};\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw getMatTooltipInvalidPositionError(position);\n    }\n\n    const {x, y} = this._invertPosition(originPosition!.originX, originPosition!.originY);\n\n    return {\n      main: originPosition!,\n      fallback: {originX: x, originY: y},\n    };\n  }\n\n  /** Returns the overlay position and a fallback position based on the user's preference */\n  _getOverlayPosition(): {main: OverlayConnectionPosition; fallback: OverlayConnectionPosition} {\n    const isLtr = !this._dir || this._dir.value == 'ltr';\n    const position = this.position;\n    let overlayPosition: OverlayConnectionPosition;\n\n    if (position == 'above') {\n      overlayPosition = {overlayX: 'center', overlayY: 'bottom'};\n    } else if (position == 'below') {\n      overlayPosition = {overlayX: 'center', overlayY: 'top'};\n    } else if (\n      position == 'before' ||\n      (position == 'left' && isLtr) ||\n      (position == 'right' && !isLtr)\n    ) {\n      overlayPosition = {overlayX: 'end', overlayY: 'center'};\n    } else if (\n      position == 'after' ||\n      (position == 'right' && isLtr) ||\n      (position == 'left' && !isLtr)\n    ) {\n      overlayPosition = {overlayX: 'start', overlayY: 'center'};\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw getMatTooltipInvalidPositionError(position);\n    }\n\n    const {x, y} = this._invertPosition(overlayPosition!.overlayX, overlayPosition!.overlayY);\n\n    return {\n      main: overlayPosition!,\n      fallback: {overlayX: x, overlayY: y},\n    };\n  }\n\n  /** Updates the tooltip message and repositions the overlay according to the new message length */\n  private _updateTooltipMessage() {\n    // Must wait for the message to be painted to the tooltip so that the overlay can properly\n    // calculate the correct positioning based on the size of the text.\n    if (this._tooltipInstance) {\n      this._tooltipInstance.message = this.message;\n      this._tooltipInstance._markForCheck();\n\n      afterNextRender(\n        () => {\n          if (this._tooltipInstance) {\n            this._overlayRef!.updatePosition();\n          }\n        },\n        {\n          injector: this._injector,\n        },\n      );\n    }\n  }\n\n  /** Updates the tooltip class */\n  private _setTooltipClass(tooltipClass: string | string[] | Set<string> | {[key: string]: any}) {\n    if (this._tooltipInstance) {\n      this._tooltipInstance.tooltipClass = tooltipClass;\n      this._tooltipInstance._markForCheck();\n    }\n  }\n\n  /** Inverts an overlay position. */\n  private _invertPosition(x: HorizontalConnectionPos, y: VerticalConnectionPos) {\n    if (this.position === 'above' || this.position === 'below') {\n      if (y === 'top') {\n        y = 'bottom';\n      } else if (y === 'bottom') {\n        y = 'top';\n      }\n    } else {\n      if (x === 'end') {\n        x = 'start';\n      } else if (x === 'start') {\n        x = 'end';\n      }\n    }\n\n    return {x, y};\n  }\n\n  /** Updates the class on the overlay panel based on the current position of the tooltip. */\n  private _updateCurrentPositionClass(connectionPair: ConnectionPositionPair): void {\n    const {overlayY, originX, originY} = connectionPair;\n    let newPosition: TooltipPosition;\n\n    // If the overlay is in the middle along the Y axis,\n    // it means that it's either before or after.\n    if (overlayY === 'center') {\n      // Note that since this information is used for styling, we want to\n      // resolve `start` and `end` to their real values, otherwise consumers\n      // would have to remember to do it themselves on each consumption.\n      if (this._dir && this._dir.value === 'rtl') {\n        newPosition = originX === 'end' ? 'left' : 'right';\n      } else {\n        newPosition = originX === 'start' ? 'left' : 'right';\n      }\n    } else {\n      newPosition = overlayY === 'bottom' && originY === 'top' ? 'above' : 'below';\n    }\n\n    if (newPosition !== this._currentPosition) {\n      const overlayRef = this._overlayRef;\n\n      if (overlayRef) {\n        const classPrefix = `${this._cssClassPrefix}-${PANEL_CLASS}-`;\n        overlayRef.removePanelClass(classPrefix + this._currentPosition);\n        overlayRef.addPanelClass(classPrefix + newPosition);\n      }\n\n      this._currentPosition = newPosition;\n    }\n  }\n\n  /** Binds the pointer events to the tooltip trigger. */\n  private _setupPointerEnterEventsIfNeeded() {\n    // Optimization: Defer hooking up events if there's no message or the tooltip is disabled.\n    if (\n      this._disabled ||\n      !this.message ||\n      !this._viewInitialized ||\n      this._passiveListeners.length\n    ) {\n      return;\n    }\n\n    // The mouse events shouldn't be bound on mobile devices, because they can prevent the\n    // first tap from firing its click event or can cause the tooltip to open for clicks.\n    if (this._platformSupportsMouseEvents()) {\n      this._passiveListeners.push([\n        'mouseenter',\n        event => {\n          this._setupPointerExitEventsIfNeeded();\n          let point = undefined;\n          if ((event as MouseEvent).x !== undefined && (event as MouseEvent).y !== undefined) {\n            point = event as MouseEvent;\n          }\n          this.show(undefined, point);\n        },\n      ]);\n    } else if (this.touchGestures !== 'off') {\n      this._disableNativeGesturesIfNecessary();\n\n      this._passiveListeners.push([\n        'touchstart',\n        event => {\n          const touch = (event as TouchEvent).targetTouches?.[0];\n          const origin = touch ? {x: touch.clientX, y: touch.clientY} : undefined;\n          // Note that it's important that we don't `preventDefault` here,\n          // because it can prevent click events from firing on the element.\n          this._setupPointerExitEventsIfNeeded();\n          if (this._touchstartTimeout) {\n            clearTimeout(this._touchstartTimeout);\n          }\n\n          const DEFAULT_LONGPRESS_DELAY = 500;\n          this._touchstartTimeout = setTimeout(() => {\n            this._touchstartTimeout = null;\n            this.show(undefined, origin);\n          }, this._defaultOptions?.touchLongPressShowDelay ?? DEFAULT_LONGPRESS_DELAY);\n        },\n      ]);\n    }\n\n    this._addListeners(this._passiveListeners);\n  }\n\n  private _setupPointerExitEventsIfNeeded() {\n    if (this._pointerExitEventsInitialized) {\n      return;\n    }\n    this._pointerExitEventsInitialized = true;\n\n    const exitListeners: (readonly [string, EventListenerOrEventListenerObject])[] = [];\n    if (this._platformSupportsMouseEvents()) {\n      exitListeners.push(\n        [\n          'mouseleave',\n          event => {\n            const newTarget = (event as MouseEvent).relatedTarget as Node | null;\n            if (!newTarget || !this._overlayRef?.overlayElement.contains(newTarget)) {\n              this.hide();\n            }\n          },\n        ],\n        ['wheel', event => this._wheelListener(event as WheelEvent)],\n      );\n    } else if (this.touchGestures !== 'off') {\n      this._disableNativeGesturesIfNecessary();\n      const touchendListener = () => {\n        if (this._touchstartTimeout) {\n          clearTimeout(this._touchstartTimeout);\n        }\n        this.hide(this._defaultOptions?.touchendHideDelay);\n      };\n\n      exitListeners.push(['touchend', touchendListener], ['touchcancel', touchendListener]);\n    }\n\n    this._addListeners(exitListeners);\n    this._passiveListeners.push(...exitListeners);\n  }\n\n  private _addListeners(listeners: (readonly [string, EventListenerOrEventListenerObject])[]) {\n    listeners.forEach(([event, listener]) => {\n      this._elementRef.nativeElement.addEventListener(event, listener, passiveListenerOptions);\n    });\n  }\n\n  private _platformSupportsMouseEvents() {\n    return !this._platform.IOS && !this._platform.ANDROID;\n  }\n\n  /** Listener for the `wheel` event on the element. */\n  private _wheelListener(event: WheelEvent) {\n    if (this._isTooltipVisible()) {\n      const elementUnderPointer = this._injector\n        .get(DOCUMENT)\n        .elementFromPoint(event.clientX, event.clientY);\n      const element = this._elementRef.nativeElement;\n\n      // On non-touch devices we depend on the `mouseleave` event to close the tooltip, but it\n      // won't fire if the user scrolls away using the wheel without moving their cursor. We\n      // work around it by finding the element under the user's cursor and closing the tooltip\n      // if it's not the trigger.\n      if (elementUnderPointer !== element && !element.contains(elementUnderPointer)) {\n        this.hide();\n      }\n    }\n  }\n\n  /** Disables the native browser gestures, based on how the tooltip has been configured. */\n  private _disableNativeGesturesIfNecessary() {\n    const gestures = this.touchGestures;\n\n    if (gestures !== 'off') {\n      const element = this._elementRef.nativeElement;\n      const style = element.style;\n\n      // If gestures are set to `auto`, we don't disable text selection on inputs and\n      // textareas, because it prevents the user from typing into them on iOS Safari.\n      if (gestures === 'on' || (element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA')) {\n        style.userSelect =\n          (style as any).msUserSelect =\n          style.webkitUserSelect =\n          (style as any).MozUserSelect =\n            'none';\n      }\n\n      // If we have `auto` gestures and the element uses native HTML dragging,\n      // we don't set `-webkit-user-drag` because it prevents the native behavior.\n      if (gestures === 'on' || !element.draggable) {\n        (style as any).webkitUserDrag = 'none';\n      }\n\n      style.touchAction = 'none';\n      (style as any).webkitTapHighlightColor = 'transparent';\n    }\n  }\n\n  /** Updates the tooltip's ARIA description based on it current state. */\n  private _syncAriaDescription(oldMessage: string): void {\n    if (this._ariaDescriptionPending) {\n      return;\n    }\n\n    this._ariaDescriptionPending = true;\n    this._ariaDescriber.removeDescription(this._elementRef.nativeElement, oldMessage, 'tooltip');\n\n    // The `AriaDescriber` has some functionality that avoids adding a description if it's the\n    // same as the `aria-label` of an element, however we can't know whether the tooltip trigger\n    // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the\n    // issue by deferring the description by a tick so Angular has time to set the `aria-label`.\n    if (!this._isDestroyed) {\n      afterNextRender(\n        {\n          write: () => {\n            this._ariaDescriptionPending = false;\n\n            if (this.message && !this.disabled) {\n              this._ariaDescriber.describe(this._elementRef.nativeElement, this.message, 'tooltip');\n            }\n          },\n        },\n        {injector: this._injector},\n      );\n    }\n  }\n}\n\n/**\n * Internal component that wraps the tooltip's content.\n * @docs-private\n */\n@Component({\n  selector: 'mat-tooltip-component',\n  templateUrl: 'tooltip.html',\n  styleUrl: 'tooltip.css',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '(mouseleave)': '_handleMouseLeave($event)',\n    'aria-hidden': 'true',\n  },\n  imports: [NgClass],\n})\nexport class TooltipComponent implements OnDestroy {\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  protected _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n\n  /* Whether the tooltip text overflows to multiple lines */\n  _isMultiline = false;\n\n  /** Message to display in the tooltip */\n  message: string;\n\n  /** Classes to be added to the tooltip. Supports the same syntax as `ngClass`. */\n  tooltipClass: string | string[] | Set<string> | {[key: string]: any};\n\n  /** The timeout ID of any current timer set to show the tooltip */\n  private _showTimeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  /** The timeout ID of any current timer set to hide the tooltip */\n  private _hideTimeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  /** Element that caused the tooltip to open. */\n  _triggerElement: HTMLElement;\n\n  /** Amount of milliseconds to delay the closing sequence. */\n  _mouseLeaveHideDelay: number;\n\n  /** Whether animations are currently disabled. */\n  private _animationsDisabled: boolean;\n\n  /** Reference to the internal tooltip element. */\n  @ViewChild('tooltip', {\n    // Use a static query here since we interact directly with\n    // the DOM which can happen before `ngAfterViewInit`.\n    static: true,\n  })\n  _tooltip: ElementRef<HTMLElement>;\n\n  /** Whether interactions on the page should close the tooltip */\n  private _closeOnInteraction = false;\n\n  /** Whether the tooltip is currently visible. */\n  private _isVisible = false;\n\n  /** Subject for notifying that the tooltip has been hidden from the view */\n  private readonly _onHide: Subject<void> = new Subject();\n\n  /** Name of the show animation and the class that toggles it. */\n  private readonly _showAnimation = 'mat-mdc-tooltip-show';\n\n  /** Name of the hide animation and the class that toggles it. */\n  private readonly _hideAnimation = 'mat-mdc-tooltip-hide';\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const animationMode = inject(ANIMATION_MODULE_TYPE, {optional: true});\n    this._animationsDisabled = animationMode === 'NoopAnimations';\n  }\n\n  /**\n   * Shows the tooltip with an animation originating from the provided origin\n   * @param delay Amount of milliseconds to the delay showing the tooltip.\n   */\n  show(delay: number): void {\n    // Cancel the delayed hide if it is scheduled\n    if (this._hideTimeoutId != null) {\n      clearTimeout(this._hideTimeoutId);\n    }\n\n    this._showTimeoutId = setTimeout(() => {\n      this._toggleVisibility(true);\n      this._showTimeoutId = undefined;\n    }, delay);\n  }\n\n  /**\n   * Begins the animation to hide the tooltip after the provided delay in ms.\n   * @param delay Amount of milliseconds to delay showing the tooltip.\n   */\n  hide(delay: number): void {\n    // Cancel the delayed show if it is scheduled\n    if (this._showTimeoutId != null) {\n      clearTimeout(this._showTimeoutId);\n    }\n\n    this._hideTimeoutId = setTimeout(() => {\n      this._toggleVisibility(false);\n      this._hideTimeoutId = undefined;\n    }, delay);\n  }\n\n  /** Returns an observable that notifies when the tooltip has been hidden from view. */\n  afterHidden(): Observable<void> {\n    return this._onHide;\n  }\n\n  /** Whether the tooltip is being displayed. */\n  isVisible(): boolean {\n    return this._isVisible;\n  }\n\n  ngOnDestroy() {\n    this._cancelPendingAnimations();\n    this._onHide.complete();\n    this._triggerElement = null!;\n  }\n\n  /**\n   * Interactions on the HTML body should close the tooltip immediately as defined in the\n   * material design spec.\n   * https://material.io/design/components/tooltips.html#behavior\n   */\n  _handleBodyInteraction(): void {\n    if (this._closeOnInteraction) {\n      this.hide(0);\n    }\n  }\n\n  /**\n   * Marks that the tooltip needs to be checked in the next change detection run.\n   * Mainly used for rendering the initial text before positioning a tooltip, which\n   * can be problematic in components with OnPush change detection.\n   */\n  _markForCheck(): void {\n    this._changeDetectorRef.markForCheck();\n  }\n\n  _handleMouseLeave({relatedTarget}: MouseEvent) {\n    if (!relatedTarget || !this._triggerElement.contains(relatedTarget as Node)) {\n      if (this.isVisible()) {\n        this.hide(this._mouseLeaveHideDelay);\n      } else {\n        this._finalizeAnimation(false);\n      }\n    }\n  }\n\n  /**\n   * Callback for when the timeout in this.show() gets completed.\n   * This method is only needed by the mdc-tooltip, and so it is only implemented\n   * in the mdc-tooltip, not here.\n   */\n  protected _onShow(): void {\n    this._isMultiline = this._isTooltipMultiline();\n    this._markForCheck();\n  }\n\n  /** Whether the tooltip text has overflown to the next line */\n  private _isTooltipMultiline() {\n    const rect = this._elementRef.nativeElement.getBoundingClientRect();\n    return rect.height > MIN_HEIGHT && rect.width >= MAX_WIDTH;\n  }\n\n  /** Event listener dispatched when an animation on the tooltip finishes. */\n  _handleAnimationEnd({animationName}: AnimationEvent) {\n    if (animationName === this._showAnimation || animationName === this._hideAnimation) {\n      this._finalizeAnimation(animationName === this._showAnimation);\n    }\n  }\n\n  /** Cancels any pending animation sequences. */\n  _cancelPendingAnimations() {\n    if (this._showTimeoutId != null) {\n      clearTimeout(this._showTimeoutId);\n    }\n\n    if (this._hideTimeoutId != null) {\n      clearTimeout(this._hideTimeoutId);\n    }\n\n    this._showTimeoutId = this._hideTimeoutId = undefined;\n  }\n\n  /** Handles the cleanup after an animation has finished. */\n  private _finalizeAnimation(toVisible: boolean) {\n    if (toVisible) {\n      this._closeOnInteraction = true;\n    } else if (!this.isVisible()) {\n      this._onHide.next();\n    }\n  }\n\n  /** Toggles the visibility of the tooltip element. */\n  private _toggleVisibility(isVisible: boolean) {\n    // We set the classes directly here ourselves so that toggling the tooltip state\n    // isn't bound by change detection. This allows us to hide it even if the\n    // view ref has been detached from the CD tree.\n    const tooltip = this._tooltip.nativeElement;\n    const showClass = this._showAnimation;\n    const hideClass = this._hideAnimation;\n    tooltip.classList.remove(isVisible ? hideClass : showClass);\n    tooltip.classList.add(isVisible ? showClass : hideClass);\n    if (this._isVisible !== isVisible) {\n      this._isVisible = isVisible;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // It's common for internal apps to disable animations using `* { animation: none !important }`\n    // which can break the opening sequence. Try to detect such cases and work around them.\n    if (isVisible && !this._animationsDisabled && typeof getComputedStyle === 'function') {\n      const styles = getComputedStyle(tooltip);\n\n      // Use `getPropertyValue` to avoid issues with property renaming.\n      if (\n        styles.getPropertyValue('animation-duration') === '0s' ||\n        styles.getPropertyValue('animation-name') === 'none'\n      ) {\n        this._animationsDisabled = true;\n      }\n    }\n\n    if (isVisible) {\n      this._onShow();\n    }\n\n    if (this._animationsDisabled) {\n      tooltip.classList.add('_mat-animation-noopable');\n      this._finalizeAnimation(isVisible);\n    }\n  }\n}\n", "<div\n  #tooltip\n  class=\"mdc-tooltip mat-mdc-tooltip\"\n  [ngClass]=\"tooltipClass\"\n  (animationend)=\"_handleAnimationEnd($event)\"\n  [class.mdc-tooltip--multiline]=\"_isMultiline\">\n  <div class=\"mat-mdc-tooltip-surface mdc-tooltip__surface\">{{message}}</div>\n</div>\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {A11yModule} from '@angular/cdk/a11y';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MatCommonModule} from '../core';\nimport {\n  MatTooltip,\n  TooltipComponent,\n  MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER,\n} from './tooltip';\n\n@NgModule({\n  imports: [A11yModule, OverlayModule, MatCommonModule, MatTooltip, TooltipComponent],\n  exports: [MatTooltip, TooltipComponent, MatCommonModule, CdkScrollableModule],\n  providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER],\n})\nexport class MatTooltipModule {}\n"],
  "mappings": "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",
  "names": ["policy", "getPolicy", "undefined", "window", "ttWindow", "trustedTypes", "createPolicy", "createHTML", "s", "trustedHTMLFromString", "html", "getMatIconNameNotFoundError", "iconName", "Error", "getMatIconNoHttpProviderError", "getMatIconFailedToSanitizeUrlError", "url", "getMatIconFailedToSanitizeLiteralError", "literal", "SvgIconConfig", "svgText", "options", "svgElement", "constructor", "MatIconRegistry", "_httpClient", "_sanitizer", "_errorHandler", "_document", "_svgIconConfigs", "Map", "_iconSetConfigs", "_cachedIconsByUrl", "_inProgressUrlFetches", "_fontCssClassesByAlias", "_resolvers", "_defaultFontSetClass", "document", "addSvgIcon", "addSvgIconInNamespace", "addSvgIconLiteral", "addSvgIconLiteralInNamespace", "namespace", "_addSvgIconConfig", "addSvgIconResolver", "resolver", "push", "cleanLiteral", "sanitize", "SecurityContext", "HTML", "trustedLiteral", "addSvgIconSet", "addSvgIconSetInNamespace", "addSvgIconSetLiteral", "addSvgIconSetLiteralInNamespace", "_addSvgIconSetConfig", "registerFontClassAlias", "alias", "classNames", "set", "classNameForFontAlias", "get", "setDefaultFontSetClass", "getDefaultFontSetClass", "getSvgIconFromUrl", "safeUrl", "RESOURCE_URL", "cachedIcon", "of", "cloneSvg", "_loadSvgIconFromConfig", "pipe", "tap", "svg", "map", "getNamedSvgIcon", "name", "key", "iconKey", "config", "_getSvgFromConfig", "_getIconConfigFromResolvers", "iconSetConfigs", "_getSvgFromIconSetConfigs", "throwError", "ngOnDestroy", "clear", "_svgElementFromConfig", "namedIcon", "_extractIconWithNameFromAnySet", "iconSetFetchRequests", "filter", "iconSetConfig", "_loadSvgIconSetFromConfig", "catchError", "err", "errorMessage", "message", "handleError", "forkJoin", "foundIcon", "i", "length", "toString", "indexOf", "_extractSvgIconFromSet", "_fetchIcon", "iconSet", "iconSource", "querySelector", "iconElement", "cloneNode", "removeAttribute", "nodeName", "toLowerCase", "_setSvgAttributes", "_toSvgElement", "_svgElementFromString", "appendChild", "str", "div", "createElement", "innerHTML", "element", "attributes", "value", "setAttribute", "childNodes", "nodeType", "ELEMENT_NODE", "viewBox", "iconConfig", "withCredentials", "inProgressFetch", "req", "responseType", "finalize", "delete", "share", "configNamespace", "result", "isSafeUrlWithOptions", "\u0275fac", "__ngFactoryType__", "\u0275\u0275inject", "HttpClient", "DomSanitizer", "DOCUMENT", "ErrorHandler", "\u0275prov", "\u0275\u0275defineInjectable", "token", "factory", "providedIn", "cloneSvg", "svg", "cloneNode", "iconKey", "namespace", "name", "isSafeUrlWithOptions", "value", "url", "options", "_c0", "MAT_ICON_DEFAULT_OPTIONS", "InjectionToken", "MAT_ICON_LOCATION", "providedIn", "factory", "MAT_ICON_LOCATION_FACTORY", "_document", "inject", "DOCUMENT", "_location", "location", "getPathname", "pathname", "search", "funcIriAttributes", "funcIriAttributeSelector", "map", "attr", "join", "funcIriPattern", "MatIcon", "_elementRef", "ElementRef", "_iconRegistry", "MatIconRegistry", "_errorHandler", "ErrorHandler", "_defaultColor", "color", "_color", "value", "inline", "svgIcon", "_svgIcon", "_updateSvgIcon", "_clearSvgElement", "fontSet", "_fontSet", "newValue", "_cleanupFontValue", "_updateFontIconClasses", "fontIcon", "_fontIcon", "_previousFontSetClass", "_previousFontIconClass", "_svgName", "_svgNamespace", "_previousPath", "_elementsWithExternalReferences", "_currentIconFetch", "Subscription", "EMPTY", "constructor", "ariaHidden", "HostAttributeToken", "optional", "defaults", "nativeElement", "setAttribute", "_splitIconName", "iconName", "parts", "split", "length", "Error", "ngOnInit", "ngAfterViewChecked", "cachedElements", "size", "newPath", "_prependPathToReferences", "ngOnDestroy", "unsubscribe", "clear", "_usingFontIcon", "_setSvgElement", "svg", "path", "_cacheChildrenWithExternalReferences", "appendChild", "layoutElement", "childCount", "childNodes", "child", "nodeType", "nodeName", "toLowerCase", "remove", "elem", "fontSetClasses", "classNameForFontAlias", "getDefaultFontSetClass", "filter", "className", "forEach", "classList", "add", "includes", "trim", "elements", "attrs", "element", "name", "elementsWithFuncIri", "querySelectorAll", "Map", "i", "elementWithReference", "getAttribute", "match", "attributes", "get", "set", "push", "rawName", "namespace", "getNamedSvgIcon", "pipe", "take", "subscribe", "err", "errorMessage", "message", "handleError", "selectors", "hostAttrs", "hostVars", "hostBindings", "rf", "ctx", "inputs", "booleanAttribute", "exportAs", "ngContentSelectors", "decls", "vars", "template", "styles", "encapsulation", "changeDetection", "MatIconModule", "\u0275mod", "\u0275\u0275defineNgModule", "MatCommonModule", "_c0", "SCROLL_THROTTLE_MS", "MAT_TOOLTIP_SCROLL_STRATEGY", "InjectionToken", "providedIn", "factory", "overlay", "inject", "Overlay", "scrollStrategies", "reposition", "scrollThrottle", "SCROLL_THROTTLE_MS", "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY", "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER", "provide", "deps", "useFactory", "MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY", "showDelay", "hideDelay", "touchendHideDelay", "MAT_TOOLTIP_DEFAULT_OPTIONS", "PANEL_CLASS", "passiveListenerOptions", "normalizePassiveListenerOptions", "passive", "MIN_VIEWPORT_TOOLTIP_THRESHOLD", "UNBOUNDED_ANCHOR_GAP", "MIN_HEIGHT", "MAX_WIDTH", "MatTooltip", "_elementRef", "inject", "ElementRef", "_ngZone", "NgZone", "_platform", "Platform", "_ariaDescriber", "AriaDescriber", "_focusMonitor", "FocusMonitor", "_dir", "Directionality", "_injector", "Injector", "_viewContainerRef", "ViewContainerRef", "_defaultOptions", "MAT_TOOLTIP_DEFAULT_OPTIONS", "optional", "_overlayRef", "_tooltipInstance", "_portal", "_position", "_positionAtOrigin", "_disabled", "_tooltipClass", "_viewInitialized", "_pointerExitEventsInitialized", "_tooltipComponent", "TooltipComponent", "_viewportMargin", "_currentPosition", "_cssClassPrefix", "_ariaDescriptionPending", "_dirSubscribed", "position", "value", "_updatePosition", "show", "updatePosition", "positionAtOrigin", "coerceBooleanProperty", "_detach", "disabled", "isDisabled", "hide", "_setupPointerEnterEventsIfNeeded", "_syncAriaDescription", "message", "showDelay", "_showDelay", "coerceNumberProperty", "hideDelay", "_hideDelay", "_mouseLeaveHideDelay", "touchGestures", "_message", "oldMessage", "String", "trim", "_isTooltipVisible", "_updateTooltipMessage", "tooltipClass", "_setTooltipClass", "_passiveListeners", "_touchstartTimeout", "_destroyed", "Subject", "_isDestroyed", "constructor", "defaultOptions", "ngAfterViewInit", "monitor", "pipe", "takeUntil", "subscribe", "origin", "run", "ngOnDestroy", "nativeElement", "clearTimeout", "dispose", "forEach", "event", "listener", "removeEventListener", "length", "next", "complete", "removeDescription", "stopMonitoring", "delay", "_cancelPendingAnimations", "overlayRef", "_createOverlay", "ComponentPortal", "instance", "attach", "_triggerElement", "afterHidden", "isVisible", "toggle", "undefined", "existingStrategy", "getConfig", "positionStrategy", "_origin", "scrollableAncestors", "get", "ScrollDispatcher", "getAncestorScrollContainers", "overlay", "Overlay", "strategy", "flexibleConnectedTo", "withTransformOriginOn", "withFlexibleDimensions", "withViewportMargin", "withScrollableContainers", "positionChanges", "change", "_updateCurrentPositionClass", "connectionPair", "scrollableViewProperties", "isOverlayClipped", "create", "direction", "panelClass", "scrollStrategy", "MAT_TOOLTIP_SCROLL_STRATEGY", "detachments", "outsidePointerEvents", "_handleBodyInteraction", "keydownEvents", "keyCode", "ESCAPE", "hasModifierKey", "preventDefault", "stopPropagation", "disableTooltipInteractivity", "addPanelClass", "hasAttached", "detach", "_getOrigin", "_getOverlayPosition", "withPositions", "_addOffset", "__spreadValues", "main", "fallback", "offset", "isLtr", "originY", "offsetY", "originX", "offsetX", "originPosition", "x", "y", "_invertPosition", "overlayPosition", "overlayX", "overlayY", "_markForCheck", "afterNextRender", "injector", "newPosition", "classPrefix", "removePanelClass", "_platformSupportsMouseEvents", "push", "_setupPointerExitEventsIfNeeded", "point", "_disableNativeGesturesIfNecessary", "touch", "targetTouches", "clientX", "clientY", "DEFAULT_LONGPRESS_DELAY", "setTimeout", "touchLongPressShowDelay", "_addListeners", "exitListeners", "newTarget", "relatedTarget", "overlayElement", "contains", "_wheelListener", "touchendListener", "touchendHideDelay", "listeners", "addEventListener", "IOS", "ANDROID", "elementUnderPointer", "DOCUMENT", "elementFromPoint", "element", "gestures", "style", "nodeName", "userSelect", "msUserSelect", "webkitUserSelect", "MozUserSelect", "draggable", "webkitUserDrag", "touchAction", "webkitTapHighlightColor", "write", "describe", "selectors", "hostAttrs", "hostVars", "hostBindings", "rf", "ctx", "inputs", "exportAs", "_changeDetectorRef", "ChangeDetectorRef", "_isMultiline", "_showTimeoutId", "_hideTimeoutId", "_animationsDisabled", "_tooltip", "_closeOnInteraction", "_isVisible", "_onHide", "_showAnimation", "_hideAnimation", "animationMode", "ANIMATION_MODULE_TYPE", "_toggleVisibility", "markForCheck", "_handleMouseLeave", "_finalizeAnimation", "_onShow", "_isTooltipMultiline", "rect", "getBoundingClientRect", "height", "width", "_handleAnimationEnd", "animationName", "toVisible", "tooltip", "showClass", "hideClass", "classList", "remove", "add", "getComputedStyle", "styles", "getPropertyValue", "viewQuery", "$event", "decls", "vars", "consts", "template", "_r1", "\u0275\u0275getCurrentView", "dependencies", "NgClass", "encapsulation", "changeDetection", "MatTooltipModule", "\u0275mod", "\u0275\u0275defineNgModule", "\u0275inj", "\u0275\u0275defineInjector", "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER", "imports", "A11yModule", "OverlayModule", "MatCommonModule", "CdkScrollableModule"]
}
